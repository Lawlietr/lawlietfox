diff -r f7a18ca15f55 content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/content/base/src/nsContentUtils.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -3112,6 +3112,9 @@
 }
 
 /* static */
+#ifdef _MSC_VER
+#pragma inline_recursion(on)
+#endif
 Element*
 nsContentUtils::MatchElementId(nsIContent *aContent, const nsIAtom* aId)
 {
@@ -3125,8 +3128,14 @@
 
   return nsnull;
 }
+#ifdef _MSC_VER
+#pragma inline_recursion(off)
+#endif
 
 /* static */
+#ifdef _MSC_VER
+#pragma inline_recursion(on)
+#endif
 Element *
 nsContentUtils::MatchElementId(nsIContent *aContent, const nsAString& aId)
 {
@@ -3141,6 +3150,9 @@
 
   return MatchElementId(aContent, id);
 }
+#ifdef _MSC_VER
+#pragma inline_recursion(off)
+#endif
 
 // Convert the string from the given charset to Unicode.
 /* static */
diff -r f7a18ca15f55 content/canvas/src/CanvasUtils.cpp
--- a/content/canvas/src/CanvasUtils.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/content/canvas/src/CanvasUtils.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -35,6 +35,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+extern "C" {
+  extern __m128i _mm_shuffle_epi8(__m128i a, __m128i b);
+  extern __m128i _mm_alignr_epi8(__m128i a, __m128i b, const int ralign);
+}
+#else
+#include <tmmintrin.h>
+#endif
+#include "mozilla/SSE.h"
+
 #include <stdlib.h>
 #include <stdarg.h>
 
@@ -211,5 +222,233 @@
     return MatrixEltsToJSVal(elts, cx, val);
 }
 
+void
+GetImageData_component(PRUint8* _src, PRUint8* _dst,
+                       PRUint32 width, PRUint32 height,
+                       PRUint32 srcStride, PRUint32 dstStride,
+                       PRUint8 (*sUnpremultiplyTable)[256])
+{
+    PRUint8 *srcFirst = _src;
+    PRUint8 *dstFirst = _dst;
+
+    for (PRInt64 j = 0; j < height; j++) {
+        PRUint8 *src = srcFirst + (srcStride * j);
+        PRUint8 *dst = dstFirst + (dstStride * j);
+
+        for (PRUint32 i = 0; i < width; i++) {
+            // XXX Is there some useful swizzle MMX we can use here?
+#ifdef IS_LITTLE_ENDIAN
+            PRUint8 b = *src++;
+            PRUint8 g = *src++;
+            PRUint8 r = *src++;
+            PRUint8 a = *src++;
+#else
+            PRUint8 a = *src++;
+            PRUint8 r = *src++;
+            PRUint8 g = *src++;
+            PRUint8 b = *src++;
+#endif
+            // Convert to non-premultiplied color
+            *dst++ = sUnpremultiplyTable[a][r];
+            *dst++ = sUnpremultiplyTable[a][g];
+            *dst++ = sUnpremultiplyTable[a][b];
+            *dst++ = a;
+        }
+    }
+}
+
+void
+PutImageData_component(PRUint8* _src, PRUint8* _dst,
+                       PRUint32 width, PRUint32 height,
+                       PRUint32 srcStride, PRUint32 dstStride,
+                       PRUint8 (*sPremultiplyTable)[256])
+{
+    PRUint8 *srcFirst = _src;
+    PRUint8 *dstFirst = _dst;
+
+#if (_MSC_VER != 1400) || !defined(_M_AMD64)
+    if (mozilla::supports_ssse3()) {
+        static const __m128i msk_alpha = _mm_set1_epi32(0xFF000000);
+        static const __m128i sfl_alphaLo = _mm_set_epi8(0x80, 7, 0x80, 7, 0x80, 7, 0x80, 7, 0x80, 3, 0x80, 3, 0x80, 3, 0x80, 3);
+        static const __m128i sfl_alphaHi = _mm_set_epi8(0x80, 15, 0x80, 15, 0x80, 15, 0x80, 15, 0x80, 11, 0x80, 11, 0x80, 11, 0x80, 11);
+        static const __m128i word_add = _mm_set1_epi16(0x00FF);
+        static const __m128i word_mul = _mm_set_epi16(0, 257, 257, 257, 0, 257, 257, 257);
+        static const __m128i sfl_bgra = _mm_set_epi8(15, 12, 13, 14, 11, 8, 9, 10, 7, 4, 5, 6, 3, 0, 1, 2);
+
+        for (int j = 0; j < height; j++) {
+            PRUint8 *src = srcFirst + (srcStride * j);
+            PRUint8 *dst = dstFirst + (dstStride * j);
+            PRUint32 i = width;
+
+            while (i >= 1 && ((unsigned)dst & 15)) {
+                PRUint8 r = *src++;
+                PRUint8 g = *src++;
+                PRUint8 b = *src++;
+                PRUint8 a = *src++;
+
+                // Convert to premultiplied color (losslessly if the input came from getImageData)
+                *dst++ = sPremultiplyTable[a][b];
+                *dst++ = sPremultiplyTable[a][g];
+                *dst++ = sPremultiplyTable[a][r];
+                *dst++ = a;
+                i -= 1;
+            }
+
+            const int srcMissalignedBytes = ((unsigned)src & 15);
+
+            if (srcMissalignedBytes == 0) {
+                while (i >= 4) {
+                    __m128i xmb = _mm_load_si128((__m128i*)src);
+                    __m128i xmwLo = _mm_unpacklo_epi8(xmb, _mm_setzero_si128());
+                    __m128i xmwHi = _mm_unpackhi_epi8(xmb, _mm_setzero_si128());
+
+                    __m128i xmwAlpha = _mm_and_si128(xmb, msk_alpha);
+                    __m128i xmwAlphaLo = _mm_shuffle_epi8(xmb, sfl_alphaLo);
+                    __m128i xmwAlphaHi = _mm_shuffle_epi8(xmb, sfl_alphaHi);
+
+                    xmwLo = _mm_mullo_epi16(xmwLo, xmwAlphaLo);
+                    xmwLo = _mm_adds_epu16(xmwLo, word_add);
+                    xmwLo = _mm_mulhi_epu16(xmwLo, word_mul);
+
+                    xmwHi = _mm_mullo_epi16(xmwHi, xmwAlphaHi);
+                    xmwHi = _mm_adds_epu16(xmwHi, word_add);
+                    xmwHi = _mm_mulhi_epu16(xmwHi, word_mul);
+
+                    __m128i xmRes = _mm_packus_epi16(xmwLo, xmwHi);
+                    xmRes = _mm_or_si128(xmRes, xmwAlpha);
+                    xmRes = _mm_shuffle_epi8(xmRes, sfl_bgra);
+                    _mm_store_si128((__m128i*)dst, xmRes);
+
+                    src += 16;
+                    dst += 16;
+                    i -= 4;
+                }
+            } else {
+                __m128i xmLoadPre = _mm_load_si128((__m128i*)(src - srcMissalignedBytes));
+
+                while (i >= 4) {
+                    __m128i xmLoadNext = _mm_load_si128((__m128i*)(src - srcMissalignedBytes + 16));
+                    __m128i xmb;
+
+                    switch (srcMissalignedBytes) {
+                    case 1:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 1);
+                        break;
+                    case 2:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 2);
+                        break;
+                    case 3:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 3);
+                        break;
+                    case 4:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 4);
+                        break;
+                    case 5:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 5);
+                        break;
+                    case 6:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 6);
+                        break;
+                    case 7:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 7);
+                        break;
+                    case 8:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 8);
+                        break;
+                    case 9:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 9);
+                        break;
+                    case 10:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 10);
+                        break;
+                    case 11:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 11);
+                        break;
+                    case 12:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 12);
+                        break;
+                    case 13:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 13);
+                        break;
+                    case 14:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 14);
+                        break;
+                    case 15:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 15);
+                        break;
+                    }
+                    xmLoadPre = xmLoadNext;
+
+                    __m128i xmwLo = _mm_unpacklo_epi8(xmb, _mm_setzero_si128());
+                    __m128i xmwHi = _mm_unpackhi_epi8(xmb, _mm_setzero_si128());
+
+                    __m128i xmwAlpha = _mm_and_si128(xmb, msk_alpha);
+                    __m128i xmwAlphaLo = _mm_shuffle_epi8(xmb, sfl_alphaLo);
+                    __m128i xmwAlphaHi = _mm_shuffle_epi8(xmb, sfl_alphaHi);
+
+                    xmwLo = _mm_mullo_epi16(xmwLo, xmwAlphaLo);
+                    xmwLo = _mm_adds_epu16(xmwLo, word_add);
+                    xmwLo = _mm_mulhi_epu16(xmwLo, word_mul);
+
+                    xmwHi = _mm_mullo_epi16(xmwHi, xmwAlphaHi);
+                    xmwHi = _mm_adds_epu16(xmwHi, word_add);
+                    xmwHi = _mm_mulhi_epu16(xmwHi, word_mul);
+
+                    __m128i xmRes = _mm_packus_epi16(xmwLo, xmwHi);
+                    xmRes = _mm_or_si128(xmRes, xmwAlpha);
+                    xmRes = _mm_shuffle_epi8(xmRes, sfl_bgra);
+                    _mm_store_si128((__m128i*)dst, xmRes);
+
+                    src += 16;
+                    dst += 16;
+                    i -= 4;
+                }
+            }
+
+            while (i >= 1) {
+                PRUint8 r = *src++;
+                PRUint8 g = *src++;
+                PRUint8 b = *src++;
+                PRUint8 a = *src++;
+
+                // Convert to premultiplied color (losslessly if the input came from getImageData)
+                *dst++ = sPremultiplyTable[a][b];
+                *dst++ = sPremultiplyTable[a][g];
+                *dst++ = sPremultiplyTable[a][r];
+                *dst++ = a;
+                i -= 1;
+            }
+        }
+    } else
+#endif // (_MSC_VER != 1400) || !defined(_M_AMD64)
+    {
+        for (PRInt64 j = 0; j < height; j++) {
+            PRUint8 *src = srcFirst + (srcStride * j);
+            PRUint8 *dst = dstFirst + (dstStride * j);
+
+            for (PRUint32 i = 0; i < width; i++) {
+                // XXX Is there some useful swizzle MMX we can use here?
+                PRUint8 r = *src++;
+                PRUint8 g = *src++;
+                PRUint8 b = *src++;
+                PRUint8 a = *src++;
+
+                // Convert to premultiplied color (losslessly if the input came from getImageData)
+#ifdef IS_LITTLE_ENDIAN
+                *dst++ = sPremultiplyTable[a][b];
+                *dst++ = sPremultiplyTable[a][g];
+                *dst++ = sPremultiplyTable[a][r];
+                *dst++ = a;
+#else
+                *dst++ = a;
+                *dst++ = sPremultiplyTable[a][r];
+                *dst++ = sPremultiplyTable[a][g];
+                *dst++ = sPremultiplyTable[a][b];
+#endif
+            }
+        }
+    }
+}
+
 } // namespace CanvasUtils
 } // namespace mozilla
diff -r f7a18ca15f55 content/canvas/src/CanvasUtils.h
--- a/content/canvas/src/CanvasUtils.h    Sun Jan 29 12:39:30 2012 -0800
+++ b/content/canvas/src/CanvasUtils.h    Wed Feb 01 17:49:51 2012 +0900
@@ -55,6 +55,16 @@
 
 using namespace gfx;
 
+void GetImageData_component(PRUint8* _src, PRUint8* _dst,
+                            PRUint32 width, PRUint32 height,
+                            PRUint32 srcStride, PRUint32 dstStride,
+                            PRUint8 (*sUnpremultiplyTable)[256]);
+
+void PutImageData_component(PRUint8* _src, PRUint8* _dst,
+                            PRUint32 width, PRUint32 height,
+                            PRUint32 srcStride, PRUint32 dstStride,
+                            PRUint8 (*sPremultiplyTable)[256]);
+
 // Check that the rectangle [x,y,w,h] is a subrectangle of [0,0,realWidth,realHeight]
 
 inline bool CheckSaneSubrectSize(PRInt32 x, PRInt32 y, PRInt32 w, PRInt32 h,
diff -r f7a18ca15f55 content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -3931,27 +3931,7 @@
     PRUint8 *src = aData;
     PRUint8 *dst = aData;
 
-    for (PRUint32 j = 0; j < h; j++) {
-        for (PRUint32 i = 0; i < w; i++) {
-            // XXX Is there some useful swizzle MMX we can use here?
-#ifdef IS_LITTLE_ENDIAN
-            PRUint8 b = *src++;
-            PRUint8 g = *src++;
-            PRUint8 r = *src++;
-            PRUint8 a = *src++;
-#else
-            PRUint8 a = *src++;
-            PRUint8 r = *src++;
-            PRUint8 g = *src++;
-            PRUint8 b = *src++;
-#endif
-            // Convert to non-premultiplied color
-            *dst++ = sUnpremultiplyTable[a][r];
-            *dst++ = sUnpremultiplyTable[a][g];
-            *dst++ = sUnpremultiplyTable[a][b];
-            *dst++ = a;
-        }
-    }
+    GetImageData_component(src, dst, w, h, w * 4, w * 4, sUnpremultiplyTable);
 
     return NS_OK;
 }
@@ -4054,27 +4034,8 @@
     PRUint8 *src = aData;
     PRUint8 *dst = imgsurf->Data();
 
-    for (PRUint32 j = 0; j < h; j++) {
-        for (PRUint32 i = 0; i < w; i++) {
-            PRUint8 r = *src++;
-            PRUint8 g = *src++;
-            PRUint8 b = *src++;
-            PRUint8 a = *src++;
-
-            // Convert to premultiplied color (losslessly if the input came from getImageData)
-#ifdef IS_LITTLE_ENDIAN
-            *dst++ = sPremultiplyTable[a][b];
-            *dst++ = sPremultiplyTable[a][g];
-            *dst++ = sPremultiplyTable[a][r];
-            *dst++ = a;
-#else
-            *dst++ = a;
-            *dst++ = sPremultiplyTable[a][r];
-            *dst++ = sPremultiplyTable[a][g];
-            *dst++ = sPremultiplyTable[a][b];
-#endif
-        }
-    }
+    PutImageData_component(src, dst, w, h,
+                           w * 4, w * 4, sPremultiplyTable);
 
     PathAutoSaveRestore pathSR(this);
     gfxContextAutoSaveRestore autoSR(mThebes);
diff -r f7a18ca15f55 content/canvas/src/nsCanvasRenderingContext2DAzure.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2DAzure.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/content/canvas/src/nsCanvasRenderingContext2DAzure.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -4058,29 +4058,9 @@
   // from src and advancing that ptr before writing to dst.
   PRUint8 *dst = aData + dstWriteRect.y * (w * 4) + dstWriteRect.x * 4;
 
-  for (int j = 0; j < dstWriteRect.height; j++) {
-    for (int i = 0; i < dstWriteRect.width; i++) {
-      // XXX Is there some useful swizzle MMX we can use here?
-#ifdef IS_LITTLE_ENDIAN
-      PRUint8 b = *src++;
-      PRUint8 g = *src++;
-      PRUint8 r = *src++;
-      PRUint8 a = *src++;
-#else
-      PRUint8 a = *src++;
-      PRUint8 r = *src++;
-      PRUint8 g = *src++;
-      PRUint8 b = *src++;
-#endif
-      // Convert to non-premultiplied color
-      *dst++ = sUnpremultiplyTable[a][r];
-      *dst++ = sUnpremultiplyTable[a][g];
-      *dst++ = sUnpremultiplyTable[a][b];
-      *dst++ = a;
-    }
-    src += srcStride - (dstWriteRect.width * 4);
-    dst += (w * 4) - (dstWriteRect.width * 4);
-  }
+  GetImageData_component(src, dst, dstWriteRect.width, dstWriteRect.height,
+                         srcStride, w * 4, sUnpremultiplyTable);
+
   return NS_OK;
 }
 
@@ -4196,27 +4176,8 @@
   PRUint8 *src = aData;
   PRUint8 *dst = imgsurf->Data();
 
-  for (PRUint32 j = 0; j < h; j++) {
-    for (PRUint32 i = 0; i < w; i++) {
-      PRUint8 r = *src++;
-      PRUint8 g = *src++;
-      PRUint8 b = *src++;
-      PRUint8 a = *src++;
-
-      // Convert to premultiplied color (losslessly if the input came from getImageData)
-#ifdef IS_LITTLE_ENDIAN
-      *dst++ = sPremultiplyTable[a][b];
-      *dst++ = sPremultiplyTable[a][g];
-      *dst++ = sPremultiplyTable[a][r];
-      *dst++ = a;
-#else
-      *dst++ = a;
-      *dst++ = sPremultiplyTable[a][r];
-      *dst++ = sPremultiplyTable[a][g];
-      *dst++ = sPremultiplyTable[a][b];
-#endif
-    }
-  }
+  PutImageData_component(src, dst, w, h,
+                         w * 4, w * 4, sPremultiplyTable);
 
   RefPtr<SourceSurface> sourceSurface =
     mTarget->CreateSourceSurfaceFromData(imgsurf->Data(), IntSize(w, h), imgsurf->Stride(), FORMAT_B8G8R8A8);
diff -r f7a18ca15f55 content/media/Makefile.in
--- a/content/media/Makefile.in    Sun Jan 29 12:39:30 2012 -0800
+++ b/content/media/Makefile.in    Wed Feb 01 17:49:51 2012 +0900
@@ -106,3 +106,11 @@
   -I$(srcdir)/../base/src \
   -I$(srcdir)/../html/content/src \
   $(NULL)
+
+# Optimizer bug with MSVC PGO
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+nsMediaCache.$(OBJ_SUFFIX): nsMediaCache.cpp $(GLOBAL_DEPS)
+    $(REPORT_BUILD)
+    @$(MAKE_DEPS_AUTO_CC)
+    $(ELOG) $(CCC) $(OUTOPTION)$@ -c $(COMPILE_CXXFLAGS) -GL- $(_VPATH_SRCS)
+endif
diff -r f7a18ca15f55 content/media/nsAudioStream.cpp
--- a/content/media/nsAudioStream.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/content/media/nsAudioStream.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -43,6 +43,9 @@
 #include "nsXULAppAPI.h"
 using namespace mozilla::dom;
 
+#if (_M_IX86_FP >= 1) || defined(__SSE__)
+#include <xmmintrin.h>
+#endif
 #include <stdio.h>
 #include <math.h>
 #include "prlog.h"
@@ -485,6 +488,63 @@
       }
       case FORMAT_FLOAT32: {
         const float* buf = static_cast<const float*>(aBuf);
+#if (_M_IX86_FP >= 1) || defined(__SSE__)
+        static const __m128 sMin = _mm_set_ps1(-32768.0);
+        static const __m128 sMax = _mm_set_ps1(32767.0);
+        const __m128 xmmMin = sMin;
+        const __m128 xmmMax = sMax;
+        float* b = (float*)buf;
+        const __m128 xmmMul = _mm_set_ps1((float)(32768 * scaled_volume));
+        __m128 xmmTmp = _mm_setzero_ps();
+        PRUint32 i = 0;
+        PRInt32 n = samples;
+#ifdef _MSC_VER
+        __declspec(align(16)) PRInt32
+#elif defined(__GNUC__)
+        PRInt32 __attribute__((aligned(16)))
+#else
+        PRInt32
+#endif
+        r_dest[4];
+
+        while (n >= 1 && ((unsigned long)b & 15)) {
+          __m128 scaled_value = _mm_mul_ss(xmmMul, _mm_load_ss(b));
+          scaled_value = _mm_max_ss(scaled_value, xmmMin);
+          scaled_value = _mm_min_ss(scaled_value, xmmMax);
+          s_data[i] = (short)_mm_cvtss_si32(scaled_value);
+
+          b++;
+          i++;
+          n--;
+        }
+
+        while (n >= 4) {
+          __m128 scaled_value = _mm_mul_ps(xmmMul, _mm_load_ps(b));
+          scaled_value = _mm_max_ps(scaled_value, xmmMin);
+          scaled_value = _mm_min_ps(scaled_value, xmmMax);
+          *((__m64*)&r_dest[0]) = _mm_cvtps_pi32(scaled_value);
+          *((__m64*)&r_dest[2]) = _mm_cvtps_pi32(_mm_movehl_ps(xmmTmp, scaled_value));
+          s_data[i++] = r_dest[0];
+          s_data[i++] = r_dest[1];
+          s_data[i++] = r_dest[2];
+          s_data[i++] = r_dest[3];
+
+          b += 4;
+          n -= 4;
+        }
+        _mm_empty();
+
+        while (n >= 1) {
+          __m128 scaled_value = _mm_mul_ss(xmmMul, _mm_load_ss(b));
+          scaled_value = _mm_max_ss(scaled_value, xmmMin);
+          scaled_value = _mm_min_ss(scaled_value, xmmMax);
+          s_data[i] = (short)_mm_cvtss_si32(scaled_value);
+
+          b++;
+          i++;
+          n--;
+        }
+#else // (_M_IX86_FP >= 1) || defined(__SSE__)
         for (PRUint32 i = 0; i <  samples; ++i) {
           float scaled_value = floorf(0.5 + 32768 * buf[i] * scaled_volume);
           if (buf[i] < 0.0) {
@@ -497,6 +557,7 @@
               short(scaled_value);
           }
         }
+#endif // (_M_IX86_FP >= 1) || defined(__SSE__)
         break;
       }
     }
diff -r f7a18ca15f55 content/svg/content/src/nsSVGFilters.cpp
--- a/content/svg/content/src/nsSVGFilters.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/content/svg/content/src/nsSVGFilters.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -937,6 +937,18 @@
 
   PRUint16 mode = mEnumAttributes[MODE].GetAnimValue();
 
+  switch (mode) {
+    case nsSVGFEBlendElement::SVG_MODE_NORMAL:
+    case nsSVGFEBlendElement::SVG_MODE_MULTIPLY:
+    case nsSVGFEBlendElement::SVG_MODE_SCREEN:
+    case nsSVGFEBlendElement::SVG_MODE_DARKEN:
+    case nsSVGFEBlendElement::SVG_MODE_LIGHTEN:
+      break;
+    default:
+      return NS_ERROR_FAILURE;
+      break;
+  }
+
   for (PRInt32 x = rect.x; x < rect.XMost(); x++) {
     for (PRInt32 y = rect.y; y < rect.YMost(); y++) {
       PRUint32 targIndex = y * stride + 4 * x;
@@ -965,11 +977,9 @@
             val = NS_MAX((255 - qa) * cb + 255 * ca,
                          (255 - qb) * ca + 255 * cb);
             break;
-          default:
-            return NS_ERROR_FAILURE;
-            break;
         }
-        val = NS_MIN(val / 255, 255U);
+        FAST_DIVIDE_BY_255(val, val);
+        val = NS_MIN(val, 255U);
         targetData[targIndex + i] =  static_cast<PRUint8>(val);
       }
       PRUint32 alpha = 255 * 255 - (255 - qa) * (255 - qb);
@@ -1527,6 +1537,7 @@
     // Blend in the second source image
     float k1Scaled = k1 / 255.0f;
     float k4Scaled = k4*255.0f;
+
     for (PRInt32 x = rect.x; x < rect.XMost(); x++) {
       for (PRInt32 y = rect.y; y < rect.YMost(); y++) {
         PRUint32 targIndex = y * stride + 4 * x;
@@ -1986,7 +1997,8 @@
       break;
 
     for (i = 0; i < 256; i++) {
-      PRUint32 k = (i * (tvLength - 1)) / 255;
+      PRUint32 k;
+      FAST_DIVIDE_BY_255(k, (i * (tvLength - 1)));
       float v1 = tableValues[k];
       float v2 = tableValues[NS_MIN(k + 1, tvLength - 1)];
       PRInt32 val =
@@ -2004,7 +2016,8 @@
       break;
 
     for (i = 0; i < 256; i++) {
-      PRUint32 k = (i * tvLength) / 255;
+      PRUint32 k;
+      FAST_DIVIDE_BY_255(k, (i * tvLength));
       k = NS_MIN(k, tvLength - 1);
       float v = tableValues[k];
       PRInt32 val = PRInt32(255 * v);
@@ -3332,7 +3345,7 @@
       }
 
       PRUint8 r, g, b, a;
-      a = PRUint8(col[3]);
+      a = (PRUint8)(col[3]);
       FAST_DIVIDE_BY_255(r, unsigned(col[0]) * a);
       FAST_DIVIDE_BY_255(g, unsigned(col[1]) * a);
       FAST_DIVIDE_BY_255(b, unsigned(col[2]) * a);
@@ -3791,8 +3804,6 @@
   PRUint8* sourceData = aSources[0]->mImage->Data();
   PRUint8* targetData = aTarget->mImage->Data();
   PRUint32 stride = aTarget->mImage->Stride();
-  PRUint32 xExt[4], yExt[4];  // X, Y indices of RGBA extrema
-  PRUint8 extrema[4];         // RGBA magnitude of extrema
   PRUint16 op = mEnumAttributes[OPERATOR].GetAnimValue();
 
   /* Scan the kernel for each pixel to determine max/min RGBA values.  Note that
@@ -3803,6 +3814,8 @@
    * not fall within the current kernel or if we are starting a new row.
    */
   for (PRInt32 y = rect.y; y < rect.YMost(); y++) {
+    PRUint32 xExt[4], yExt[4];  // X, Y indices of RGBA extrema
+    PRUint8 extrema[4];         // RGBA magnitude of extrema
     PRUint32 startY = NS_MAX(0, y - ry);
     // We need to read pixels not just in 'rect', which is limited to
     // the dirty part of our filter primitive subregion, but all pixels in
@@ -5020,16 +5033,16 @@
 
   const float radPerDeg = M_PI/180.0;
 
-  float L[3];
+  float L_orig[3];
   if (distantLight) {
     float azimuth, elevation;
     static_cast<nsSVGFEDistantLightElement*>
       (distantLight.get())->GetAnimatedNumberValues(&azimuth,
                                                     &elevation,
                                                     nsnull);
-    L[0] = cos(azimuth * radPerDeg) * cos(elevation * radPerDeg);
-    L[1] = sin(azimuth * radPerDeg) * cos(elevation * radPerDeg);
-    L[2] = sin(elevation * radPerDeg);
+    L_orig[0] = cos(azimuth * radPerDeg) * cos(elevation * radPerDeg);
+    L_orig[1] = sin(azimuth * radPerDeg) * cos(elevation * radPerDeg);
+    L_orig[2] = sin(elevation * radPerDeg);
   }
   float lightPos[3], pointsAt[3], specularExponent;
   float cosConeAngle = 0;
@@ -5077,6 +5090,8 @@
       PRInt32 index = y * stride + x * 4;
 
       float N[3];
+      float L[3];
+      memcpy(L, L_orig, sizeof(L));
       GenerateNormal(N, sourceData, stride, surfaceWidth, surfaceHeight,
                      x, y, surfaceScale);
 
diff -r f7a18ca15f55 dom/plugins/base/nsPluginNativeWindowWin.cpp
--- a/dom/plugins/base/nsPluginNativeWindowWin.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/dom/plugins/base/nsPluginNativeWindowWin.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -69,7 +69,18 @@
    && nsMinorVersion(suppliedV) >= nsMinorVersion(requiredV))
 
 
-#define NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION TEXT("MozillaPluginWindowPropertyAssociation")
+class CAtom_MozillaPluginWindowPropertyAssociation {
+public:
+  CAtom_MozillaPluginWindowPropertyAssociation() {
+    atom = ::GlobalAddAtomW(L"MozillaPluginWindowPropertyAssociation");
+  }
+  ~CAtom_MozillaPluginWindowPropertyAssociation() {
+    ::GlobalDeleteAtom(atom);
+  }
+  ATOM atom;
+};
+static CAtom_MozillaPluginWindowPropertyAssociation gaMpwpa;
+#define NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION ((LPCWSTR)(DWORD)gaMpwpa.atom)
 #define NS_PLUGIN_CUSTOM_MSG_ID TEXT("MozFlashUserRelay")
 #define WM_USER_FLASH WM_USER+1
 static UINT sWM_FLASHBOUNCEMSG = 0;
@@ -224,7 +235,7 @@
  */
 static LRESULT CALLBACK PluginWndProcInternal(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 {
-  nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+  nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
   if (!win)
     return TRUE;
 
@@ -423,7 +434,7 @@
                        LONG_PTR newLong)
 {
   nsPluginNativeWindowWin * win =
-    (nsPluginNativeWindowWin *)GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+    (nsPluginNativeWindowWin *)GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
   if (!win || (win && win->mPluginType != nsPluginType_Flash) ||
       (nIndex == GWLP_WNDPROC &&
        newLong == reinterpret_cast<LONG_PTR>(PluginWndProc)))
@@ -451,7 +462,7 @@
 
   // We already checked this in SetWindowLongHookCheck
   nsPluginNativeWindowWin * win =
-    (nsPluginNativeWindowWin *)GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+    (nsPluginNativeWindowWin *)GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
 
   // Hook our subclass back up, just like we do on setwindow.   
   win->SetPrevWindowProc(
@@ -480,7 +491,7 @@
 
   // We already checked this in SetWindowLongHookCheck
   nsPluginNativeWindowWin * win =
-    (nsPluginNativeWindowWin *)GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+    (nsPluginNativeWindowWin *)GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
 
   // Hook our subclass back up, just like we do on setwindow.   
   win->SetPrevWindowProc(
@@ -723,10 +734,10 @@
   if (!mPluginWinProc)
     return NS_ERROR_FAILURE;
 
-  nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+  nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
   NS_ASSERTION(!win || (win == this), "plugin window already has property and this is not us");
   
-  if (!::SetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION, (HANDLE)this))
+  if (!::SetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION, (HANDLE)this))
     return NS_ERROR_FAILURE;
 
   return NS_OK;
@@ -740,7 +751,7 @@
   // remove window property
   HWND hWnd = (HWND)window;
   if (IsWindow(hWnd))
-    ::RemoveProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+    ::RemovePropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
 
   // restore the original win proc
   // but only do this if this were us last time
diff -r f7a18ca15f55 gfx/2d/DrawTargetD2D.cpp
--- a/gfx/2d/DrawTargetD2D.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/gfx/2d/DrawTargetD2D.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -46,6 +46,16 @@
 #include "Tools.h"
 #include <algorithm>
 
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+extern "C" {
+  extern __m128i _mm_shuffle_epi8(__m128i a, __m128i b);
+}
+#else
+#include <tmmintrin.h>
+#endif
+#include "mozilla/SSE.h"
+
 #ifndef M_PI
 #define M_PI 3.14159265358979323846
 #endif
@@ -1790,6 +1800,12 @@
   return style;
 }
 
+static const float f_zero = 0;
+static const float f_one = 1.0f;
+static const __m128 xm_4095_rcp_mul = _mm_set_ss(1.0f / 4095);
+static const __m128 xm_255x4 = _mm_set1_ps(255.0f);
+static const __m128i sfl_pack4 = _mm_set_epi8(0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 12, 0, 4, 8);
+
 TemporaryRef<ID3D10Texture1D>
 DrawTargetD2D::CreateGradientTexture(const GradientStopsD2D *aStops)
 {
@@ -1799,10 +1815,84 @@
   rawStops.resize(aStops->mStopCollection->GetGradientStopCount());
   aStops->mStopCollection->GetGradientStops(&rawStops.front(), rawStops.size());
 
+#if defined(_M_AMD64)
   std::vector<unsigned char> textureData;
   textureData.resize(4096 * 4);
   unsigned char *texData = &textureData.front();
+#else
+  unsigned char *textureData = new unsigned char [4096 * 4];
+  unsigned char *texData = textureData;
 
+if (mozilla::supports_sse()) {
+  __m128 prevColorPos = _mm_load_ss(&f_zero);
+  __m128 nextColorPos = _mm_load_ss(&f_one);
+  __m128 prevColor = _mm_loadu_ps((float*)&rawStops[0].color);
+  __m128 nextColor = prevColor;
+
+  if (rawStops.size() >= 2) {
+    nextColor = _mm_loadu_ps((float*)&rawStops[1].color);
+    nextColorPos = _mm_load_ss(&rawStops[1].position);
+  }
+
+  uint32_t stopPosition = 2;
+  __m128 interp_rcp_mul = _mm_div_ss(_mm_load_ss(&f_one), _mm_sub_ss(nextColorPos, prevColorPos));
+
+  // Not the most optimized way but this will do for now.
+  for (int i = 0; i < 4096; i++) {
+    // The 4095 seems a little counter intuitive, but we want the gradient
+    // color at offset 0 at the first pixel, and at offset 1.0f at the last
+    // pixel.
+    __m128 pos;
+    pos = _mm_cvtsi32_ss(pos, i);
+    pos = _mm_mul_ss(pos, xm_4095_rcp_mul);
+
+    if (_mm_comigt_ss(pos, nextColorPos)) {
+      prevColor = nextColor;
+      prevColorPos = nextColorPos;
+      if (rawStops.size() > stopPosition) {
+        nextColor = _mm_loadu_ps((float*)&rawStops[stopPosition].color);
+        nextColorPos = _mm_load_ss(&rawStops[stopPosition++].position);
+      } else {
+        nextColorPos = _mm_load_ss(&f_one);
+      }
+      interp_rcp_mul = _mm_div_ss(_mm_load_ss(&f_one), _mm_sub_ss(nextColorPos, prevColorPos));
+    }
+
+    __m128 interp = _mm_mul_ss(_mm_sub_ss(pos, prevColorPos), interp_rcp_mul);
+    interp = _mm_shuffle_ps(interp, interp, _MM_SHUFFLE(0, 0, 0, 0));
+
+    __m128 newColor = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(nextColor, prevColor), interp), prevColor);
+    newColor = _mm_mul_ps(newColor, xm_255x4);
+
+#if (_MSC_VER != 1400) || !defined(_M_AMD64)
+    if (mozilla::supports_ssse3()) {
+      __m128i xmResult = _mm_cvttps_epi32(newColor);
+      xmResult = _mm_shuffle_epi8(xmResult, sfl_pack4);
+      *((uint32_t*)&texData[i * 4]) = _mm_cvtsi128_si32(xmResult);
+    } else
+#endif
+    {
+      newColor = _mm_shuffle_ps(newColor, newColor, _MM_SHUFFLE(3, 0, 1, 2));
+      if (mozilla::supports_sse2()) {
+        __m128i xmResult = _mm_cvttps_epi32(newColor);
+        xmResult = _mm_packs_epi32(xmResult, _mm_setzero_si128());
+        xmResult = _mm_packus_epi16(xmResult, _mm_setzero_si128());
+        *((uint32_t*)&texData[i * 4]) = _mm_cvtsi128_si32(xmResult);
+      }
+      else {
+        __m64 mResult = _mm_cvttps_pi32(_mm_movehl_ps(newColor, newColor));
+        mResult = _mm_packs_pi32(_mm_cvttps_pi32(newColor), mResult);
+        mResult = _mm_packs_pu16(mResult, _mm_setzero_si64());
+        *((uint32_t*)&texData[i * 4]) = _mm_cvtsi64_si32(mResult);
+      }
+    }
+  }
+
+  if (!mozilla::supports_sse2()) {
+    _mm_empty();
+  }
+} else {
+#endif
   float prevColorPos = 0;
   float nextColorPos = 1.0f;
   D2D1_COLOR_F prevColor = rawStops[0].color;
@@ -1845,13 +1935,24 @@
     texData[i * 4 + 2] = (char)(255.0f * newColor.r);
     texData[i * 4 + 3] = (char)(255.0f * newColor.a);
   }
+#if !defined(_M_AMD64)
+}
+#endif    // not _M_AMD64
 
   D3D10_SUBRESOURCE_DATA data;
+#if defined(_M_AMD64)
   data.pSysMem = &textureData.front();
+#else
+  data.pSysMem = textureData;
+#endif    // _M_AMD64
 
   RefPtr<ID3D10Texture1D> tex;
   mDevice->CreateTexture1D(&desc, &data, byRef(tex));
 
+#if !defined(_M_AMD64)
+  delete [] textureData;
+#endif    // not _M_AMD64
+
   return tex;
 }
 
diff -r f7a18ca15f55 gfx/cairo/cairo/src/cairo-d2d-private.h
--- a/gfx/cairo/cairo/src/cairo-d2d-private.h    Sun Jan 29 12:39:30 2012 -0800
+++ b/gfx/cairo/cairo/src/cairo-d2d-private.h    Wed Feb 01 17:49:51 2012 +0900
@@ -42,6 +42,7 @@
 #include <d2d1.h>
 #include <d3d10.h>
 #include <dxgi.h>
+#include <list>
 
 #include "cairoint.h"
 #include "cairo-surface-clipper-private.h"
@@ -73,6 +74,18 @@
     int mVRAMUsage;
 };
 
+typedef struct
+{
+    RefPtr<ID2D1RadialGradientBrush> radialGradientBrush;
+    RefPtr<ID2D1GradientStopCollection> radialGradientStopCollection;
+} radial_gradient;
+
+typedef struct
+{
+    RefPtr<ID2D1LinearGradientBrush> linearGradientBrush;
+    RefPtr<ID2D1GradientStopCollection> linearGradientStopCollection;
+} linear_gradient;
+
 const unsigned int TEXT_TEXTURE_WIDTH = 2048;
 const unsigned int TEXT_TEXTURE_HEIGHT = 512;
 typedef struct _cairo_d2d_device cairo_d2d_device_t;
@@ -130,6 +143,12 @@
     RefPtr<ID2D1BitmapBrush> bitmapBrush;
     /** Brush used for solid colors */
     RefPtr<ID2D1SolidColorBrush> solidColorBrush;
+
+    /** Brush used for radial gradients */
+    std::list<radial_gradient> mRadialGradientCache;
+    /** Brush used for linear gradients */
+    std::list<linear_gradient> mLinearGradientCache;
+
     /** Indicates if our render target is currently in drawing mode */
     bool isDrawing;
     /** Indicates if text rendering is initialized */
diff -r f7a18ca15f55 gfx/cairo/cairo/src/cairo-d2d-surface.cpp
--- a/gfx/cairo/cairo/src/cairo-d2d-surface.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/gfx/cairo/cairo/src/cairo-d2d-surface.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -1519,19 +1519,55 @@
     return NULL;
     }
 
-    RefPtr<ID2D1GradientStopCollection> stopCollection;
-    d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &stopCollection);
-    RefPtr<ID2D1RadialGradientBrush> brush;
-
-    d2dsurf->rt->CreateRadialGradientBrush(D2D1::RadialGradientBrushProperties(center,
-                                           origin,
-                                           outer_radius,
-                                           outer_radius),
-                       brushProps,
-                       stopCollection,
-                       &brush);
-    delete [] stops;
-    return brush;
+     std::list<radial_gradient>::iterator iterRadialGradient = d2dsurf->mRadialGradientCache.end();
+ 
+     if (d2dsurf->mRadialGradientCache.size() > 0) {
+         for (std::list<radial_gradient>::iterator iter = d2dsurf->mRadialGradientCache.begin();
+              iter != d2dsurf->mRadialGradientCache.end(); iter++) {
+             UINT32 nCount = (*iter).radialGradientStopCollection->GetGradientStopCount();
+ 
+             if (nCount == num_stops &&
+                 nCount > 0) {
+                 D2D1_GRADIENT_STOP *gradientStopsOld = new D2D1_GRADIENT_STOP[nCount];
+ 
+                 (*iter).radialGradientStopCollection->GetGradientStops(gradientStopsOld, nCount);
+                 bool stopCollectionEqual = (memcmp(gradientStopsOld, stops, sizeof(D2D1_GRADIENT_STOP) * nCount) == 0);
+                 delete [] gradientStopsOld;
+                 if (stopCollectionEqual) {
+                     iterRadialGradient = iter;
+                     break;
+                 }
+             }
+         }
+     }
+ 
+     if (iterRadialGradient != d2dsurf->mRadialGradientCache.end()) {
+         (*iterRadialGradient).radialGradientBrush->SetOpacity(brushProps.opacity);
+         (*iterRadialGradient).radialGradientBrush->SetTransform(&brushProps.transform);
+         (*iterRadialGradient).radialGradientBrush->SetCenter(center);
+         (*iterRadialGradient).radialGradientBrush->SetGradientOriginOffset(origin);
+         (*iterRadialGradient).radialGradientBrush->SetRadiusX(outer_radius);
+         (*iterRadialGradient).radialGradientBrush->SetRadiusY(outer_radius);
+     } else {
+         radial_gradient rg;
+ 
+         d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &rg.radialGradientStopCollection);
+         d2dsurf->rt->CreateRadialGradientBrush(D2D1::RadialGradientBrushProperties(center,
+             origin,
+             outer_radius,
+             outer_radius),
+             brushProps,
+             rg.radialGradientStopCollection,
+             &rg.radialGradientBrush);
+ 
+         iterRadialGradient = d2dsurf->mRadialGradientCache.insert(d2dsurf->mRadialGradientCache.begin(), rg);
+         if (d2dsurf->mRadialGradientCache.size() > 100) {
+             d2dsurf->mRadialGradientCache.pop_back();
+         }
+     }
+
+     delete [] stops;
+     return (*iterRadialGradient).radialGradientBrush;
 }
 
 static RefPtr<ID2D1Brush>
@@ -1681,16 +1717,50 @@
     stops[source_pattern->base.n_stops + 1].position = 1.0f;
     stops[source_pattern->base.n_stops + 1].color = D2D1::ColorF(0, 0);
     }
-    RefPtr<ID2D1GradientStopCollection> stopCollection;
-    d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &stopCollection);
-    RefPtr<ID2D1LinearGradientBrush> brush;
-    d2dsurf->rt->CreateLinearGradientBrush(D2D1::LinearGradientBrushProperties(D2D1::Point2F((FLOAT)p1.x, (FLOAT)p1.y),
-                                           D2D1::Point2F((FLOAT)p2.x, (FLOAT)p2.y)),
-                       brushProps,
-                       stopCollection,
-                       &brush);
+    std::list<linear_gradient>::iterator iterLinearGradient = d2dsurf->mLinearGradientCache.end();
+
+    if (d2dsurf->mLinearGradientCache.size() > 0) {
+        for (std::list<linear_gradient>::iterator iter = d2dsurf->mLinearGradientCache.begin();
+             iter != d2dsurf->mLinearGradientCache.end(); iter++) {
+            UINT32 nCount = (*iter).linearGradientStopCollection->GetGradientStopCount();
+
+            if (nCount == num_stops &&
+                nCount > 0) {
+                D2D1_GRADIENT_STOP *gradientStopsOld = new D2D1_GRADIENT_STOP[nCount];
+
+                (*iter).linearGradientStopCollection->GetGradientStops(gradientStopsOld, nCount);
+                bool stopCollectionEqual = (memcmp(gradientStopsOld, stops, sizeof(D2D1_GRADIENT_STOP) * nCount) == 0);
+                delete [] gradientStopsOld;
+                if (stopCollectionEqual) {
+                    iterLinearGradient = iter;
+                    break;
+                }
+            }
+        }
+    }
+
+    if (iterLinearGradient != d2dsurf->mLinearGradientCache.end()) {
+        (*iterLinearGradient).linearGradientBrush->SetOpacity(brushProps.opacity);
+        (*iterLinearGradient).linearGradientBrush->SetTransform(&brushProps.transform);
+        (*iterLinearGradient).linearGradientBrush->SetStartPoint(D2D1::Point2F((FLOAT)p1.x, (FLOAT)p1.y));
+        (*iterLinearGradient).linearGradientBrush->SetEndPoint(D2D1::Point2F((FLOAT)p2.x, (FLOAT)p2.y));
+    } else {
+        linear_gradient lg;
+
+        d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &lg.linearGradientStopCollection);
+        d2dsurf->rt->CreateLinearGradientBrush(D2D1::LinearGradientBrushProperties(D2D1::Point2F((FLOAT)p1.x, (FLOAT)p1.y), D2D1::Point2F((FLOAT)p2.x, (FLOAT)p2.y)),
+            brushProps,
+            lg.linearGradientStopCollection,
+            &lg.linearGradientBrush);
+
+        iterLinearGradient = d2dsurf->mLinearGradientCache.insert(d2dsurf->mLinearGradientCache.begin(), lg);
+        if (d2dsurf->mLinearGradientCache.size() > 100) {
+            d2dsurf->mLinearGradientCache.pop_back();
+        }
+    }
+
     delete [] stops;
-    return brush;
+    return (*iterLinearGradient).linearGradientBrush;
 }
 
 /**
diff -r f7a18ca15f55 gfx/cairo/libpixman/src/pixman-bits-image.c
--- a/gfx/cairo/libpixman/src/pixman-bits-image.c    Sun Jan 29 12:39:30 2012 -0800
+++ b/gfx/cairo/libpixman/src/pixman-bits-image.c    Wed Feb 01 17:49:51 2012 +0900
@@ -34,6 +34,12 @@
 #include <string.h>
 #include "pixman-private.h"
 #include "pixman-combine32.h"
+#ifdef _WIN64
+#include "pixman-x64-mmx-emulation.h"
+#endif
+#include <xmmintrin.h>
+#include <emmintrin.h>
+#include "pixman-accessor.h"
 
 /*
  * By default, just evaluate the image at 32bpp and expand.  Individual image
@@ -87,8 +93,495 @@
     return image->fetch_pixel_32 (image, x, y);
 }
 
-typedef uint32_t (* get_pixel_t) (bits_image_t *image,
-                  int x, int y, pixman_bool_t check_bounds);
+/* --------------- MMX primitivess ------------------------------------ */
+
+#ifdef __GNUC__
+typedef unsigned long long ullong;
+typedef ullong mmxdatafield;
+#endif
+#ifdef _MSC_VER
+typedef unsigned __int64 ullong;
+typedef __m64 mmxdatafield;
+#endif
+
+typedef struct
+{
+    mmxdatafield mmx_4x8000;
+    mmxdatafield mmx_2x00800000;
+    mmxdatafield mmx_2x00ff0000;
+    mmxdatafield mmx_2x0000ff00;
+} MMXData;
+
+static const MMXData c =
+{
+#ifdef __GNUC__
+    .mmx_4x8000 =     0x8000800080008000ULL;
+    .mmx_2x00800000 = 0x0080000000800000ULL;
+    .mmx_2x00ff0000 = 0x00ff000000ff0000ULL;
+    .mmx_2x0000ff00 = 0x0000ff000000ff00ULL;
+#endif
+#ifdef _MSC_VER
+    { 0x8000800080008000UI64 },
+    { 0x0080000000800000UI64 },
+    { 0x00ff000000ff0000UI64 },
+    { 0x0000ff000000ff00UI64 },
+#endif
+};
+
+#ifdef __GNUC__
+#define MC(x) ((__m64) c.mmx_##x)
+#endif
+#ifdef _MSC_VER
+#define MC(x) c.mmx_##x
+#endif
+
+static force_inline uint32_t
+
+
+transform_mmx(int distx, int idistx, int disty, int idisty,
+              uint32_t tl, uint32_t tr, uint32_t bl, uint32_t br)
+{
+    uint32_t r;
+    __m64 mZero = _mm_setzero_si64();
+
+    __m64 tlm = _m_from_int(tl);
+    __m64 trm = _m_from_int(tr);
+    __m64 blm = _m_from_int(bl);
+    __m64 brm = _m_from_int(br);
+
+    __m64 tlrLm, tlrHm, blrLm, blrHm;
+    __m64 ftLm, ftHm, fbLm, fbHm;
+    __m64 rLm, rHm;
+
+    __m64 distxm, distym;
+/*
+    distxm = _mm_set_pi16(distx, idistx, distx, idistx);
+    distym = _mm_set_pi16(disty, idisty, disty, idisty);
+*/
+    distxm = _m_punpcklwd(_m_from_int(idistx), _m_from_int(distx));
+    distym = _m_punpcklwd(_m_from_int(idisty), _m_from_int(disty));
+
+    distxm = _m_punpckldq(distxm, distxm);
+    distym = _m_punpckldq(distym, distym);
+
+    tlm = _m_punpcklbw(tlm, mZero);
+    trm = _m_punpcklbw(trm, mZero);
+    tlrLm = _m_punpcklwd(tlm, trm);
+    tlrHm = _m_punpckhwd(tlm, trm);
+    ftLm = _m_pmaddwd(tlrLm, distxm);
+    ftHm = _m_pmaddwd(tlrHm, distxm);
+
+    blm = _m_punpcklbw(blm, mZero);
+    brm = _m_punpcklbw(brm, mZero);
+    blrLm = _m_punpcklwd(blm, brm);
+    blrHm = _m_punpckhwd(blm, brm);
+    fbLm = _m_pmaddwd(blrLm, distxm);
+    fbHm = _m_pmaddwd(blrHm, distxm);
+
+    rLm = _m_por(_m_pslldi(fbLm, 16), ftLm);
+    rLm = _m_paddw(rLm, MC(4x8000));
+    rLm = _m_pmaddwd(rLm, distym);
+    rLm = _m_paddd(rLm, MC(2x00800000));
+
+    rHm = _m_por(_m_pslldi(fbHm, 16), ftHm);
+    rHm = _m_paddw(rHm, MC(4x8000));
+    rHm = _m_pmaddwd(rHm, distym);
+    rHm = _m_paddd(rHm, MC(2x00800000));
+
+#if _M_IX86_FP >= 1 || defined(USE_SSE) || defined(USE_SSE2)
+    rLm = _m_pand(rLm, MC(2x00ff0000));
+    rLm = _m_psrlqi(rLm, 16);
+    rHm = _m_pand(rHm, MC(2x00ff0000));
+    rLm = _m_por(rLm, rHm);
+    rLm = _m_pshufw(rLm, _MM_SHUFFLE(3, 1, 2, 0));
+    rLm = _m_packuswb(rLm, mZero);
+    r = _m_to_int(rLm);
+#else
+    r = ((_m_to_int(rLm) >> 16) & 0xff);
+    r |= ((_m_to_int(_m_psrlqi(rLm, 32)) >> 8) & 0xff00);
+    r |= ((_m_to_int(rHm)) & 0xff0000);
+    r |= ((_m_to_int(_m_psrlqi(rHm, 32)) << 8) & 0xff000000);
+#endif
+    return r;
+}
+
+static force_inline uint32_t
+transform_mmx_same_height(int distx, int idistx, uint32_t tl, uint32_t tr)
+{
+    uint32_t r;
+    __m64 mZero = _mm_setzero_si64();
+
+    __m64 tlm = _m_from_int(tl);
+    __m64 trm = _m_from_int(tr);
+
+    __m64 tlrLm, tlrHm;
+    __m64 ftLm, ftHm, fbLm, fbHm;
+
+    __m64 distxm;
+/*
+    distxm = _mm_set_pi16(distx, idistx, distx, idistx);
+*/
+    distxm = _m_punpcklwd(_m_from_int(idistx), _m_from_int(distx));
+    distxm = _m_punpckldq(distxm, distxm);
+
+    tlm = _m_punpcklbw(tlm, mZero);
+    trm = _m_punpcklbw(trm, mZero);
+    tlrLm = _m_punpcklwd(tlm, trm);
+    tlrHm = _m_punpckhwd(tlm, trm);
+    ftLm = _m_pmaddwd(tlrLm, distxm);
+    ftHm = _m_pmaddwd(tlrHm, distxm);
+
+#if _M_IX86_FP >= 1 || defined(USE_SSE) || defined(USE_SSE2)
+    ftLm = _m_pand(ftLm, MC(2x0000ff00));
+    ftHm = _m_pand(ftHm, MC(2x0000ff00));
+    ftHm = _m_pslldi(ftHm, 16);
+    ftLm = _m_por(ftLm, ftHm);
+    ftLm = _m_psrlwi(ftLm, 8);
+    ftLm = _m_pshufw(ftLm, _MM_SHUFFLE(3, 1, 2, 0));
+    ftLm = _m_packuswb(ftLm, mZero);
+    r = _m_to_int(ftLm);
+#else
+    r = ((_m_to_int(ftLm) >> 8) & 0xff);
+    r |= (_m_to_int(_m_psrlqi(ftLm, 32)) & 0xff00);
+    r |= ((_m_to_int(ftHm) << 8) & 0xff0000);
+    r |= ((_m_to_int(_m_psrlqi(ftHm, 32)) << 16) & 0xff000000);
+#endif
+    return r;
+}
+
+#if defined(_MSC_VER) && (_M_IX86_FP >= 1)
+static force_inline uint32_t
+transform_sse_vc86(int _distx, int _idistx, int _disty, int _idisty,
+                   uint32_t _tl, uint32_t _tr, uint32_t _bl, uint32_t _br)
+{
+    __asm
+    {
+        pxor        mm0, mm0
+
+        movd        mm1, _tl
+        movd        mm2, _tr
+        movd        mm3, _bl
+        movd        mm4, _br
+
+        movd        mm6, _idistx
+        punpcklwd   mm6, _distx
+        punpckldq   mm6, mm6
+
+        movd        mm7, _idisty
+        punpcklwd   mm7, _disty
+        punpckldq   mm7, mm7
+
+        punpcklbw   mm1, mm0
+        punpcklbw   mm2, mm0
+        movq        mm5, mm1
+        punpcklwd   mm1, mm2
+        punpckhwd   mm5, mm2
+        pmaddwd     mm1, mm6
+        pmaddwd     mm5, mm6
+
+        punpcklbw   mm3, mm0
+        punpcklbw   mm4, mm0
+        movq        mm2, mm3
+        punpcklwd   mm3, mm4
+        punpckhwd   mm2, mm4
+        pmaddwd     mm3, mm6
+        pmaddwd     mm2, mm6
+
+        pslld       mm3, 16
+        por         mm3, mm1
+        paddw       mm3, MC(4x8000)
+        pmaddwd     mm3, mm7
+        paddd       mm3, MC(2x00800000)
+
+        pslld       mm2, 16
+        por         mm2, mm5
+        paddw       mm2, MC(4x8000)
+        pmaddwd     mm2, mm7
+        paddd       mm2, MC(2x00800000)
+
+        pand        mm3, MC(2x00ff0000)
+        psrlq       mm3, 16
+        pand        mm2, MC(2x00ff0000)
+        por         mm3, mm2
+        pshufw      mm3, mm3, _MM_SHUFFLE(3, 1, 2, 0)
+        packuswb    mm3, mm0
+        movd        eax, mm3
+    }
+}
+#define transform_mmx(distx, idistx, disty, idisty, tl, tr, bl, br) \
+        transform_sse_vc86((distx), (idistx), (disty), (idisty), (tl), (tr), (bl), (br))
+
+static force_inline uint32_t
+transform_sse_same_height_vc86(int _distx, int _idistx, uint32_t _tl, uint32_t _tr)
+{
+    __asm
+    {
+        pxor        mm0, mm0
+
+        movd        mm1, _tl
+        movd        mm2, _tr
+
+        movd        mm6, _idistx
+        punpcklwd   mm6, _distx
+        punpckldq   mm6, mm6
+
+        punpcklbw   mm1, mm0
+        punpcklbw   mm2, mm0
+        movq        mm5, mm1
+        punpcklwd   mm1, mm2
+        punpckhwd   mm5, mm2
+        pmaddwd     mm1, mm6
+        pmaddwd     mm5, mm6
+
+        pand        mm1, MC(2x0000ff00)
+        pand        mm5, MC(2x0000ff00)
+        pslld       mm5, 16
+        por         mm1, mm5
+        psrlw       mm1, 8
+        pshufw      mm1, mm1, _MM_SHUFFLE(3, 1, 2, 0)
+        packuswb    mm1, mm0
+        movd        eax, mm1
+    }
+}
+#define transform_mmx_same_height(distx, idistx, tl, tr) \
+        transform_sse_same_height_vc86((distx), (idistx), (tl), (tr))
+#endif
+
+
+#if (_M_IX86_FP >= 2) || defined(__SSE2__) || defined(_WIN64)
+
+#if defined(_MSC_VER)
+  #define TT_ALIGN16(expr) __declspec(align(16)) expr
+#elif defined(__GNUC__)
+  #define TT_ALIGN16(expr) expr __attribute__((aligned(16)))
+#else
+  #define TT_ALIGN16(expr) expr
+#endif
+static const TT_ALIGN16(uint16_t) Mask8000[8] = { 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000 };
+static const TT_ALIGN16(uint32_t) Mask00800000[4] = { 0x00800000, 0x00800000, 0x00800000, 0x00800000 };
+static const TT_ALIGN16(uint32_t) Mask00ff0000[4] = { 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000 };
+static const TT_ALIGN16(uint32_t) Mask0000ff00[4] = { 0x0000ff00, 0x0000ff00, 0x0000ff00, 0x0000ff00 };
+/*
+static const __m128i Mask8000 = _mm_set1_epi16(0x8000);
+static const __m128i Mask00800000 = _mm_set1_epi32(0x00800000);
+static const __m128i Mask00ff0000 = _mm_set1_epi32(0x00ff0000);
+static const __m128i Mask0000ff00 = _mm_set1_epi32(0x0000ff00);
+*/
+
+static force_inline uint32_t
+transform_sse2(int distx, int idistx, int disty, int idisty,
+               uint32_t tl, uint32_t tr, uint32_t bl, uint32_t br)
+{
+    uint32_t r;
+    __m128i mZero = _mm_setzero_si128();
+
+    __m128i tlm = _mm_cvtsi32_si128(tl);
+    __m128i trm = _mm_cvtsi32_si128(tr);
+    __m128i blm = _mm_cvtsi32_si128(bl);
+    __m128i brm = _mm_cvtsi32_si128(br);
+
+    __m128i tlrm, blrm;
+    __m128i ftm, fbm;
+    __m128i rm;
+
+    __m128i distxm, distym;
+    distxm = _mm_set1_epi32((distx << 16) | idistx);
+    distym = _mm_set1_epi32((disty << 16) | idisty);
+
+    tlrm = _mm_unpacklo_epi8(tlm, trm);
+    tlrm = _mm_unpacklo_epi8(tlrm, mZero);
+    ftm = _mm_madd_epi16(tlrm, distxm);
+
+    blrm = _mm_unpacklo_epi8(blm, brm);
+    blrm = _mm_unpacklo_epi8(blrm, mZero);
+    fbm = _mm_madd_epi16(blrm, distxm);
+
+    rm = _mm_or_si128(_mm_slli_epi32(fbm, 16), ftm);
+    rm = _mm_add_epi16(rm, *(__m128i*)Mask8000);
+    rm = _mm_madd_epi16(rm, distym);
+    rm = _mm_add_epi32(rm, *(__m128i*)Mask00800000);
+
+    rm = _mm_and_si128(rm, *(__m128i*)Mask00ff0000);
+    rm = _mm_srli_epi64(rm, 16);
+    rm = _mm_packs_epi32(rm, mZero);
+    rm = _mm_packus_epi16(rm, mZero);
+    r = _mm_cvtsi128_si32(rm);
+    return r;
+}
+#undef  transform_mmx
+#define transform_mmx(distx, idistx, disty, idisty, tl, tr, bl, br) \
+        transform_sse2((distx), (idistx), (disty), (idisty), (tl), (tr), (bl), (br))
+
+static force_inline uint32_t
+transform_sse2_same_height(int distx, int idistx, uint32_t tl, uint32_t tr)
+{
+    uint32_t r;
+    __m128i mZero = _mm_setzero_si128();
+
+    __m128i tlm = _mm_cvtsi32_si128(tl);
+    __m128i trm = _mm_cvtsi32_si128(tr);
+
+    __m128i tlrm;
+    __m128i ftm;
+    __m128i rm;
+
+    __m128i distxm = _mm_set1_epi32((distx << 16) | idistx);
+
+    tlrm = _mm_unpacklo_epi8(tlm, trm);
+    tlrm = _mm_unpacklo_epi8(tlrm, mZero);
+    ftm = _mm_madd_epi16(tlrm, distxm);
+
+    rm = _mm_and_si128(ftm, *(__m128i*)Mask0000ff00);
+    rm = _mm_srli_epi16(rm, 8);
+    rm = _mm_packs_epi32(rm, mZero);
+    rm = _mm_packus_epi16(rm, mZero);
+    r = _mm_cvtsi128_si32(rm);
+    return r;
+}
+#undef  transform_mmx_same_height
+#define transform_mmx_same_height(distx, idistx, tl, tr) \
+        transform_sse2_same_height((distx), (idistx), (tl), (tr))
+
+#if defined(_MSC_VER) && (_M_IX86_FP >= 2) && !defined(_WIN64)
+static force_inline uint32_t
+transform_sse2_vc86(int _distx, int _idistx, int _disty, int _idisty,
+                    uint32_t _tl, uint32_t _tr, uint32_t _bl, uint32_t _br)
+{
+    __asm
+    {
+        mov         eax, _distx
+        shl         eax, 16
+        or          eax, _idistx
+        movd        xmm5, eax
+        pxor        xmm0, xmm0
+        pshufd      xmm5, xmm5, _MM_SHUFFLE(0, 0, 0, 0)
+
+        movd        xmm1, _tl
+        movd        xmm2, _tr
+        punpcklbw   xmm1, xmm2
+        punpcklbw   xmm1, xmm0
+        pmaddwd     xmm1, xmm5
+
+    mov         eax, _disty
+    shl         eax, 16
+    or          eax, _idisty
+    movd        xmm6, eax
+
+        movd        xmm3, _bl
+        movd        xmm4, _br
+        punpcklbw   xmm3, xmm4
+        punpcklbw   xmm3, xmm0
+        pmaddwd     xmm3, xmm5
+
+    pshufd      xmm6, xmm6, _MM_SHUFFLE(0, 0, 0, 0)
+
+        pslld       xmm3, 16
+        por         xmm3, xmm1
+        paddw       xmm3, Mask8000
+        pmaddwd     xmm3, xmm6
+        paddd       xmm3, Mask00800000
+
+        pand        xmm3, Mask00ff0000
+        psrlq       xmm3, 16
+        packssdw    xmm3, xmm0
+        packuswb    xmm3, xmm0
+        movd        eax, xmm3
+    }
+}
+#undef  transform_mmx
+#define transform_mmx(distx, idistx, disty, idisty, tl, tr, bl, br) \
+        transform_sse2_vc86((distx), (idistx), (disty), (idisty), (tl), (tr), (bl), (br))
+
+static force_inline uint32_t
+transform_sse2_same_height_vc86(int _distx, int _idistx, uint32_t _tl, uint32_t _tr)
+{
+    __asm
+    {
+        mov         eax, _distx
+        shl         eax, 16
+        or          eax, _idistx
+        movd        xmm5, eax
+        pxor        xmm0, xmm0
+        pshufd      xmm5, xmm5, _MM_SHUFFLE(0, 0, 0, 0)
+
+        movd        xmm1, _tl
+        movd        xmm2, _tr
+        punpcklbw   xmm1, xmm2
+        punpcklbw   xmm1, xmm0
+        pmaddwd     xmm1, xmm5
+
+        pand        xmm1, Mask0000ff00
+        psrlw       xmm1, 8
+        packssdw    xmm1, xmm0
+        packuswb    xmm1, xmm0
+        movd        eax, xmm1
+    }
+}
+#undef  transform_mmx_same_height
+#define transform_mmx_same_height(distx, idistx, tl, tr) \
+        transform_sse2_same_height_vc86((distx), (idistx), (tl), (tr))
+#endif /* defined(_MSC_VER) && (_M_IX86_FP >= 2) && !defined(_WIN64) */
+
+#endif /* (_M_IX86_FP >= 2) || defined(__SSE2__) || defined(_WIN64) */
+
+
+#ifdef _MSC_VER
+#undef MOD
+#define MOD(a, b) ((a) >= 0 ? MOD_TT(a, b) : ((b) - MOD_TT(-(a) - 1, b)) - 1)
+#ifndef PIXMAN_FB_ACCESSORS
+extern
+#endif
+int __fastcall MOD_TT(int a, int b);
+#endif
+
+
+#define fetch_pixel_32_x8r8g8b8_opt(pict, offset, lineaddr) \
+    (uint32_t)(READ((pict), (uint32_t *)(lineaddr) + (offset)) | 0xff000000)
+#define fetch_pixel_32_a8r8g8b8_opt(pict, offset, lineaddr) \
+    (uint32_t)(READ((pict), (uint32_t *)(lineaddr) + (offset)))
+
+static force_inline uint32_t
+get_pixel_orig (bits_image_t *image, int x, int y, pixman_bool_t check_bounds)
+{
+  if (check_bounds &&
+(x < 0 || x >= image->width || y < 0 || y >= image->height))
+  {
+return 0;
+  }
+
+  return image->fetch_pixel_32 (image, x, y);
+}
+
+static force_inline uint32_t
+get_pixel (bits_image_t *image, int x, int y, pixman_bool_t check_bounds,
+           uint32_t *lineaddr, pixman_bool_t use_pxmask, uint32_t pxmask)
+{
+    if (check_bounds &&
+    (x < 0 || x >= image->width || y < 0 || y >= image->height))
+    {
+    return 0;
+    }
+
+    if (use_pxmask)
+    {
+        return (uint32_t)(READ(image, (uint32_t *)lineaddr + x) | pxmask);
+    }
+    else
+    {
+        if (PIXMAN_x8r8g8b8 == image->format)
+        {
+           return fetch_pixel_32_x8r8g8b8_opt(image, x, lineaddr);
+        }
+        else if (PIXMAN_a8r8g8b8 == image->format)
+        {
+           return fetch_pixel_32_a8r8g8b8_opt(image, x, lineaddr);
+        }
+        else
+        {
+            return image->fetch_pixel_32 (image, x, y);
+        }
+    }
+}
 
 static force_inline void
 repeat (pixman_repeat_t repeat, int size, int *coord)
@@ -118,25 +611,50 @@
     }
 }
 
+typedef struct
+{
+  int y_old;
+  int y_mod_or_cliped_old;
+  uint32_t *y_line;
+} fetch_nearest_info_tt;
+
 static force_inline uint32_t
 bits_image_fetch_pixel_nearest (bits_image_t   *image,
                 pixman_fixed_t  x,
                 pixman_fixed_t  y,
-                get_pixel_t    get_pixel)
+
+                pixman_repeat_t repeat_mode,
+                fetch_nearest_info_tt *fni,
+                pixman_bool_t use_pxmask,
+                uint32_t pxmask)
 {
     int x0 = pixman_fixed_to_int (x - pixman_fixed_e);
     int y0 = pixman_fixed_to_int (y - pixman_fixed_e);
 
-    if (image->common.repeat != PIXMAN_REPEAT_NONE)
+    if (repeat_mode != PIXMAN_REPEAT_NONE)
     {
     repeat (image->common.repeat, image->width, &x0);
-    repeat (image->common.repeat, image->height, &y0);
-
-    return get_pixel (image, x0, y0, FALSE);
+    if (fni->y_old != y0)
+    {
+        fni->y_old = y0;
+        repeat (image->common.repeat, image->height, &y0);
+        fni->y_mod_or_cliped_old = y0;
+        fni->y_line = image->bits + y0 * image->rowstride;
+    }
+    else
+    {
+        y0 = fni->y_mod_or_cliped_old;
+    }
+    return get_pixel (image, x0, y0, FALSE, fni->y_line, use_pxmask, pxmask);
     }
     else
     {
-    return get_pixel (image, x0, y0, TRUE);
+        if (fni->y_old != y0)
+        {
+            fni->y_old = y0;
+            fni->y_line = image->bits + y0 * image->rowstride;
+        }
+    return get_pixel (image, x0, y0, TRUE, fni->y_line, use_pxmask, pxmask);
     }
 }
 
@@ -191,53 +709,36 @@
             uint32_t bl, uint32_t br,
             int distx, int disty)
 {
-    int distxy, distxiy, distixy, distixiy;
-    uint32_t f, r;
-
-    distxy = distx * disty;
-    distxiy = (distx << 8) - distxy;    /* distx * (256 - disty) */
-    distixy = (disty << 8) - distxy;    /* disty * (256 - distx) */
-    distixiy =
-    256 * 256 - (disty << 8) -
-    (distx << 8) + distxy;        /* (256 - distx) * (256 - disty) */
-
-    /* Blue */
-    r = (tl & 0x000000ff) * distixiy + (tr & 0x000000ff) * distxiy
-      + (bl & 0x000000ff) * distixy  + (br & 0x000000ff) * distxy;
-
-    /* Green */
-    f = (tl & 0x0000ff00) * distixiy + (tr & 0x0000ff00) * distxiy
-      + (bl & 0x0000ff00) * distixy  + (br & 0x0000ff00) * distxy;
-    r |= f & 0xff000000;
-
-    tl >>= 16;
-    tr >>= 16;
-    bl >>= 16;
-    br >>= 16;
-    r >>= 16;
-
-    /* Red */
-    f = (tl & 0x000000ff) * distixiy + (tr & 0x000000ff) * distxiy
-      + (bl & 0x000000ff) * distixy  + (br & 0x000000ff) * distxy;
-    r |= f & 0x00ff0000;
-
-    /* Alpha */
-    f = (tl & 0x0000ff00) * distixiy + (tr & 0x0000ff00) * distxiy
-      + (bl & 0x0000ff00) * distixy  + (br & 0x0000ff00) * distxy;
-    r |= f & 0xff000000;
-
-    return r;
+    return transform_mmx(distx, 256 - distx, disty, 256 - disty, tl, tr, bl, br);
 }
 
+static force_inline uint32_t
+bilinear_interpolation_same_height (uint32_t tl, uint32_t tr, int distx)
+{
+    return transform_mmx_same_height(distx, 256 - distx, tl, tr);
+}
+
 #endif
 
+typedef struct
+{
+  int y1_old;
+  int y1_mod_or_cliped_old;
+  int y2_mod_or_cliped_old;
+  uint32_t *y1_line;
+  uint32_t *y2_line;
+} fetch_bilinear_info_tt;
+
 static force_inline uint32_t
 bits_image_fetch_pixel_bilinear (bits_image_t   *image,
                  pixman_fixed_t  x,
                  pixman_fixed_t  y,
-                 get_pixel_t     get_pixel)
+
+                 pixman_repeat_t repeat_mode,
+                 fetch_bilinear_info_tt *fbi,
+                 pixman_bool_t use_pxmask,
+                 uint32_t pxmask)
 {
-    pixman_repeat_t repeat_mode = image->common.repeat;
     int width = image->width;
     int height = image->height;
     int x1, y1, x2, y2;
@@ -257,25 +758,83 @@
 
     if (repeat_mode != PIXMAN_REPEAT_NONE)
     {
-    repeat (repeat_mode, width, &x1);
-    repeat (repeat_mode, height, &y1);
-    repeat (repeat_mode, width, &x2);
-    repeat (repeat_mode, height, &y2);
-
-    tl = get_pixel (image, x1, y1, FALSE);
-    bl = get_pixel (image, x1, y2, FALSE);
-    tr = get_pixel (image, x2, y1, FALSE);
-    br = get_pixel (image, x2, y2, FALSE);
+        if (PIXMAN_REPEAT_PAD == repeat_mode)
+        {
+            if (x1 < 0 || x2 >= width)
+            {
+                repeat (repeat_mode, width, &x1);
+                repeat (repeat_mode, width, &x2);
+            }
+        }
+        else
+        {
+            repeat (repeat_mode, width, &x1);
+            repeat (repeat_mode, width, &x2);
+        }
+
+        if (fbi->y1_old != y1)
+        {
+            fbi->y1_old = y1;
+            repeat (repeat_mode, height, &y1);
+            repeat (repeat_mode, height, &y2);
+            fbi->y1_mod_or_cliped_old = y1;
+            fbi->y2_mod_or_cliped_old = y2;
+            fbi->y1_line = image->bits + y1 * image->rowstride;
+            fbi->y2_line = image->bits + y2 * image->rowstride;
+        }
+        else
+        {
+            y1 = fbi->y1_mod_or_cliped_old;
+            y2 = fbi->y2_mod_or_cliped_old;
+        }
+
+        tl = get_pixel (image, x1, y1, FALSE, fbi->y1_line, use_pxmask, pxmask);
+        tr = get_pixel (image, x2, y1, FALSE, fbi->y1_line, use_pxmask, pxmask);
+        if (0 != disty)
+        {
+            bl = get_pixel (image, x1, y2, FALSE, fbi->y2_line, use_pxmask, pxmask);
+            br = get_pixel (image, x2, y2, FALSE, fbi->y2_line, use_pxmask, pxmask);
+            if (tl != br || tl != tr || tl != bl)
+                return bilinear_interpolation (tl, tr, bl, br, distx, disty);
+            else
+                return tl;
+        }
+        else
+        {
+            if (tl != tr)
+                return bilinear_interpolation_same_height(tl, tr, distx);
+            else
+                return tl;
+        }
     }
     else
     {
-    tl = get_pixel (image, x1, y1, TRUE);
-    tr = get_pixel (image, x2, y1, TRUE);
-    bl = get_pixel (image, x1, y2, TRUE);
-    br = get_pixel (image, x2, y2, TRUE);
+        if (fbi->y1_old != y1)
+        {
+            fbi->y1_old = y1;
+            fbi->y1_line = image->bits + y1 * image->rowstride;
+            fbi->y2_line = image->bits + y2 * image->rowstride;
+        }
+
+        tl = get_pixel (image, x1, y1, TRUE, fbi->y1_line, use_pxmask, pxmask);
+        tr = get_pixel (image, x2, y1, TRUE, fbi->y1_line, use_pxmask, pxmask);
+        if (0 != disty)
+        {
+            bl = get_pixel (image, x1, y2, TRUE, fbi->y2_line, use_pxmask, pxmask);
+            br = get_pixel (image, x2, y2, TRUE, fbi->y2_line, use_pxmask, pxmask);
+            if (tl != br || tl != tr || tl != bl)
+                return bilinear_interpolation (tl, tr, bl, br, distx, disty);
+            else
+                return tl;
+        }
+        else
+        {
+            if (tl != tr)
+                return bilinear_interpolation_same_height(tl, tr, distx);
+            else
+                return tl;
+        }
     }
-
-    return bilinear_interpolation (tl, tr, bl, br, distx, disty);
 }
 
 static void
@@ -483,6 +1042,10 @@
     mask += mask_inc;
     }
 
+#if (_M_IX86_FP < 2) && !defined(__SSE2__)
+    _mm_empty();
+#endif
+
     /* Zero fill to the left of the image */
     while (buffer < end)
     *buffer++ = 0;
@@ -492,7 +1055,8 @@
 bits_image_fetch_pixel_convolution (bits_image_t   *image,
                     pixman_fixed_t  x,
                     pixman_fixed_t  y,
-                    get_pixel_t     get_pixel)
+
+                    pixman_repeat_t repeat_mode)
 {
     pixman_fixed_t *params = image->common.filter_params;
     int x_off = (params[0] - pixman_fixed_1) >> 1;
@@ -501,7 +1065,6 @@
     int32_t cheight = pixman_fixed_to_int (params[1]);
     int32_t srtot, sgtot, sbtot, satot;
     int32_t i, j, x1, x2, y1, y2;
-    pixman_repeat_t repeat_mode = image->common.repeat;
     int width = image->width;
     int height = image->height;
 
@@ -532,11 +1095,11 @@
             repeat (repeat_mode, width, &rx);
             repeat (repeat_mode, height, &ry);
 
-            pixel = get_pixel (image, rx, ry, FALSE);
+            pixel = get_pixel_orig (image, rx, ry, FALSE);
         }
         else
         {
-            pixel = get_pixel (image, rx, ry, TRUE);
+            pixel = get_pixel_orig (image, rx, ry, TRUE);
         }
 
         srtot += RED_8 (pixel) * f;
@@ -562,82 +1125,37 @@
     return ((satot << 24) | (srtot << 16) | (sgtot <<  8) | (sbtot));
 }
 
-static force_inline uint32_t
-bits_image_fetch_pixel_filtered (bits_image_t *image,
-                 pixman_fixed_t x,
-                 pixman_fixed_t y,
-                 get_pixel_t    get_pixel)
+static force_inline void
+fetch_scanline_a8r8g8b8 (pixman_image_t *image,
+                         int             x,
+                         int             y,
+                         int             width,
+                         uint32_t *      buffer,
+                         const uint32_t *mask,
+                         uint32_t        mask_bits)
 {
-    switch (image->common.filter)
-    {
-    case PIXMAN_FILTER_NEAREST:
-    case PIXMAN_FILTER_FAST:
-    return bits_image_fetch_pixel_nearest (image, x, y, get_pixel);
-    break;
-
-    case PIXMAN_FILTER_BILINEAR:
-    case PIXMAN_FILTER_GOOD:
-    case PIXMAN_FILTER_BEST:
-    return bits_image_fetch_pixel_bilinear (image, x, y, get_pixel);
-    break;
-
-    case PIXMAN_FILTER_CONVOLUTION:
-    return bits_image_fetch_pixel_convolution (image, x, y, get_pixel);
-    break;
-
-    default:
-        break;
-    }
-
-    return 0;
+    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
+    
+    MEMCPY_WRAPPED (image,
+                    buffer, (const uint32_t *)bits + x,
+                    width * sizeof(uint32_t));
 }
 
-static void
-bits_image_fetch_affine_no_alpha (pixman_image_t * image,
-                  int              offset,
-                  int              line,
-                  int              width,
-                  uint32_t *       buffer,
-                  const uint32_t * mask)
+static force_inline void
+fetch_scanline_x8r8g8b8 (pixman_image_t *image,
+                         int             x,
+                         int             y,
+                         int             width,
+                         uint32_t *      buffer,
+                         const uint32_t *mask,
+                         uint32_t        mask_bits)
 {
-    pixman_fixed_t x, y;
-    pixman_fixed_t ux, uy;
-    pixman_vector_t v;
-    int i;
-
-    /* reference point is the center of the pixel */
-    v.vector[0] = pixman_int_to_fixed (offset) + pixman_fixed_1 / 2;
-    v.vector[1] = pixman_int_to_fixed (line) + pixman_fixed_1 / 2;
-    v.vector[2] = pixman_fixed_1;
-
-    if (image->common.transform)
-    {
-    if (!pixman_transform_point_3d (image->common.transform, &v))
-        return;
-
-    ux = image->common.transform->matrix[0][0];
-    uy = image->common.transform->matrix[1][0];
-    }
-    else
-    {
-    ux = pixman_fixed_1;
-    uy = 0;
-    }
-
-    x = v.vector[0];
-    y = v.vector[1];
-
-    for (i = 0; i < width; ++i)
-    {
-    if (!mask || mask[i])
-    {
-        buffer[i] = bits_image_fetch_pixel_filtered (
-        &image->bits, x, y, fetch_pixel_no_alpha);
-    }
-
-    x += ux;
-    y += uy;
-    }
+    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
+    const uint32_t *pixel = (const uint32_t *)bits + x;
+    const uint32_t *end = pixel + width;
+    
+    while (pixel < end)
+    *buffer++ = READ (image, pixel++) | 0xff000000;
 }
 
 /* General fetcher */
@@ -719,30 +1237,276 @@
     y = v.vector[1];
     w = v.vector[2];
 
-    for (i = 0; i < width; ++i)
+    if (w == pixman_fixed_1 && uw == 0) /* Affine */
     {
-    pixman_fixed_t x0, y0;
-
-    if (!mask || mask[i])
-    {
-        if (w != 0)
-        {
-        x0 = ((pixman_fixed_48_16_t)x << 16) / w;
-        y0 = ((pixman_fixed_48_16_t)y << 16) / w;
-        }
-        else
-        {
-        x0 = 0;
-        y0 = 0;
-        }
-
-        buffer[i] = bits_image_fetch_pixel_filtered (
-        &image->bits, x0, y0, fetch_pixel_general);
-    }
-
-    x += ux;
-    y += uy;
-    w += uw;
+        const pixman_bool_t use_pxmask = (PIXMAN_x8r8g8b8 == image->bits.format || PIXMAN_a8r8g8b8 == image->bits.format);
+        const uint32_t pxmask = (PIXMAN_x8r8g8b8 == image->bits.format ? 0xff000000 : 0);
+
+        if ((PIXMAN_REPEAT_NORMAL == image->common.repeat || PIXMAN_REPEAT_PAD == image->common.repeat) &&
+            use_pxmask)
+        {
+            switch (image->common.filter)
+            {
+            case PIXMAN_FILTER_NEAREST:
+            case PIXMAN_FILTER_FAST:
+                {
+                    pixman_repeat_t repeat_mode = image->common.repeat;
+                    fetch_nearest_info_tt fni = { 0, 0, image->bits.bits };
+
+                    switch (repeat_mode)
+                    {
+                    case PIXMAN_REPEAT_NORMAL:
+                        for (i = 0; i < width; ++i)
+                        {
+                          if (!mask || mask[i])
+                          {
+                              buffer[i] =
+                                  bits_image_fetch_pixel_nearest (&image->bits, x, y, repeat_mode, &fni, use_pxmask, pxmask);
+                          }
+
+                          x += ux;
+                          y += uy;
+                        }
+                        break;
+
+                    case PIXMAN_REPEAT_PAD:
+                        for (i = 0; i < width; ++i)
+                        {
+                          if (!mask || mask[i])
+                          {
+                              buffer[i] =
+                                  bits_image_fetch_pixel_nearest (&image->bits, x, y, repeat_mode, &fni, use_pxmask, pxmask);
+                          }
+
+                          x += ux;
+                          y += uy;
+                        }
+                        break;
+                    }
+                }
+                break;
+
+            case PIXMAN_FILTER_BILINEAR:
+            case PIXMAN_FILTER_GOOD:
+            case PIXMAN_FILTER_BEST:
+                {
+                    pixman_repeat_t repeat_mode = image->common.repeat;
+                    fetch_bilinear_info_tt fbi = { INT_MIN, 0, 0, image->bits.bits, image->bits.bits };
+
+                    switch (repeat_mode)
+                    {
+                    case PIXMAN_REPEAT_NORMAL:
+                        for (i = 0; i < width; ++i)
+                        {
+                          if (!mask || mask[i])
+                          {
+                              buffer[i] =
+                                  bits_image_fetch_pixel_bilinear (&image->bits, x, y, repeat_mode, &fbi, use_pxmask, pxmask);
+                          }
+
+                          x += ux;
+                          y += uy;
+                        }
+#if (_M_IX86_FP < 2) && !defined(__SSE2__)
+                        _mm_empty();
+#endif
+                        break;
+
+                    case PIXMAN_REPEAT_PAD:
+                        for (i = 0; i < width; ++i)
+                        {
+                          if (!mask || mask[i])
+                          {
+                              buffer[i] =
+                                  bits_image_fetch_pixel_bilinear (&image->bits, x, y, repeat_mode, &fbi, use_pxmask, pxmask);
+                          }
+
+                          x += ux;
+                          y += uy;
+                        }
+#if (_M_IX86_FP < 2) && !defined(__SSE2__)
+                        _mm_empty();
+#endif
+                        break;
+                    }
+
+                }
+                break;
+
+            case PIXMAN_FILTER_CONVOLUTION:
+                {
+                    pixman_repeat_t repeat_mode = image->common.repeat;
+
+                    for (i = 0; i < width; ++i)
+                    {
+                      if (!mask || mask[i])
+                      {
+                          buffer[i] =
+                              bits_image_fetch_pixel_convolution (&image->bits, x, y, repeat_mode);
+                      }
+
+                      x += ux;
+                      y += uy;
+                    }
+                }
+                break;
+            }
+        }
+        else
+        {
+            switch (image->common.filter)
+            {
+            case PIXMAN_FILTER_NEAREST:
+            case PIXMAN_FILTER_FAST:
+                {
+                    pixman_repeat_t repeat_mode = image->common.repeat;
+                    fetch_nearest_info_tt fni = { 0, 0, image->bits.bits };
+
+                    for (i = 0; i < width; ++i)
+                    {
+                      if (!mask || mask[i])
+                      {
+                          buffer[i] =
+                              bits_image_fetch_pixel_nearest (&image->bits, x, y, repeat_mode, &fni, use_pxmask, pxmask);
+                      }
+
+                      x += ux;
+                      y += uy;
+                    }
+                }
+                break;
+
+            case PIXMAN_FILTER_BILINEAR:
+            case PIXMAN_FILTER_GOOD:
+            case PIXMAN_FILTER_BEST:
+                {
+                    pixman_repeat_t repeat_mode = image->common.repeat;
+                    fetch_bilinear_info_tt fbi = { INT_MIN, 0, 0, image->bits.bits, image->bits.bits };
+
+                    for (i = 0; i < width; ++i)
+                    {
+                      if (!mask || mask[i])
+                      {
+                          buffer[i] =
+                              bits_image_fetch_pixel_bilinear (&image->bits, x, y, repeat_mode, &fbi, use_pxmask, pxmask);
+                      }
+
+                      x += ux;
+                      y += uy;
+                    }
+#if (_M_IX86_FP < 2) && !defined(__SSE2__)
+                    _mm_empty();
+#endif
+                }
+                break;
+
+            case PIXMAN_FILTER_CONVOLUTION:
+                {
+                    pixman_repeat_t repeat_mode = image->common.repeat;
+
+                    for (i = 0; i < width; ++i)
+                    {
+                      if (!mask || mask[i])
+                      {
+                          buffer[i] =
+                              bits_image_fetch_pixel_convolution (&image->bits, x, y, repeat_mode);
+                      }
+
+                      x += ux;
+                      y += uy;
+                    }
+                }
+                break;
+            }
+        }
+    }
+    else
+    {
+        const pixman_bool_t use_pxmask = (PIXMAN_x8r8g8b8 == image->bits.format || PIXMAN_a8r8g8b8 == image->bits.format);
+        const uint32_t pxmask = (PIXMAN_x8r8g8b8 == image->bits.format ? 0xff000000 : 0);
+
+        switch (image->common.filter)
+        {
+        case PIXMAN_FILTER_NEAREST:
+        case PIXMAN_FILTER_FAST:
+            {
+                pixman_repeat_t repeat_mode = image->common.repeat;
+                fetch_nearest_info_tt fni = { 0, 0, image->bits.bits };
+
+                for (i = 0; i < width; ++i)
+                {
+                    pixman_fixed_t x0, y0;
+
+                    if (!mask || mask[i])
+                    {
+                        x0 = ((pixman_fixed_48_16_t)x << 16) / w;
+                        y0 = ((pixman_fixed_48_16_t)y << 16) / w;
+
+                        buffer[i] =
+                            bits_image_fetch_pixel_nearest (&image->bits, x0, y0, repeat_mode, &fni, use_pxmask, pxmask);
+                    }
+
+                    x += ux;
+                    y += uy;
+                    w += uw;
+                }
+            }
+            break;
+
+        case PIXMAN_FILTER_BILINEAR:
+        case PIXMAN_FILTER_GOOD:
+        case PIXMAN_FILTER_BEST:
+            {
+                pixman_repeat_t repeat_mode = image->common.repeat;
+                fetch_bilinear_info_tt fbi = { INT_MIN, 0, 0, image->bits.bits, image->bits.bits };
+
+                for (i = 0; i < width; ++i)
+                {
+                    pixman_fixed_t x0, y0;
+
+                    if (!mask || mask[i])
+                    {
+                        x0 = ((pixman_fixed_48_16_t)x << 16) / w;
+                        y0 = ((pixman_fixed_48_16_t)y << 16) / w;
+
+                        buffer[i] =
+                            bits_image_fetch_pixel_bilinear (&image->bits, x0, y0, repeat_mode, &fbi, use_pxmask, pxmask);
+                    }
+
+                    x += ux;
+                    y += uy;
+                    w += uw;
+                }
+#if (_M_IX86_FP < 2) && !defined(__SSE2__)
+                _mm_empty();
+#endif
+            }
+            break;
+
+        case PIXMAN_FILTER_CONVOLUTION:
+            {
+                pixman_repeat_t repeat_mode = image->common.repeat;
+
+                for (i = 0; i < width; ++i)
+                {
+                    pixman_fixed_t x0, y0;
+
+                    if (!mask || mask[i])
+                    {
+                        x0 = ((pixman_fixed_48_16_t)x << 16) / w;
+                        y0 = ((pixman_fixed_48_16_t)y << 16) / w;
+
+                        buffer[i] =
+                            bits_image_fetch_pixel_convolution (&image->bits, x0, y0, repeat_mode);
+                    }
+
+                    x += ux;
+                    y += uy;
+                    w += uw;
+                }
+            }
+            break;
+        }
     }
 }
 
@@ -902,6 +1666,10 @@
     x += ux;
     y += uy;
     }
+
+#if (_M_IX86_FP < 2) && !defined(__SSE2__)
+    _mm_empty();
+#endif
 }
 
 static force_inline void
@@ -1309,7 +2077,7 @@
     /* Affine, no alpha */
     { PIXMAN_any,
       (FAST_PATH_NO_ALPHA_MAP | FAST_PATH_HAS_TRANSFORM | FAST_PATH_AFFINE_TRANSFORM),
-      bits_image_fetch_affine_no_alpha,
+      bits_image_fetch_general,
       _pixman_image_get_scanline_generic_64
     },
 
@@ -1600,3 +2368,1225 @@
 
     return image;
 }
+
+#if defined(_MSC_VER) && !defined(PIXMAN_FB_ACCESSORS)
+#define CASEMOD(b) case (b): return a % (b)
+int __fastcall MOD_TT(int a, int b)
+{
+  switch (b)
+  {
+  CASEMOD(1);
+  CASEMOD(2);
+  CASEMOD(3);
+  CASEMOD(4);
+  CASEMOD(5);
+  CASEMOD(6);
+  CASEMOD(7);
+  CASEMOD(8);
+  CASEMOD(9);
+  CASEMOD(10);
+
+  CASEMOD(11);
+  CASEMOD(12);
+  CASEMOD(13);
+  CASEMOD(14);
+  CASEMOD(15);
+  CASEMOD(16);
+  CASEMOD(17);
+  CASEMOD(18);
+  CASEMOD(19);
+  CASEMOD(20);
+
+  CASEMOD(21);
+  CASEMOD(22);
+  CASEMOD(23);
+  CASEMOD(24);
+  CASEMOD(25);
+  CASEMOD(26);
+  CASEMOD(27);
+  CASEMOD(28);
+  CASEMOD(29);
+  CASEMOD(30);
+
+  CASEMOD(31);
+  CASEMOD(32);
+  CASEMOD(33);
+  CASEMOD(34);
+  CASEMOD(35);
+  CASEMOD(36);
+  CASEMOD(37);
+  CASEMOD(38);
+  CASEMOD(39);
+  CASEMOD(40);
+
+  CASEMOD(41);
+  CASEMOD(42);
+  CASEMOD(43);
+  CASEMOD(44);
+  CASEMOD(45);
+  CASEMOD(46);
+  CASEMOD(47);
+  CASEMOD(48);
+  CASEMOD(49);
+  CASEMOD(50);
+
+  CASEMOD(51);
+  CASEMOD(52);
+  CASEMOD(53);
+  CASEMOD(54);
+  CASEMOD(55);
+  CASEMOD(56);
+  CASEMOD(57);
+  CASEMOD(58);
+  CASEMOD(59);
+  CASEMOD(60);
+
+  CASEMOD(61);
+  CASEMOD(62);
+  CASEMOD(63);
+  CASEMOD(64);
+  CASEMOD(65);
+  CASEMOD(66);
+  CASEMOD(67);
+  CASEMOD(68);
+  CASEMOD(69);
+  CASEMOD(70);
+
+  CASEMOD(71);
+  CASEMOD(72);
+  CASEMOD(73);
+  CASEMOD(74);
+  CASEMOD(75);
+  CASEMOD(76);
+  CASEMOD(77);
+  CASEMOD(78);
+  CASEMOD(79);
+  CASEMOD(80);
+
+  CASEMOD(81);
+  CASEMOD(82);
+  CASEMOD(83);
+  CASEMOD(84);
+  CASEMOD(85);
+  CASEMOD(86);
+  CASEMOD(87);
+  CASEMOD(88);
+  CASEMOD(89);
+  CASEMOD(90);
+
+  CASEMOD(91);
+  CASEMOD(92);
+  CASEMOD(93);
+  CASEMOD(94);
+  CASEMOD(95);
+  CASEMOD(96);
+  CASEMOD(97);
+  CASEMOD(98);
+  CASEMOD(99);
+  CASEMOD(100);
+
+  CASEMOD(101);
+  CASEMOD(102);
+  CASEMOD(103);
+  CASEMOD(104);
+  CASEMOD(105);
+  CASEMOD(106);
+  CASEMOD(107);
+  CASEMOD(108);
+  CASEMOD(109);
+  CASEMOD(110);
+
+  CASEMOD(111);
+  CASEMOD(112);
+  CASEMOD(113);
+  CASEMOD(114);
+  CASEMOD(115);
+  CASEMOD(116);
+  CASEMOD(117);
+  CASEMOD(118);
+  CASEMOD(119);
+  CASEMOD(120);
+
+  CASEMOD(121);
+  CASEMOD(122);
+  CASEMOD(123);
+  CASEMOD(124);
+  CASEMOD(125);
+  CASEMOD(126);
+  CASEMOD(127);
+  CASEMOD(128);
+  CASEMOD(129);
+  CASEMOD(130);
+
+  CASEMOD(131);
+  CASEMOD(132);
+  CASEMOD(133);
+  CASEMOD(134);
+  CASEMOD(135);
+  CASEMOD(136);
+  CASEMOD(137);
+  CASEMOD(138);
+  CASEMOD(139);
+  CASEMOD(140);
+
+  CASEMOD(141);
+  CASEMOD(142);
+  CASEMOD(143);
+  CASEMOD(144);
+  CASEMOD(145);
+  CASEMOD(146);
+  CASEMOD(147);
+  CASEMOD(148);
+  CASEMOD(149);
+  CASEMOD(150);
+
+  CASEMOD(151);
+  CASEMOD(152);
+  CASEMOD(153);
+  CASEMOD(154);
+  CASEMOD(155);
+  CASEMOD(156);
+  CASEMOD(157);
+  CASEMOD(158);
+  CASEMOD(159);
+  CASEMOD(160);
+
+  CASEMOD(161);
+  CASEMOD(162);
+  CASEMOD(163);
+  CASEMOD(164);
+  CASEMOD(165);
+  CASEMOD(166);
+  CASEMOD(167);
+  CASEMOD(168);
+  CASEMOD(169);
+  CASEMOD(170);
+
+  CASEMOD(171);
+  CASEMOD(172);
+  CASEMOD(173);
+  CASEMOD(174);
+  CASEMOD(175);
+  CASEMOD(176);
+  CASEMOD(177);
+  CASEMOD(178);
+  CASEMOD(179);
+  CASEMOD(180);
+
+  CASEMOD(181);
+  CASEMOD(182);
+  CASEMOD(183);
+  CASEMOD(184);
+  CASEMOD(185);
+  CASEMOD(186);
+  CASEMOD(187);
+  CASEMOD(188);
+  CASEMOD(189);
+  CASEMOD(190);
+
+  CASEMOD(191);
+  CASEMOD(192);
+  CASEMOD(193);
+  CASEMOD(194);
+  CASEMOD(195);
+  CASEMOD(196);
+  CASEMOD(197);
+  CASEMOD(198);
+  CASEMOD(199);
+  CASEMOD(200);
+
+  CASEMOD(201);
+  CASEMOD(202);
+  CASEMOD(203);
+  CASEMOD(204);
+  CASEMOD(205);
+  CASEMOD(206);
+  CASEMOD(207);
+  CASEMOD(208);
+  CASEMOD(209);
+  CASEMOD(210);
+
+  CASEMOD(211);
+  CASEMOD(212);
+  CASEMOD(213);
+  CASEMOD(214);
+  CASEMOD(215);
+  CASEMOD(216);
+  CASEMOD(217);
+  CASEMOD(218);
+  CASEMOD(219);
+  CASEMOD(220);
+
+  CASEMOD(221);
+  CASEMOD(222);
+  CASEMOD(223);
+  CASEMOD(224);
+  CASEMOD(225);
+  CASEMOD(226);
+  CASEMOD(227);
+  CASEMOD(228);
+  CASEMOD(229);
+  CASEMOD(230);
+
+  CASEMOD(231);
+  CASEMOD(232);
+  CASEMOD(233);
+  CASEMOD(234);
+  CASEMOD(235);
+  CASEMOD(236);
+  CASEMOD(237);
+  CASEMOD(238);
+  CASEMOD(239);
+  CASEMOD(240);
+
+  CASEMOD(241);
+  CASEMOD(242);
+  CASEMOD(243);
+  CASEMOD(244);
+  CASEMOD(245);
+  CASEMOD(246);
+  CASEMOD(247);
+  CASEMOD(248);
+  CASEMOD(249);
+  CASEMOD(250);
+
+  CASEMOD(251);
+  CASEMOD(252);
+  CASEMOD(253);
+  CASEMOD(254);
+  CASEMOD(255);
+  CASEMOD(256);
+  CASEMOD(257);
+  CASEMOD(258);
+  CASEMOD(259);
+  CASEMOD(260);
+
+  CASEMOD(261);
+  CASEMOD(262);
+  CASEMOD(263);
+  CASEMOD(264);
+  CASEMOD(265);
+  CASEMOD(266);
+  CASEMOD(267);
+  CASEMOD(268);
+  CASEMOD(269);
+  CASEMOD(270);
+
+  CASEMOD(271);
+  CASEMOD(272);
+  CASEMOD(273);
+  CASEMOD(274);
+  CASEMOD(275);
+  CASEMOD(276);
+  CASEMOD(277);
+  CASEMOD(278);
+  CASEMOD(279);
+  CASEMOD(280);
+
+  CASEMOD(281);
+  CASEMOD(282);
+  CASEMOD(283);
+  CASEMOD(284);
+  CASEMOD(285);
+  CASEMOD(286);
+  CASEMOD(287);
+  CASEMOD(288);
+  CASEMOD(289);
+  CASEMOD(290);
+
+  CASEMOD(291);
+  CASEMOD(292);
+  CASEMOD(293);
+  CASEMOD(294);
+  CASEMOD(295);
+  CASEMOD(296);
+  CASEMOD(297);
+  CASEMOD(298);
+  CASEMOD(299);
+  CASEMOD(300);
+
+  CASEMOD(301);
+  CASEMOD(302);
+  CASEMOD(303);
+  CASEMOD(304);
+  CASEMOD(305);
+  CASEMOD(306);
+  CASEMOD(307);
+  CASEMOD(308);
+  CASEMOD(309);
+  CASEMOD(310);
+
+  CASEMOD(311);
+  CASEMOD(312);
+  CASEMOD(313);
+  CASEMOD(314);
+  CASEMOD(315);
+  CASEMOD(316);
+  CASEMOD(317);
+  CASEMOD(318);
+  CASEMOD(319);
+  CASEMOD(320);
+
+  CASEMOD(321);
+  CASEMOD(322);
+  CASEMOD(323);
+  CASEMOD(324);
+  CASEMOD(325);
+  CASEMOD(326);
+  CASEMOD(327);
+  CASEMOD(328);
+  CASEMOD(329);
+  CASEMOD(330);
+
+  CASEMOD(331);
+  CASEMOD(332);
+  CASEMOD(333);
+  CASEMOD(334);
+  CASEMOD(335);
+  CASEMOD(336);
+  CASEMOD(337);
+  CASEMOD(338);
+  CASEMOD(339);
+  CASEMOD(340);
+
+  CASEMOD(341);
+  CASEMOD(342);
+  CASEMOD(343);
+  CASEMOD(344);
+  CASEMOD(345);
+  CASEMOD(346);
+  CASEMOD(347);
+  CASEMOD(348);
+  CASEMOD(349);
+  CASEMOD(350);
+
+  CASEMOD(351);
+  CASEMOD(352);
+  CASEMOD(353);
+  CASEMOD(354);
+  CASEMOD(355);
+  CASEMOD(356);
+  CASEMOD(357);
+  CASEMOD(358);
+  CASEMOD(359);
+  CASEMOD(360);
+
+  CASEMOD(361);
+  CASEMOD(362);
+  CASEMOD(363);
+  CASEMOD(364);
+  CASEMOD(365);
+  CASEMOD(366);
+  CASEMOD(367);
+  CASEMOD(368);
+  CASEMOD(369);
+  CASEMOD(370);
+
+  CASEMOD(371);
+  CASEMOD(372);
+  CASEMOD(373);
+  CASEMOD(374);
+  CASEMOD(375);
+  CASEMOD(376);
+  CASEMOD(377);
+  CASEMOD(378);
+  CASEMOD(379);
+  CASEMOD(380);
+
+  CASEMOD(381);
+  CASEMOD(382);
+  CASEMOD(383);
+  CASEMOD(384);
+  CASEMOD(385);
+  CASEMOD(386);
+  CASEMOD(387);
+  CASEMOD(388);
+  CASEMOD(389);
+  CASEMOD(390);
+
+  CASEMOD(391);
+  CASEMOD(392);
+  CASEMOD(393);
+  CASEMOD(394);
+  CASEMOD(395);
+  CASEMOD(396);
+  CASEMOD(397);
+  CASEMOD(398);
+  CASEMOD(399);
+  CASEMOD(400);
+
+  CASEMOD(401);
+  CASEMOD(402);
+  CASEMOD(403);
+  CASEMOD(404);
+  CASEMOD(405);
+  CASEMOD(406);
+  CASEMOD(407);
+  CASEMOD(408);
+  CASEMOD(409);
+  CASEMOD(410);
+
+  CASEMOD(411);
+  CASEMOD(412);
+  CASEMOD(413);
+  CASEMOD(414);
+  CASEMOD(415);
+  CASEMOD(416);
+  CASEMOD(417);
+  CASEMOD(418);
+  CASEMOD(419);
+  CASEMOD(420);
+
+  CASEMOD(421);
+  CASEMOD(422);
+  CASEMOD(423);
+  CASEMOD(424);
+  CASEMOD(425);
+  CASEMOD(426);
+  CASEMOD(427);
+  CASEMOD(428);
+  CASEMOD(429);
+  CASEMOD(430);
+
+  CASEMOD(431);
+  CASEMOD(432);
+  CASEMOD(433);
+  CASEMOD(434);
+  CASEMOD(435);
+  CASEMOD(436);
+  CASEMOD(437);
+  CASEMOD(438);
+  CASEMOD(439);
+  CASEMOD(440);
+
+  CASEMOD(441);
+  CASEMOD(442);
+  CASEMOD(443);
+  CASEMOD(444);
+  CASEMOD(445);
+  CASEMOD(446);
+  CASEMOD(447);
+  CASEMOD(448);
+  CASEMOD(449);
+  CASEMOD(450);
+
+  CASEMOD(451);
+  CASEMOD(452);
+  CASEMOD(453);
+  CASEMOD(454);
+  CASEMOD(455);
+  CASEMOD(456);
+  CASEMOD(457);
+  CASEMOD(458);
+  CASEMOD(459);
+  CASEMOD(460);
+
+  CASEMOD(461);
+  CASEMOD(462);
+  CASEMOD(463);
+  CASEMOD(464);
+  CASEMOD(465);
+  CASEMOD(466);
+  CASEMOD(467);
+  CASEMOD(468);
+  CASEMOD(469);
+  CASEMOD(470);
+
+  CASEMOD(471);
+  CASEMOD(472);
+  CASEMOD(473);
+  CASEMOD(474);
+  CASEMOD(475);
+  CASEMOD(476);
+  CASEMOD(477);
+  CASEMOD(478);
+  CASEMOD(479);
+  CASEMOD(480);
+
+  CASEMOD(481);
+  CASEMOD(482);
+  CASEMOD(483);
+  CASEMOD(484);
+  CASEMOD(485);
+  CASEMOD(486);
+  CASEMOD(487);
+  CASEMOD(488);
+  CASEMOD(489);
+  CASEMOD(490);
+
+  CASEMOD(491);
+  CASEMOD(492);
+  CASEMOD(493);
+  CASEMOD(494);
+  CASEMOD(495);
+  CASEMOD(496);
+  CASEMOD(497);
+  CASEMOD(498);
+  CASEMOD(499);
+  CASEMOD(500);
+
+  CASEMOD(501);
+  CASEMOD(502);
+  CASEMOD(503);
+  CASEMOD(504);
+  CASEMOD(505);
+  CASEMOD(506);
+  CASEMOD(507);
+  CASEMOD(508);
+  CASEMOD(509);
+  CASEMOD(510);
+
+  CASEMOD(511);
+  CASEMOD(512);
+  CASEMOD(513);
+  CASEMOD(514);
+  CASEMOD(515);
+  CASEMOD(516);
+  CASEMOD(517);
+  CASEMOD(518);
+  CASEMOD(519);
+  CASEMOD(520);
+
+  CASEMOD(521);
+  CASEMOD(522);
+  CASEMOD(523);
+  CASEMOD(524);
+  CASEMOD(525);
+  CASEMOD(526);
+  CASEMOD(527);
+  CASEMOD(528);
+  CASEMOD(529);
+  CASEMOD(530);
+
+  CASEMOD(531);
+  CASEMOD(532);
+  CASEMOD(533);
+  CASEMOD(534);
+  CASEMOD(535);
+  CASEMOD(536);
+  CASEMOD(537);
+  CASEMOD(538);
+  CASEMOD(539);
+  CASEMOD(540);
+
+  CASEMOD(541);
+  CASEMOD(542);
+  CASEMOD(543);
+  CASEMOD(544);
+  CASEMOD(545);
+  CASEMOD(546);
+  CASEMOD(547);
+  CASEMOD(548);
+  CASEMOD(549);
+  CASEMOD(550);
+
+  CASEMOD(551);
+  CASEMOD(552);
+  CASEMOD(553);
+  CASEMOD(554);
+  CASEMOD(555);
+  CASEMOD(556);
+  CASEMOD(557);
+  CASEMOD(558);
+  CASEMOD(559);
+  CASEMOD(560);
+
+  CASEMOD(561);
+  CASEMOD(562);
+  CASEMOD(563);
+  CASEMOD(564);
+  CASEMOD(565);
+  CASEMOD(566);
+  CASEMOD(567);
+  CASEMOD(568);
+  CASEMOD(569);
+  CASEMOD(570);
+
+  CASEMOD(571);
+  CASEMOD(572);
+  CASEMOD(573);
+  CASEMOD(574);
+  CASEMOD(575);
+  CASEMOD(576);
+  CASEMOD(577);
+  CASEMOD(578);
+  CASEMOD(579);
+  CASEMOD(580);
+
+  CASEMOD(581);
+  CASEMOD(582);
+  CASEMOD(583);
+  CASEMOD(584);
+  CASEMOD(585);
+  CASEMOD(586);
+  CASEMOD(587);
+  CASEMOD(588);
+  CASEMOD(589);
+  CASEMOD(590);
+
+  CASEMOD(591);
+  CASEMOD(592);
+  CASEMOD(593);
+  CASEMOD(594);
+  CASEMOD(595);
+  CASEMOD(596);
+  CASEMOD(597);
+  CASEMOD(598);
+  CASEMOD(599);
+  CASEMOD(600);
+
+  CASEMOD(601);
+  CASEMOD(602);
+  CASEMOD(603);
+  CASEMOD(604);
+  CASEMOD(605);
+  CASEMOD(606);
+  CASEMOD(607);
+  CASEMOD(608);
+  CASEMOD(609);
+  CASEMOD(610);
+
+  CASEMOD(611);
+  CASEMOD(612);
+  CASEMOD(613);
+  CASEMOD(614);
+  CASEMOD(615);
+  CASEMOD(616);
+  CASEMOD(617);
+  CASEMOD(618);
+  CASEMOD(619);
+  CASEMOD(620);
+
+  CASEMOD(621);
+  CASEMOD(622);
+  CASEMOD(623);
+  CASEMOD(624);
+  CASEMOD(625);
+  CASEMOD(626);
+  CASEMOD(627);
+  CASEMOD(628);
+  CASEMOD(629);
+  CASEMOD(630);
+
+  CASEMOD(631);
+  CASEMOD(632);
+  CASEMOD(633);
+  CASEMOD(634);
+  CASEMOD(635);
+  CASEMOD(636);
+  CASEMOD(637);
+  CASEMOD(638);
+  CASEMOD(639);
+  CASEMOD(640);
+
+  CASEMOD(641);
+  CASEMOD(642);
+  CASEMOD(643);
+  CASEMOD(644);
+  CASEMOD(645);
+  CASEMOD(646);
+  CASEMOD(647);
+  CASEMOD(648);
+  CASEMOD(649);
+  CASEMOD(650);
+
+  CASEMOD(651);
+  CASEMOD(652);
+  CASEMOD(653);
+  CASEMOD(654);
+  CASEMOD(655);
+  CASEMOD(656);
+  CASEMOD(657);
+  CASEMOD(658);
+  CASEMOD(659);
+  CASEMOD(660);
+
+  CASEMOD(661);
+  CASEMOD(662);
+  CASEMOD(663);
+  CASEMOD(664);
+  CASEMOD(665);
+  CASEMOD(666);
+  CASEMOD(667);
+  CASEMOD(668);
+  CASEMOD(669);
+  CASEMOD(670);
+
+  CASEMOD(671);
+  CASEMOD(672);
+  CASEMOD(673);
+  CASEMOD(674);
+  CASEMOD(675);
+  CASEMOD(676);
+  CASEMOD(677);
+  CASEMOD(678);
+  CASEMOD(679);
+  CASEMOD(680);
+
+  CASEMOD(681);
+  CASEMOD(682);
+  CASEMOD(683);
+  CASEMOD(684);
+  CASEMOD(685);
+  CASEMOD(686);
+  CASEMOD(687);
+  CASEMOD(688);
+  CASEMOD(689);
+  CASEMOD(690);
+
+  CASEMOD(691);
+  CASEMOD(692);
+  CASEMOD(693);
+  CASEMOD(694);
+  CASEMOD(695);
+  CASEMOD(696);
+  CASEMOD(697);
+  CASEMOD(698);
+  CASEMOD(699);
+  CASEMOD(700);
+
+  CASEMOD(701);
+  CASEMOD(702);
+  CASEMOD(703);
+  CASEMOD(704);
+  CASEMOD(705);
+  CASEMOD(706);
+  CASEMOD(707);
+  CASEMOD(708);
+  CASEMOD(709);
+  CASEMOD(710);
+
+  CASEMOD(711);
+  CASEMOD(712);
+  CASEMOD(713);
+  CASEMOD(714);
+  CASEMOD(715);
+  CASEMOD(716);
+  CASEMOD(717);
+  CASEMOD(718);
+  CASEMOD(719);
+  CASEMOD(720);
+
+  CASEMOD(721);
+  CASEMOD(722);
+  CASEMOD(723);
+  CASEMOD(724);
+  CASEMOD(725);
+  CASEMOD(726);
+  CASEMOD(727);
+  CASEMOD(728);
+  CASEMOD(729);
+  CASEMOD(730);
+
+  CASEMOD(731);
+  CASEMOD(732);
+  CASEMOD(733);
+  CASEMOD(734);
+  CASEMOD(735);
+  CASEMOD(736);
+  CASEMOD(737);
+  CASEMOD(738);
+  CASEMOD(739);
+  CASEMOD(740);
+
+  CASEMOD(741);
+  CASEMOD(742);
+  CASEMOD(743);
+  CASEMOD(744);
+  CASEMOD(745);
+  CASEMOD(746);
+  CASEMOD(747);
+  CASEMOD(748);
+  CASEMOD(749);
+  CASEMOD(750);
+
+  CASEMOD(751);
+  CASEMOD(752);
+  CASEMOD(753);
+  CASEMOD(754);
+  CASEMOD(755);
+  CASEMOD(756);
+  CASEMOD(757);
+  CASEMOD(758);
+  CASEMOD(759);
+  CASEMOD(760);
+
+  CASEMOD(761);
+  CASEMOD(762);
+  CASEMOD(763);
+  CASEMOD(764);
+  CASEMOD(765);
+  CASEMOD(766);
+  CASEMOD(767);
+  CASEMOD(768);
+  CASEMOD(769);
+  CASEMOD(770);
+
+  CASEMOD(771);
+  CASEMOD(772);
+  CASEMOD(773);
+  CASEMOD(774);
+  CASEMOD(775);
+  CASEMOD(776);
+  CASEMOD(777);
+  CASEMOD(778);
+  CASEMOD(779);
+  CASEMOD(780);
+
+  CASEMOD(781);
+  CASEMOD(782);
+  CASEMOD(783);
+  CASEMOD(784);
+  CASEMOD(785);
+  CASEMOD(786);
+  CASEMOD(787);
+  CASEMOD(788);
+  CASEMOD(789);
+  CASEMOD(790);
+
+  CASEMOD(791);
+  CASEMOD(792);
+  CASEMOD(793);
+  CASEMOD(794);
+  CASEMOD(795);
+  CASEMOD(796);
+  CASEMOD(797);
+  CASEMOD(798);
+  CASEMOD(799);
+  CASEMOD(800);
+
+  CASEMOD(801);
+  CASEMOD(802);
+  CASEMOD(803);
+  CASEMOD(804);
+  CASEMOD(805);
+  CASEMOD(806);
+  CASEMOD(807);
+  CASEMOD(808);
+  CASEMOD(809);
+  CASEMOD(810);
+
+  CASEMOD(811);
+  CASEMOD(812);
+  CASEMOD(813);
+  CASEMOD(814);
+  CASEMOD(815);
+  CASEMOD(816);
+  CASEMOD(817);
+  CASEMOD(818);
+  CASEMOD(819);
+  CASEMOD(820);
+
+  CASEMOD(821);
+  CASEMOD(822);
+  CASEMOD(823);
+  CASEMOD(824);
+  CASEMOD(825);
+  CASEMOD(826);
+  CASEMOD(827);
+  CASEMOD(828);
+  CASEMOD(829);
+  CASEMOD(830);
+
+  CASEMOD(831);
+  CASEMOD(832);
+  CASEMOD(833);
+  CASEMOD(834);
+  CASEMOD(835);
+  CASEMOD(836);
+  CASEMOD(837);
+  CASEMOD(838);
+  CASEMOD(839);
+  CASEMOD(840);
+
+  CASEMOD(841);
+  CASEMOD(842);
+  CASEMOD(843);
+  CASEMOD(844);
+  CASEMOD(845);
+  CASEMOD(846);
+  CASEMOD(847);
+  CASEMOD(848);
+  CASEMOD(849);
+  CASEMOD(850);
+
+  CASEMOD(851);
+  CASEMOD(852);
+  CASEMOD(853);
+  CASEMOD(854);
+  CASEMOD(855);
+  CASEMOD(856);
+  CASEMOD(857);
+  CASEMOD(858);
+  CASEMOD(859);
+  CASEMOD(860);
+
+  CASEMOD(861);
+  CASEMOD(862);
+  CASEMOD(863);
+  CASEMOD(864);
+  CASEMOD(865);
+  CASEMOD(866);
+  CASEMOD(867);
+  CASEMOD(868);
+  CASEMOD(869);
+  CASEMOD(870);
+
+  CASEMOD(871);
+  CASEMOD(872);
+  CASEMOD(873);
+  CASEMOD(874);
+  CASEMOD(875);
+  CASEMOD(876);
+  CASEMOD(877);
+  CASEMOD(878);
+  CASEMOD(879);
+  CASEMOD(880);
+
+  CASEMOD(881);
+  CASEMOD(882);
+  CASEMOD(883);
+  CASEMOD(884);
+  CASEMOD(885);
+  CASEMOD(886);
+  CASEMOD(887);
+  CASEMOD(888);
+  CASEMOD(889);
+  CASEMOD(890);
+
+  CASEMOD(891);
+  CASEMOD(892);
+  CASEMOD(893);
+  CASEMOD(894);
+  CASEMOD(895);
+  CASEMOD(896);
+  CASEMOD(897);
+  CASEMOD(898);
+  CASEMOD(899);
+  CASEMOD(900);
+
+  CASEMOD(901);
+  CASEMOD(902);
+  CASEMOD(903);
+  CASEMOD(904);
+  CASEMOD(905);
+  CASEMOD(906);
+  CASEMOD(907);
+  CASEMOD(908);
+  CASEMOD(909);
+  CASEMOD(910);
+
+  CASEMOD(911);
+  CASEMOD(912);
+  CASEMOD(913);
+  CASEMOD(914);
+  CASEMOD(915);
+  CASEMOD(916);
+  CASEMOD(917);
+  CASEMOD(918);
+  CASEMOD(919);
+  CASEMOD(920);
+
+  CASEMOD(921);
+  CASEMOD(922);
+  CASEMOD(923);
+  CASEMOD(924);
+  CASEMOD(925);
+  CASEMOD(926);
+  CASEMOD(927);
+  CASEMOD(928);
+  CASEMOD(929);
+  CASEMOD(930);
+
+  CASEMOD(931);
+  CASEMOD(932);
+  CASEMOD(933);
+  CASEMOD(934);
+  CASEMOD(935);
+  CASEMOD(936);
+  CASEMOD(937);
+  CASEMOD(938);
+  CASEMOD(939);
+  CASEMOD(940);
+
+  CASEMOD(941);
+  CASEMOD(942);
+  CASEMOD(943);
+  CASEMOD(944);
+  CASEMOD(945);
+  CASEMOD(946);
+  CASEMOD(947);
+  CASEMOD(948);
+  CASEMOD(949);
+  CASEMOD(950);
+
+  CASEMOD(951);
+  CASEMOD(952);
+  CASEMOD(953);
+  CASEMOD(954);
+  CASEMOD(955);
+  CASEMOD(956);
+  CASEMOD(957);
+  CASEMOD(958);
+  CASEMOD(959);
+  CASEMOD(960);
+
+  CASEMOD(961);
+  CASEMOD(962);
+  CASEMOD(963);
+  CASEMOD(964);
+  CASEMOD(965);
+  CASEMOD(966);
+  CASEMOD(967);
+  CASEMOD(968);
+  CASEMOD(969);
+  CASEMOD(970);
+
+  CASEMOD(971);
+  CASEMOD(972);
+  CASEMOD(973);
+  CASEMOD(974);
+  CASEMOD(975);
+  CASEMOD(976);
+  CASEMOD(977);
+  CASEMOD(978);
+  CASEMOD(979);
+  CASEMOD(980);
+
+  CASEMOD(981);
+  CASEMOD(982);
+  CASEMOD(983);
+  CASEMOD(984);
+  CASEMOD(985);
+  CASEMOD(986);
+  CASEMOD(987);
+  CASEMOD(988);
+  CASEMOD(989);
+  CASEMOD(990);
+
+  CASEMOD(991);
+  CASEMOD(992);
+  CASEMOD(993);
+  CASEMOD(994);
+  CASEMOD(995);
+  CASEMOD(996);
+  CASEMOD(997);
+  CASEMOD(998);
+  CASEMOD(999);
+  CASEMOD(1000);
+
+  CASEMOD(1001);
+  CASEMOD(1002);
+  CASEMOD(1003);
+  CASEMOD(1004);
+  CASEMOD(1005);
+  CASEMOD(1006);
+  CASEMOD(1007);
+  CASEMOD(1008);
+  CASEMOD(1009);
+  CASEMOD(1010);
+
+  CASEMOD(1011);
+  CASEMOD(1012);
+  CASEMOD(1013);
+  CASEMOD(1014);
+  CASEMOD(1015);
+  CASEMOD(1016);
+  CASEMOD(1017);
+  CASEMOD(1018);
+  CASEMOD(1019);
+  CASEMOD(1020);
+
+  CASEMOD(1021);
+  CASEMOD(1022);
+  CASEMOD(1023);
+  CASEMOD(1024);
+  CASEMOD(1025);
+  CASEMOD(1026);
+  CASEMOD(1027);
+  CASEMOD(1028);
+  CASEMOD(1029);
+  CASEMOD(1030);
+
+  CASEMOD(1031);
+  CASEMOD(1032);
+  CASEMOD(1033);
+  CASEMOD(1034);
+  CASEMOD(1035);
+  CASEMOD(1036);
+  CASEMOD(1037);
+  CASEMOD(1038);
+  CASEMOD(1039);
+  CASEMOD(1040);
+
+  CASEMOD(1041);
+  CASEMOD(1042);
+  CASEMOD(1043);
+  CASEMOD(1044);
+  CASEMOD(1045);
+  CASEMOD(1046);
+  CASEMOD(1047);
+  CASEMOD(1048);
+  CASEMOD(1049);
+  CASEMOD(1050);
+
+  CASEMOD(1051);
+  CASEMOD(1052);
+  CASEMOD(1053);
+  CASEMOD(1054);
+  CASEMOD(1055);
+  CASEMOD(1056);
+  CASEMOD(1057);
+  CASEMOD(1058);
+  CASEMOD(1059);
+  CASEMOD(1060);
+
+  CASEMOD(1061);
+  CASEMOD(1062);
+  CASEMOD(1063);
+  CASEMOD(1064);
+  CASEMOD(1065);
+  CASEMOD(1066);
+  CASEMOD(1067);
+  CASEMOD(1068);
+  CASEMOD(1069);
+  CASEMOD(1070);
+
+  CASEMOD(1071);
+  CASEMOD(1072);
+  CASEMOD(1073);
+  CASEMOD(1074);
+  CASEMOD(1075);
+  CASEMOD(1076);
+  CASEMOD(1077);
+  CASEMOD(1078);
+  CASEMOD(1079);
+  CASEMOD(1080);
+
+  CASEMOD(1081);
+  CASEMOD(1082);
+  CASEMOD(1083);
+  CASEMOD(1084);
+  CASEMOD(1085);
+  CASEMOD(1086);
+  CASEMOD(1087);
+  CASEMOD(1088);
+  CASEMOD(1089);
+  CASEMOD(1090);
+
+  CASEMOD(1091);
+  CASEMOD(1092);
+  CASEMOD(1093);
+  CASEMOD(1094);
+  CASEMOD(1095);
+  CASEMOD(1096);
+  CASEMOD(1097);
+  CASEMOD(1098);
+  CASEMOD(1099);
+  CASEMOD(1100);
+
+  default:
+    return a % b;
+  }
+}
+#endif
diff -r f7a18ca15f55 gfx/cairo/libpixman/src/pixman-cpu.c
--- a/gfx/cairo/libpixman/src/pixman-cpu.c    Sun Jan 29 12:39:30 2012 -0800
+++ b/gfx/cairo/libpixman/src/pixman-cpu.c    Wed Feb 01 17:49:51 2012 +0900
@@ -30,6 +30,10 @@
 #include <windows.h>
 #endif
 
+#ifdef _MSC_VER
+#include <windows.h>
+#endif
+
 #include "pixman-private.h"
 
 #ifdef USE_VMX
diff -r f7a18ca15f55 gfx/cairo/libpixman/src/pixman-edge.c
--- a/gfx/cairo/libpixman/src/pixman-edge.c    Sun Jan 29 12:39:30 2012 -0800
+++ b/gfx/cairo/libpixman/src/pixman-edge.c    Wed Feb 01 17:49:51 2012 +0900
@@ -166,6 +166,8 @@
     uint32_t *buf = (image)->bits.bits;
     int stride = (image)->bits.rowstride;
     int width = (image)->bits.width;
+    pixman_fixed_t rx_old = 0;
+    int rxs_old = 0, rxi_old = 0;
 
     line = buf + pixman_fixed_to_int (y) * stride;
 
@@ -197,12 +199,29 @@
             int lxs, rxs;
 
             /* Find pixel bounds for span. */
-            lxi = pixman_fixed_to_int (lx);
-            rxi = pixman_fixed_to_int (rx);
+            /* Sample coverage for edge pixels */
+            if (lx == 0)
+            {
+                lxi = 0;
+                lxs = 0;
+            }
+            else
+            {
+                lxi = pixman_fixed_to_int (lx);
+                lxs = RENDER_SAMPLES_X (lx, 8);
+            }
 
-            /* Sample coverage for edge pixels */
-            lxs = RENDER_SAMPLES_X (lx, 8);
-            rxs = RENDER_SAMPLES_X (rx, 8);
+            if (rx == rx_old)
+            {
+                rxi = rxi_old;
+                rxs = rxs_old;
+            }
+            else
+            {
+                rxi_old = rxi = pixman_fixed_to_int (rx);
+                rxs_old = rxs = RENDER_SAMPLES_X (rx, 8);
+                rx_old = rx;
+            }
 
             /* Add coverage across row */
             if (lxi == rxi)
diff -r f7a18ca15f55 gfx/cairo/libpixman/src/pixman-mmx.c
--- a/gfx/cairo/libpixman/src/pixman-mmx.c    Sun Jan 29 12:39:30 2012 -0800
+++ b/gfx/cairo/libpixman/src/pixman-mmx.c    Wed Feb 01 17:49:51 2012 +0900
@@ -35,6 +35,11 @@
 
 #ifdef USE_MMX
 
+#if (_M_IX86_FP >= 1) || defined(__SSE__)
+#include <xmmintrin.h>
+#define USE_SSE
+#endif
+
 #include <mmintrin.h>
 #include "pixman-private.h"
 #include "pixman-combine32.h"
@@ -202,6 +207,28 @@
     return _mm_adds_pu8 (a, b);
 }
 
+#ifdef USE_SSE
+
+static force_inline __m64
+expand_alpha (__m64 pixel)
+{
+    return _mm_shuffle_pi16 (pixel, _MM_SHUFFLE(3, 3, 3, 3));
+}
+
+static force_inline __m64
+expand_alpha_rev (__m64 pixel)
+{
+    return _mm_shuffle_pi16 (pixel, _MM_SHUFFLE(0, 0, 0, 0));
+}
+
+static force_inline __m64
+invert_colors (__m64 pixel)
+{
+    return _mm_shuffle_pi16 (pixel, _MM_SHUFFLE(3, 0, 1, 2));
+}
+
+#else
+
 static force_inline __m64
 expand_alpha (__m64 pixel)
 {
@@ -253,6 +280,8 @@
     return x;
 }
 
+#endif
+
 static force_inline __m64
 over (__m64 src,
       __m64 srca,
@@ -3026,6 +3055,7 @@
     return FALSE;
     }
 
+
     while (height--)
     {
     int w;
@@ -3101,6 +3131,7 @@
         s += 64;
         d += 64;
     }
+
     while (w >= 4)
     {
         *(uint32_t *)d = *(uint32_t *)s;
diff -r f7a18ca15f55 gfx/cairo/libpixman/src/pixman-private.h
--- a/gfx/cairo/libpixman/src/pixman-private.h    Sun Jan 29 12:39:30 2012 -0800
+++ b/gfx/cairo/libpixman/src/pixman-private.h    Wed Feb 01 17:49:51 2012 +0900
@@ -900,4 +900,9 @@
 
 #endif /* PIXMAN_TIMERS */
 
+#ifdef _MSC_VER
+#define OMP_MAX_THREAD_COUNTS_TT   4
+extern int omp_thread_counts;
+#endif /* _MSC_VER */
+
 #endif /* PIXMAN_PRIVATE_H */
diff -r f7a18ca15f55 gfx/cairo/libpixman/src/pixman-sse2.c
--- a/gfx/cairo/libpixman/src/pixman-sse2.c    Sun Jan 29 12:39:30 2012 -0800
+++ b/gfx/cairo/libpixman/src/pixman-sse2.c    Wed Feb 01 17:49:51 2012 +0900
@@ -354,6 +354,13 @@
     _mm_stream_si128 (dst, data);
 }
 
+/* save 1 pixels using Write Combining memory */
+static force_inline void
+save_32_write_combining (int* dst, int data)
+{
+    _mm_stream_si32 (dst, data);
+}
+
 /* save 4 pixels on a 16-byte boundary aligned address */
 static force_inline void
 save_128_aligned (__m128i* dst,
@@ -3332,7 +3339,6 @@
         dst++;
     }
     }
-
 }
 
 static pixman_bool_t
@@ -4793,7 +4799,6 @@
     }
     }
 
-
     return TRUE;
 }
 
diff -r f7a18ca15f55 gfx/cairo/libpixman/src/pixman-trap.c
--- a/gfx/cairo/libpixman/src/pixman-trap.c    Sun Jan 29 12:39:30 2012 -0800
+++ b/gfx/cairo/libpixman/src/pixman-trap.c    Wed Feb 01 17:49:51 2012 +0900
@@ -25,6 +25,8 @@
 #include <config.h>
 #endif
 
+#include <limits.h>
+
 #include <stdio.h>
 #include <stdlib.h>
 #include "pixman-private.h"
@@ -40,6 +42,26 @@
     pixman_fixed_t f = pixman_fixed_frac (y);
     pixman_fixed_t i = pixman_fixed_floor (y);
 
+if (8 == n)
+{
+    f = DIV (f - Y_FRAC_FIRST (8) + (STEP_Y_SMALL (8) - pixman_fixed_e), STEP_Y_SMALL (8)) * STEP_Y_SMALL (8) +
+    Y_FRAC_FIRST (8);
+    
+    if (f > Y_FRAC_LAST (8))
+    {
+    if (pixman_fixed_to_int (i) == 0x7fff)
+    {
+        f = 0xffff; /* saturate */
+    }
+    else
+    {
+        f = Y_FRAC_FIRST (8);
+        i += pixman_fixed_1;
+    }
+    }
+}
+else
+{
     f = DIV (f - Y_FRAC_FIRST (n) + (STEP_Y_SMALL (n) - pixman_fixed_e), STEP_Y_SMALL (n)) * STEP_Y_SMALL (n) +
     Y_FRAC_FIRST (n);
     
@@ -55,6 +77,7 @@
         i += pixman_fixed_1;
     }
     }
+}
     return (i | f);
 }
 
@@ -69,6 +92,26 @@
     pixman_fixed_t f = pixman_fixed_frac (y);
     pixman_fixed_t i = pixman_fixed_floor (y);
 
+if (8 == n)
+{
+    f = DIV (f - pixman_fixed_e - Y_FRAC_FIRST (8), STEP_Y_SMALL (8)) * STEP_Y_SMALL (8) +
+    Y_FRAC_FIRST (8);
+
+    if (f < Y_FRAC_FIRST (8))
+    {
+    if (pixman_fixed_to_int (i) == 0x8000)
+    {
+        f = 0; /* saturate */
+    }
+    else
+    {
+        f = Y_FRAC_LAST (8);
+        i -= pixman_fixed_1;
+    }
+    }
+}
+else
+{
     f = DIV (f - pixman_fixed_e - Y_FRAC_FIRST (n), STEP_Y_SMALL (n)) * STEP_Y_SMALL (n) +
     Y_FRAC_FIRST (n);
 
@@ -84,6 +127,8 @@
         i -= pixman_fixed_1;
     }
     }
+}
+
     return (i | f);
 }
 
@@ -104,7 +149,18 @@
     {
     if (ne > 0)
     {
-        int nx = (ne + e->dy - 1) / e->dy;
+        pixman_fixed_48_16_t neTemp = (ne + e->dy - 1);
+        int nx;
+
+        if (neTemp >= (pixman_fixed_48_16_t)INT_MIN &&
+            neTemp <= (pixman_fixed_48_16_t)INT_MAX)
+        {
+            nx = (int)neTemp / e->dy;
+        }
+        else
+        {
+            nx = neTemp / e->dy;
+        }
         e->e = ne - nx * (pixman_fixed_48_16_t) e->dy;
         e->x += nx * e->signdx;
     }
@@ -138,9 +194,18 @@
 
     if (ne > 0)
     {
-    int nx = ne / e->dy;
-    ne -= nx * e->dy;
-    stepx += nx * e->signdx;
+        int nx;
+
+        if (ne <= (pixman_fixed_48_16_t)INT_MAX)
+        {
+            nx = (int)ne / e->dy;
+        }
+        else
+        {
+            nx = ne / e->dy;
+        }
+        ne -= nx * e->dy;
+        stepx += nx * e->signdx;
     }
 
     *dx_p = ne;
@@ -186,11 +251,22 @@
         e->e = 0;
     }
 
+if (8 == n)
+{
+    _pixman_edge_multi_init (e, STEP_Y_SMALL (8),
+                 &e->stepx_small, &e->dx_small);
+
+    _pixman_edge_multi_init (e, STEP_Y_BIG (8),
+                 &e->stepx_big, &e->dx_big);
+}
+else
+{
     _pixman_edge_multi_init (e, STEP_Y_SMALL (n),
                  &e->stepx_small, &e->dx_small);
 
     _pixman_edge_multi_init (e, STEP_Y_BIG (n),
                  &e->stepx_big, &e->dx_big);
+}
     }
     pixman_edge_step (e, y_start - y_top);
 }
diff -r f7a18ca15f55 gfx/thebes/gfxContext.h
--- a/gfx/thebes/gfxContext.h    Sun Jan 29 12:39:30 2012 -0800
+++ b/gfx/thebes/gfxContext.h    Wed Feb 01 17:49:51 2012 +0900
@@ -674,7 +674,11 @@
         /**
          * Disable copying of backgrounds in PushGroupAndCopyBackground.
          */
-        FLAG_DISABLE_COPY_BACKGROUND = (1 << 2)
+        FLAG_DISABLE_COPY_BACKGROUND = (1 << 2),
+        /**
+         * tete009 extension
+         */
+        FLAG_DRAW_SINGLE_IMAGE_TT = (1 << 20)
     };
 
     void SetFlag(PRInt32 aFlag) { mFlags |= aFlag; }
diff -r f7a18ca15f55 gfx/thebes/gfxUtils.cpp
--- a/gfx/thebes/gfxUtils.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/gfx/thebes/gfxUtils.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -378,7 +378,10 @@
                            const gfxImageSurface::gfxImageFormat aFormat,
                            const gfxPattern::GraphicsFilter& aFilter)
 {
-    bool doTile = !aImageRect.Contains(aSourceRect);
+    PRBool drawSingleImage = (aContext->GetFlags() & gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+    aContext->ClearFlag(gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+
+    PRBool doTile = (drawSingleImage ? PR_FALSE : !aImageRect.Contains(aSourceRect));
 
     nsRefPtr<gfxASurface> currentTarget = aContext->CurrentSurface();
     gfxASurface::gfxSurfaceType surfaceType = currentTarget->GetType();
diff -r f7a18ca15f55 js/src/Makefile.in
--- a/js/src/Makefile.in    Sun Jan 29 12:39:30 2012 -0800
+++ b/js/src/Makefile.in    Wed Feb 01 17:49:51 2012 +0900
@@ -77,10 +77,6 @@
 
 LIBS        = $(NSPR_LIBS) 
 
-ifeq ($(OS_ARCH),WINNT)
-NO_PROFILE_GUIDED_OPTIMIZE = 1
-endif
-
 # JavaScript must be built shared, even for static builds, as it is used by
 # other modules which are always built shared. Failure to do so results in
 # the js code getting copied into xpinstall and jsd as well as mozilla-bin,
@@ -955,3 +951,27 @@
 # END kludges for the Nitro assembler
 ###############################################
 
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# Optimizer bug with MSVC PGO (Bug 595653)
+YarrPattern.$(OBJ_SUFFIX): YarrPattern.cpp $(GLOBAL_DEPS)
+    $(REPORT_BUILD)
+    @$(MAKE_DEPS_AUTO_CXX)
+    $(ELOG) $(CCC) $(OUTOPTION)$@ -c $(COMPILE_CXXFLAGS:arch:SSE2=arch:SSE) $(_VPATH_SRCS)
+
+# -LTCG:PGINSTRUMENT bug of MSVC PGO
+PolyIC.$(OBJ_SUFFIX): PolyIC.cpp $(GLOBAL_DEPS)
+    $(REPORT_BUILD)
+    @$(MAKE_DEPS_AUTO_CXX)
+    $(ELOG) $(CCC) $(OUTOPTION)$@ -c $(COMPILE_CXXFLAGS) -GL- $(_VPATH_SRCS)
+
+# Optimizer bug with MSVC PGO
+FrameState.$(OBJ_SUFFIX): FrameState.cpp $(GLOBAL_DEPS)
+    $(REPORT_BUILD)
+    @$(MAKE_DEPS_AUTO_CXX)
+    $(ELOG) $(CCC) $(OUTOPTION)$@ -c $(COMPILE_CXXFLAGS) -GL- $(_VPATH_SRCS)
+
+FastOps.$(OBJ_SUFFIX): FastOps.cpp $(GLOBAL_DEPS)
+    $(REPORT_BUILD)
+    @$(MAKE_DEPS_AUTO_CXX)
+    $(ELOG) $(CCC) $(OUTOPTION)$@ -c $(COMPILE_CXXFLAGS) -GL- $(_VPATH_SRCS)
+endif
diff -r f7a18ca15f55 js/src/jscntxt.h
--- a/js/src/jscntxt.h    Sun Jan 29 12:39:30 2012 -0800
+++ b/js/src/jscntxt.h    Wed Feb 01 17:49:51 2012 +0900
@@ -63,6 +63,8 @@
 #include "js/Vector.h"
 #include "vm/StackSpace.h"
 
+#include <emmintrin.h>
+
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable:4100) /* Silence unreferenced formal parameter warnings */
diff -r f7a18ca15f55 js/src/jsdhash.cpp
--- a/js/src/jsdhash.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/js/src/jsdhash.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -43,6 +43,9 @@
  *
  * Try to keep this file in sync with xpcom/glue/pldhash.cpp.
  */
+#if _MSC_VER >= 1400
+#include <intrin.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -169,13 +172,29 @@
                       const JSDHashEntryHdr *from,
                       JSDHashEntryHdr *to)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __movsd((unsigned long*)to, (unsigned long*)from, table->entrySize >> 2);
+    } else {
+        memcpy(to, from, table->entrySize);
+    }
+#else
     memcpy(to, from, table->entrySize);
+#endif
 }
 
 JS_PUBLIC_API(void)
 JS_DHashClearEntryStub(JSDHashTable *table, JSDHashEntryHdr *entry)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __stosd((unsigned long*)entry, 0, table->entrySize >> 2);
+    } else {
+        memset(entry, 0, table->entrySize);
+    }
+#else
     memset(entry, 0, table->entrySize);
+#endif
 }
 
 JS_PUBLIC_API(void)
diff -r f7a18ca15f55 js/src/jsgc.cpp
--- a/js/src/jsgc.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/js/src/jsgc.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -48,6 +48,9 @@
  *
  * XXX swizzle page to freelist for better locality of reference
  */
+#if (_M_IX86_FP >= 1) || defined(__SSE__) || defined(_M_AMD64) || defined(__amd64__)
+#include <xmmintrin.h>
+#endif
 #include <math.h>
 #include <string.h>     /* for memset used when DEBUG */
 
@@ -283,6 +286,9 @@
     DebugOnly<size_t> nmarked = 0;
     for (;; thing += thingSize) {
         JS_ASSERT(thing <= lastByte + 1);
+#if (_M_IX86_FP >= 1) || defined(__SSE__) || defined(_M_AMD64) || defined(__amd64__)
+        _mm_prefetch((char *)(thing + sizeof(T) * 4), _MM_HINT_NTA);
+#endif
         if (thing == nextFree.first) {
             JS_ASSERT(nextFree.last <= lastByte);
             if (nextFree.last == lastByte)
@@ -355,6 +361,9 @@
     ArenaHeader **ap = &al->head;
     size_t thingSize = Arena::thingSize(thingKind);
     while (ArenaHeader *aheader = *ap) {
+#if (_M_IX86_FP >= 1) || defined(__SSE__) || defined(_M_AMD64) || defined(__amd64__)
+        _mm_prefetch((char *)aheader->next, _MM_HINT_NTA);
+#endif
         bool allClear = aheader->getArena()->finalize<T>(cx, thingKind, thingSize, background);
         if (allClear) {
             *ap = aheader->next;
diff -r f7a18ca15f55 js/src/jsinterp.h
--- a/js/src/jsinterp.h    Sun Jan 29 12:39:30 2012 -0800
+++ b/js/src/jsinterp.h    Wed Feb 01 17:49:51 2012 +0900
@@ -49,11 +49,17 @@
 
 #include "vm/Stack.h"
 
+#include <emmintrin.h>
+
 namespace js {
 
 extern JSObject *
 GetBlockChain(JSContext *cx, StackFrame *fp);
 
+#ifdef _MSC_VER
+/* hack to avoid the bug of PGO */
+__declspec(dllexport)
+#endif
 extern JSObject *
 GetBlockChainFast(JSContext *cx, StackFrame *fp, JSOp op, size_t oplen);
 
@@ -247,6 +253,10 @@
 extern JS_REQUIRES_STACK bool
 RunScript(JSContext *cx, JSScript *script, StackFrame *fp);
 
+#ifdef _MSC_VER
+/* hack to avoid the bug of PGO */
+__declspec(dllexport)
+#endif
 extern bool
 CheckRedeclaration(JSContext *cx, JSObject *obj, jsid id, uintN attrs);
 
diff -r f7a18ca15f55 js/src/jsmath.cpp
--- a/js/src/jsmath.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/js/src/jsmath.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -57,6 +57,20 @@
 #include "jsinferinlines.h"
 #include "jsobjinlines.h"
 
+#if defined JS_CPU_X86 || defined JS_CPU_X64
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+#else  /* _MSC_VER == 1400 */
+#include <smmintrin.h>
+#endif /* _MSC_VER == 1400 */
+#endif /* defined JS_CPU_X86 || defined JS_CPU_X64 */
+
+# include "assembler/assembler/MacroAssembler.h"
+
+#if (_M_IX86_FP >= 2)
+#pragma function(floor)
+#endif
+
 using namespace js;
 
 #ifndef M_E
@@ -248,13 +262,42 @@
     return JS_TRUE;
 }
 
-jsdouble
+JS_ALWAYS_INLINE jsdouble
 js_math_ceil_impl(jsdouble x)
 {
 #ifdef __APPLE__
     if (x < 0 && x > -1.0)
         return js_copysign(0, -1);
 #endif
+
+#if defined JS_CPU_X86 || defined JS_CPU_X64
+    if (JSC::MacroAssemblerX86Common::getSSEState() >=
+        JSC::MacroAssemblerX86Common::HasSSE4_1) {
+#if _MSC_VER != 1400
+        __m128d xd = _mm_load_sd(&x);
+        double d;
+
+        xd = _mm_ceil_sd(xd, xd);
+        _mm_store_sd(&d, xd);
+        return d;
+#elif defined JS_CPU_X86
+        double d;
+
+        __asm {
+            movsd       xmm0, x
+            /* roundsd  xmm0, xmm0, 2 */
+            __asm _emit 0x66
+            __asm _emit 0x0F
+            __asm _emit 0x3A
+            __asm _emit 0x0B
+            __asm _emit 0xC0
+            __asm _emit 0x02
+            movsd       d, xmm0
+        }
+        return d;
+#endif
+    }
+#endif /* defined JS_CPU_X86 || defined JS_CPU_X64 */
     return ceil(x);
 }
 
@@ -326,9 +369,37 @@
     return JS_TRUE;
 }
 
-jsdouble
+JS_ALWAYS_INLINE jsdouble
 js_math_floor_impl(jsdouble x)
 {
+#if defined JS_CPU_X86 || defined JS_CPU_X64
+    if (JSC::MacroAssemblerX86Common::getSSEState() >=
+        JSC::MacroAssemblerX86Common::HasSSE4_1) {
+#if _MSC_VER != 1400
+        __m128d xd = _mm_load_sd(&x);
+        double d;
+
+        xd = _mm_floor_sd(xd, xd);
+        _mm_store_sd(&d, xd);
+        return d;
+#elif defined JS_CPU_X86
+        double d;
+
+        __asm {
+            movsd       xmm0, x
+            /* roundsd  xmm0, xmm0, 1 */
+            __asm _emit 0x66
+            __asm _emit 0x0F
+            __asm _emit 0x3A
+            __asm _emit 0x0B
+            __asm _emit 0xC0
+            __asm _emit 0x01
+            movsd       d, xmm0
+        }
+        return d;
+#endif
+    }
+#endif /* defined JS_CPU_X86 || defined JS_CPU_X64 */
     return floor(x);
 }
 
@@ -577,10 +648,59 @@
 }
 #endif
 
-jsdouble
+#if (defined JS_CPU_X86 || defined JS_CPU_X64) && _MSC_VER
+static const double  dbhalf =  0.5;
+__declspec(align(16)) static const __int64 mask_sign[2] = { 0x8000000000000000 };
+#endif
+
+JS_ALWAYS_INLINE jsdouble
 js_math_round_impl(jsdouble x)
 {
-    return js_copysign(floor(x + 0.5), x);
+#if defined JS_CPU_X86 || defined JS_CPU_X64
+    if (JSC::MacroAssemblerX86Common::getSSEState() >=
+        JSC::MacroAssemblerX86Common::HasSSE4_1) {
+#if _MSC_VER != 1400
+        __m128d xmm1d = _mm_load_sd(&x);
+        __m128d xmm0d = xmm1d;
+        double d;
+
+        xmm0d = _mm_add_sd(xmm0d, *(__m128d *)&dbhalf);
+        xmm0d = _mm_floor_sd(xmm0d, xmm0d);
+
+        __m128i xmm2i = _mm_load_si128((__m128i *)mask_sign);
+        __m128i xmm1i = _mm_castpd_si128(xmm1d);
+
+        xmm1i = _mm_and_si128(xmm1i, xmm2i);
+        xmm2i = _mm_andnot_si128(xmm2i, _mm_castpd_si128(xmm0d));
+        xmm1i = _mm_or_si128(xmm1i, xmm2i);
+
+        _mm_store_sd(&d, _mm_castsi128_pd(xmm1i));
+        return d;
+#elif defined JS_CPU_X86
+        double d;
+
+        __asm {
+            movsd       xmm1, x
+            movdqa      xmm2, mask_sign
+            movaps      xmm0, xmm1
+            addsd       xmm0, dbhalf
+            pand        xmm1, xmm2
+            /* roundsd  xmm0, xmm0, 1 */
+            __asm _emit 0x66
+            __asm _emit 0x0F
+            __asm _emit 0x3A
+            __asm _emit 0x0B
+            __asm _emit 0xC0
+            __asm _emit 0x01
+            pandn       xmm2, xmm0
+            por         xmm1, xmm2
+            movsd       d, xmm1
+        }
+        return d;
+#endif
+    }
+#endif /* defined JS_CPU_X86 || defined JS_CPU_X64 */
+    return js_copysign(js_math_floor_impl(x + 0.5), x);
 }
 
 JSBool
@@ -594,7 +714,7 @@
     }
     if (!ToNumber(cx, vp[2], &x))
         return JS_FALSE;
-    z = js_copysign(floor(x + 0.5), x);
+    z = js_math_round_impl(x);
     vp->setNumber(z);
     return JS_TRUE;
 }
diff -r f7a18ca15f55 js/src/jsstr.h
--- a/js/src/jsstr.h    Sun Jan 29 12:39:30 2012 -0800
+++ b/js/src/jsstr.h    Wed Feb 01 17:49:51 2012 +0900
@@ -215,7 +215,26 @@
 extern jschar *
 js_strchr_limit(const jschar *s, jschar c, const jschar *limit);
 
+#if _MSC_VER >= 1400
+/* #include <intrin.h> */
+#ifdef  __cplusplus
+extern "C" {
+#endif
+#ifdef _WIN64
+#include <intrin.h>
+#else /* WIN64 */
+void __movsw(unsigned short *Dest, unsigned short *Source, size_t Count);
+#pragma intrinsic(__movsw)
+#endif /* WIN64 */
+#define js_strncpy(t, s, n)     (((n) <= 30) ? \
+    (__movsw((unsigned short *)(t), (unsigned short *)(s), (n)), (t)) : \
+    (memcpy((t), (s), (n) * sizeof(jschar))))
+#ifdef  __cplusplus
+}
+#endif
+#else
 #define js_strncpy(t, s, n)     memcpy((t), (s), (n) * sizeof(jschar))
+#endif
 
 namespace js {
 
diff -r f7a18ca15f55 js/src/jsval.h
--- a/js/src/jsval.h    Sun Jan 29 12:39:30 2012 -0800
+++ b/js/src/jsval.h    Wed Feb 01 17:49:51 2012 +0900
@@ -39,6 +39,7 @@
 
 #ifndef jsvalimpl_h__
 #define jsvalimpl_h__
+#include <emmintrin.h>
 /*
  * Implementation details for js::Value in jsapi.h.
  */
@@ -74,12 +75,32 @@
     return (x.s.hi & JSDOUBLE_HI32_SIGNBIT) != 0;
 }
 
+/* Older versions of MSVC don't have _mm_castpd_si128. */
+#if defined(_MSC_VER) && (_MSC_VER < 1500)
+static JS_ALWAYS_INLINE __m128i
+_mm_castpd_si128(__m128d v)
+{
+    return *(__m128i *)&v;
+}
+#endif
+
 static JS_ALWAYS_INLINE JSBool
 JSDOUBLE_IS_INT32(double d, int32_t* pi)
 {
+#if (_M_IX86_FP >= 2) || defined(__SSE2__) || defined(_M_AMD64) || defined(__amd64__)
+    __m128d xd = _mm_set_sd(d);       /* load double into an XMM register */
+    int ii = _mm_cvtsd_si32(xd);      /* Inf/NaN & large |d| convert to -2^31 */
+    __m128d xdi = _mm_cvtsi32_sd(_mm_setzero_pd(), ii);    /* convert the result back to double */
+    __m128i xcmp = _mm_cmpeq_epi32(_mm_castpd_si128(xd),   /* 32-bit integer bit-to-bit */
+                                   _mm_castpd_si128(xdi)); /* comparison */
+    int m = _mm_movemask_epi8(xcmp);  /* extract significant bits of compare */
+    *pi = ii;
+    return ((m & 0xff) == 0xff);      /* result is integer? */
+#else
     if (JSDOUBLE_IS_NEGZERO(d))
         return JS_FALSE;
     return d == (*pi = (int32_t)d);
+#endif
 }
 
 /******************************************************************************/
diff -r f7a18ca15f55 layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/layout/base/nsLayoutUtils.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -3504,7 +3504,8 @@
                   const nsPoint&       aAnchor,
                   const nsRect&        aDirty,
                   const nsIntSize&     aImageSize,
-                  PRUint32             aImageFlags)
+                  PRUint32             aImageFlags,
+                  const PRBool         aSingleImage = PR_FALSE)
 {
   PRInt32 appUnitsPerDevPixel = aRenderingContext->AppUnitsPerDevPixel();
   gfxContext* ctx = aRenderingContext->ThebesContext();
@@ -3521,6 +3522,10 @@
     ctx->IdentityMatrix();
   }
 
+  if (aSingleImage) {
+    ctx->SetFlag(gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+  }
+
   aImage->Draw(ctx, aGraphicsFilter, drawingParams.mUserSpaceToImageSpace,
                drawingParams.mFillRect, drawingParams.mSubimage, aImageSize,
                aImageFlags);
@@ -3601,7 +3606,7 @@
   fill.IntersectRect(fill, dest);
   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter,
                            dest, fill, aDest, aDirty ? *aDirty : dest,
-                           imageSize, aImageFlags);
+                           imageSize, aImageFlags, PR_TRUE);
 }
 
 /* static */ nsresult
@@ -3640,7 +3645,7 @@
   nsRect fill;
   fill.IntersectRect(aDest, dest);
   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter, dest, fill,
-                           fill.TopLeft(), aDirty, imageSize, aImageFlags);
+                           fill.TopLeft(), aDirty, imageSize, aImageFlags, PR_TRUE);
 }
 
 /* static */ void
diff -r f7a18ca15f55 layout/generic/nsContainerFrame.cpp
--- a/layout/generic/nsContainerFrame.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/layout/generic/nsContainerFrame.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -275,6 +275,10 @@
 /////////////////////////////////////////////////////////////////////////////
 // Child frame enumeration
 
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
+
 nsFrameList
 nsContainerFrame::GetChildList(ChildListID aListID) const
 {
@@ -301,6 +305,10 @@
   }
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
+
 static void AppendIfNonempty(const nsIFrame* aFrame,
                             FramePropertyTable* aPropTable,
                             const FramePropertyDescriptor* aProperty,
diff -r f7a18ca15f55 layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/layout/style/nsCSSDataBlock.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -394,6 +394,10 @@
     return result;
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
+
 void
 nsCSSExpandedDataBlock::Compress(nsCSSCompressedDataBlock **aNormalBlock,
                                  nsCSSCompressedDataBlock **aImportantBlock)
@@ -463,6 +467,10 @@
     *aImportantBlock = result_important.forget();
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
+
 void
 nsCSSExpandedDataBlock::AddLonghandProperty(nsCSSProperty aProperty,
                                             const nsCSSValue& aValue)
diff -r f7a18ca15f55 layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/layout/style/nsCSSRuleProcessor.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -1580,11 +1580,22 @@
 //    which is done only when SelectorMatches calls itself recursively
 //  * what it points to should be set to true whenever a test is skipped
 //    because of aStateMask
-static bool SelectorMatches(Element* aElement,
-                              nsCSSSelector* aSelector,
-                              NodeMatchContext& aNodeMatchContext,
-                              TreeMatchContext& aTreeMatchContext,
-                              bool* const aDependence = nsnull)
+PRBool SelectorMatchesComponent(Element* aElement,
+                                nsCSSSelector* aSelector,
+                                NodeMatchContext& aNodeMatchContext,
+                                TreeMatchContext& aTreeMatchContext,
+                                PRBool* const aDependence);
+
+#ifdef _MSC_VER
+__forceinline
+#else
+inline
+#endif
+PRBool SelectorMatches(Element* aElement,
+                       nsCSSSelector* aSelector,
+                       NodeMatchContext& aNodeMatchContext,
+                       TreeMatchContext& aTreeMatchContext,
+                       PRBool* const aDependence = nsnull)
 
 {
   NS_PRECONDITION(!aSelector->IsPseudoElement(),
@@ -1610,6 +1621,21 @@
     }
   }
 
+  return SelectorMatchesComponent(aElement,
+                                  aSelector,
+                                  aNodeMatchContext,
+                                  aTreeMatchContext,
+                                  aDependence);
+}
+
+#define isNegated (aDependence != nsnull)
+
+static PRBool SelectorMatchesComponent(Element* aElement,
+                                       nsCSSSelector* aSelector,
+                                       NodeMatchContext& aNodeMatchContext,
+                                       TreeMatchContext& aTreeMatchContext,
+                                       PRBool* const aDependence)
+{
   nsAtomList* IDList = aSelector->mIDList;
   if (IDList) {
     nsIAtom* id = aElement->GetID();
@@ -1667,7 +1693,6 @@
     }
   }
 
-  const bool isNegated = (aDependence != nsnull);
   // The selectors for which we set node bits are, unfortunately, early
   // in this function (because they're pseudo-classes, which are
   // generally quick to test, and thus earlier).  If they were later,
@@ -2142,7 +2167,7 @@
   if (!isNegated) {
     for (nsCSSSelector *negation = aSelector->mNegations;
          result && negation; negation = negation->mNegations) {
-      bool dependence = false;
+      PRBool dependence = false;
       result = !SelectorMatches(aElement, negation, aNodeMatchContext,
                                 aTreeMatchContext, &dependence);
       // If the selector does match due to the dependence on aStateMask,
diff -r f7a18ca15f55 layout/svg/base/src/nsSVGMaskFrame.cpp
--- a/layout/svg/base/src/nsSVGMaskFrame.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/layout/svg/base/src/nsSVGMaskFrame.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -153,7 +153,7 @@
                    ((pixel[GFX_ARGB32_OFFSET_R] * 0.2125 +
                         pixel[GFX_ARGB32_OFFSET_G] * 0.7154 +
                         pixel[GFX_ARGB32_OFFSET_B] * 0.0721) *
-                       (pixel[GFX_ARGB32_OFFSET_A] / 255.0) * aOpacity);
+                       (pixel[GFX_ARGB32_OFFSET_A] * 0.003921568627451) * aOpacity);
 
       memset(pixel, alpha, 4);
     }
diff -r f7a18ca15f55 memory/jemalloc/jemalloc.c
--- a/memory/jemalloc/jemalloc.c    Sun Jan 29 12:39:30 2012 -0800
+++ b/memory/jemalloc/jemalloc.c    Wed Feb 01 17:49:51 2012 +0900
@@ -100,6 +100,8 @@
  *******************************************************************************
  */
 
+#define _CRT_RAND_S
+
 #ifdef MOZ_MEMORY_ANDROID
 #define NO_TLS
 #define _pthread_self() pthread_self()
@@ -233,6 +235,26 @@
 #define __crtInitCritSecAndSpinCount InitializeCriticalSectionAndSpinCount
 #include <io.h>
 #include <windows.h>
+#include <intrin.h>
+#if defined _M_IX86 || defined _M_AMD64
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+#else  /* _MSC_VER == 1400 */
+#include <smmintrin.h>
+#endif /* _MSC_VER == 1400 */
+#endif /* defined _M_IX86 || defined _M_AMD64 */
+
+#if _MSC_VER >= 1400
+#ifdef _WIN64
+unsigned __int64 __readgsqword(unsigned long Offset);
+#pragma intrinsic(__readgsqword)
+#define TlsGetValue(x) (LPVOID)(__readgsqword((x) * 8 + 0x1480))
+#else /* _WIN64 */
+unsigned long __readfsdword(unsigned long Offset);
+#pragma intrinsic(__readfsdword)
+#define TlsGetValue(x) (LPVOID)(*(unsigned long *)(__readfsdword(0x18) + (x) * 4 + 3600))
+#endif /* _WIN64 */
+#endif /* _MSC_VER >= 1400 */
 
 #pragma warning( disable: 4267 4996 4146 )
 
@@ -249,6 +271,17 @@
 static unsigned long tlsIndex = 0xffffffff;
 #endif 
 
+BOOL ReplaceAPICode(FARPROC lpProcAddr, LPBYTE lpCodeData, int nCodeDataSize);
+static BOOL use_win2kstyle_rand_s = FALSE;
+static BOOL sse4_1_supported = FALSE;
+typedef struct
+{
+  int EAX;
+  int EBX;
+  int ECX;
+  int EDX;
+} CPU_INFO;
+
 #define    __thread
 #define    _pthread_self() __threadid()
 #define    issetugid() 0
@@ -5630,6 +5663,23 @@
 #ifdef MOZ_MEMORY_WINDOWS
     /* get a thread local storage index */
     tlsIndex = TlsAlloc();
+
+    use_win2kstyle_rand_s =
+        (NULL == GetProcAddress(GetModuleHandleA("advapi32.dll"), "SystemFunction036"));
+
+    {
+        CPU_INFO CPUInfo;
+
+        __cpuid((int*)&CPUInfo, 0);
+        if (CPUInfo.EAX >= 1)
+        {
+            __cpuid((int*)&CPUInfo, 1);
+            if (CPUInfo.ECX & (1 << 19))
+            {
+                sse4_1_supported = TRUE;
+            }
+        }
+    }
 #endif
 
     /* Get page size and number of CPUs */
@@ -7229,3 +7279,115 @@
 }
 
 #endif
+
+
+#ifdef MOZ_MEMORY_WINDOWS
+#include <wincrypt.h>
+#include <math.h>
+
+errno_t __cdecl rand_s_tt(unsigned int *randomValue)
+{
+  if (!use_win2kstyle_rand_s)
+  {
+    return rand_s(randomValue);
+  }
+  else
+  {
+    if (randomValue)
+    {
+      BOOL bResult = FALSE;
+      HCRYPTPROV hProv;
+
+      if (CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL,
+                              CRYPT_VERIFYCONTEXT | CRYPT_SILENT) ||
+         (GetLastError() == NTE_BAD_KEYSET &&
+          CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL,
+                              CRYPT_VERIFYCONTEXT | CRYPT_SILENT | CRYPT_NEWKEYSET)))
+      {
+          if (CryptGenRandom(hProv, sizeof(unsigned int), (BYTE*)randomValue))
+          {
+              bResult = TRUE;
+          }
+          CryptReleaseContext(hProv, 0);
+      }
+
+      if (bResult)
+      {
+        return 0;
+      }
+    }
+
+    errno = ENOMEM;
+    return errno;
+  }
+}
+
+double __cdecl floor_tt(double x)
+{
+#if defined _M_IX86 || defined _M_AMD64
+  if (sse4_1_supported)
+  {
+#if _MSC_VER != 1400
+    __m128d xd = _mm_load_sd(&x);
+    double d;
+
+    xd = _mm_floor_sd(xd, xd);
+    _mm_store_sd(&d, xd);
+    return d;
+#elif defined _M_IX86
+    double d;
+
+    __asm
+    {
+      movsd       xmm0, x
+      /* roundsd  xmm0, xmm0, 1 */
+      __asm _emit 0x66
+      __asm _emit 0x0F
+      __asm _emit 0x3A
+      __asm _emit 0x0B
+      __asm _emit 0xC0
+      __asm _emit 0x01
+      movsd       d, xmm0
+    }
+    return d;
+#endif
+  }
+#endif /* defined _M_IX86 || defined _M_AMD64 */
+  return floor(x);
+}
+
+double __cdecl ceil_tt(double x)
+{
+#if defined _M_IX86 || defined _M_AMD64
+  if (sse4_1_supported)
+  {
+#if _MSC_VER != 1400
+    __m128d xd = _mm_load_sd(&x);
+    double d;
+
+    xd = _mm_ceil_sd(xd, xd);
+    _mm_store_sd(&d, xd);
+    return d;
+#elif defined _M_IX86
+    double d;
+
+    __asm
+    {
+      movsd       xmm0, x
+      /* roundsd  xmm0, xmm0, 2 */
+      __asm _emit 0x66
+      __asm _emit 0x0F
+      __asm _emit 0x3A
+      __asm _emit 0x0B
+      __asm _emit 0xC0
+      __asm _emit 0x02
+      movsd       d, xmm0
+    }
+    return d;
+#endif
+  }
+#endif /* defined _M_IX86 || defined _M_AMD64 */
+  return ceil(x);
+}
+
+#endif
diff -r f7a18ca15f55 nsprpub/pr/include/md/_win95.h
--- a/nsprpub/pr/include/md/_win95.h    Sun Jan 29 12:39:30 2012 -0800
+++ b/nsprpub/pr/include/md/_win95.h    Wed Feb 01 17:49:51 2012 +0900
@@ -510,6 +510,17 @@
 #define _MD_CURRENT_CPU() _pr_currentCPU
 #define _MD_SET_CURRENT_CPU(_cpu) (_pr_currentCPU = 0)
 #else /* _PR_USE_STATIC_TLS */
+#if _MSC_VER >= 1400
+#ifdef _WIN64
+unsigned __int64 __readgsqword(unsigned long Offset);
+#pragma intrinsic(__readgsqword)
+#define TlsGetValue(x) (LPVOID)(__readgsqword((x) * 8 + 0x1480))
+#else /* _WIN64 */
+unsigned long __readfsdword(unsigned long Offset);
+#pragma intrinsic(__readfsdword)
+#define TlsGetValue(x) (LPVOID)(*(unsigned long *)(__readfsdword(0x18) + (x) * 4 + 3600))
+#endif /* _WIN64 */
+#endif /* _MSC_VER >= 1400 */
 extern DWORD _pr_currentThreadIndex;
 #define _MD_GET_ATTACHED_THREAD() ((PRThread *) TlsGetValue(_pr_currentThreadIndex))
 #define _MD_SET_CURRENT_THREAD(_thread) TlsSetValue(_pr_currentThreadIndex, (_thread))
diff -r f7a18ca15f55 nsprpub/pr/src/io/prsocket.c
--- a/nsprpub/pr/src/io/prsocket.c    Sun Jan 29 12:39:30 2012 -0800
+++ b/nsprpub/pr/src/io/prsocket.c    Wed Feb 01 17:49:51 2012 +0900
@@ -320,14 +320,6 @@
 
 #elif defined(WIN32) || defined(WIN16)
 
-#if defined(WIN32)
-    /*
-     * The sleep circumvents a bug in Win32 WinSock.
-     * See Microsoft Knowledge Base article ID: Q165989.
-     */
-    Sleep(0);
-#endif /* WIN32 */
-
     if (out_flags & PR_POLL_EXCEPT) {
         int len = sizeof(err);
         if (getsockopt(osfd, (int)SOL_SOCKET, SO_ERROR, (char *) &err, &len)
diff -r f7a18ca15f55 security/nss/lib/freebl/Makefile
--- a/security/nss/lib/freebl/Makefile    Sun Jan 29 12:39:30 2012 -0800
+++ b/security/nss/lib/freebl/Makefile    Wed Feb 01 17:49:51 2012 +0900
@@ -163,11 +163,10 @@
     DEFINES += -DMP_NO_MP_WORD -DMP_USE_UINT_DIGIT
 else
 # MSVC
-    MPI_SRCS += mpi_x86_asm.c
     DEFINES += -DMP_ASSEMBLY_MULTIPLY -DMP_ASSEMBLY_SQUARE 
     DEFINES += -DMP_ASSEMBLY_DIV_2DX1D -DMP_USE_UINT_DIGIT -DMP_NO_MP_WORD
     ifdef BUILD_OPT
-    OPTIMIZER += -Ox  # maximum optimization for freebl
+    OPTIMIZER += -O2  # maximum optimization for freebl
     endif
 endif
 else
diff -r f7a18ca15f55 security/nss/lib/freebl/manifest.mn
--- a/security/nss/lib/freebl/manifest.mn    Sun Jan 29 12:39:30 2012 -0800
+++ b/security/nss/lib/freebl/manifest.mn    Wed Feb 01 17:49:51 2012 +0900
@@ -100,7 +100,11 @@
     $(NULL)
 
 MPI_HDRS = mpi-config.h mpi.h mpi-priv.h mplogic.h mpprime.h logtab.h mp_gf2m.h
+ifdef USE_64
 MPI_SRCS = mpprime.c mpmontg.c mplogic.c mpi.c mp_gf2m.c
+else
+MPI_SRCS = mpprime.c mpmontg.c mplogic.c mpi.c mp_gf2m.c mpi_x86_asm.c
+endif
 
 
 ECL_HDRS = ecl-exp.h ecl.h ec2.h ecp.h ecl-priv.h
diff -r f7a18ca15f55 toolkit/content/debug.js
--- a/toolkit/content/debug.js    Sun Jan 29 12:39:30 2012 -0800
+++ b/toolkit/content/debug.js    Wed Feb 01 17:49:51 2012 +0900
@@ -75,7 +75,7 @@
     switch (defB.getCharPref("app.update.channel")) {
       case "nightly":
       case "beta":
-      case "default":
+      // case "default":
         releaseBuild = false;
     }
   } catch(ex) {}
diff -r f7a18ca15f55 widget/src/windows/nsWindow.cpp
--- a/widget/src/windows/nsWindow.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/widget/src/windows/nsWindow.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -970,15 +970,24 @@
  *
  **************************************************************/
 
-static PRUnichar sPropName[40] = L"";
-static PRUnichar* GetNSWindowPropName()
-{
-  if (!*sPropName)
-  {
+class CAtom_NSWindowPropName {
+public:
+  CAtom_NSWindowPropName() {
+    PRUnichar sPropName[40] = L"";
     _snwprintf(sPropName, 39, L"MozillansIWidgetPtr%p", GetCurrentProcessId());
     sPropName[39] = '\0';
-  }
-  return sPropName;
+    atom = ::GlobalAddAtomW(sPropName);
+  }
+  ~CAtom_NSWindowPropName() {
+    ::GlobalDeleteAtom(atom);
+  }
+  ATOM atom;
+};
+
+static PRUnichar* GetNSWindowPropName()
+{
+  static CAtom_NSWindowPropName gaNswpn;
+  return (PRUnichar*)(UINT_PTR)gaNswpn.atom;
 }
 
 nsWindow * nsWindow::GetNSWindowPtr(HWND aWnd)
@@ -2023,7 +2032,18 @@
 // Internally track the caption status via a window property. Required
 // due to our internal handling of WM_NCACTIVATE when custom client
 // margins are set.
-static const PRUnichar kManageWindowInfoProperty[] = L"ManageWindowInfoProperty";
+class CAtom_ManageWindowInfoProperty {
+public:
+  CAtom_ManageWindowInfoProperty() {
+    atom = ::GlobalAddAtomW(L"ManageWindowInfoProperty");
+  }
+  ~CAtom_ManageWindowInfoProperty() {
+    ::GlobalDeleteAtom(atom);
+  }
+  ATOM atom;
+};
+static CAtom_ManageWindowInfoProperty gaMwip;
+#define kManageWindowInfoProperty ((LPCWSTR)(UINT_PTR)gaMwip.atom)
 typedef BOOL (WINAPI *GetWindowInfoPtr)(HWND hwnd, PWINDOWINFO pwi);
 static GetWindowInfoPtr sGetWindowInfoPtrStub = NULL;
 
diff -r f7a18ca15f55 xpcom/glue/nsThreadUtils.cpp
--- a/xpcom/glue/nsThreadUtils.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/xpcom/glue/nsThreadUtils.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -48,7 +48,18 @@
 
 #ifdef XP_WIN
 #include <windows.h>
-#endif
+#if _MSC_VER >= 1400
+#ifdef _WIN64
+unsigned __int64 __readgsqword(unsigned long Offset);
+#pragma intrinsic(__readgsqword)
+#define TlsGetValue(x) (LPVOID)(__readgsqword((x) * 8 + 0x1480))
+#else /* _WIN64 */
+unsigned long __readfsdword(unsigned long Offset);
+#pragma intrinsic(__readfsdword)
+#define TlsGetValue(x) (LPVOID)(*(unsigned long *)(__readfsdword(0x18) + (x) * 4 + 3600))
+#endif /* _WIN64 */
+#endif /* _MSC_VER >= 1400 */
+#endif /* XP_WIN */
 
 #ifndef XPCOM_GLUE_AVOID_NSPR
 
diff -r f7a18ca15f55 xpcom/glue/pldhash.cpp
--- a/xpcom/glue/pldhash.cpp    Sun Jan 29 12:39:30 2012 -0800
+++ b/xpcom/glue/pldhash.cpp    Wed Feb 01 17:49:51 2012 +0900
@@ -43,6 +43,9 @@
  *
  * Try to keep this file in sync with js/src/jsdhash.cpp.
  */
+#if _MSC_VER >= 1400
+#include <intrin.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -166,13 +169,29 @@
                       const PLDHashEntryHdr *from,
                       PLDHashEntryHdr *to)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __movsd((unsigned long*)to, (unsigned long*)from, table->entrySize >> 2);
+    } else {
+        memcpy(to, from, table->entrySize);
+    }
+#else
     memcpy(to, from, table->entrySize);
+#endif
 }
 
 void
 PL_DHashClearEntryStub(PLDHashTable *table, PLDHashEntryHdr *entry)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __stosd((unsigned long*)entry, 0, table->entrySize >> 2);
+    } else {
+        memset(entry, 0, table->entrySize);
+    }
+#else
     memset(entry, 0, table->entrySize);
+#endif
 }
 
 void
diff -r f7a18ca15f55 xpcom/string/public/nsCharTraits.h
--- a/xpcom/string/public/nsCharTraits.h    Sun Jan 29 12:39:30 2012 -0800
+++ b/xpcom/string/public/nsCharTraits.h    Wed Feb 01 17:49:51 2012 +0900
@@ -215,6 +215,10 @@
     char_type*
     copy( char_type* s1, const char_type* s2, size_t n )
       {
+        if (1 == n) {
+          *s1 = *s2;
+          return s1;
+        }
         return static_cast<char_type*>(memcpy(s1, s2, n * sizeof(char_type)));
       }
 


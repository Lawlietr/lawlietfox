From: Jonathan Kew <jkew@mozilla.com>

diff --git a/gfx/thebes/gfxFont.h b/gfx/thebes/gfxFont.h
--- a/gfx/thebes/gfxFont.h
+++ b/gfx/thebes/gfxFont.h
@@ -41,17 +41,17 @@ class gfxFont;
 class gfxFontFamily;
 class gfxFontGroup;
 class gfxUserFontSet;
 class gfxUserFontData;
 class gfxShapedWord;
 
 class nsILanguageAtomService;
 
-typedef struct _hb_blob_t hb_blob_t;
+typedef struct hb_blob_t hb_blob_t;
 
 #define FONT_MAX_SIZE                  2000.0
 
 #define NO_FONT_LANGUAGE_OVERRIDE      0
 
 struct FontListSizes;
 
 struct THEBES_API gfxFontStyle {
diff --git a/gfx/thebes/gfxHarfBuzzShaper.cpp b/gfx/thebes/gfxHarfBuzzShaper.cpp
--- a/gfx/thebes/gfxHarfBuzzShaper.cpp
+++ b/gfx/thebes/gfxHarfBuzzShaper.cpp
@@ -640,42 +640,45 @@ HBGetHKerning(hb_font_t *font, void *fon
     return fcd->mShaper->GetHKerning(first_glyph, second_glyph);
 }
 
 /*
  * HarfBuzz unicode property callbacks
  */
 
 static hb_codepoint_t
-HBGetMirroring(hb_unicode_funcs_t *ufuncs, hb_codepoint_t aCh, void *user_data)
+HBGetMirroring(hb_unicode_funcs_t *ufuncs, hb_codepoint_t aCh,
+               void *user_data)
 {
     return GetMirroredChar(aCh);
 }
 
 static hb_unicode_general_category_t
-HBGetGeneralCategory(hb_unicode_funcs_t *ufuncs, hb_codepoint_t aCh, void *user_data)
+HBGetGeneralCategory(hb_unicode_funcs_t *ufuncs, hb_codepoint_t aCh,
+                     void *user_data)
 {
     return hb_unicode_general_category_t(GetGeneralCategory(aCh));
 }
 
 static hb_script_t
 HBGetScript(hb_unicode_funcs_t *ufuncs, hb_codepoint_t aCh, void *user_data)
 {
-    return hb_script_t(GetScriptTagForCode
-        (GetScriptCode(aCh)));
+    return hb_script_t(GetScriptTagForCode(GetScriptCode(aCh)));
+}
+
+static hb_unicode_combining_class_t
+HBGetCombiningClass(hb_unicode_funcs_t *ufuncs, hb_codepoint_t aCh,
+                    void *user_data)
+{
+    return hb_unicode_combining_class_t(GetCombiningClass(aCh));
 }
 
 static unsigned int
-HBGetCombiningClass(hb_unicode_funcs_t *ufuncs, hb_codepoint_t aCh, void *user_data)
-{
-    return GetCombiningClass(aCh);
-}
-
-static unsigned int
-HBGetEastAsianWidth(hb_unicode_funcs_t *ufuncs, hb_codepoint_t aCh, void *user_data)
+HBGetEastAsianWidth(hb_unicode_funcs_t *ufuncs, hb_codepoint_t aCh,
+                    void *user_data)
 {
     return GetEastAsianWidth(aCh);
 }
 
 // Hebrew presentation forms with dagesh, for characters 0x05D0..0x05EA;
 // note that some letters do not have a dagesh presForm encoded
 static const PRUnichar sDageshForms[0x05EA - 0x05D0 + 1] = {
     0xFB30, // ALEF

From: Jonathan Kew <jkew@mozilla.com>
update harfbuzz to commit 8ba8042...

diff --git a/gfx/harfbuzz/src/Makefile.am b/gfx/harfbuzz/src/Makefile.am
--- a/gfx/harfbuzz/src/Makefile.am
+++ b/gfx/harfbuzz/src/Makefile.am
@@ -1,32 +1,34 @@
 # Process this file with automake to produce Makefile.in
 
 NULL =
+SUBDIRS =
+DIST_SUBDIRS =
 BUILT_SOURCES =
 EXTRA_DIST =
 CLEANFILES =
 DISTCLEANFILES =
 MAINTAINERCLEANFILES =
+DISTCHECK_CONFIGURE_FLAGS = --enable-introspection
 
-# The following warning options are useful for debugging: -Wpadded -Wcast-align
+# The following warning options are useful for debugging: -Wpadded
 #AM_CXXFLAGS =
 
 lib_LTLIBRARIES = libharfbuzz.la
 
 HBCFLAGS =
 HBLIBS =
 HBSOURCES =  \
 	hb-atomic-private.hh \
 	hb-blob.cc \
 	hb-buffer-private.hh \
 	hb-buffer.cc \
 	hb-cache-private.hh \
 	hb-common.cc \
-	hb-fallback-shape-private.hh \
 	hb-fallback-shape.cc \
 	hb-font-private.hh \
 	hb-font.cc \
 	hb-mutex-private.hh \
 	hb-object-private.hh \
 	hb-open-file-private.hh \
 	hb-open-type-private.hh \
 	hb-ot-head-table.hh \
@@ -34,16 +36,23 @@ HBSOURCES =  \
 	hb-ot-hmtx-table.hh \
 	hb-ot-maxp-table.hh \
 	hb-ot-name-table.hh \
 	hb-ot-tag.cc \
 	hb-private.hh \
 	hb-set-private.hh \
 	hb-set.cc \
 	hb-shape.cc \
+	hb-shape-plan-private.hh \
+	hb-shape-plan.cc \
+	hb-shape-plan.h \
+	hb-shaper-list.hh \
+	hb-shaper-impl-private.hh \
+	hb-shaper-private.hh \
+	hb-shaper.cc \
 	hb-tt-font.cc \
 	hb-unicode-private.hh \
 	hb-unicode.cc \
 	hb-warning.cc \
 	$(NULL)
 HBHEADERS = \
 	hb.h \
 	hb-blob.h \
@@ -121,28 +130,45 @@ HBCFLAGS += $(FREETYPE_CFLAGS)
 HBLIBS   += $(FREETYPE_LIBS)
 HBSOURCES += hb-ft.cc
 HBHEADERS += hb-ft.h
 endif
 
 if HAVE_GRAPHITE2
 HBCFLAGS += $(GRAPHITE2_CFLAGS)
 HBLIBS   += $(GRAPHITE2_LIBS)
-HBSOURCES += hb-graphite2.cc hb-graphite2-private.hh
+HBSOURCES += hb-graphite2.cc
 HBHEADERS += hb-graphite2.h
 endif
 
 if HAVE_UNISCRIBE
 HBCFLAGS += $(UNISCRIBE_CFLAGS)
 HBLIBS   += $(UNISCRIBE_LIBS)
-HBSOURCES += hb-uniscribe.cc hb-uniscribe-private.hh
+HBSOURCES += hb-uniscribe.cc
 HBHEADERS += hb-uniscribe.h
 endif
 
-CXXLINK = $(LINK)
+if HAVE_CORETEXT
+HBCFLAGS += $(CORETEXT_CFLAGS)
+HBLIBS   += $(CORETEXT_LIBS)
+HBSOURCES += hb-coretext.cc
+HBHEADERS += hb-coretext.h
+endif
+
+if HAVE_HB_OLD
+SUBDIRS += hb-old
+HBCFLAGS += -I$(srcdir)/hb-old
+HBLIBS   += hb-old/libhb-old.la
+HBSOURCES += hb-old.cc
+endif
+DIST_SUBDIRS += hb-old
+
+
+# Use a C linker, not C++; Don't link to libstdc++
+libharfbuzz_la_LINK = $(LINK) $(libharfbuzz_la_LDFLAGS)
 libharfbuzz_la_SOURCES = $(HBSOURCES) $(HBHEADERS)
 nodist_libharfbuzz_la_SOURCES = $(nodist_HBSOURCES)
 libharfbuzz_la_CPPFLAGS = $(HBCFLAGS)
 libharfbuzz_la_LDFLAGS = $(AM_LDFLAGS) -version-info $(HB_LIBTOOL_VERSION_INFO) -no-undefined
 libharfbuzz_la_LIBADD = $(HBLIBS)
 pkginclude_HEADERS = $(HBHEADERS)
 nodist_pkginclude_HEADERS = hb-version.h
 
@@ -170,44 +196,67 @@ arabic-table: gen-arabic-table.py Arabic
 .PHONY: unicode-tables arabic-table indic-table
 
 BUILT_SOURCES += hb-ot-shape-complex-indic-machine.hh
 EXTRA_DIST += hb-ot-shape-complex-indic-machine.rl
 hb-ot-shape-complex-indic-machine.hh: hb-ot-shape-complex-indic-machine.rl
 	$(AM_V_GEN)$(top_srcdir)/missing --run ragel -e -F1 -o "$@.tmp" "$<" && \
 	mv "$@.tmp" "$@" || ( $(RM) "$@.tmp" && false )
 
-noinst_PROGRAMS = main indic
+noinst_PROGRAMS = main indic test-would-substitute
 bin_PROGRAMS =
 
 main_SOURCES = main.cc
 main_CPPFLAGS = $(HBCFLAGS)
 main_LDADD = libharfbuzz.la $(HBLIBS)
 
 indic_SOURCES = indic.cc
 indic_CPPFLAGS = $(HBCFLAGS)
 indic_LDADD = libharfbuzz.la $(HBLIBS)
 
+test_would_substitute_SOURCES = test-would-substitute.cc
+test_would_substitute_CPPFLAGS = $(HBCFLAGS) $(FREETYPE_CFLAGS)
+test_would_substitute_LDADD = libharfbuzz.la $(HBLIBS) $(FREETYPE_LIBS)
+
 dist_check_SCRIPTS = \
 	check-c-linkage-decls.sh \
 	check-header-guards.sh \
+	check-includes.sh \
 	check-internal-symbols.sh \
-	check-includes.sh \
+	check-static-inits.sh \
 	$(NULL)
 
 if HAVE_ICU
 else
 dist_check_SCRIPTS += check-libstdc++.sh
 endif
 
 TESTS = $(dist_check_SCRIPTS)
 TESTS_ENVIRONMENT = \
 	srcdir="$(srcdir)" \
 	MAKE="$(MAKE) $(AM_MAKEFLAGS)" \
 	HBSOURCES="$(HBSOURCES)" \
 	HBHEADERS="$(HBHEADERS)" \
 	$(NULL)
 
-scan:
-	g-ir-scanner $(HBCFLAGS) $(HBHEADERS) -n hb --strip-prefix=hb --library libharfbuzz.la
-
+#-include $(INTROSPECTION_MAKEFILE)
+#INTROSPECTION_GIRS = hb-1.0.gir
+#INTROSPECTION_SCANNER_ARGS = -I$(srcdir) -n hb --identifier-prefix=hb_
+#INTROSPECTION_COMPILER_ARGS = --includedir=$(srcdir)
+#
+#if HAVE_INTROSPECTION
+#
+#hb-1.0.gir: libharfbuzz.la
+#hb_1_0_gir_INCLUDES = GObject-2.0
+#hb_1_0_gir_CFLAGS = $(INCLUDES) $(HBCFLAGS) -DHB_H -DHB_H_IN -DHB_OT_H -DHB_OT_H_IN
+#hb_1_0_gir_LIBS = libharfbuzz.la
+#hb_1_0_gir_FILES = $(HBHEADERS)
+#
+#girdir = $(datadir)/gir-1.0
+#gir_DATA = $(INTROSPECTION_GIRS)
+#
+#typelibdir = $(libdir)/girepository-1.0
+#typelib_DATA = $(INTROSPECTION_GIRS:.gir=.typelib)
+#
+#CLEANFILES += $(gir_DATA) $(typelib_DATA)
+#endif
 
 -include $(top_srcdir)/git.mk
diff --git a/gfx/harfbuzz/src/Makefile.in b/gfx/harfbuzz/src/Makefile.in
--- a/gfx/harfbuzz/src/Makefile.in
+++ b/gfx/harfbuzz/src/Makefile.in
@@ -49,16 +49,18 @@ CPPSRCS	=                        \
   hb-ot-shape-complex-arabic.cc  \
   hb-ot-shape-complex-indic.cc   \
   hb-ot-shape-complex-misc.cc    \
   hb-ot-shape-normalize.cc       \
   hb-ot-shape.cc                 \
   hb-ot-tag.cc                   \
   hb-set.cc                      \
   hb-shape.cc                    \
+  hb-shape-plan.cc               \
+  hb-shaper.cc                   \
   hb-unicode.cc                  \
   hb-warning.cc                  \
   $(NULL)
 
 EXPORTS_NAMESPACES = harfbuzz
 
 EXPORTS_harfbuzz = \
   hb.h             \
@@ -67,16 +69,17 @@ EXPORTS_harfbuzz = \
   hb-common.h      \
   hb-font.h        \
   hb-ot.h          \
   hb-ot-layout.h   \
   hb-ot-tag.h      \
   hb-ot-shape.h    \
   hb-set.h         \
   hb-shape.h       \
+  hb-shape-plan.h  \
   hb-unicode.h     \
   hb-version.h     \
   $(NULL)
 
 LOCAL_INCLUDES  += -I$(srcdir) 
 
 FORCE_STATIC_LIB = 1
 
diff --git a/gfx/harfbuzz/src/check-c-linkage-decls.sh b/gfx/harfbuzz/src/check-c-linkage-decls.sh
--- a/gfx/harfbuzz/src/check-c-linkage-decls.sh
+++ b/gfx/harfbuzz/src/check-c-linkage-decls.sh
@@ -2,19 +2,27 @@
 
 LC_ALL=C
 export LC_ALL
 
 test -z "$srcdir" && srcdir=.
 stat=0
 
 test "x$HBHEADERS" = x && HBHEADERS=`find . -maxdepth 1 -name 'hb*.h'`
+test "x$HBSOURCES" = x && HBSOURCES=`find . -maxdepth 1 -name 'hb*.h'`
 
 
 for x in $HBHEADERS; do
 	test -f $srcdir/$x && x=$srcdir/$x
 	if ! grep -q HB_BEGIN_DECLS "$x" || ! grep -q HB_END_DECLS "$x"; then
-		echo "Ouch, file $x does not HB_BEGIN_DECLS / HB_END_DECLS"
+		echo "Ouch, file $x does not have HB_BEGIN_DECLS / HB_END_DECLS, but it should"
+		stat=1
+	fi
+done
+for x in $HBSOURCES; do
+	test -f $srcdir/$x && x=$srcdir/$x
+	if grep -q HB_BEGIN_DECLS "$x" || grep -q HB_END_DECLS "$x"; then
+		echo "Ouch, file $x has HB_BEGIN_DECLS / HB_END_DECLS, but it shouldn't"
 		stat=1
 	fi
 done
 
 exit $stat
diff --git a/gfx/harfbuzz/src/check-internal-symbols.sh b/gfx/harfbuzz/src/check-internal-symbols.sh
--- a/gfx/harfbuzz/src/check-internal-symbols.sh
+++ b/gfx/harfbuzz/src/check-internal-symbols.sh
@@ -9,22 +9,28 @@ stat=0
 
 if which nm 2>/dev/null >/dev/null; then
 	:
 else
 	echo "check-internal-symbols.sh: 'nm' not found; skipping test"
 	exit 77
 fi
 
+if which c++filt 2>/dev/null >/dev/null; then
+	cplusplusfilt=c++filt
+else
+	cplusplusfilt=cat
+fi
+
 tested=false
 for suffix in so; do
 	so=.libs/libharfbuzz.$suffix
 	if test -f "$so"; then
-		echo "Checking that we are exposing internal symbols"
-		if nm $so | grep ' T ' | grep -v ' T _fini\>\| T _init\>\| T hb_'; then
+		echo "Checking that we are not exposing internal symbols"
+		if nm $so | grep ' [TW] ' | $cplusplusfilt | grep -v ' T _fini\>\| T _init\>\| T hb_'; then
 			echo "Ouch, internal symbols exposed"
 			stat=1
 		fi
 		tested=true
 	fi
 done
 if ! $tested; then
 	echo "check-internal-symbols.sh: libharfbuzz shared library not found; skipping test"
diff --git a/gfx/harfbuzz/src/check-static-inits.sh b/gfx/harfbuzz/src/check-static-inits.sh
new file mode 100755
--- /dev/null
+++ b/gfx/harfbuzz/src/check-static-inits.sh
@@ -0,0 +1,33 @@
+#!/bin/sh
+
+LC_ALL=C
+export LC_ALL
+
+test -z "$srcdir" && srcdir=.
+stat=0
+
+
+if which objdump 2>/dev/null >/dev/null; then
+	:
+else
+	echo "check-static-inits.sh: 'objdump' not found; skipping test"
+	exit 77
+fi
+
+echo "Checking that no object file has static initializers"
+for obj in .libs/*.o; do
+	if objdump -t "$obj" | grep '[.]ctors'; then
+		echo "Ouch, $obj has static initializers"
+		stat=1
+	fi
+done
+
+echo "Checking that no object file has lazy static C++ constructors/destructors"
+for obj in .libs/*.o; do
+	if objdump -t "$obj" | grep '__c'; then
+		echo "Ouch, $obj has lazy static C++ constructors/destructors"
+		stat=1
+	fi
+done
+
+exit $stat
diff --git a/gfx/harfbuzz/src/hb-atomic-private.hh b/gfx/harfbuzz/src/hb-atomic-private.hh
--- a/gfx/harfbuzz/src/hb-atomic-private.hh
+++ b/gfx/harfbuzz/src/hb-atomic-private.hh
@@ -40,48 +40,74 @@
 /* We need external help for these */
 
 #if 0
 
 
 #elif !defined(HB_NO_MT) && defined(_MSC_VER) && _MSC_VER >= 1600
 
 #include <intrin.h>
+/* On x86, _InterlockedCompareExchangePointer is a macro defined in concrt.h */
+#include <concrt.h>
+
 typedef long hb_atomic_int_t;
 #define hb_atomic_int_add(AI, V)	_InterlockedExchangeAdd (&(AI), (V))
-#define hb_atomic_int_set(AI, V)	((AI) = (V), MemoryBarrier ())
-#define hb_atomic_int_get(AI)		(MemoryBarrier (), (AI))
+
+#define hb_atomic_ptr_get(P)		(MemoryBarrier (), (void *) *(P))
+#define hb_atomic_ptr_cmpexch(P,O,N)	(_InterlockedCompareExchangePointer ((void **) (P), (void *) (N), (void *) (O)) == (void *) (O))
 
 
 #elif !defined(HB_NO_MT) && defined(__APPLE__)
 
 #include <libkern/OSAtomic.h>
+
 typedef int32_t hb_atomic_int_t;
 #define hb_atomic_int_add(AI, V)	(OSAtomicAdd32Barrier ((V), &(AI)) - (V))
-#define hb_atomic_int_set(AI, V)	((AI) = (V), OSMemoryBarrier ())
-#define hb_atomic_int_get(AI)		(OSMemoryBarrier (), (AI))
 
+#define hb_atomic_ptr_get(P)		(OSMemoryBarrier (), (void *) *(P))
+#define hb_atomic_ptr_cmpexch(P,O,N)	OSAtomicCompareAndSwapPtrBarrier ((void *) (O), (void *) (N), (void **) (P))
+
+
+#elif !defined(HB_NO_MT) && defined(HAVE_INTEL_ATOMIC_PRIMITIVES)
+
+typedef int hb_atomic_int_t;
+#define hb_atomic_int_add(AI, V)	__sync_fetch_and_add (&(AI), (V))
+
+#define hb_atomic_ptr_get(P)		(void *) (__sync_synchronize (), *(P))
+#define hb_atomic_ptr_cmpexch(P,O,N)	__sync_bool_compare_and_swap ((P), (O), (N))
 
 #elif !defined(HB_NO_MT) && defined(HAVE_GLIB)
 
 #include <glib.h>
-typedef volatile int hb_atomic_int_t;
+typedef int hb_atomic_int_t;
 #if GLIB_CHECK_VERSION(2,29,5)
 #define hb_atomic_int_add(AI, V)	g_atomic_int_add (&(AI), (V))
 #else
 #define hb_atomic_int_add(AI, V)	g_atomic_int_exchange_and_add (&(AI), (V))
 #endif
-#define hb_atomic_int_set(AI, V)	g_atomic_int_set (&(AI), (V))
-#define hb_atomic_int_get(AI)		g_atomic_int_get (&(AI))
 
+#define hb_atomic_ptr_get(P)		g_atomic_pointer_get (P)
+#define hb_atomic_ptr_cmpexch(P,O,N)	g_atomic_pointer_compare_and_exchange ((void **) (P), (void *) (O), (void *) (N))
 
-#else
 
-#define HB_ATOMIC_INT_NIL 1
+#elif !defined(HB_NO_MT)
+
+#define HB_ATOMIC_INT_NIL 1 /* Warn that fallback implementation is in use. */
 typedef volatile int hb_atomic_int_t;
 #define hb_atomic_int_add(AI, V)	(((AI) += (V)) - (V))
-#define hb_atomic_int_set(AI, V)	((void) ((AI) = (V)))
-#define hb_atomic_int_get(AI)		(AI)
+
+#define hb_atomic_ptr_get(P)		((void *) *(P))
+#define hb_atomic_ptr_cmpexch(P,O,N)	(* (void * volatile *) (P) == (void *) (O) ? (* (void * volatile *) (P) = (void *) (N), true) : false)
+
+
+#else /* HB_NO_MT */
+
+typedef int hb_atomic_int_t;
+#define hb_atomic_int_add(AI, V)	(((AI) += (V)) - (V))
+
+#define hb_atomic_ptr_get(P)		((void *) *(P))
+#define hb_atomic_ptr_cmpexch(P,O,N)	(* (void **) (P) == (void *) (O) ? (* (void **) (P) = (void *) (N), true) : false)
 
 #endif
 
+/* TODO Add tracing. */
 
 #endif /* HB_ATOMIC_PRIVATE_HH */
diff --git a/gfx/harfbuzz/src/hb-blob.cc b/gfx/harfbuzz/src/hb-blob.cc
--- a/gfx/harfbuzz/src/hb-blob.cc
+++ b/gfx/harfbuzz/src/hb-blob.cc
@@ -41,42 +41,30 @@
 
 
 
 #ifndef HB_DEBUG_BLOB
 #define HB_DEBUG_BLOB (HB_DEBUG+0)
 #endif
 
 
-struct _hb_blob_t {
+struct hb_blob_t {
   hb_object_header_t header;
+  ASSERT_POD ();
 
   bool immutable;
 
   const char *data;
   unsigned int length;
   hb_memory_mode_t mode;
 
   void *user_data;
   hb_destroy_func_t destroy;
 };
 
-static hb_blob_t _hb_blob_nil = {
-  HB_OBJECT_HEADER_STATIC,
-
-  TRUE, /* immutable */
-
-  NULL, /* data */
-  0, /* length */
-  HB_MEMORY_MODE_READONLY, /* mode */
-
-  NULL, /* user_data */
-  NULL  /* destroy */
-};
-
 
 static bool _try_writable (hb_blob_t *blob);
 
 static void
 _hb_blob_destroy_user_data (hb_blob_t *blob)
 {
   if (blob->destroy) {
     blob->destroy (blob->user_data);
@@ -92,62 +80,75 @@ hb_blob_create (const char        *data,
 		void              *user_data,
 		hb_destroy_func_t  destroy)
 {
   hb_blob_t *blob;
 
   if (!length || !(blob = hb_object_create<hb_blob_t> ())) {
     if (destroy)
       destroy (user_data);
-    return &_hb_blob_nil;
+    return hb_blob_get_empty ();
   }
 
   blob->data = data;
   blob->length = length;
   blob->mode = mode;
 
   blob->user_data = user_data;
   blob->destroy = destroy;
 
   if (blob->mode == HB_MEMORY_MODE_DUPLICATE) {
     blob->mode = HB_MEMORY_MODE_READONLY;
     if (!_try_writable (blob)) {
       hb_blob_destroy (blob);
-      return &_hb_blob_nil;
+      return hb_blob_get_empty ();
     }
   }
 
   return blob;
 }
 
 hb_blob_t *
 hb_blob_create_sub_blob (hb_blob_t    *parent,
 			 unsigned int  offset,
 			 unsigned int  length)
 {
   hb_blob_t *blob;
 
   if (!length || offset >= parent->length)
-    return &_hb_blob_nil;
+    return hb_blob_get_empty ();
 
   hb_blob_make_immutable (parent);
 
   blob = hb_blob_create (parent->data + offset,
 			 MIN (length, parent->length - offset),
 			 parent->mode,
 			 hb_blob_reference (parent),
 			 (hb_destroy_func_t) hb_blob_destroy);
 
   return blob;
 }
 
 hb_blob_t *
 hb_blob_get_empty (void)
 {
-  return &_hb_blob_nil;
+  static const hb_blob_t _hb_blob_nil = {
+    HB_OBJECT_HEADER_STATIC,
+
+    true, /* immutable */
+
+    NULL, /* data */
+    0, /* length */
+    HB_MEMORY_MODE_READONLY, /* mode */
+
+    NULL, /* user_data */
+    NULL  /* destroy */
+  };
+
+  return const_cast<hb_blob_t *> (&_hb_blob_nil);
 }
 
 hb_blob_t *
 hb_blob_reference (hb_blob_t *blob)
 {
   return hb_object_reference (blob);
 }
 
@@ -180,17 +181,17 @@ hb_blob_get_user_data (hb_blob_t        
 
 
 void
 hb_blob_make_immutable (hb_blob_t *blob)
 {
   if (hb_object_is_inert (blob))
     return;
 
-  blob->immutable = TRUE;
+  blob->immutable = true;
 }
 
 hb_bool_t
 hb_blob_is_immutable (hb_blob_t *blob)
 {
   return blob->immutable;
 }
 
@@ -239,86 +240,86 @@ static hb_bool_t
 #elif defined(HAVE_SYSCONF) && defined(_SC_PAGESIZE)
   pagesize = (uintptr_t) sysconf (_SC_PAGESIZE);
 #elif defined(HAVE_GETPAGESIZE)
   pagesize = (uintptr_t) getpagesize ();
 #endif
 
   if ((uintptr_t) -1L == pagesize) {
     DEBUG_MSG_FUNC (BLOB, blob, "failed to get pagesize: %s", strerror (errno));
-    return FALSE;
+    return false;
   }
   DEBUG_MSG_FUNC (BLOB, blob, "pagesize is %lu", (unsigned long) pagesize);
 
   mask = ~(pagesize-1);
   addr = (const char *) (((uintptr_t) blob->data) & mask);
   length = (const char *) (((uintptr_t) blob->data + blob->length + pagesize-1) & mask)  - addr;
   DEBUG_MSG_FUNC (BLOB, blob,
 		  "calling mprotect on [%p..%p] (%lu bytes)",
 		  addr, addr+length, (unsigned long) length);
   if (-1 == mprotect ((void *) addr, length, PROT_READ | PROT_WRITE)) {
     DEBUG_MSG_FUNC (BLOB, blob, "mprotect failed: %s", strerror (errno));
-    return FALSE;
+    return false;
   }
 
   blob->mode = HB_MEMORY_MODE_WRITABLE;
 
   DEBUG_MSG_FUNC (BLOB, blob,
 		  "successfully made [%p..%p] (%lu bytes) writable\n",
 		  addr, addr+length, (unsigned long) length);
-  return TRUE;
+  return true;
 #else
-  return FALSE;
+  return false;
 #endif
 }
 
 static bool
 _try_writable_inplace (hb_blob_t *blob)
 {
   DEBUG_MSG_FUNC (BLOB, blob, "making writable inplace\n");
 
   if (_try_make_writable_inplace_unix (blob))
-    return TRUE;
+    return true;
 
   DEBUG_MSG_FUNC (BLOB, blob, "making writable -> FAILED\n");
 
   /* Failed to make writable inplace, mark that */
   blob->mode = HB_MEMORY_MODE_READONLY;
-  return FALSE;
+  return false;
 }
 
 static bool
 _try_writable (hb_blob_t *blob)
 {
   if (blob->immutable)
-    return FALSE;
+    return false;
 
   if (blob->mode == HB_MEMORY_MODE_WRITABLE)
-    return TRUE;
+    return true;
 
   if (blob->mode == HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE && _try_writable_inplace (blob))
-    return TRUE;
+    return true;
 
   if (blob->mode == HB_MEMORY_MODE_WRITABLE)
-    return TRUE;
+    return true;
 
 
   DEBUG_MSG_FUNC (BLOB, blob, "current data is -> %p\n", blob->data);
 
   char *new_data;
 
   new_data = (char *) malloc (blob->length);
   if (unlikely (!new_data))
-    return FALSE;
+    return false;
 
   DEBUG_MSG_FUNC (BLOB, blob, "dupped successfully -> %p\n", blob->data);
 
   memcpy (new_data, blob->data, blob->length);
   _hb_blob_destroy_user_data (blob);
   blob->mode = HB_MEMORY_MODE_WRITABLE;
   blob->data = new_data;
   blob->user_data = new_data;
   blob->destroy = free;
 
-  return TRUE;
+  return true;
 }
 
 
diff --git a/gfx/harfbuzz/src/hb-blob.h b/gfx/harfbuzz/src/hb-blob.h
--- a/gfx/harfbuzz/src/hb-blob.h
+++ b/gfx/harfbuzz/src/hb-blob.h
@@ -38,17 +38,17 @@ HB_BEGIN_DECLS
 
 typedef enum {
   HB_MEMORY_MODE_DUPLICATE,
   HB_MEMORY_MODE_READONLY,
   HB_MEMORY_MODE_WRITABLE,
   HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE
 } hb_memory_mode_t;
 
-typedef struct _hb_blob_t hb_blob_t;
+typedef struct hb_blob_t hb_blob_t;
 
 hb_blob_t *
 hb_blob_create (const char        *data,
 		unsigned int       length,
 		hb_memory_mode_t   mode,
 		void              *user_data,
 		hb_destroy_func_t  destroy);
 
diff --git a/gfx/harfbuzz/src/hb-buffer-private.hh b/gfx/harfbuzz/src/hb-buffer-private.hh
--- a/gfx/harfbuzz/src/hb-buffer-private.hh
+++ b/gfx/harfbuzz/src/hb-buffer-private.hh
@@ -35,25 +35,58 @@
 #include "hb-object-private.hh"
 #include "hb-unicode-private.hh"
 
 
 
 ASSERT_STATIC (sizeof (hb_glyph_info_t) == 20);
 ASSERT_STATIC (sizeof (hb_glyph_info_t) == sizeof (hb_glyph_position_t));
 
-typedef struct _hb_segment_properties_t {
+
+/*
+ * hb_segment_properties_t
+ */
+
+typedef struct hb_segment_properties_t {
     hb_direction_t      direction;
     hb_script_t         script;
     hb_language_t       language;
+    ASSERT_POD ();
 } hb_segment_properties_t;
 
+#define _HB_BUFFER_PROPS_DEFAULT { HB_DIRECTION_INVALID, HB_SCRIPT_INVALID, HB_LANGUAGE_INVALID }
 
-struct _hb_buffer_t {
+static inline hb_bool_t
+hb_segment_properties_equal (const hb_segment_properties_t *a,
+			     const hb_segment_properties_t *b)
+{
+  return a->direction == b->direction &&
+	 a->script    == b->script    &&
+	 a->language  == b->language;
+}
+
+
+static inline long
+hb_segment_properties_hash (const hb_segment_properties_t *p)
+{
+  /* TODO improve */
+  return (long) p->direction +
+	 (long) p->script +
+	 (long) p->language;
+}
+
+
+
+/*
+ * hb_buffer_t
+ */
+
+struct hb_buffer_t {
   hb_object_header_t header;
+  ASSERT_POD ();
 
   /* Information about how the text in the buffer should be treated */
 
   hb_unicode_funcs_t *unicode; /* Unicode functions */
   hb_segment_properties_t props; /* Script, language, direction */
 
   /* Buffer contents */
 
@@ -103,22 +136,21 @@ struct _hb_buffer_t {
   HB_INTERNAL void reverse_range (unsigned int start, unsigned int end);
   HB_INTERNAL void reverse (void);
   HB_INTERNAL void reverse_clusters (void);
   HB_INTERNAL void guess_properties (void);
 
   HB_INTERNAL void swap_buffers (void);
   HB_INTERNAL void clear_output (void);
   HB_INTERNAL void clear_positions (void);
-  HB_INTERNAL void replace_glyphs_be16 (unsigned int num_in,
-					unsigned int num_out,
-					const uint16_t *glyph_data_be);
+
   HB_INTERNAL void replace_glyphs (unsigned int num_in,
 				   unsigned int num_out,
 				   const hb_codepoint_t *glyph_data);
+
   HB_INTERNAL void replace_glyph (hb_codepoint_t glyph_index);
   /* Makes a copy of the glyph at idx to output and replace glyph_index */
   HB_INTERNAL void output_glyph (hb_codepoint_t glyph_index);
   /* Copies glyph at idx to output but doesn't advance idx */
   HB_INTERNAL void copy_glyph (void);
   /* Copies glyph at idx to output and advance idx.
    * If there's no output, just advance idx. */
   HB_INTERNAL void next_glyph (void);
@@ -144,27 +176,26 @@ struct _hb_buffer_t {
 				   unsigned int end);
   HB_INTERNAL void merge_out_clusters (unsigned int start,
 				       unsigned int end);
 
   /* Internal methods */
   HB_INTERNAL bool enlarge (unsigned int size);
 
   inline bool ensure (unsigned int size)
-  { return likely (size <= allocated) ? TRUE : enlarge (size); }
+  { return likely (size < allocated) ? true : enlarge (size); }
 
   HB_INTERNAL bool make_room_for (unsigned int num_in, unsigned int num_out);
 
   HB_INTERNAL void *get_scratch_buffer (unsigned int *size);
 };
 
 
 #define HB_BUFFER_XALLOCATE_VAR(b, func, var, owner) \
   b->func (offsetof (hb_glyph_info_t, var) - offsetof(hb_glyph_info_t, var1), \
 	   sizeof (b->info[0].var), owner)
 #define HB_BUFFER_ALLOCATE_VAR(b, var) \
 	HB_BUFFER_XALLOCATE_VAR (b, allocate_var, var (), #var)
 #define HB_BUFFER_DEALLOCATE_VAR(b, var) \
 	HB_BUFFER_XALLOCATE_VAR (b, deallocate_var, var (), #var)
 
 
-
 #endif /* HB_BUFFER_PRIVATE_HH */
diff --git a/gfx/harfbuzz/src/hb-buffer.cc b/gfx/harfbuzz/src/hb-buffer.cc
--- a/gfx/harfbuzz/src/hb-buffer.cc
+++ b/gfx/harfbuzz/src/hb-buffer.cc
@@ -32,31 +32,17 @@
 #include <string.h>
 
 
 
 #ifndef HB_DEBUG_BUFFER
 #define HB_DEBUG_BUFFER (HB_DEBUG+0)
 #endif
 
-
-static hb_buffer_t _hb_buffer_nil = {
-  HB_OBJECT_HEADER_STATIC,
-
-  &_hb_unicode_funcs_default,
-  {
-    HB_DIRECTION_INVALID,
-    HB_SCRIPT_INVALID,
-    NULL,
-  },
-
-  TRUE, /* in_error */
-  TRUE, /* have_output */
-  TRUE  /* have_positions */
-};
+#define _HB_BUFFER_UNICODE_FUNCS_DEFAULT (const_cast<hb_unicode_funcs_t *> (&_hb_unicode_funcs_default))
 
 /* Here is how the buffer works internally:
  *
  * There are two info pointers: info and out_info.  They always have
  * the same allocated size, but different lengths.
  *
  * As an optimization, both info and out_info may point to the
  * same piece of memory, which is owned by info.  This remains the
@@ -74,17 +60,17 @@ static hb_buffer_t _hb_buffer_nil = {
 
 
 /* Internal API */
 
 bool
 hb_buffer_t::enlarge (unsigned int size)
 {
   if (unlikely (in_error))
-    return FALSE;
+    return false;
 
   unsigned int new_allocated = allocated;
   hb_glyph_position_t *new_pos = NULL;
   hb_glyph_info_t *new_info = NULL;
   bool separate_out = out_info != info;
 
   if (unlikely (_hb_unsigned_int_mul_overflows (size, sizeof (info[0]))))
     goto done;
@@ -96,17 +82,17 @@ hb_buffer_t::enlarge (unsigned int size)
   if (unlikely (_hb_unsigned_int_mul_overflows (new_allocated, sizeof (info[0]))))
     goto done;
 
   new_pos = (hb_glyph_position_t *) realloc (pos, new_allocated * sizeof (pos[0]));
   new_info = (hb_glyph_info_t *) realloc (info, new_allocated * sizeof (info[0]));
 
 done:
   if (unlikely (!new_pos || !new_info))
-    in_error = TRUE;
+    in_error = true;
 
   if (likely (new_pos))
     pos = new_pos;
 
   if (likely (new_info))
     info = new_info;
 
   out_info = separate_out ? (hb_glyph_info_t *) pos : info;
@@ -115,67 +101,71 @@ done:
 
   return likely (!in_error);
 }
 
 bool
 hb_buffer_t::make_room_for (unsigned int num_in,
 			    unsigned int num_out)
 {
-  if (unlikely (!ensure (out_len + num_out))) return FALSE;
+  if (unlikely (!ensure (out_len + num_out))) return false;
 
   if (out_info == info &&
       out_len + num_out > idx + num_in)
   {
     assert (have_output);
 
     out_info = (hb_glyph_info_t *) pos;
     memcpy (out_info, info, out_len * sizeof (out_info[0]));
   }
 
-  return TRUE;
+  return true;
 }
 
 void *
 hb_buffer_t::get_scratch_buffer (unsigned int *size)
 {
-  have_output = FALSE;
-  have_positions = FALSE;
+  have_output = false;
+  have_positions = false;
+
   out_len = 0;
+  out_info = info;
+
   *size = allocated * sizeof (pos[0]);
   return pos;
 }
 
 
+
 /* HarfBuzz-Internal API */
 
 void
 hb_buffer_t::reset (void)
 {
   if (unlikely (hb_object_is_inert (this)))
     return;
 
   hb_unicode_funcs_destroy (unicode);
-  unicode = _hb_buffer_nil.unicode;
+  unicode = _HB_BUFFER_UNICODE_FUNCS_DEFAULT;
 
-  props = _hb_buffer_nil.props;
+  hb_segment_properties_t default_props = _HB_BUFFER_PROPS_DEFAULT;
+  props = default_props;
 
-  in_error = FALSE;
-  have_output = FALSE;
-  have_positions = FALSE;
+  in_error = false;
+  have_output = false;
+  have_positions = false;
 
   idx = 0;
   len = 0;
   out_len = 0;
+  out_info = info;
 
   serial = 0;
   memset (allocated_var_bytes, 0, sizeof allocated_var_bytes);
   memset (allocated_var_owner, 0, sizeof allocated_var_owner);
-
-  out_info = info;
 }
 
 void
 hb_buffer_t::add (hb_codepoint_t  codepoint,
 		  hb_mask_t       mask,
 		  unsigned int    cluster)
 {
   hb_glyph_info_t *glyph;
@@ -193,42 +183,45 @@ hb_buffer_t::add (hb_codepoint_t  codepo
 }
 
 void
 hb_buffer_t::clear_output (void)
 {
   if (unlikely (hb_object_is_inert (this)))
     return;
 
-  have_output = TRUE;
-  have_positions = FALSE;
+  have_output = true;
+  have_positions = false;
 
   out_len = 0;
   out_info = info;
 }
 
 void
 hb_buffer_t::clear_positions (void)
 {
   if (unlikely (hb_object_is_inert (this)))
     return;
 
-  have_output = FALSE;
-  have_positions = TRUE;
+  have_output = false;
+  have_positions = true;
+
+  out_len = 0;
+  out_info = info;
 
   memset (pos, 0, sizeof (pos[0]) * len);
 }
 
 void
 hb_buffer_t::swap_buffers (void)
 {
   if (unlikely (in_error)) return;
 
   assert (have_output);
-  have_output = FALSE;
+  have_output = false;
 
   if (out_info != info)
   {
     hb_glyph_info_t *tmp_string;
     tmp_string = info;
     info = out_info;
     out_info = tmp_string;
     pos = (hb_glyph_position_t *) out_info;
@@ -237,120 +230,89 @@ hb_buffer_t::swap_buffers (void)
   unsigned int tmp;
   tmp = len;
   len = out_len;
   out_len = tmp;
 
   idx = 0;
 }
 
-void
-hb_buffer_t::replace_glyphs_be16 (unsigned int num_in,
-				  unsigned int num_out,
-				  const uint16_t *glyph_data_be)
-{
-  if (!make_room_for (num_in, num_out)) return;
-
-  hb_glyph_info_t orig_info = info[idx];
-  for (unsigned int i = 1; i < num_in; i++)
-  {
-    hb_glyph_info_t *inf = &info[idx + i];
-    orig_info.cluster = MIN (orig_info.cluster, inf->cluster);
-  }
-
-  hb_glyph_info_t *pinfo = &out_info[out_len];
-  for (unsigned int i = 0; i < num_out; i++)
-  {
-    *pinfo = orig_info;
-    pinfo->codepoint = hb_be_uint16 (glyph_data_be[i]);
-    pinfo++;
-  }
-
-  idx  += num_in;
-  out_len += num_out;
-}
 
 void
 hb_buffer_t::replace_glyphs (unsigned int num_in,
 			     unsigned int num_out,
 			     const uint32_t *glyph_data)
 {
-  if (!make_room_for (num_in, num_out)) return;
+  if (unlikely (!make_room_for (num_in, num_out))) return;
+
+  merge_clusters (idx, idx + num_in);
 
   hb_glyph_info_t orig_info = info[idx];
-  for (unsigned int i = 1; i < num_in; i++)
-  {
-    hb_glyph_info_t *inf = &info[idx + i];
-    orig_info.cluster = MIN (orig_info.cluster, inf->cluster);
-  }
-
   hb_glyph_info_t *pinfo = &out_info[out_len];
   for (unsigned int i = 0; i < num_out; i++)
   {
     *pinfo = orig_info;
     pinfo->codepoint = glyph_data[i];
     pinfo++;
   }
 
   idx  += num_in;
   out_len += num_out;
 }
 
 void
 hb_buffer_t::output_glyph (hb_codepoint_t glyph_index)
 {
-  if (!make_room_for (0, 1)) return;
+  if (unlikely (!make_room_for (0, 1))) return;
 
   out_info[out_len] = info[idx];
   out_info[out_len].codepoint = glyph_index;
 
   out_len++;
 }
 
 void
 hb_buffer_t::copy_glyph (void)
 {
-  if (!make_room_for (0, 1)) return;
+  if (unlikely (!make_room_for (0, 1))) return;
 
   out_info[out_len] = info[idx];
 
   out_len++;
 }
 
 void
 hb_buffer_t::replace_glyph (hb_codepoint_t glyph_index)
 {
-  if (!make_room_for (1, 1)) return;
-
-  out_info[out_len] = info[idx];
+  if (unlikely (out_info != info || out_len != idx)) {
+    if (unlikely (!make_room_for (1, 1))) return;
+    out_info[out_len] = info[idx];
+  }
   out_info[out_len].codepoint = glyph_index;
 
   idx++;
   out_len++;
 }
 
 void
 hb_buffer_t::next_glyph (void)
 {
   if (have_output)
   {
-    if (out_info != info)
-    {
-      if (unlikely (!ensure (out_len + 1))) return;
+    if (unlikely (out_info != info || out_len != idx)) {
+      if (unlikely (!make_room_for (1, 1))) return;
       out_info[out_len] = info[idx];
     }
-    else if (out_len != idx)
-      out_info[out_len] = info[idx];
-
     out_len++;
   }
 
   idx++;
 }
 
+
 void
 hb_buffer_t::set_masks (hb_mask_t    value,
 			hb_mask_t    mask,
 			unsigned int cluster_start,
 			unsigned int cluster_end)
 {
   hb_mask_t not_mask = ~mask;
   value &= mask;
@@ -430,42 +392,76 @@ hb_buffer_t::reverse_clusters (void)
   }
   reverse_range (start, i);
 }
 
 void
 hb_buffer_t::merge_clusters (unsigned int start,
 			     unsigned int end)
 {
-  unsigned int cluster = this->info[start].cluster;
+  if (unlikely (end - start < 2))
+    return;
+
+  unsigned int cluster = info[start].cluster;
 
   for (unsigned int i = start + 1; i < end; i++)
-    cluster = MIN (cluster, this->info[i].cluster);
+    cluster = MIN (cluster, info[i].cluster);
+
+  /* Extend end */
+  while (end < len && info[end - 1].cluster == info[end].cluster)
+    end++;
+
+  /* Extend start */
+  while (idx < start && info[start - 1].cluster == info[start].cluster)
+    start--;
+
+  /* If we hit the start of buffer, continue in out-buffer. */
+  if (idx == start)
+    for (unsigned i = out_len; i && out_info[i - 1].cluster == info[start].cluster; i--)
+      out_info[i - 1].cluster = cluster;
+
   for (unsigned int i = start; i < end; i++)
-    this->info[i].cluster = cluster;
+    info[i].cluster = cluster;
 }
 void
 hb_buffer_t::merge_out_clusters (unsigned int start,
 				 unsigned int end)
 {
-  unsigned int cluster = this->out_info[start].cluster;
+  if (unlikely (end - start < 2))
+    return;
+
+  unsigned int cluster = out_info[start].cluster;
 
   for (unsigned int i = start + 1; i < end; i++)
-    cluster = MIN (cluster, this->out_info[i].cluster);
+    cluster = MIN (cluster, out_info[i].cluster);
+
+  /* Extend start */
+  while (start && out_info[start - 1].cluster == out_info[start].cluster)
+    start--;
+
+  /* Extend end */
+  while (end < out_len && out_info[end - 1].cluster == out_info[end].cluster)
+    end++;
+
+  /* If we hit the end of out-buffer, continue in buffer. */
+  if (end == out_len)
+    for (unsigned i = idx; i < len && info[i].cluster == out_info[end - 1].cluster; i++)
+      info[i].cluster = cluster;
+
   for (unsigned int i = start; i < end; i++)
-    this->out_info[i].cluster = cluster;
+    out_info[i].cluster = cluster;
 }
 
 void
 hb_buffer_t::guess_properties (void)
 {
   /* If script is set to INVALID, guess from buffer contents */
   if (props.script == HB_SCRIPT_INVALID) {
     for (unsigned int i = 0; i < len; i++) {
-      hb_script_t script = hb_unicode_script (unicode, info[i].codepoint);
+      hb_script_t script = unicode->script (info[i].codepoint);
       if (likely (script != HB_SCRIPT_COMMON &&
 		  script != HB_SCRIPT_INHERITED &&
 		  script != HB_SCRIPT_UNKNOWN)) {
         props.script = script;
         break;
       }
     }
   }
@@ -538,27 +534,38 @@ void hb_buffer_t::deallocate_var_all (vo
 /* Public API */
 
 hb_buffer_t *
 hb_buffer_create ()
 {
   hb_buffer_t *buffer;
 
   if (!(buffer = hb_object_create<hb_buffer_t> ()))
-    return &_hb_buffer_nil;
+    return hb_buffer_get_empty ();
 
   buffer->reset ();
 
   return buffer;
 }
 
 hb_buffer_t *
 hb_buffer_get_empty (void)
 {
-  return &_hb_buffer_nil;
+  static const hb_buffer_t _hb_buffer_nil = {
+    HB_OBJECT_HEADER_STATIC,
+
+    _HB_BUFFER_UNICODE_FUNCS_DEFAULT,
+    _HB_BUFFER_PROPS_DEFAULT,
+
+    true, /* in_error */
+    true, /* have_output */
+    true  /* have_positions */
+  };
+
+  return const_cast<hb_buffer_t *> (&_hb_buffer_nil);
 }
 
 hb_buffer_t *
 hb_buffer_reference (hb_buffer_t *buffer)
 {
   return hb_object_reference (buffer);
 }
 
@@ -596,17 +603,17 @@ hb_buffer_get_user_data (hb_buffer_t    
 void
 hb_buffer_set_unicode_funcs (hb_buffer_t        *buffer,
 			     hb_unicode_funcs_t *unicode)
 {
   if (unlikely (hb_object_is_inert (buffer)))
     return;
 
   if (!unicode)
-    unicode = _hb_buffer_nil.unicode;
+    unicode = _HB_BUFFER_UNICODE_FUNCS_DEFAULT;
 
   hb_unicode_funcs_reference (unicode);
   hb_unicode_funcs_destroy (buffer->unicode);
   buffer->unicode = unicode;
 }
 
 hb_unicode_funcs_t *
 hb_buffer_get_unicode_funcs (hb_buffer_t        *buffer)
@@ -690,28 +697,31 @@ hb_buffer_add (hb_buffer_t    *buffer,
 {
   buffer->add (codepoint, mask, cluster);
 }
 
 hb_bool_t
 hb_buffer_set_length (hb_buffer_t  *buffer,
 		      unsigned int  length)
 {
+  if (unlikely (hb_object_is_inert (buffer)))
+    return length == 0;
+
   if (!buffer->ensure (length))
-    return FALSE;
+    return false;
 
   /* Wipe the new space */
   if (length > buffer->len) {
     memset (buffer->info + buffer->len, 0, sizeof (buffer->info[0]) * (length - buffer->len));
     if (buffer->have_positions)
       memset (buffer->pos + buffer->len, 0, sizeof (buffer->pos[0]) * (length - buffer->len));
   }
 
   buffer->len = length;
-  return TRUE;
+  return true;
 }
 
 unsigned int
 hb_buffer_get_length (hb_buffer_t *buffer)
 {
   return buffer->len;
 }
 
@@ -876,8 +886,84 @@ hb_buffer_add_utf32 (hb_buffer_t    *buf
 		     int             item_length)
 {
 #define UTF_NEXT(S, E, U)	((U) = *(S), (S)+1)
   ADD_UTF (uint32_t);
 #undef UTF_NEXT
 }
 
 
+static int
+compare_info_codepoint (const hb_glyph_info_t *pa,
+			const hb_glyph_info_t *pb)
+{
+  return (int) pb->codepoint - (int) pa->codepoint;
+}
+
+static inline void
+normalize_glyphs_cluster (hb_buffer_t *buffer,
+			  unsigned int start,
+			  unsigned int end,
+			  bool backward)
+{
+  hb_glyph_position_t *pos = buffer->pos;
+
+  /* Total cluster advance */
+  hb_position_t total_x_advance = 0, total_y_advance = 0;
+  for (unsigned int i = start; i < end; i++)
+  {
+    total_x_advance += pos[i].x_advance;
+    total_y_advance += pos[i].y_advance;
+  }
+
+  hb_position_t x_advance = 0, y_advance = 0;
+  for (unsigned int i = start; i < end; i++)
+  {
+    pos[i].x_offset += x_advance;
+    pos[i].y_offset += y_advance;
+
+    x_advance += pos[i].x_advance;
+    y_advance += pos[i].y_advance;
+
+    pos[i].x_advance = 0;
+    pos[i].y_advance = 0;
+  }
+
+  if (backward)
+  {
+    /* Transfer all cluster advance to the last glyph. */
+    pos[end - 1].x_advance = total_x_advance;
+    pos[end - 1].y_advance = total_y_advance;
+
+    hb_bubble_sort (buffer->info + start, end - start - 1, compare_info_codepoint, buffer->pos + start);
+  } else {
+    /* Transfer all cluster advance to the first glyph. */
+    pos[start].x_advance += total_x_advance;
+    pos[start].y_advance += total_y_advance;
+    for (unsigned int i = start + 1; i < end; i++) {
+      pos[i].x_offset -= total_x_advance;
+      pos[i].y_offset -= total_y_advance;
+    }
+    hb_bubble_sort (buffer->info + start + 1, end - start - 1, compare_info_codepoint, buffer->pos + start + 1);
+  }
+}
+
+void
+hb_buffer_normalize_glyphs (hb_buffer_t *buffer)
+{
+  assert (buffer->have_positions);
+  /* XXX assert (buffer->have_glyphs); */
+
+  bool backward = HB_DIRECTION_IS_BACKWARD (buffer->props.direction);
+
+  unsigned int count = buffer->len;
+  if (unlikely (!count)) return;
+  hb_glyph_info_t *info = buffer->info;
+
+  unsigned int start = 0;
+  unsigned int end;
+  for (end = start + 1; end < count; end++)
+    if (info[start].cluster != info[end].cluster) {
+      normalize_glyphs_cluster (buffer, start, end, backward);
+      start = end;
+    }
+  normalize_glyphs_cluster (buffer, start, end, backward);
+}
diff --git a/gfx/harfbuzz/src/hb-buffer.h b/gfx/harfbuzz/src/hb-buffer.h
--- a/gfx/harfbuzz/src/hb-buffer.h
+++ b/gfx/harfbuzz/src/hb-buffer.h
@@ -35,29 +35,29 @@
 #define HB_BUFFER_H
 
 #include "hb-common.h"
 #include "hb-unicode.h"
 
 HB_BEGIN_DECLS
 
 
-typedef struct _hb_buffer_t hb_buffer_t;
+typedef struct hb_buffer_t hb_buffer_t;
 
-typedef struct _hb_glyph_info_t {
+typedef struct hb_glyph_info_t {
   hb_codepoint_t codepoint;
   hb_mask_t      mask;
   uint32_t       cluster;
 
   /*< private >*/
   hb_var_int_t   var1;
   hb_var_int_t   var2;
 } hb_glyph_info_t;
 
-typedef struct _hb_glyph_position_t {
+typedef struct hb_glyph_position_t {
   hb_position_t  x_advance;
   hb_position_t  y_advance;
   hb_position_t  x_offset;
   hb_position_t  y_offset;
 
   /*< private >*/
   hb_var_int_t   var;
 } hb_glyph_position_t;
@@ -116,23 +116,23 @@ hb_language_t
 hb_buffer_get_language (hb_buffer_t *buffer);
 
 
 /* Resets the buffer.  Afterwards it's as if it was just created,
  * except that it has a larger buffer allocated perhaps... */
 void
 hb_buffer_reset (hb_buffer_t *buffer);
 
-/* Returns FALSE if allocation failed */
+/* Returns false if allocation failed */
 hb_bool_t
 hb_buffer_pre_allocate (hb_buffer_t  *buffer,
 		        unsigned int  size);
 
 
-/* Returns FALSE if allocation has failed before */
+/* Returns false if allocation has failed before */
 hb_bool_t
 hb_buffer_allocation_successful (hb_buffer_t  *buffer);
 
 void
 hb_buffer_reverse (hb_buffer_t *buffer);
 
 void
 hb_buffer_reverse_clusters (hb_buffer_t *buffer);
@@ -188,11 +188,24 @@ hb_buffer_get_glyph_infos (hb_buffer_t  
                            unsigned int *length);
 
 /* Return value valid as long as buffer not modified */
 hb_glyph_position_t *
 hb_buffer_get_glyph_positions (hb_buffer_t  *buffer,
                                unsigned int *length);
 
 
+/* Reorders a glyph buffer to have canonical in-cluster glyph order / position.
+ * The resulting clusters should behave identical to pre-reordering clusters.
+ * NOTE: This has nothing to do with Unicode normalization. */
+void
+hb_buffer_normalize_glyphs (hb_buffer_t *buffer);
+
+/*
+ * NOT IMPLEMENTED
+void
+hb_buffer_normalize_characters (hb_buffer_t *buffer);
+*/
+
+
 HB_END_DECLS
 
 #endif /* HB_BUFFER_H */
diff --git a/gfx/harfbuzz/src/hb-cache-private.hh b/gfx/harfbuzz/src/hb-cache-private.hh
--- a/gfx/harfbuzz/src/hb-cache-private.hh
+++ b/gfx/harfbuzz/src/hb-cache-private.hh
@@ -44,16 +44,18 @@ struct hb_cache_t
   }
 
   inline bool get (unsigned int key, unsigned int *value)
   {
     unsigned int k = key & ((1<<cache_bits)-1);
     unsigned int v = values[k];
     if ((v >> value_bits) != (key >> cache_bits))
       return false;
+    *value = v & ((1<<value_bits)-1);
+    return true;
   }
 
   inline bool set (unsigned int key, unsigned int value)
   {
     if (unlikely ((key >> key_bits) || (value >> value_bits)))
       return false; /* Overflows */
     unsigned int k = key & ((1<<cache_bits)-1);
     unsigned int v = ((key>>cache_bits)<<value_bits) | value;
diff --git a/gfx/harfbuzz/src/hb-common.cc b/gfx/harfbuzz/src/hb-common.cc
--- a/gfx/harfbuzz/src/hb-common.cc
+++ b/gfx/harfbuzz/src/hb-common.cc
@@ -93,44 +93,42 @@ hb_direction_to_string (hb_direction_t d
     return direction_strings[direction - HB_DIRECTION_LTR];
 
   return "invalid";
 }
 
 
 /* hb_language_t */
 
-struct _hb_language_t {
+struct hb_language_impl_t {
   const char s[1];
 };
 
 static const char canon_map[256] = {
    0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,  '-',  0,   0,
   '0', '1', '2', '3', '4', '5', '6', '7',  '8', '9',  0,   0,   0,   0,   0,   0,
   '-', 'a', 'b', 'c', 'd', 'e', 'f', 'g',  'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
   'p', 'q', 'r', 's', 't', 'u', 'v', 'w',  'x', 'y', 'z',  0,   0,   0,   0,  '-',
    0,  'a', 'b', 'c', 'd', 'e', 'f', 'g',  'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
   'p', 'q', 'r', 's', 't', 'u', 'v', 'w',  'x', 'y', 'z',  0,   0,   0,   0,   0
 };
 
 static hb_bool_t
-lang_equal (const void *v1,
-	    const void *v2)
+lang_equal (hb_language_t  v1,
+	    const void    *v2)
 {
   const unsigned char *p1 = (const unsigned char *) v1;
   const unsigned char *p2 = (const unsigned char *) v2;
 
-  while (canon_map[*p1] && canon_map[*p1] == canon_map[*p2])
-    {
-      p1++, p2++;
-    }
+  while (*p1 && *p1 == canon_map[*p2])
+    p1++, p2++;
 
-  return (canon_map[*p1] == canon_map[*p2]);
+  return *p1 == canon_map[*p2];
 }
 
 #if 0
 static unsigned int
 lang_hash (const void *key)
 {
   const unsigned char *p = key;
   unsigned int h = 0;
@@ -142,16 +140,17 @@ lang_hash (const void *key)
 
   return h;
 }
 #endif
 
 
 struct hb_language_item_t {
 
+  struct hb_language_item_t *next;
   hb_language_t lang;
 
   inline bool operator == (const char *s) const {
     return lang_equal (lang, s);
   }
 
   inline hb_language_item_t & operator = (const char *s) {
     lang = (hb_language_t) strdup (s);
@@ -159,35 +158,77 @@ struct hb_language_item_t {
       *p = canon_map[*p];
 
     return *this;
   }
 
   void finish (void) { free (lang); }
 };
 
-static struct hb_static_lang_set_t : hb_lockable_set_t<hb_language_item_t, hb_static_mutex_t> {
-  ~hb_static_lang_set_t (void) { this->finish (lock); }
-  hb_static_mutex_t lock;
-} langs;
+
+/* Thread-safe lock-free language list */
+
+static hb_language_item_t *langs;
+
+static
+void free_langs (void)
+{
+  while (langs) {
+    hb_language_item_t *next = langs->next;
+    langs->finish ();
+    free (langs);
+    langs = next;
+  }
+}
+
+static hb_language_item_t *
+lang_find_or_insert (const char *key)
+{
+retry:
+  hb_language_item_t *first_lang = (hb_language_item_t *) hb_atomic_ptr_get (&langs);
+
+  for (hb_language_item_t *lang = first_lang; lang; lang = lang->next)
+    if (*lang == key)
+      return lang;
+
+  /* Not found; allocate one. */
+  hb_language_item_t *lang = (hb_language_item_t *) calloc (1, sizeof (hb_language_item_t));
+  if (unlikely (!lang))
+    return NULL;
+  lang->next = first_lang;
+  *lang = key;
+
+  if (!hb_atomic_ptr_cmpexch (&langs, first_lang, lang)) {
+    free (lang);
+    goto retry;
+  }
+
+#ifdef HAVE_ATEXIT
+  if (!first_lang)
+    atexit (free_langs); /* First person registers atexit() callback. */
+#endif
+
+  return lang;
+}
+
 
 hb_language_t
 hb_language_from_string (const char *str, int len)
 {
   if (!str || !len || !*str)
     return HB_LANGUAGE_INVALID;
 
   char strbuf[32];
   if (len >= 0) {
     len = MIN (len, (int) sizeof (strbuf) - 1);
     str = (char *) memcpy (strbuf, str, len);
     strbuf[len] = '\0';
   }
 
-  hb_language_item_t *item = langs.find_or_insert (str, langs.lock);
+  hb_language_item_t *item = lang_find_or_insert (str);
 
   return likely (item) ? item->lang : HB_LANGUAGE_INVALID;
 }
 
 const char *
 hb_language_to_string (hb_language_t language)
 {
   /* This is actually NULL-safe! */
@@ -309,57 +350,51 @@ hb_script_get_horizontal_direction (hb_s
   }
 
   return HB_DIRECTION_LTR;
 }
 
 
 /* hb_user_data_array_t */
 
-
-/* NOTE: Currently we use a global lock for user_data access
- * threadsafety.  If one day we add a mutex to any object, we
- * should switch to using that insted for these too.
- */
-
-static hb_static_mutex_t user_data_lock;
-
 bool
 hb_user_data_array_t::set (hb_user_data_key_t *key,
 			   void *              data,
 			   hb_destroy_func_t   destroy,
-			   hb_bool_t           replace)
+			   hb_bool_t           replace,
+			   hb_mutex_t         &lock)
 {
   if (!key)
     return false;
 
   if (replace) {
     if (!data && !destroy) {
-      items.remove (key, user_data_lock);
+      items.remove (key, lock);
       return true;
     }
   }
   hb_user_data_item_t item = {key, data, destroy};
-  bool ret = !!items.replace_or_insert (item, user_data_lock, replace);
+  bool ret = !!items.replace_or_insert (item, lock, replace);
 
   return ret;
 }
 
 void *
-hb_user_data_array_t::get (hb_user_data_key_t *key)
+hb_user_data_array_t::get (hb_user_data_key_t *key,
+			   hb_mutex_t         &lock)
 {
   hb_user_data_item_t item = {NULL };
 
-  return items.find (key, &item, user_data_lock) ? item.data : NULL;
+  return items.find (key, &item, lock) ? item.data : NULL;
 }
 
 void
-hb_user_data_array_t::finish (void)
+hb_user_data_array_t::finish (hb_mutex_t &lock)
 {
-  items.finish (user_data_lock);
+  items.finish (lock);
 }
 
 
 /* hb_version */
 
 void
 hb_version (unsigned int *major,
 	    unsigned int *minor,
diff --git a/gfx/harfbuzz/src/hb-common.h b/gfx/harfbuzz/src/hb-common.h
--- a/gfx/harfbuzz/src/hb-common.h
+++ b/gfx/harfbuzz/src/hb-common.h
@@ -28,23 +28,25 @@
 
 #ifndef HB_H_IN
 #error "Include <hb.h> instead."
 #endif
 
 #ifndef HB_COMMON_H
 #define HB_COMMON_H
 
+#ifndef HB_BEGIN_DECLS
 # ifdef __cplusplus
 #  define HB_BEGIN_DECLS	extern "C" {
 #  define HB_END_DECLS		}
 # else /* !__cplusplus */
 #  define HB_BEGIN_DECLS
 #  define HB_END_DECLS
 # endif /* !__cplusplus */
+#endif
 
 HB_BEGIN_DECLS
 
 #if !defined (HB_DONT_DEFINE_STDINT)
 
 #if defined (_SVR4) || defined (SVR4) || defined (__OpenBSD__) || \
     defined (_sgi) || defined (__sun) || defined (sun) || \
     defined (__digital__) || defined (__HP_cc)
@@ -119,72 +121,36 @@ hb_direction_to_string (hb_direction_t d
 #define HB_DIRECTION_IS_FORWARD(dir)	((((unsigned int) (dir)) & ~2U) == 4)
 #define HB_DIRECTION_IS_BACKWARD(dir)	((((unsigned int) (dir)) & ~2U) == 5)
 #define HB_DIRECTION_IS_VALID(dir)	((((unsigned int) (dir)) & ~3U) == 4)
 #define HB_DIRECTION_REVERSE(dir)	((hb_direction_t) (((unsigned int) (dir)) ^ 1)) /* Direction must be valid */
 
 
 /* hb_language_t */
 
-typedef struct _hb_language_t *hb_language_t;
+typedef struct hb_language_impl_t *hb_language_t;
 
 /* len=-1 means str is NUL-terminated */
 hb_language_t
 hb_language_from_string (const char *str, int len);
 
 const char *
 hb_language_to_string (hb_language_t language);
 
 #define HB_LANGUAGE_INVALID ((hb_language_t) NULL)
 
 hb_language_t
 hb_language_get_default (void);
 
 
-/* hb_unicode_general_category_t */
-
-typedef enum
-{
-  HB_UNICODE_GENERAL_CATEGORY_CONTROL,			/* Cc */
-  HB_UNICODE_GENERAL_CATEGORY_FORMAT,			/* Cf */
-  HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED,		/* Cn */
-  HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE,		/* Co */
-  HB_UNICODE_GENERAL_CATEGORY_SURROGATE,		/* Cs */
-  HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER,		/* Ll */
-  HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER,		/* Lm */
-  HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER,		/* Lo */
-  HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER,		/* Lt */
-  HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER,		/* Lu */
-  HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK,		/* Mc */
-  HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK,		/* Me */
-  HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK,		/* Mn */
-  HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER,		/* Nd */
-  HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER,		/* Nl */
-  HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER,		/* No */
-  HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION,	/* Pc */
-  HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION,		/* Pd */
-  HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION,	/* Pe */
-  HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION,	/* Pf */
-  HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION,	/* Pi */
-  HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION,	/* Po */
-  HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION,		/* Ps */
-  HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL,		/* Sc */
-  HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL,		/* Sk */
-  HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL,		/* Sm */
-  HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL,		/* So */
-  HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR,		/* Zl */
-  HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR,	/* Zp */
-  HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR		/* Zs */
-} hb_unicode_general_category_t;
-
-
 /* hb_script_t */
 
 /* http://unicode.org/iso15924/ */
 /* http://goo.gl/x9ilM */
+/* Unicode Character Database property: Script (sc) */
 typedef enum
 {
   /* Unicode-1.1 additions */
   HB_SCRIPT_COMMON			= HB_TAG ('Z','y','y','y'),
   HB_SCRIPT_ARABIC			= HB_TAG ('A','r','a','b'),
   HB_SCRIPT_ARMENIAN			= HB_TAG ('A','r','m','n'),
   HB_SCRIPT_BENGALI			= HB_TAG ('B','e','n','g'),
   HB_SCRIPT_BOPOMOFO			= HB_TAG ('B','o','p','o'),
@@ -328,17 +294,17 @@ hb_tag_t
 hb_script_to_iso15924_tag (hb_script_t script);
 
 hb_direction_t
 hb_script_get_horizontal_direction (hb_script_t script);
 
 
 /* User data */
 
-typedef struct _hb_user_data_key_t {
+typedef struct hb_user_data_key_t {
   /*< private >*/
   char unused;
 } hb_user_data_key_t;
 
 typedef void (*hb_destroy_func_t) (void *user_data);
 
 
 HB_END_DECLS
diff --git a/gfx/harfbuzz/src/hb-coretext.cc b/gfx/harfbuzz/src/hb-coretext.cc
new file mode 100644
--- /dev/null
+++ b/gfx/harfbuzz/src/hb-coretext.cc
@@ -0,0 +1,357 @@
+/*
+ * Copyright © 2012  Mozilla Foundation.
+ * Copyright © 2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Mozilla Author(s): Jonathan Kew
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#define HB_SHAPER coretext
+#include "hb-shaper-impl-private.hh"
+
+#define GlyphID GlyphID_mac
+#include <ApplicationServices/ApplicationServices.h>
+#undef GlyphID
+
+#include "hb-coretext.h"
+
+
+#ifndef HB_DEBUG_CORETEXT
+#define HB_DEBUG_CORETEXT (HB_DEBUG+0)
+#endif
+
+
+HB_SHAPER_DATA_ENSURE_DECLARE(coretext, face)
+HB_SHAPER_DATA_ENSURE_DECLARE(coretext, font)
+
+
+/*
+ * shaper face data
+ */
+
+struct hb_coretext_shaper_face_data_t {
+  CGFontRef cg_font;
+};
+
+static void
+release_data (void *info, const void *data, size_t size)
+{
+  assert (hb_blob_get_length ((hb_blob_t *) info) == size &&
+          hb_blob_get_data ((hb_blob_t *) info, NULL) == data);
+
+  hb_blob_destroy ((hb_blob_t *) info);
+}
+
+hb_coretext_shaper_face_data_t *
+_hb_coretext_shaper_face_data_create (hb_face_t *face)
+{
+  hb_coretext_shaper_face_data_t *data = (hb_coretext_shaper_face_data_t *) calloc (1, sizeof (hb_coretext_shaper_face_data_t));
+  if (unlikely (!data))
+    return NULL;
+
+  hb_blob_t *blob = hb_face_reference_blob (face);
+  unsigned int blob_length;
+  const char *blob_data = hb_blob_get_data (blob, &blob_length);
+  if (unlikely (!blob_length))
+    DEBUG_MSG (CORETEXT, face, "Face has empty blob");
+
+  CGDataProviderRef provider = CGDataProviderCreateWithData (blob, blob_data, blob_length, &release_data);
+  data->cg_font = CGFontCreateWithDataProvider (provider);
+  CGDataProviderRelease (provider);
+
+  if (unlikely (!data->cg_font)) {
+    DEBUG_MSG (CORETEXT, face, "Face CGFontCreateWithDataProvider() failed");
+    free (data);
+    return NULL;
+  }
+
+  return data;
+}
+
+void
+_hb_coretext_shaper_face_data_destroy (hb_coretext_shaper_face_data_t *data)
+{
+  CFRelease (data->cg_font);
+  free (data);
+}
+
+
+/*
+ * shaper font data
+ */
+
+struct hb_coretext_shaper_font_data_t {
+  CTFontRef ct_font;
+};
+
+hb_coretext_shaper_font_data_t *
+_hb_coretext_shaper_font_data_create (hb_font_t *font)
+{
+  if (unlikely (!hb_coretext_shaper_face_data_ensure (font->face))) return NULL;
+
+  hb_coretext_shaper_font_data_t *data = (hb_coretext_shaper_font_data_t *) calloc (1, sizeof (hb_coretext_shaper_font_data_t));
+  if (unlikely (!data))
+    return NULL;
+
+  hb_face_t *face = font->face;
+  hb_coretext_shaper_face_data_t *face_data = HB_SHAPER_DATA_GET (face);
+
+  data->ct_font = CTFontCreateWithGraphicsFont (face_data->cg_font, font->y_scale, NULL, NULL);
+  if (unlikely (!data->ct_font)) {
+    DEBUG_MSG (CORETEXT, font, "Font CTFontCreateWithGraphicsFont() failed");
+    free (data);
+    return NULL;
+  }
+
+  return data;
+}
+
+void
+_hb_coretext_shaper_font_data_destroy (hb_coretext_shaper_font_data_t *data)
+{
+  CFRelease (data->ct_font);
+  free (data);
+}
+
+
+/*
+ * shaper shape_plan data
+ */
+
+struct hb_coretext_shaper_shape_plan_data_t {};
+
+hb_coretext_shaper_shape_plan_data_t *
+_hb_coretext_shaper_shape_plan_data_create (hb_shape_plan_t    *shape_plan,
+					     const hb_feature_t *user_features,
+					     unsigned int        num_user_features)
+{
+  return (hb_coretext_shaper_shape_plan_data_t *) HB_SHAPER_DATA_SUCCEEDED;
+}
+
+void
+_hb_coretext_shaper_shape_plan_data_destroy (hb_coretext_shaper_shape_plan_data_t *data)
+{
+}
+
+
+/*
+ * shaper
+ */
+
+CTFontRef
+hb_coretext_font_get_ct_font (hb_font_t *font)
+{
+  if (unlikely (!hb_coretext_shaper_font_data_ensure (font))) return 0;
+  hb_coretext_shaper_font_data_t *font_data = HB_SHAPER_DATA_GET (font);
+  return font_data->ct_font;
+}
+
+hb_bool_t
+_hb_coretext_shape (hb_shape_plan_t    *shape_plan,
+		    hb_font_t          *font,
+                    hb_buffer_t        *buffer,
+                    const hb_feature_t *features,
+                    unsigned int        num_features)
+{
+  hb_face_t *face = font->face;
+  hb_coretext_shaper_face_data_t *face_data = HB_SHAPER_DATA_GET (face);
+  hb_coretext_shaper_font_data_t *font_data = HB_SHAPER_DATA_GET (font);
+
+#define FAIL(...) \
+  HB_STMT_START { \
+    DEBUG_MSG (CORETEXT, NULL, __VA_ARGS__); \
+    return false; \
+  } HB_STMT_END;
+
+  unsigned int scratch_size;
+  char *scratch = (char *) buffer->get_scratch_buffer (&scratch_size);
+
+#define utf16_index() var1.u32
+
+  UniChar *pchars = (UniChar *) scratch;
+  unsigned int chars_len = 0;
+  for (unsigned int i = 0; i < buffer->len; i++) {
+    hb_codepoint_t c = buffer->info[i].codepoint;
+    buffer->info[i].utf16_index() = chars_len;
+    if (likely (c < 0x10000))
+      pchars[chars_len++] = c;
+    else if (unlikely (c >= 0x110000))
+      pchars[chars_len++] = 0xFFFD;
+    else {
+      pchars[chars_len++] = 0xD800 + ((c - 0x10000) >> 10);
+      pchars[chars_len++] = 0xDC00 + ((c - 0x10000) & ((1 << 10) - 1));
+    }
+  }
+
+#undef utf16_index
+
+  CFStringRef string_ref = CFStringCreateWithCharactersNoCopy (kCFAllocatorDefault,
+                                                               pchars, chars_len,
+                                                               kCFAllocatorNull);
+
+  CFDictionaryRef attrs = CFDictionaryCreate (kCFAllocatorDefault,
+                                              (const void**) &kCTFontAttributeName,
+                                              (const void**) &font_data->ct_font,
+                                              1, // count of attributes
+                                              &kCFTypeDictionaryKeyCallBacks,
+                                              &kCFTypeDictionaryValueCallBacks);
+
+  // TODO: support features
+
+  // Now we can create an attributed string
+  CFAttributedStringRef attr_string = CFAttributedStringCreate (kCFAllocatorDefault, string_ref, attrs);
+  CFRelease (string_ref);
+  CFRelease (attrs);
+
+  // Create the CoreText line from our string, then we're done with it
+  CTLineRef line = CTLineCreateWithAttributedString (attr_string);
+  CFRelease (attr_string);
+
+  // and finally retrieve the glyph data and store into the gfxTextRun
+  CFArrayRef glyph_runs = CTLineGetGlyphRuns (line);
+  unsigned int num_runs = CFArrayGetCount (glyph_runs);
+
+  // Iterate through the glyph runs.
+  bool success = true;
+  buffer->len = 0;
+
+  const CFRange range_all = CFRangeMake (0, 0);
+
+  for (unsigned int i = 0; i < num_runs; i++) {
+    CTRunRef run = (CTRunRef) CFArrayGetValueAtIndex (glyph_runs, i);
+
+    unsigned int num_glyphs = CTRunGetGlyphCount (run);
+    if (num_glyphs == 0)
+      continue;
+
+    buffer->ensure (buffer->len + num_glyphs);
+
+    // retrieve the laid-out glyph data from the CTRun
+
+    // Testing indicates that CTRunGetGlyphsPtr (almost?) always succeeds,
+    // and so copying data to our own buffer with CTRunGetGlyphs will be
+    // extremely rare.
+
+    unsigned int scratch_size;
+    char *scratch = (char *) buffer->get_scratch_buffer (&scratch_size);
+
+#define ALLOCATE_ARRAY(Type, name, len) \
+  Type *name = (Type *) scratch; \
+  scratch += (len) * sizeof ((name)[0]); \
+  scratch_size -= (len) * sizeof ((name)[0]);
+
+    const CGGlyph* glyphs = CTRunGetGlyphsPtr (run);
+    if (!glyphs) {
+      ALLOCATE_ARRAY (CGGlyph, glyph_buf, num_glyphs);
+      CTRunGetGlyphs (run, range_all, glyph_buf);
+      glyphs = glyph_buf;
+    }
+
+    const CGPoint* positions = CTRunGetPositionsPtr (run);
+    if (!positions) {
+      ALLOCATE_ARRAY (CGPoint, position_buf, num_glyphs);
+      CTRunGetPositions (run, range_all, position_buf);
+      positions = position_buf;
+    }
+
+    const CFIndex* string_indices = CTRunGetStringIndicesPtr (run);
+    if (!string_indices) {
+      ALLOCATE_ARRAY (CFIndex, index_buf, num_glyphs);
+      CTRunGetStringIndices (run, range_all, index_buf);
+      string_indices = index_buf;
+    }
+
+#undef ALLOCATE_ARRAY
+
+    double run_width = CTRunGetTypographicBounds (run, range_all, NULL, NULL, NULL);
+
+    for (unsigned int j = 0; j < num_glyphs; j++) {
+      double advance = (j + 1 < num_glyphs ? positions[j + 1].x : positions[0].x + run_width) - positions[j].x;
+
+      hb_glyph_info_t *info = &buffer->info[buffer->len];
+      hb_glyph_position_t *pos = &buffer->pos[buffer->len];
+
+      info->codepoint = glyphs[j];
+      info->cluster = string_indices[j];
+
+      // currently, we do all x-positioning by setting the advance, we never use x-offset
+      info->mask = advance;
+      info->var1.u32 = 0;
+      info->var2.u32 = positions[j].y;
+
+      buffer->len++;
+    }
+  }
+
+  buffer->clear_positions ();
+
+  unsigned int count = buffer->len;
+  for (unsigned int i = 0; i < count; ++i) {
+    hb_glyph_info_t *info = &buffer->info[i];
+    hb_glyph_position_t *pos = &buffer->pos[i];
+
+    /* TODO vertical */
+    pos->x_advance = info->mask;
+    pos->x_offset = info->var1.u32;
+    pos->y_offset = info->var2.u32;
+  }
+
+  // Fix up clusters so that we never return out-of-order indices;
+  // if core text has reordered glyphs, we'll merge them to the
+  // beginning of the reordered cluster.
+  // This does *not* mean we'll form the same clusters as Uniscribe
+  // or the native OT backend, only that the cluster indices will be
+  // non-decreasing in the output buffer.
+  if (HB_DIRECTION_IS_FORWARD (buffer->props.direction)) {
+    unsigned int prev_cluster = 0;
+    for (unsigned int i = 0; i < count; i++) {
+      unsigned int curr_cluster = buffer->info[i].cluster;
+      if (curr_cluster < prev_cluster) {
+        for (unsigned int j = i; j > 0; j--) {
+          if (buffer->info[j - 1].cluster > curr_cluster)
+            buffer->info[j - 1].cluster = curr_cluster;
+          else
+            break;
+        }
+      }
+      prev_cluster = curr_cluster;
+    }
+  } else {
+    // For RTL runs, we make them non-increasing instead.
+    unsigned int prev_cluster = (unsigned int)-1;
+    for (unsigned int i = 0; i < count; i++) {
+      unsigned int curr_cluster = buffer->info[i].cluster;
+      if (curr_cluster > prev_cluster) {
+        for (unsigned int j = i; j > 0; j--) {
+          if (buffer->info[j - 1].cluster < curr_cluster)
+            buffer->info[j - 1].cluster = curr_cluster;
+          else
+            break;
+        }
+      }
+      prev_cluster = curr_cluster;
+    }
+  }
+
+  return true;
+}
diff --git a/gfx/harfbuzz/src/hb-coretext.h b/gfx/harfbuzz/src/hb-coretext.h
new file mode 100644
--- /dev/null
+++ b/gfx/harfbuzz/src/hb-coretext.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright © 2012  Mozilla Foundation.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Mozilla Author(s): Jonathan Kew
+ */
+
+#ifndef HB_CORETEXT_H
+#define HB_CORETEXT_H
+
+#include "hb.h"
+
+#include <ApplicationServices/ApplicationServices.h>
+
+HB_BEGIN_DECLS
+
+
+CTFontRef
+hb_coretext_font_get_ct_font (hb_font_t *font);
+
+
+HB_END_DECLS
+
+#endif /* HB_CORETEXT_H */
diff --git a/gfx/harfbuzz/src/hb-fallback-shape.cc b/gfx/harfbuzz/src/hb-fallback-shape.cc
--- a/gfx/harfbuzz/src/hb-fallback-shape.cc
+++ b/gfx/harfbuzz/src/hb-fallback-shape.cc
@@ -19,43 +19,111 @@
  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  *
  * Google Author(s): Behdad Esfahbod
  */
 
-#include "hb-fallback-shape-private.hh"
+#define HB_SHAPER fallback
+#include "hb-shaper-impl-private.hh"
 
-#include "hb-buffer-private.hh"
+
+/*
+ * shaper face data
+ */
+
+struct hb_fallback_shaper_face_data_t {};
+
+hb_fallback_shaper_face_data_t *
+_hb_fallback_shaper_face_data_create (hb_face_t *face)
+{
+  return (hb_fallback_shaper_face_data_t *) HB_SHAPER_DATA_SUCCEEDED;
+}
+
+void
+_hb_fallback_shaper_face_data_destroy (hb_fallback_shaper_face_data_t *data)
+{
+}
+
+
+/*
+ * shaper font data
+ */
+
+struct hb_fallback_shaper_font_data_t {};
+
+hb_fallback_shaper_font_data_t *
+_hb_fallback_shaper_font_data_create (hb_font_t *font)
+{
+  return (hb_fallback_shaper_font_data_t *) HB_SHAPER_DATA_SUCCEEDED;
+}
+
+void
+_hb_fallback_shaper_font_data_destroy (hb_fallback_shaper_font_data_t *data)
+{
+}
+
+
+/*
+ * shaper shape_plan data
+ */
+
+struct hb_fallback_shaper_shape_plan_data_t {};
+
+hb_fallback_shaper_shape_plan_data_t *
+_hb_fallback_shaper_shape_plan_data_create (hb_shape_plan_t    *shape_plan,
+					    const hb_feature_t *user_features,
+					    unsigned int        num_user_features)
+{
+  return (hb_fallback_shaper_shape_plan_data_t *) HB_SHAPER_DATA_SUCCEEDED;
+}
+
+void
+_hb_fallback_shaper_shape_plan_data_destroy (hb_fallback_shaper_shape_plan_data_t *data)
+{
+}
+
+
+/*
+ * shaper
+ */
 
 hb_bool_t
-_hb_fallback_shape (hb_font_t          *font,
+_hb_fallback_shape (hb_shape_plan_t    *shape_plan,
+		    hb_font_t          *font,
 		    hb_buffer_t        *buffer,
 		    const hb_feature_t *features HB_UNUSED,
 		    unsigned int        num_features HB_UNUSED)
 {
+  hb_codepoint_t space;
+  font->get_glyph (' ', 0, &space);
+
   buffer->guess_properties ();
+  buffer->clear_positions ();
 
   unsigned int count = buffer->len;
 
   for (unsigned int i = 0; i < count; i++)
-    hb_font_get_glyph (font, buffer->info[i].codepoint, 0, &buffer->info[i].codepoint);
-
-  buffer->clear_positions ();
-
-  for (unsigned int i = 0; i < count; i++) {
-    hb_font_get_glyph_advance_for_direction (font, buffer->info[i].codepoint,
-					     buffer->props.direction,
-					     &buffer->pos[i].x_advance,
-					     &buffer->pos[i].y_advance);
-    hb_font_subtract_glyph_origin_for_direction (font, buffer->info[i].codepoint,
-						 buffer->props.direction,
-						 &buffer->pos[i].x_offset,
-						 &buffer->pos[i].y_offset);
+  {
+    if (buffer->unicode->is_zero_width (buffer->info[i].codepoint)) {
+      buffer->info[i].codepoint = space;
+      buffer->pos[i].x_advance = 0;
+      buffer->pos[i].y_advance = 0;
+      continue;
+    }
+    font->get_glyph (buffer->info[i].codepoint, 0, &buffer->info[i].codepoint);
+    font->get_glyph_advance_for_direction (buffer->info[i].codepoint,
+					   buffer->props.direction,
+					   &buffer->pos[i].x_advance,
+					   &buffer->pos[i].y_advance);
+    font->subtract_glyph_origin_for_direction (buffer->info[i].codepoint,
+					       buffer->props.direction,
+					       &buffer->pos[i].x_offset,
+					       &buffer->pos[i].y_offset);
   }
 
   if (HB_DIRECTION_IS_BACKWARD (buffer->props.direction))
     hb_buffer_reverse (buffer);
 
-  return TRUE;
+  return true;
 }
diff --git a/gfx/harfbuzz/src/hb-font-private.hh b/gfx/harfbuzz/src/hb-font-private.hh
--- a/gfx/harfbuzz/src/hb-font-private.hh
+++ b/gfx/harfbuzz/src/hb-font-private.hh
@@ -28,16 +28,18 @@
 
 #ifndef HB_FONT_PRIVATE_HH
 #define HB_FONT_PRIVATE_HH
 
 #include "hb-private.hh"
 
 #include "hb-font.h"
 #include "hb-object-private.hh"
+#include "hb-shaper-private.hh"
+#include "hb-shape-plan-private.hh"
 
 
 
 /*
  * hb_font_funcs_t
  */
 
 #define HB_FONT_FUNCS_IMPLEMENT_CALLBACKS \
@@ -45,20 +47,23 @@
   HB_FONT_FUNC_IMPLEMENT (glyph_h_advance) \
   HB_FONT_FUNC_IMPLEMENT (glyph_v_advance) \
   HB_FONT_FUNC_IMPLEMENT (glyph_h_origin) \
   HB_FONT_FUNC_IMPLEMENT (glyph_v_origin) \
   HB_FONT_FUNC_IMPLEMENT (glyph_h_kerning) \
   HB_FONT_FUNC_IMPLEMENT (glyph_v_kerning) \
   HB_FONT_FUNC_IMPLEMENT (glyph_extents) \
   HB_FONT_FUNC_IMPLEMENT (glyph_contour_point) \
+  HB_FONT_FUNC_IMPLEMENT (glyph_name) \
+  HB_FONT_FUNC_IMPLEMENT (glyph_from_name) \
   /* ^--- Add new callbacks here */
 
-struct _hb_font_funcs_t {
+struct hb_font_funcs_t {
   hb_object_header_t header;
+  ASSERT_POD ();
 
   hb_bool_t immutable;
 
   /* Don't access these directly.  Call hb_font_get_*() instead. */
 
   struct {
 #define HB_FONT_FUNC_IMPLEMENT(name) hb_font_get_##name##_func_t name;
     HB_FONT_FUNCS_IMPLEMENT_CALLBACKS
@@ -78,54 +83,69 @@ struct _hb_font_funcs_t {
   } destroy;
 };
 
 
 /*
  * hb_face_t
  */
 
-struct _hb_face_t {
+struct hb_face_t {
   hb_object_header_t header;
+  ASSERT_POD ();
 
   hb_bool_t immutable;
 
   hb_reference_table_func_t  reference_table;
   void                      *user_data;
   hb_destroy_func_t          destroy;
 
-  struct hb_ot_layout_t *ot_layout;
-
   unsigned int index;
   unsigned int upem;
+
+  struct hb_shaper_data_t shaper_data;
+
+  struct plan_node_t {
+    hb_shape_plan_t *shape_plan;
+    plan_node_t *next;
+  } *shape_plans;
 };
 
+#define HB_SHAPER_DATA_CREATE_FUNC_EXTRA_ARGS
+#define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_PROTOTYPE(shaper, face);
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+#undef HB_SHAPER_DATA_CREATE_FUNC_EXTRA_ARGS
+
 
 /*
  * hb_font_t
  */
 
-struct _hb_font_t {
+struct hb_font_t {
   hb_object_header_t header;
+  ASSERT_POD ();
 
   hb_bool_t immutable;
 
   hb_font_t *parent;
   hb_face_t *face;
 
   int x_scale;
   int y_scale;
 
   unsigned int x_ppem;
   unsigned int y_ppem;
 
   hb_font_funcs_t   *klass;
   void              *user_data;
   hb_destroy_func_t  destroy;
 
+  struct hb_shaper_data_t shaper_data;
+
 
   /* Convert from font-space to user-space */
   inline hb_position_t em_scale_x (int16_t v) { return em_scale (v, this->x_scale); }
   inline hb_position_t em_scale_y (int16_t v) { return em_scale (v, this->y_scale); }
 
   /* Convert from parent-font user-space to our user-space */
   inline hb_position_t parent_scale_x_distance (hb_position_t v) {
     if (unlikely (parent && parent->x_scale != x_scale))
@@ -149,15 +169,224 @@ struct _hb_font_t {
     *y = parent_scale_y_distance (*y);
   }
   inline void parent_scale_position (hb_position_t *x, hb_position_t *y) {
     *x = parent_scale_x_position (*x);
     *y = parent_scale_y_position (*y);
   }
 
 
+  /* Public getters */
+
+  inline hb_bool_t get_glyph (hb_codepoint_t unicode, hb_codepoint_t variation_selector,
+			      hb_codepoint_t *glyph)
+  {
+    *glyph = 0;
+    return klass->get.glyph (this, user_data,
+			     unicode, variation_selector, glyph,
+			     klass->user_data.glyph);
+  }
+
+  inline hb_position_t get_glyph_h_advance (hb_codepoint_t glyph)
+  {
+    return klass->get.glyph_h_advance (this, user_data,
+				       glyph,
+				       klass->user_data.glyph_h_advance);
+  }
+
+  inline hb_position_t get_glyph_v_advance (hb_codepoint_t glyph)
+  {
+    return klass->get.glyph_v_advance (this, user_data,
+				       glyph,
+				       klass->user_data.glyph_v_advance);
+  }
+
+  inline hb_bool_t get_glyph_h_origin (hb_codepoint_t glyph,
+				       hb_position_t *x, hb_position_t *y)
+  {
+    *x = *y = 0;
+    return klass->get.glyph_h_origin (this, user_data,
+				      glyph, x, y,
+				      klass->user_data.glyph_h_origin);
+  }
+
+  inline hb_bool_t get_glyph_v_origin (hb_codepoint_t glyph,
+				       hb_position_t *x, hb_position_t *y)
+  {
+    *x = *y = 0;
+    return klass->get.glyph_v_origin (this, user_data,
+				      glyph, x, y,
+				      klass->user_data.glyph_v_origin);
+  }
+
+  inline hb_position_t get_glyph_h_kerning (hb_codepoint_t left_glyph, hb_codepoint_t right_glyph)
+  {
+    return klass->get.glyph_h_kerning (this, user_data,
+				       left_glyph, right_glyph,
+				       klass->user_data.glyph_h_kerning);
+  }
+
+  inline hb_position_t get_glyph_v_kerning (hb_codepoint_t left_glyph, hb_codepoint_t right_glyph)
+  {
+    return klass->get.glyph_v_kerning (this, user_data,
+				       left_glyph, right_glyph,
+				       klass->user_data.glyph_v_kerning);
+  }
+
+  inline hb_bool_t get_glyph_extents (hb_codepoint_t glyph,
+				      hb_glyph_extents_t *extents)
+  {
+    memset (extents, 0, sizeof (*extents));
+    return klass->get.glyph_extents (this, user_data,
+				     glyph,
+				     extents,
+				     klass->user_data.glyph_extents);
+  }
+
+  inline hb_bool_t get_glyph_contour_point (hb_codepoint_t glyph, unsigned int point_index,
+					    hb_position_t *x, hb_position_t *y)
+  {
+    *x = *y = 0;
+    return klass->get.glyph_contour_point (this, user_data,
+					   glyph, point_index,
+					   x, y,
+					   klass->user_data.glyph_contour_point);
+  }
+
+  inline hb_bool_t get_glyph_name (hb_codepoint_t glyph,
+				   char *name, unsigned int size)
+  {
+    return klass->get.glyph_name (this, user_data,
+				  glyph,
+				  name, size,
+				  klass->user_data.glyph_name);
+  }
+
+  inline hb_bool_t get_glyph_from_name (const char *name, int len, /* -1 means nul-terminated */
+					hb_codepoint_t *glyph)
+  {
+    return klass->get.glyph_from_name (this, user_data,
+				       name, len,
+				       glyph,
+				       klass->user_data.glyph_from_name);
+  }
+
+
+  /* A bit higher-level, and with fallback */
+
+  inline void get_glyph_advance_for_direction (hb_codepoint_t glyph,
+					       hb_direction_t direction,
+					       hb_position_t *x, hb_position_t *y)
+  {
+    if (likely (HB_DIRECTION_IS_HORIZONTAL (direction))) {
+      *x = get_glyph_h_advance (glyph);
+      *y = 0;
+    } else {
+      *x = 0;
+      *y = get_glyph_v_advance (glyph);
+    }
+  }
+
+  /* Internal only */
+  inline void guess_v_origin_minus_h_origin (hb_codepoint_t glyph,
+					     hb_position_t *x, hb_position_t *y)
+  {
+    *x = get_glyph_h_advance (glyph) / 2;
+
+    /* TODO use font_metics.ascent */
+    *y = y_scale;
+  }
+
+  inline void get_glyph_origin_for_direction (hb_codepoint_t glyph,
+					      hb_direction_t direction,
+					      hb_position_t *x, hb_position_t *y)
+  {
+    if (likely (HB_DIRECTION_IS_HORIZONTAL (direction))) {
+      hb_bool_t ret = get_glyph_h_origin (glyph, x, y);
+      if (!ret && (ret = get_glyph_v_origin (glyph, x, y))) {
+	hb_position_t dx, dy;
+	guess_v_origin_minus_h_origin (glyph, &dx, &dy);
+	*x -= dx; *y -= dy;
+      }
+    } else {
+      hb_bool_t ret = get_glyph_v_origin (glyph, x, y);
+      if (!ret && (ret = get_glyph_h_origin (glyph, x, y))) {
+	hb_position_t dx, dy;
+	guess_v_origin_minus_h_origin (glyph, &dx, &dy);
+	*x += dx; *y += dy;
+      }
+    }
+  }
+
+  inline void add_glyph_origin_for_direction (hb_codepoint_t glyph,
+					      hb_direction_t direction,
+					      hb_position_t *x, hb_position_t *y)
+  {
+    hb_position_t origin_x, origin_y;
+
+    get_glyph_origin_for_direction (glyph, direction, &origin_x, &origin_y);
+
+    *x += origin_x;
+    *y += origin_y;
+  }
+
+  inline void subtract_glyph_origin_for_direction (hb_codepoint_t glyph,
+						   hb_direction_t direction,
+						   hb_position_t *x, hb_position_t *y)
+  {
+    hb_position_t origin_x, origin_y;
+
+    get_glyph_origin_for_direction (glyph, direction, &origin_x, &origin_y);
+
+    *x -= origin_x;
+    *y -= origin_y;
+  }
+
+  inline void get_glyph_kerning_for_direction (hb_codepoint_t first_glyph, hb_codepoint_t second_glyph,
+					       hb_direction_t direction,
+					       hb_position_t *x, hb_position_t *y)
+  {
+    if (likely (HB_DIRECTION_IS_HORIZONTAL (direction))) {
+      *x = get_glyph_h_kerning (first_glyph, second_glyph);
+      *y = 0;
+    } else {
+      *x = 0;
+      *y = get_glyph_v_kerning (first_glyph, second_glyph);
+    }
+  }
+
+  inline hb_bool_t get_glyph_extents_for_origin (hb_codepoint_t glyph,
+						 hb_direction_t direction,
+						 hb_glyph_extents_t *extents)
+  {
+    hb_bool_t ret = get_glyph_extents (glyph, extents);
+
+    if (ret)
+      subtract_glyph_origin_for_direction (glyph, direction, &extents->x_bearing, &extents->y_bearing);
+
+    return ret;
+  }
+
+  inline hb_bool_t get_glyph_contour_point_for_origin (hb_codepoint_t glyph, unsigned int point_index,
+						       hb_direction_t direction,
+						       hb_position_t *x, hb_position_t *y)
+  {
+    hb_bool_t ret = get_glyph_contour_point (glyph, point_index, x, y);
+
+    if (ret)
+      subtract_glyph_origin_for_direction (glyph, direction, x, y);
+
+    return ret;
+  }
+
+
   private:
   inline hb_position_t em_scale (int16_t v, int scale) { return v * (int64_t) scale / hb_face_get_upem (this->face); }
 };
 
+#define HB_SHAPER_DATA_CREATE_FUNC_EXTRA_ARGS
+#define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_PROTOTYPE(shaper, font);
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+#undef HB_SHAPER_DATA_CREATE_FUNC_EXTRA_ARGS
 
 
 #endif /* HB_FONT_PRIVATE_HH */
diff --git a/gfx/harfbuzz/src/hb-font.cc b/gfx/harfbuzz/src/hb-font.cc
--- a/gfx/harfbuzz/src/hb-font.cc
+++ b/gfx/harfbuzz/src/hb-font.cc
@@ -1,10 +1,11 @@
 /*
  * Copyright © 2009  Red Hat, Inc.
+ * Copyright © 2012  Google, Inc.
  *
  *  This is part of HarfBuzz, a text shaping library.
  *
  * Permission is hereby granted, without written agreement and without
  * license or royalty fees, to use, copy, modify, and distribute this
  * software and its documentation for any purpose, provided that the
  * above copyright notice and the following two paragraphs appear in
  * all copies of this software.
@@ -17,16 +18,17 @@
  *
  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  *
  * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
  */
 
 #include "hb-private.hh"
 
 #include "hb-ot-layout-private.hh"
 
 #include "hb-font-private.hh"
 #include "hb-blob.h"
@@ -39,124 +41,120 @@
 
 
 
 /*
  * hb_font_funcs_t
  */
 
 static hb_bool_t
-hb_font_get_glyph_nil (hb_font_t *font HB_UNUSED,
+hb_font_get_glyph_nil (hb_font_t *font,
 		       void *font_data HB_UNUSED,
 		       hb_codepoint_t unicode,
 		       hb_codepoint_t variation_selector,
 		       hb_codepoint_t *glyph,
 		       void *user_data HB_UNUSED)
 {
   if (font->parent)
     return hb_font_get_glyph (font->parent, unicode, variation_selector, glyph);
 
   *glyph = 0;
-  return FALSE;
+  return false;
 }
 
 static hb_position_t
-hb_font_get_glyph_h_advance_nil (hb_font_t *font HB_UNUSED,
+hb_font_get_glyph_h_advance_nil (hb_font_t *font,
 				 void *font_data HB_UNUSED,
 				 hb_codepoint_t glyph,
 				 void *user_data HB_UNUSED)
 {
   if (font->parent)
     return font->parent_scale_x_distance (hb_font_get_glyph_h_advance (font->parent, glyph));
 
   return font->x_scale;
 }
 
 static hb_position_t
-hb_font_get_glyph_v_advance_nil (hb_font_t *font HB_UNUSED,
+hb_font_get_glyph_v_advance_nil (hb_font_t *font,
 				 void *font_data HB_UNUSED,
 				 hb_codepoint_t glyph,
 				 void *user_data HB_UNUSED)
 {
   if (font->parent)
     return font->parent_scale_y_distance (hb_font_get_glyph_v_advance (font->parent, glyph));
 
   return font->y_scale;
 }
 
 static hb_bool_t
-hb_font_get_glyph_h_origin_nil (hb_font_t *font HB_UNUSED,
+hb_font_get_glyph_h_origin_nil (hb_font_t *font,
 				void *font_data HB_UNUSED,
 				hb_codepoint_t glyph,
 				hb_position_t *x,
 				hb_position_t *y,
 				void *user_data HB_UNUSED)
 {
   if (font->parent) {
-    hb_bool_t ret = hb_font_get_glyph_h_origin (font->parent,
-						glyph,
-						x, y);
+    hb_bool_t ret = hb_font_get_glyph_h_origin (font->parent, glyph, x, y);
     if (ret)
       font->parent_scale_position (x, y);
     return ret;
   }
 
   *x = *y = 0;
-  return FALSE;
+  return false;
 }
 
 static hb_bool_t
-hb_font_get_glyph_v_origin_nil (hb_font_t *font HB_UNUSED,
+hb_font_get_glyph_v_origin_nil (hb_font_t *font,
 				void *font_data HB_UNUSED,
 				hb_codepoint_t glyph,
 				hb_position_t *x,
 				hb_position_t *y,
 				void *user_data HB_UNUSED)
 {
   if (font->parent) {
-    hb_bool_t ret = hb_font_get_glyph_v_origin (font->parent,
-						glyph,
-						x, y);
+    hb_bool_t ret = hb_font_get_glyph_v_origin (font->parent, glyph, x, y);
     if (ret)
       font->parent_scale_position (x, y);
     return ret;
   }
 
   *x = *y = 0;
-  return FALSE;
+  return false;
 }
 
 static hb_position_t
-hb_font_get_glyph_h_kerning_nil (hb_font_t *font HB_UNUSED,
+hb_font_get_glyph_h_kerning_nil (hb_font_t *font,
 				 void *font_data HB_UNUSED,
 				 hb_codepoint_t left_glyph,
 				 hb_codepoint_t right_glyph,
 				 void *user_data HB_UNUSED)
 {
   if (font->parent)
     return font->parent_scale_x_distance (hb_font_get_glyph_h_kerning (font->parent, left_glyph, right_glyph));
 
   return 0;
 }
 
 static hb_position_t
-hb_font_get_glyph_v_kerning_nil (hb_font_t *font HB_UNUSED,
+hb_font_get_glyph_v_kerning_nil (hb_font_t *font,
 				 void *font_data HB_UNUSED,
 				 hb_codepoint_t top_glyph,
 				 hb_codepoint_t bottom_glyph,
 				 void *user_data HB_UNUSED)
 {
   if (font->parent)
     return font->parent_scale_y_distance (hb_font_get_glyph_v_kerning (font->parent, top_glyph, bottom_glyph));
 
   return 0;
 }
 
 static hb_bool_t
-hb_font_get_glyph_extents_nil (hb_font_t *font HB_UNUSED,
+hb_font_get_glyph_extents_nil (hb_font_t *font,
 			       void *font_data HB_UNUSED,
 			       hb_codepoint_t glyph,
 			       hb_glyph_extents_t *extents,
 			       void *user_data HB_UNUSED)
 {
   if (font->parent) {
     hb_bool_t ret = hb_font_get_glyph_extents (font->parent,
 					       glyph,
@@ -164,72 +162,98 @@ hb_font_get_glyph_extents_nil (hb_font_t
     if (ret) {
       font->parent_scale_position (&extents->x_bearing, &extents->y_bearing);
       font->parent_scale_distance (&extents->width, &extents->height);
     }
     return ret;
   }
 
   memset (extents, 0, sizeof (*extents));
-  return FALSE;
+  return false;
 }
 
 static hb_bool_t
-hb_font_get_glyph_contour_point_nil (hb_font_t *font HB_UNUSED,
+hb_font_get_glyph_contour_point_nil (hb_font_t *font,
 				     void *font_data HB_UNUSED,
 				     hb_codepoint_t glyph,
 				     unsigned int point_index,
 				     hb_position_t *x,
 				     hb_position_t *y,
 				     void *user_data HB_UNUSED)
 {
   if (font->parent) {
-    hb_bool_t ret = hb_font_get_glyph_contour_point (font->parent,
-						     glyph, point_index,
-						     x, y);
+    hb_bool_t ret = hb_font_get_glyph_contour_point (font->parent, glyph, point_index, x, y);
     if (ret)
       font->parent_scale_position (x, y);
     return ret;
   }
 
   *x = *y = 0;
-  return FALSE;
+  return false;
 }
 
+static hb_bool_t
+hb_font_get_glyph_name_nil (hb_font_t *font,
+			    void *font_data HB_UNUSED,
+			    hb_codepoint_t glyph,
+			    char *name, unsigned int size,
+			    void *user_data HB_UNUSED)
+{
+  if (font->parent)
+    return hb_font_get_glyph_name (font->parent, glyph, name, size);
 
-static hb_font_funcs_t _hb_font_funcs_nil = {
+  snprintf (name, size, "gid%u", glyph);
+  return false;
+}
+
+static hb_bool_t
+hb_font_get_glyph_from_name_nil (hb_font_t *font,
+				 void *font_data HB_UNUSED,
+				 const char *name, int len, /* -1 means nul-terminated */
+				 hb_codepoint_t *glyph,
+				 void *user_data HB_UNUSED)
+{
+  if (font->parent)
+    return hb_font_get_glyph_from_name (font->parent, name, len, glyph);
+
+  *glyph = 0;
+  return false;
+}
+
+
+static const hb_font_funcs_t _hb_font_funcs_nil = {
   HB_OBJECT_HEADER_STATIC,
 
-  TRUE, /* immutable */
+  true, /* immutable */
 
   {
 #define HB_FONT_FUNC_IMPLEMENT(name) hb_font_get_##name##_nil,
     HB_FONT_FUNCS_IMPLEMENT_CALLBACKS
 #undef HB_FONT_FUNC_IMPLEMENT
   }
 };
 
 
 hb_font_funcs_t *
 hb_font_funcs_create (void)
 {
   hb_font_funcs_t *ffuncs;
 
   if (!(ffuncs = hb_object_create<hb_font_funcs_t> ()))
-    return &_hb_font_funcs_nil;
+    return hb_font_funcs_get_empty ();
 
   ffuncs->get = _hb_font_funcs_nil.get;
 
   return ffuncs;
 }
 
 hb_font_funcs_t *
 hb_font_funcs_get_empty (void)
 {
-  return &_hb_font_funcs_nil;
+  return const_cast<hb_font_funcs_t *> (&_hb_font_funcs_nil);
 }
 
 hb_font_funcs_t *
 hb_font_funcs_reference (hb_font_funcs_t *ffuncs)
 {
   return hb_object_reference (ffuncs);
 }
 
@@ -265,17 +289,17 @@ hb_font_funcs_get_user_data (hb_font_fun
 
 
 void
 hb_font_funcs_make_immutable (hb_font_funcs_t *ffuncs)
 {
   if (hb_object_is_inert (ffuncs))
     return;
 
-  ffuncs->immutable = TRUE;
+  ffuncs->immutable = true;
 }
 
 hb_bool_t
 hb_font_funcs_is_immutable (hb_font_funcs_t *ffuncs)
 {
   return ffuncs->immutable;
 }
 
@@ -307,280 +331,219 @@ hb_font_funcs_set_##name##_func (hb_font
     ffuncs->destroy.name = NULL;                                         \
   }                                                                      \
 }
 
 HB_FONT_FUNCS_IMPLEMENT_CALLBACKS
 #undef HB_FONT_FUNC_IMPLEMENT
 
 
+/* Public getters */
+
 hb_bool_t
 hb_font_get_glyph (hb_font_t *font,
 		   hb_codepoint_t unicode, hb_codepoint_t variation_selector,
 		   hb_codepoint_t *glyph)
 {
-  *glyph = 0;
-  return font->klass->get.glyph (font, font->user_data,
-				 unicode, variation_selector, glyph,
-				 font->klass->user_data.glyph);
+  return font->get_glyph (unicode, variation_selector, glyph);
 }
 
 hb_position_t
 hb_font_get_glyph_h_advance (hb_font_t *font,
 			     hb_codepoint_t glyph)
 {
-  return font->klass->get.glyph_h_advance (font, font->user_data,
-					   glyph,
-					   font->klass->user_data.glyph_h_advance);
+  return font->get_glyph_h_advance (glyph);
 }
 
 hb_position_t
 hb_font_get_glyph_v_advance (hb_font_t *font,
 			     hb_codepoint_t glyph)
 {
-  return font->klass->get.glyph_v_advance (font, font->user_data,
-					   glyph,
-					   font->klass->user_data.glyph_v_advance);
+  return font->get_glyph_v_advance (glyph);
 }
 
 hb_bool_t
 hb_font_get_glyph_h_origin (hb_font_t *font,
 			    hb_codepoint_t glyph,
 			    hb_position_t *x, hb_position_t *y)
 {
-  *x = *y = 0;
-  return font->klass->get.glyph_h_origin (font, font->user_data,
-					   glyph, x, y,
-					   font->klass->user_data.glyph_h_origin);
+  return font->get_glyph_h_origin (glyph, x, y);
 }
 
 hb_bool_t
 hb_font_get_glyph_v_origin (hb_font_t *font,
 			    hb_codepoint_t glyph,
 			    hb_position_t *x, hb_position_t *y)
 {
-  *x = *y = 0;
-  return font->klass->get.glyph_v_origin (font, font->user_data,
-					   glyph, x, y,
-					   font->klass->user_data.glyph_v_origin);
+  return font->get_glyph_v_origin (glyph, x, y);
 }
 
 hb_position_t
 hb_font_get_glyph_h_kerning (hb_font_t *font,
 			     hb_codepoint_t left_glyph, hb_codepoint_t right_glyph)
 {
-  return font->klass->get.glyph_h_kerning (font, font->user_data,
-					   left_glyph, right_glyph,
-					   font->klass->user_data.glyph_h_kerning);
+  return font->get_glyph_h_kerning (left_glyph, right_glyph);
 }
 
 hb_position_t
 hb_font_get_glyph_v_kerning (hb_font_t *font,
 			     hb_codepoint_t left_glyph, hb_codepoint_t right_glyph)
 {
-  return font->klass->get.glyph_v_kerning (font, font->user_data,
-				     left_glyph, right_glyph,
-				     font->klass->user_data.glyph_v_kerning);
+  return font->get_glyph_v_kerning (left_glyph, right_glyph);
 }
 
 hb_bool_t
 hb_font_get_glyph_extents (hb_font_t *font,
 			   hb_codepoint_t glyph,
 			   hb_glyph_extents_t *extents)
 {
-  memset (extents, 0, sizeof (*extents));
-  return font->klass->get.glyph_extents (font, font->user_data,
-					 glyph,
-					 extents,
-					 font->klass->user_data.glyph_extents);
+  return font->get_glyph_extents (glyph, extents);
 }
 
 hb_bool_t
 hb_font_get_glyph_contour_point (hb_font_t *font,
 				 hb_codepoint_t glyph, unsigned int point_index,
 				 hb_position_t *x, hb_position_t *y)
 {
-  *x = *y = 0;
-  return font->klass->get.glyph_contour_point (font, font->user_data,
-					       glyph, point_index,
-					       x, y,
-					       font->klass->user_data.glyph_contour_point);
+  return font->get_glyph_contour_point (glyph, point_index, x, y);
+}
+
+hb_bool_t
+hb_font_get_glyph_name (hb_font_t *font,
+			hb_codepoint_t glyph,
+			char *name, unsigned int size)
+{
+  return font->get_glyph_name (glyph, name, size);
+}
+
+hb_bool_t
+hb_font_get_glyph_from_name (hb_font_t *font,
+			     const char *name, int len, /* -1 means nul-terminated */
+			     hb_codepoint_t *glyph)
+{
+  return font->get_glyph_from_name (name, len, glyph);
 }
 
 
 /* A bit higher-level, and with fallback */
 
 void
 hb_font_get_glyph_advance_for_direction (hb_font_t *font,
 					 hb_codepoint_t glyph,
 					 hb_direction_t direction,
 					 hb_position_t *x, hb_position_t *y)
 {
-  if (likely (HB_DIRECTION_IS_HORIZONTAL (direction))) {
-    *x = hb_font_get_glyph_h_advance (font, glyph);
-    *y = 0;
-  } else {
-    *x = 0;
-    *y = hb_font_get_glyph_v_advance (font, glyph);
-  }
+  return font->get_glyph_advance_for_direction (glyph, direction, x, y);
 }
 
-static void
-guess_v_origin_minus_h_origin (hb_font_t *font,
-			       hb_codepoint_t glyph,
-			       hb_position_t *x, hb_position_t *y)
-{
-  *x = hb_font_get_glyph_h_advance (font, glyph) / 2;
-
-  /* TODO use font_metics.ascent */
-  *y = font->y_scale;
-}
-
-
 void
 hb_font_get_glyph_origin_for_direction (hb_font_t *font,
 					hb_codepoint_t glyph,
 					hb_direction_t direction,
 					hb_position_t *x, hb_position_t *y)
 {
-  if (likely (HB_DIRECTION_IS_HORIZONTAL (direction))) {
-    hb_bool_t ret = hb_font_get_glyph_h_origin (font, glyph, x, y);
-    if (!ret && (ret = hb_font_get_glyph_v_origin (font, glyph, x, y))) {
-      hb_position_t dx, dy;
-      guess_v_origin_minus_h_origin (font, glyph, &dx, &dy);
-      *x -= dx; *y -= dy;
-    }
-  } else {
-    hb_bool_t ret = hb_font_get_glyph_v_origin (font, glyph, x, y);
-    if (!ret && (ret = hb_font_get_glyph_h_origin (font, glyph, x, y))) {
-      hb_position_t dx, dy;
-      guess_v_origin_minus_h_origin (font, glyph, &dx, &dy);
-      *x += dx; *y += dy;
-    }
-  }
+  return font->get_glyph_origin_for_direction (glyph, direction, x, y);
 }
 
 void
 hb_font_add_glyph_origin_for_direction (hb_font_t *font,
 					hb_codepoint_t glyph,
 					hb_direction_t direction,
 					hb_position_t *x, hb_position_t *y)
 {
-  hb_position_t origin_x, origin_y;
-
-  hb_font_get_glyph_origin_for_direction (font, glyph, direction, &origin_x, &origin_y);
-
-  *x += origin_x;
-  *y += origin_y;
+  return font->add_glyph_origin_for_direction (glyph, direction, x, y);
 }
 
 void
 hb_font_subtract_glyph_origin_for_direction (hb_font_t *font,
 					     hb_codepoint_t glyph,
 					     hb_direction_t direction,
 					     hb_position_t *x, hb_position_t *y)
 {
-  hb_position_t origin_x, origin_y;
-
-  hb_font_get_glyph_origin_for_direction (font, glyph, direction, &origin_x, &origin_y);
-
-  *x -= origin_x;
-  *y -= origin_y;
+  return font->subtract_glyph_origin_for_direction (glyph, direction, x, y);
 }
 
 void
 hb_font_get_glyph_kerning_for_direction (hb_font_t *font,
 					 hb_codepoint_t first_glyph, hb_codepoint_t second_glyph,
 					 hb_direction_t direction,
 					 hb_position_t *x, hb_position_t *y)
 {
-  if (likely (HB_DIRECTION_IS_HORIZONTAL (direction))) {
-    *x = hb_font_get_glyph_h_kerning (font, first_glyph, second_glyph);
-    *y = 0;
-  } else {
-    *x = 0;
-    *y = hb_font_get_glyph_v_kerning (font, first_glyph, second_glyph);
-  }
+  return font->get_glyph_kerning_for_direction (first_glyph, second_glyph, direction, x, y);
 }
 
 hb_bool_t
 hb_font_get_glyph_extents_for_origin (hb_font_t *font,
 				      hb_codepoint_t glyph,
 				      hb_direction_t direction,
 				      hb_glyph_extents_t *extents)
 {
-  hb_bool_t ret = hb_font_get_glyph_extents (font, glyph, extents);
-
-  if (ret)
-    hb_font_subtract_glyph_origin_for_direction (font, glyph, direction, &extents->x_bearing, &extents->y_bearing);
-
-  return ret;
+  return font->get_glyph_extents_for_origin (glyph, direction, extents);
 }
 
 hb_bool_t
 hb_font_get_glyph_contour_point_for_origin (hb_font_t *font,
 					    hb_codepoint_t glyph, unsigned int point_index,
 					    hb_direction_t direction,
 					    hb_position_t *x, hb_position_t *y)
 {
-  hb_bool_t ret = hb_font_get_glyph_contour_point (font, glyph, point_index, x, y);
-
-  if (ret)
-    hb_font_subtract_glyph_origin_for_direction (font, glyph, direction, x, y);
-
-  return ret;
+  return font->get_glyph_contour_point_for_origin (glyph, point_index, direction, x, y);
 }
 
 
 /*
  * hb_face_t
  */
 
-static hb_face_t _hb_face_nil = {
+static const hb_face_t _hb_face_nil = {
   HB_OBJECT_HEADER_STATIC,
 
-  TRUE, /* immutable */
+  true, /* immutable */
 
   NULL, /* reference_table */
   NULL, /* user_data */
   NULL, /* destroy */
 
-  NULL, /* ot_layout */
+  0,    /* index */
+  1000, /* upem */
 
-  0,    /* index */
-  1000  /* upem */
+  {
+#define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_INVALID,
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+  },
+
+  NULL, /* shape_plans */
 };
 
 
 hb_face_t *
 hb_face_create_for_tables (hb_reference_table_func_t  reference_table,
 			   void                      *user_data,
 			   hb_destroy_func_t          destroy)
 {
   hb_face_t *face;
 
   if (!reference_table || !(face = hb_object_create<hb_face_t> ())) {
     if (destroy)
       destroy (user_data);
-    return &_hb_face_nil;
+    return hb_face_get_empty ();
   }
 
   face->reference_table = reference_table;
   face->user_data = user_data;
   face->destroy = destroy;
 
-  face->ot_layout = _hb_ot_layout_create (face);
-
   face->upem = 0;
 
   return face;
 }
 
 
-typedef struct _hb_face_for_data_closure_t {
+typedef struct hb_face_for_data_closure_t {
   hb_blob_t *blob;
   unsigned int  index;
 } hb_face_for_data_closure_t;
 
 static hb_face_for_data_closure_t *
 _hb_face_for_data_closure_create (hb_blob_t *blob, unsigned int index)
 {
   hb_face_for_data_closure_t *closure;
@@ -622,51 +585,64 @@ static hb_blob_t *
 
 hb_face_t *
 hb_face_create (hb_blob_t    *blob,
 		unsigned int  index)
 {
   hb_face_t *face;
 
   if (unlikely (!blob || !hb_blob_get_length (blob)))
-    return &_hb_face_nil;
+    return hb_face_get_empty ();
 
   hb_face_for_data_closure_t *closure = _hb_face_for_data_closure_create (Sanitizer<OpenTypeFontFile>::sanitize (hb_blob_reference (blob)), index);
 
   if (unlikely (!closure))
-    return &_hb_face_nil;
+    return hb_face_get_empty ();
 
   face = hb_face_create_for_tables (_hb_face_for_data_reference_table,
 				    closure,
 				    (hb_destroy_func_t) _hb_face_for_data_closure_destroy);
 
   hb_face_set_index (face, index);
 
   return face;
 }
 
 hb_face_t *
 hb_face_get_empty (void)
 {
-  return &_hb_face_nil;
+  return const_cast<hb_face_t *> (&_hb_face_nil);
 }
 
 
 hb_face_t *
 hb_face_reference (hb_face_t *face)
 {
   return hb_object_reference (face);
 }
 
 void
 hb_face_destroy (hb_face_t *face)
 {
   if (!hb_object_destroy (face)) return;
 
-  _hb_ot_layout_destroy (face->ot_layout);
+  /* The cached shape_plans think they have a reference on us, and
+   * try to release it.  Make sure that doesn't mess up. */
+  face->header.ref_count.ref_count = HB_REFERENCE_COUNT_INVALID_VALUE;
+  for (hb_face_t::plan_node_t *node = face->shape_plans; node; )
+  {
+    hb_face_t::plan_node_t *next = node->next;
+    hb_shape_plan_destroy (node->shape_plan);
+    free (node);
+    node = next;
+  }
+
+#define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_DESTROY(shaper, face);
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
 
   if (face->destroy)
     face->destroy (face->user_data);
 
   free (face);
 }
 
 hb_bool_t
@@ -762,100 +738,109 @@ hb_face_get_upem (hb_face_t *face)
   return face->upem;
 }
 
 
 /*
  * hb_font_t
  */
 
-static hb_font_t _hb_font_nil = {
-  HB_OBJECT_HEADER_STATIC,
-
-  TRUE, /* immutable */
-
-  NULL, /* parent */
-  &_hb_face_nil,
-
-  0, /* x_scale */
-  0, /* y_scale */
-
-  0, /* x_ppem */
-  0, /* y_ppem */
-
-  &_hb_font_funcs_nil, /* klass */
-  NULL, /* user_data */
-  NULL  /* destroy */
-};
-
 hb_font_t *
 hb_font_create (hb_face_t *face)
 {
   hb_font_t *font;
 
   if (unlikely (!face))
-    face = &_hb_face_nil;
+    face = hb_face_get_empty ();
   if (unlikely (hb_object_is_inert (face)))
-    return &_hb_font_nil;
+    return hb_font_get_empty ();
   if (!(font = hb_object_create<hb_font_t> ()))
-    return &_hb_font_nil;
+    return hb_font_get_empty ();
 
   hb_face_make_immutable (face);
   font->face = hb_face_reference (face);
-  font->klass = &_hb_font_funcs_nil;
+  font->klass = hb_font_funcs_get_empty ();
 
   return font;
 }
 
 hb_font_t *
 hb_font_create_sub_font (hb_font_t *parent)
 {
   if (unlikely (!parent))
-    return &_hb_font_nil;
+    return hb_font_get_empty ();
 
   hb_font_t *font = hb_font_create (parent->face);
 
   if (unlikely (hb_object_is_inert (font)))
     return font;
 
   hb_font_make_immutable (parent);
   font->parent = hb_font_reference (parent);
 
   font->x_scale = parent->x_scale;
   font->y_scale = parent->y_scale;
   font->x_ppem = parent->x_ppem;
   font->y_ppem = parent->y_ppem;
 
-  font->klass = &_hb_font_funcs_nil;
-
   return font;
 }
 
 hb_font_t *
 hb_font_get_empty (void)
 {
-  return &_hb_font_nil;
+  static const hb_font_t _hb_font_nil = {
+    HB_OBJECT_HEADER_STATIC,
+
+    true, /* immutable */
+
+    NULL, /* parent */
+    const_cast<hb_face_t *> (&_hb_face_nil),
+
+    0, /* x_scale */
+    0, /* y_scale */
+
+    0, /* x_ppem */
+    0, /* y_ppem */
+
+    const_cast<hb_font_funcs_t *> (&_hb_font_funcs_nil), /* klass */
+    NULL, /* user_data */
+    NULL, /* destroy */
+
+    {
+#define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_INVALID,
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+    }
+  };
+
+  return const_cast<hb_font_t *> (&_hb_font_nil);
 }
 
 hb_font_t *
 hb_font_reference (hb_font_t *font)
 {
   return hb_object_reference (font);
 }
 
 void
 hb_font_destroy (hb_font_t *font)
 {
   if (!hb_object_destroy (font)) return;
 
+#define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_DESTROY(shaper, font);
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+
+  if (font->destroy)
+    font->destroy (font->user_data);
+
   hb_font_destroy (font->parent);
   hb_face_destroy (font->face);
   hb_font_funcs_destroy (font->klass);
-  if (font->destroy)
-    font->destroy (font->user_data);
 
   free (font);
 }
 
 hb_bool_t
 hb_font_set_user_data (hb_font_t          *font,
 		       hb_user_data_key_t *key,
 		       void *              data,
@@ -911,17 +896,17 @@ hb_font_set_funcs (hb_font_t         *fo
       destroy (user_data);
     return;
   }
 
   if (font->destroy)
     font->destroy (font->user_data);
 
   if (!klass)
-    klass = &_hb_font_funcs_nil;
+    klass = hb_font_funcs_get_empty ();
 
   hb_font_funcs_reference (klass);
   hb_font_funcs_destroy (font->klass);
   font->klass = klass;
   font->user_data = user_data;
   font->destroy = destroy;
 }
 
@@ -981,10 +966,8 @@ hb_font_set_ppem (hb_font_t *font,
 void
 hb_font_get_ppem (hb_font_t *font,
 		  unsigned int *x_ppem,
 		  unsigned int *y_ppem)
 {
   if (x_ppem) *x_ppem = font->x_ppem;
   if (y_ppem) *y_ppem = font->y_ppem;
 }
-
-
diff --git a/gfx/harfbuzz/src/hb-font.h b/gfx/harfbuzz/src/hb-font.h
--- a/gfx/harfbuzz/src/hb-font.h
+++ b/gfx/harfbuzz/src/hb-font.h
@@ -32,18 +32,18 @@
 #define HB_FONT_H
 
 #include "hb-common.h"
 #include "hb-blob.h"
 
 HB_BEGIN_DECLS
 
 
-typedef struct _hb_face_t hb_face_t;
-typedef struct _hb_font_t hb_font_t;
+typedef struct hb_face_t hb_face_t;
+typedef struct hb_font_t hb_font_t;
 
 /*
  * hb_face_t
  */
 
 hb_face_t *
 hb_face_create (hb_blob_t    *blob,
 		unsigned int  index);
@@ -105,17 +105,17 @@ hb_face_set_upem (hb_face_t    *face,
 unsigned int
 hb_face_get_upem (hb_face_t *face);
 
 
 /*
  * hb_font_funcs_t
  */
 
-typedef struct _hb_font_funcs_t hb_font_funcs_t;
+typedef struct hb_font_funcs_t hb_font_funcs_t;
 
 hb_font_funcs_t *
 hb_font_funcs_create (void);
 
 hb_font_funcs_t *
 hb_font_funcs_get_empty (void);
 
 hb_font_funcs_t *
@@ -140,17 +140,17 @@ hb_font_funcs_get_user_data (hb_font_fun
 void
 hb_font_funcs_make_immutable (hb_font_funcs_t *ffuncs);
 
 hb_bool_t
 hb_font_funcs_is_immutable (hb_font_funcs_t *ffuncs);
 
 /* funcs */
 
-typedef struct _hb_glyph_extents_t
+typedef struct hb_glyph_extents_t
 {
   hb_position_t x_bearing;
   hb_position_t y_bearing;
   hb_position_t width;
   hb_position_t height;
 } hb_glyph_extents_t;
 
 
@@ -187,16 +187,26 @@ typedef hb_bool_t (*hb_font_get_glyph_ex
 						       hb_glyph_extents_t *extents,
 						       void *user_data);
 typedef hb_bool_t (*hb_font_get_glyph_contour_point_func_t) (hb_font_t *font, void *font_data,
 							     hb_codepoint_t glyph, unsigned int point_index,
 							     hb_position_t *x, hb_position_t *y,
 							     void *user_data);
 
 
+typedef hb_bool_t (*hb_font_get_glyph_name_func_t) (hb_font_t *font, void *font_data,
+						    hb_codepoint_t glyph,
+						    char *name, unsigned int size,
+						    void *user_data);
+typedef hb_bool_t (*hb_font_get_glyph_from_name_func_t) (hb_font_t *font, void *font_data,
+							 const char *name, int len, /* -1 means nul-terminated */
+							 hb_codepoint_t *glyph,
+							 void *user_data);
+
+
 /* func setters */
 
 void
 hb_font_funcs_set_glyph_func (hb_font_funcs_t *ffuncs,
 			      hb_font_get_glyph_func_t glyph_func,
 			      void *user_data, hb_destroy_func_t destroy);
 
 void
@@ -230,16 +240,25 @@ void
 hb_font_funcs_set_glyph_extents_func (hb_font_funcs_t *ffuncs,
 				      hb_font_get_glyph_extents_func_t func,
 				      void *user_data, hb_destroy_func_t destroy);
 void
 hb_font_funcs_set_glyph_contour_point_func (hb_font_funcs_t *ffuncs,
 					    hb_font_get_glyph_contour_point_func_t func,
 					    void *user_data, hb_destroy_func_t destroy);
 
+void
+hb_font_funcs_set_glyph_name_func (hb_font_funcs_t *ffuncs,
+				   hb_font_get_glyph_name_func_t glyph_func,
+				   void *user_data, hb_destroy_func_t destroy);
+void
+hb_font_funcs_set_glyph_from_name_func (hb_font_funcs_t *ffuncs,
+					hb_font_get_glyph_from_name_func_t glyph_func,
+					void *user_data, hb_destroy_func_t destroy);
+
 
 /* func dispatch */
 
 hb_bool_t
 hb_font_get_glyph (hb_font_t *font,
 		   hb_codepoint_t unicode, hb_codepoint_t variation_selector,
 		   hb_codepoint_t *glyph);
 
@@ -271,16 +290,25 @@ hb_font_get_glyph_extents (hb_font_t *fo
 			   hb_codepoint_t glyph,
 			   hb_glyph_extents_t *extents);
 
 hb_bool_t
 hb_font_get_glyph_contour_point (hb_font_t *font,
 				 hb_codepoint_t glyph, unsigned int point_index,
 				 hb_position_t *x, hb_position_t *y);
 
+hb_bool_t
+hb_font_get_glyph_name (hb_font_t *font,
+			hb_codepoint_t glyph,
+			char *name, unsigned int size);
+hb_bool_t
+hb_font_get_glyph_from_name (hb_font_t *font,
+			     const char *name, int len, /* -1 means nul-terminated */
+			     hb_codepoint_t *glyph);
+
 
 /* high-level funcs, with fallback */
 
 void
 hb_font_get_glyph_advance_for_direction (hb_font_t *font,
 					 hb_codepoint_t glyph,
 					 hb_direction_t direction,
 					 hb_position_t *x, hb_position_t *y);
diff --git a/gfx/harfbuzz/src/hb-ft.cc b/gfx/harfbuzz/src/hb-ft.cc
--- a/gfx/harfbuzz/src/hb-ft.cc
+++ b/gfx/harfbuzz/src/hb-ft.cc
@@ -76,17 +76,17 @@ hb_ft_get_glyph (hb_font_t *font HB_UNUS
 
 {
   FT_Face ft_face = (FT_Face) font_data;
 
 #ifdef HAVE_FT_FACE_GETCHARVARIANTINDEX
   if (unlikely (variation_selector)) {
     *glyph = FT_Face_GetCharVariantIndex (ft_face, unicode, variation_selector);
     if (*glyph)
-      return TRUE;
+      return true;
   }
 #endif
 
   *glyph = FT_Get_Char_Index (ft_face, unicode);
   return *glyph != 0;
 }
 
 static hb_position_t
@@ -127,52 +127,53 @@ static hb_bool_t
 hb_ft_get_glyph_h_origin (hb_font_t *font HB_UNUSED,
 			  void *font_data HB_UNUSED,
 			  hb_codepoint_t glyph HB_UNUSED,
 			  hb_position_t *x HB_UNUSED,
 			  hb_position_t *y HB_UNUSED,
 			  void *user_data HB_UNUSED)
 {
   /* We always work in the horizontal coordinates. */
-  return TRUE;
+  return true;
 }
 
 static hb_bool_t
 hb_ft_get_glyph_v_origin (hb_font_t *font HB_UNUSED,
 			  void *font_data,
 			  hb_codepoint_t glyph,
 			  hb_position_t *x,
 			  hb_position_t *y,
 			  void *user_data HB_UNUSED)
 {
   FT_Face ft_face = (FT_Face) font_data;
   int load_flags = FT_LOAD_DEFAULT;
 
   if (unlikely (FT_Load_Glyph (ft_face, glyph, load_flags)))
-    return FALSE;
+    return false;
 
   /* Note: FreeType's vertical metrics grows downward while other FreeType coordinates
    * have a Y growing upward.  Hence the extra negation. */
   *x = ft_face->glyph->metrics.horiBearingX -   ft_face->glyph->metrics.vertBearingX;
   *y = ft_face->glyph->metrics.horiBearingY - (-ft_face->glyph->metrics.vertBearingY);
 
-  return TRUE;
+  return true;
 }
 
 static hb_position_t
-hb_ft_get_glyph_h_kerning (hb_font_t *font HB_UNUSED,
+hb_ft_get_glyph_h_kerning (hb_font_t *font,
 			   void *font_data,
 			   hb_codepoint_t left_glyph,
 			   hb_codepoint_t right_glyph,
 			   void *user_data HB_UNUSED)
 {
   FT_Face ft_face = (FT_Face) font_data;
   FT_Vector kerningv;
 
-  if (FT_Get_Kerning (ft_face, left_glyph, right_glyph, FT_KERNING_DEFAULT, &kerningv))
+  FT_Kerning_Mode mode = font->x_ppem ? FT_KERNING_DEFAULT : FT_KERNING_UNFITTED;
+  if (FT_Get_Kerning (ft_face, left_glyph, right_glyph, mode, &kerningv))
     return 0;
 
   return kerningv.x;
 }
 
 static hb_position_t
 hb_ft_get_glyph_v_kerning (hb_font_t *font HB_UNUSED,
 			   void *font_data HB_UNUSED,
@@ -190,74 +191,108 @@ hb_ft_get_glyph_extents (hb_font_t *font
 			 hb_codepoint_t glyph,
 			 hb_glyph_extents_t *extents,
 			 void *user_data HB_UNUSED)
 {
   FT_Face ft_face = (FT_Face) font_data;
   int load_flags = FT_LOAD_DEFAULT;
 
   if (unlikely (FT_Load_Glyph (ft_face, glyph, load_flags)))
-    return FALSE;
+    return false;
 
   extents->x_bearing = ft_face->glyph->metrics.horiBearingX;
   extents->y_bearing = ft_face->glyph->metrics.horiBearingY;
   extents->width = ft_face->glyph->metrics.width;
   extents->height = ft_face->glyph->metrics.height;
-  return TRUE;
+  return true;
 }
 
 static hb_bool_t
 hb_ft_get_glyph_contour_point (hb_font_t *font HB_UNUSED,
 			       void *font_data,
 			       hb_codepoint_t glyph,
 			       unsigned int point_index,
 			       hb_position_t *x,
 			       hb_position_t *y,
 			       void *user_data HB_UNUSED)
 {
   FT_Face ft_face = (FT_Face) font_data;
   int load_flags = FT_LOAD_DEFAULT;
 
   if (unlikely (FT_Load_Glyph (ft_face, glyph, load_flags)))
-      return FALSE;
+      return false;
 
   if (unlikely (ft_face->glyph->format != FT_GLYPH_FORMAT_OUTLINE))
-      return FALSE;
+      return false;
 
   if (unlikely (point_index >= (unsigned int) ft_face->glyph->outline.n_points))
-      return FALSE;
+      return false;
 
   *x = ft_face->glyph->outline.points[point_index].x;
   *y = ft_face->glyph->outline.points[point_index].y;
 
-  return TRUE;
+  return true;
 }
 
-static hb_font_funcs_t ft_ffuncs = {
-  HB_OBJECT_HEADER_STATIC,
+static hb_bool_t
+hb_ft_get_glyph_name (hb_font_t *font HB_UNUSED,
+		      void *font_data,
+		      hb_codepoint_t glyph,
+		      char *name, unsigned int size,
+		      void *user_data HB_UNUSED)
+{
+  FT_Face ft_face = (FT_Face) font_data;
 
-  TRUE, /* immutable */
+  hb_bool_t ret = !FT_Get_Glyph_Name (ft_face, glyph, name, size);
+  if (!ret)
+    snprintf (name, size, "gid%u", glyph);
 
-  {
-    hb_ft_get_glyph,
-    hb_ft_get_glyph_h_advance,
-    hb_ft_get_glyph_v_advance,
-    hb_ft_get_glyph_h_origin,
-    hb_ft_get_glyph_v_origin,
-    hb_ft_get_glyph_h_kerning,
-    hb_ft_get_glyph_v_kerning,
-    hb_ft_get_glyph_extents,
-    hb_ft_get_glyph_contour_point,
+  return ret;
+}
+
+static hb_bool_t
+hb_ft_get_glyph_from_name (hb_font_t *font HB_UNUSED,
+			   void *font_data,
+			   const char *name, int len, /* -1 means nul-terminated */
+			   hb_codepoint_t *glyph,
+			   void *user_data HB_UNUSED)
+{
+  FT_Face ft_face = (FT_Face) font_data;
+
+  if (len < 0)
+    *glyph = FT_Get_Name_Index (ft_face, (FT_String *) name);
+  else {
+    /* Make a nul-terminated version. */
+    char buf[128];
+    len = MIN (len, (int) sizeof (buf) - 1);
+    strncpy (buf, name, len);
+    buf[len] = '\0';
+    *glyph = FT_Get_Name_Index (ft_face, buf);
   }
-};
+
+  return *glyph != 0;
+}
+
 
 static hb_font_funcs_t *
 _hb_ft_get_font_funcs (void)
 {
-  return &ft_ffuncs;
+  static const hb_font_funcs_t ft_ffuncs = {
+    HB_OBJECT_HEADER_STATIC,
+
+    true, /* immutable */
+
+    {
+#define HB_FONT_FUNC_IMPLEMENT(name) hb_ft_get_##name,
+      HB_FONT_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_FONT_FUNC_IMPLEMENT
+    }
+  };
+
+  return const_cast<hb_font_funcs_t *> (&ft_ffuncs);
 }
 
 
 static hb_blob_t *
 reference_table  (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)
 {
   FT_Face ft_face = (FT_Face) user_data;
   FT_Byte *buffer;
@@ -359,36 +394,49 @@ hb_ft_font_create (FT_Face           ft_
   hb_font_set_ppem (font,
 		    ft_face->size->metrics.x_ppem,
 		    ft_face->size->metrics.y_ppem);
 
   return font;
 }
 
 
-
+/* Thread-safe, lock-free, FT_Library */
 
 static FT_Library ft_library;
-static hb_bool_t ft_library_initialized;
-static struct ft_library_destructor {
-  ~ft_library_destructor (void) {
-    if (ft_library)
-      FT_Done_FreeType (ft_library);
-  }
-} static_ft_library_destructor;
+
+static
+void free_ft_library (void)
+{
+  FT_Done_FreeType (ft_library);
+}
 
 static FT_Library
-_get_ft_library (void)
+get_ft_library (void)
 {
-  if (unlikely (!ft_library_initialized)) {
-    FT_Init_FreeType (&ft_library);
-    ft_library_initialized = TRUE;
+retry:
+  FT_Library library = (FT_Library) hb_atomic_ptr_get (&ft_library);
+
+  if (unlikely (!library))
+  {
+    /* Not found; allocate one. */
+    if (FT_Init_FreeType (&library))
+      return NULL;
+
+    if (!hb_atomic_ptr_cmpexch (&ft_library, NULL, library)) {
+      FT_Done_FreeType (library);
+      goto retry;
+    }
+
+#ifdef HAVE_ATEXIT
+    atexit (free_ft_library); /* First person registers atexit() callback. */
+#endif
   }
 
-  return ft_library;
+  return library;
 }
 
 static void
 _release_blob (FT_Face ft_face)
 {
   hb_blob_destroy ((hb_blob_t *) ft_face->generic.data);
 }
 
@@ -397,34 +445,37 @@ hb_ft_font_set_funcs (hb_font_t *font)
 {
   hb_blob_t *blob = hb_face_reference_blob (font->face);
   unsigned int blob_length;
   const char *blob_data = hb_blob_get_data (blob, &blob_length);
   if (unlikely (!blob_length))
     DEBUG_MSG (FT, font, "Font face has empty blob");
 
   FT_Face ft_face = NULL;
-  FT_Error err = FT_New_Memory_Face (_get_ft_library (),
+  FT_Error err = FT_New_Memory_Face (get_ft_library (),
 				     (const FT_Byte *) blob_data,
 				     blob_length,
 				     hb_face_get_index (font->face),
 				     &ft_face);
 
   if (unlikely (err)) {
     hb_blob_destroy (blob);
     DEBUG_MSG (FT, font, "Font face FT_New_Memory_Face() failed");
     return;
   }
 
   FT_Select_Charmap (ft_face, FT_ENCODING_UNICODE);
 
   FT_Set_Char_Size (ft_face,
 		    font->x_scale, font->y_scale,
+		    0, 0);
+#if 0
 		    font->x_ppem * 72 * 64 / font->x_scale,
 		    font->y_ppem * 72 * 64 / font->y_scale);
+#endif
 
   ft_face->generic.data = blob;
   ft_face->generic.finalizer = (FT_Generic_Finalizer) _release_blob;
 
   hb_font_set_funcs (font,
 		     _hb_ft_get_font_funcs (),
 		     ft_face,
 		     (hb_destroy_func_t) FT_Done_Face);
diff --git a/gfx/harfbuzz/src/hb-glib.cc b/gfx/harfbuzz/src/hb-glib.cc
--- a/gfx/harfbuzz/src/hb-glib.cc
+++ b/gfx/harfbuzz/src/hb-glib.cc
@@ -187,23 +187,23 @@ hb_glib_script_from_script (hb_script_t 
   if (unlikely (script == HB_SCRIPT_INVALID))
     return G_UNICODE_SCRIPT_INVALID_CODE;
 
   return G_UNICODE_SCRIPT_UNKNOWN;
 #endif
 }
 
 
-static unsigned int
+static hb_unicode_combining_class_t
 hb_glib_unicode_combining_class (hb_unicode_funcs_t *ufuncs HB_UNUSED,
 				 hb_codepoint_t      unicode,
 				 void               *user_data HB_UNUSED)
 
 {
-  return g_unichar_combining_class (unicode);
+  return (hb_unicode_combining_class_t) g_unichar_combining_class (unicode);
 }
 
 static unsigned int
 hb_glib_unicode_eastasian_width (hb_unicode_funcs_t *ufuncs HB_UNUSED,
 				 hb_codepoint_t      unicode,
 				 void               *user_data HB_UNUSED)
 {
   return g_unichar_iswide (unicode) ? 2 : 1;
@@ -246,35 +246,35 @@ hb_glib_unicode_compose (hb_unicode_func
 #if GLIB_CHECK_VERSION(2,29,12)
   return g_unichar_compose (a, b, ab);
 #endif
 
   /* We don't ifdef-out the fallback code such that compiler always
    * sees it and makes sure it's compilable. */
 
   if (!a || !b)
-    return FALSE;
+    return false;
 
   gchar utf8[12];
   gchar *normalized;
-  gint len;
+  int len;
   hb_bool_t ret;
 
   len = g_unichar_to_utf8 (a, utf8);
   len += g_unichar_to_utf8 (b, utf8 + len);
   normalized = g_utf8_normalize (utf8, len, G_NORMALIZE_NFC);
   len = g_utf8_strlen (normalized, -1);
   if (unlikely (!len))
-    return FALSE;
+    return false;
 
   if (len == 1) {
     *ab = g_utf8_get_char (normalized);
-    ret = TRUE;
+    ret = true;
   } else {
-    ret = FALSE;
+    ret = false;
   }
 
   g_free (normalized);
   return ret;
 }
 
 static hb_bool_t
 hb_glib_unicode_decompose (hb_unicode_funcs_t *ufuncs HB_UNUSED,
@@ -287,24 +287,24 @@ hb_glib_unicode_decompose (hb_unicode_fu
   return g_unichar_decompose (ab, a, b);
 #endif
 
   /* We don't ifdef-out the fallback code such that compiler always
    * sees it and makes sure it's compilable. */
 
   gchar utf8[6];
   gchar *normalized;
-  gint len;
+  int len;
   hb_bool_t ret;
 
   len = g_unichar_to_utf8 (ab, utf8);
   normalized = g_utf8_normalize (utf8, len, G_NORMALIZE_NFD);
   len = g_utf8_strlen (normalized, -1);
   if (unlikely (!len))
-    return FALSE;
+    return false;
 
   if (len == 1) {
     *a = g_utf8_get_char (normalized);
     *b = 0;
     ret = *a != ab;
   } else if (len == 2) {
     *a = g_utf8_get_char (normalized);
     *b = g_utf8_get_char (g_utf8_next_char (normalized));
@@ -313,46 +313,76 @@ hb_glib_unicode_decompose (hb_unicode_fu
      * the second part :-(. */
     gchar *recomposed = g_utf8_normalize (normalized, -1, G_NORMALIZE_NFC);
     hb_codepoint_t c = g_utf8_get_char (recomposed);
     if (c != ab && c != *a) {
       *a = c;
       *b = 0;
     }
     g_free (recomposed);
-    ret = TRUE;
+    ret = true;
   } else {
     /* If decomposed to more than two characters, take the last one,
      * and recompose the rest to get the first component. */
     gchar *end = g_utf8_offset_to_pointer (normalized, len - 1);
     gchar *recomposed;
     *b = g_utf8_get_char (end);
     recomposed = g_utf8_normalize (normalized, end - normalized, G_NORMALIZE_NFC);
     /* We expect that recomposed has exactly one character now. */
     *a = g_utf8_get_char (recomposed);
     g_free (recomposed);
-    ret = TRUE;
+    ret = true;
   }
 
   g_free (normalized);
   return ret;
 }
 
+static unsigned int
+hb_glib_unicode_decompose_compatibility (hb_unicode_funcs_t *ufuncs,
+					 hb_codepoint_t      u,
+					 hb_codepoint_t     *decomposed,
+					 void               *user_data HB_UNUSED)
+{
+#if GLIB_CHECK_VERSION(2,29,12)
+  return g_unichar_fully_decompose (u, TRUE, decomposed, HB_UNICODE_MAX_DECOMPOSITION_LEN);
+#endif
 
-extern HB_INTERNAL hb_unicode_funcs_t _hb_unicode_funcs_glib;
-hb_unicode_funcs_t _hb_glib_unicode_funcs = {
+  /* If the user doesn't have GLib >= 2.29.12 we have to perform
+   * a round trip to UTF-8 and the associated memory management dance. */
+  gchar utf8[6];
+  gchar *utf8_decomposed, *c;
+  gsize utf8_len, utf8_decomposed_len, i;
+
+  /* Convert @u to UTF-8 and normalise it in NFKD mode. This performs the compatibility decomposition. */
+  utf8_len = g_unichar_to_utf8 (u, utf8);
+  utf8_decomposed = g_utf8_normalize (utf8, utf8_len, G_NORMALIZE_NFKD);
+  utf8_decomposed_len = g_utf8_strlen (utf8_decomposed, -1);
+
+  assert (utf8_decomposed_len <= HB_UNICODE_MAX_DECOMPOSITION_LEN);
+
+  for (i = 0, c = utf8_decomposed; i < utf8_decomposed_len; i++, c = g_utf8_next_char (c))
+    *decomposed++ = g_utf8_get_char (c);
+
+  g_free (utf8_decomposed);
+
+  return utf8_decomposed_len;
+}
+
+extern HB_INTERNAL const hb_unicode_funcs_t _hb_glib_unicode_funcs;
+const hb_unicode_funcs_t _hb_glib_unicode_funcs = {
   HB_OBJECT_HEADER_STATIC,
 
   NULL, /* parent */
-  TRUE, /* immutable */
+  true, /* immutable */
   {
 #define HB_UNICODE_FUNC_IMPLEMENT(name) hb_glib_unicode_##name,
     HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
 #undef HB_UNICODE_FUNC_IMPLEMENT
   }
 };
 
 hb_unicode_funcs_t *
 hb_glib_get_unicode_funcs (void)
 {
-  return &_hb_glib_unicode_funcs;
+  return const_cast<hb_unicode_funcs_t *> (&_hb_glib_unicode_funcs);
 }
 
diff --git a/gfx/harfbuzz/src/hb-graphite2.cc b/gfx/harfbuzz/src/hb-graphite2.cc
--- a/gfx/harfbuzz/src/hb-graphite2.cc
+++ b/gfx/harfbuzz/src/hb-graphite2.cc
@@ -103,17 +103,17 @@ static const void *hb_gr_get_table (cons
   unsigned int tlen;
   const char *d = hb_blob_get_data (blob, &tlen);
   *len = tlen;
   return d;
 }
 
 static float hb_gr_get_advance (const void *hb_font, unsigned short gid)
 {
-  return hb_font_get_glyph_h_advance ((hb_font_t *) hb_font, gid);
+  return ((hb_font_t *) font)->get_glyph_h_advance (gid);
 }
 
 static void _hb_gr_face_data_destroy (void *data)
 {
   hb_gr_face_data_t *f = (hb_gr_face_data_t *) data;
   hb_gr_tablelist_t *tlist = f->tlist;
   while (tlist)
   {
@@ -154,17 +154,17 @@ static hb_gr_face_data_t *
   }
 
   data->face = face;
   data->grface = gr_make_face (data, &hb_gr_get_table, gr_face_default);
 
 
   if (unlikely (!hb_face_set_user_data (face, &hb_gr_data_key, data,
 					(hb_destroy_func_t) _hb_gr_face_data_destroy,
-					FALSE)))
+					false)))
   {
     _hb_gr_face_data_destroy (data);
     data = (hb_gr_face_data_t *) hb_face_get_user_data (face, &hb_gr_data_key);
     if (data)
       return data;
     else
       return &_hb_gr_face_data_nil;
   }
@@ -186,24 +186,22 @@ static hb_gr_font_data_t *
   hb_blob_t *silf_blob = hb_face_reference_table (font->face, HB_GRAPHITE_TAG_Silf);
   if (!hb_blob_get_length (silf_blob))
   {
     hb_blob_destroy (silf_blob);
     return &_hb_gr_font_data_nil;
   }
 
   data->grface = _hb_gr_face_get_data (font->face)->grface;
-  int scale;
-  hb_font_get_scale (font, &scale, NULL);
-  data->grfont = gr_make_font_with_advance_fn (scale, font, &hb_gr_get_advance, data->grface);
+  data->grfont = gr_make_font_with_advance_fn (font->x_scale, font, &hb_gr_get_advance, data->grface);
 
 
   if (unlikely (!hb_font_set_user_data (font, &hb_gr_data_key, data,
 					(hb_destroy_func_t) _hb_gr_font_data_destroy,
-					FALSE)))
+					false)))
   {
     _hb_gr_font_data_destroy (data);
     data = (hb_gr_font_data_t *) hb_font_get_user_data (font, &hb_gr_data_key);
     if (data)
       return data;
     else
       return &_hb_gr_font_data_nil;
   }
@@ -220,24 +218,24 @@ hb_bool_t
 {
 
   buffer->guess_properties ();
 
   /* XXX We do a hell of a lot of stuff just to figure out this font
    * is not graphite!  Shouldn't do. */
 
   hb_gr_font_data_t *data = _hb_gr_font_get_data (font);
-  if (!data->grface) return FALSE;
+  if (!data->grface) return false;
 
   unsigned int charlen;
   hb_glyph_info_t *bufferi = hb_buffer_get_glyph_infos (buffer, &charlen);
 
   int success = 0;
 
-  if (!charlen) return TRUE;
+  if (!charlen) return true;
 
   const char *lang = hb_language_to_string (hb_buffer_get_language (buffer));
   const char *lang_end = strchr (lang, '-');
   int lang_len = lang_end ? lang_end - lang : -1;
   gr_feature_val *feats = gr_face_featureval_for_lang (data->grface, lang ? hb_tag_from_string (lang, lang_len) : 0);
 
   while (num_features--)
   {
diff --git a/gfx/harfbuzz/src/hb-icu.cc b/gfx/harfbuzz/src/hb-icu.cc
--- a/gfx/harfbuzz/src/hb-icu.cc
+++ b/gfx/harfbuzz/src/hb-icu.cc
@@ -58,23 +58,23 @@ hb_icu_script_from_script (hb_script_t s
   for (unsigned int i = 0; i < USCRIPT_CODE_LIMIT; i++)
     if (unlikely (hb_icu_script_to_script ((UScriptCode) i) == script))
       return (UScriptCode) i;
 
   return USCRIPT_UNKNOWN;
 }
 
 
-static unsigned int
+static hb_unicode_combining_class_t
 hb_icu_unicode_combining_class (hb_unicode_funcs_t *ufuncs HB_UNUSED,
 				hb_codepoint_t      unicode,
 				void               *user_data HB_UNUSED)
 
 {
-  return u_getCombiningClass (unicode);
+  return (hb_unicode_combining_class_t) u_getCombiningClass (unicode);
 }
 
 static unsigned int
 hb_icu_unicode_eastasian_width (hb_unicode_funcs_t *ufuncs HB_UNUSED,
 				hb_codepoint_t      unicode,
 				void               *user_data HB_UNUSED)
 {
   switch (u_getIntPropertyValue(unicode, UCHAR_EAST_ASIAN_WIDTH))
@@ -167,69 +167,69 @@ hb_icu_unicode_script (hb_unicode_funcs_
 static hb_bool_t
 hb_icu_unicode_compose (hb_unicode_funcs_t *ufuncs HB_UNUSED,
 			hb_codepoint_t      a,
 			hb_codepoint_t      b,
 			hb_codepoint_t     *ab,
 			void               *user_data HB_UNUSED)
 {
   if (!a || !b)
-    return FALSE;
+    return false;
 
   UChar utf16[4], normalized[5];
   int len;
   hb_bool_t ret, err;
   UErrorCode icu_err;
 
   len = 0;
-  err = FALSE;
+  err = false;
   U16_APPEND (utf16, len, ARRAY_LENGTH (utf16), a, err);
-  if (err) return FALSE;
+  if (err) return false;
   U16_APPEND (utf16, len, ARRAY_LENGTH (utf16), b, err);
-  if (err) return FALSE;
+  if (err) return false;
 
   icu_err = U_ZERO_ERROR;
   len = unorm_normalize (utf16, len, UNORM_NFC, 0, normalized, ARRAY_LENGTH (normalized), &icu_err);
   if (U_FAILURE (icu_err))
-    return FALSE;
+    return false;
   if (u_countChar32 (normalized, len) == 1) {
     U16_GET_UNSAFE (normalized, 0, *ab);
-    ret = TRUE;
+    ret = true;
   } else {
-    ret = FALSE;
+    ret = false;
   }
 
   return ret;
 }
 
 static hb_bool_t
 hb_icu_unicode_decompose (hb_unicode_funcs_t *ufuncs HB_UNUSED,
 			  hb_codepoint_t      ab,
 			  hb_codepoint_t     *a,
 			  hb_codepoint_t     *b,
 			  void               *user_data HB_UNUSED)
 {
-  UChar utf16[2], normalized[20];
+  UChar utf16[2], normalized[2 * HB_UNICODE_MAX_DECOMPOSITION_LEN + 1];
   int len;
   hb_bool_t ret, err;
   UErrorCode icu_err;
 
   /* This function is a monster! Maybe it wasn't a good idea adding a
    * pairwise decompose API... */
   /* Watchout for the dragons.  Err, watchout for macros changing len. */
 
   len = 0;
-  err = FALSE;
+  err = false;
   U16_APPEND (utf16, len, ARRAY_LENGTH (utf16), ab, err);
-  if (err) return FALSE;
+  if (err) return false;
 
   icu_err = U_ZERO_ERROR;
   len = unorm_normalize (utf16, len, UNORM_NFD, 0, normalized, ARRAY_LENGTH (normalized), &icu_err);
   if (U_FAILURE (icu_err))
-    return FALSE;
+    return false;
 
   len = u_countChar32 (normalized, len);
 
   if (len == 1) {
     U16_GET_UNSAFE (normalized, 0, *a);
     *b = 0;
     ret = *a != ab;
   } else if (len == 2) {
@@ -239,53 +239,90 @@ hb_icu_unicode_decompose (hb_unicode_fun
 
     /* Here's the ugly part: if ab decomposes to a single character and
      * that character decomposes again, we have to detect that and undo
      * the second part :-(. */
     UChar recomposed[20];
     icu_err = U_ZERO_ERROR;
     unorm_normalize (normalized, len, UNORM_NFC, 0, recomposed, ARRAY_LENGTH (recomposed), &icu_err);
     if (U_FAILURE (icu_err))
-      return FALSE;
+      return false;
     hb_codepoint_t c;
     U16_GET_UNSAFE (recomposed, 0, c);
     if (c != *a && c != ab) {
       *a = c;
       *b = 0;
     }
-    ret = TRUE;
+    ret = true;
   } else {
     /* If decomposed to more than two characters, take the last one,
      * and recompose the rest to get the first component. */
-    U16_PREV_UNSAFE (normalized, len, *b);
-    UChar recomposed[20];
+    U16_PREV_UNSAFE (normalized, len, *b); /* Changes len in-place. */
+    UChar recomposed[18 * 2];
     icu_err = U_ZERO_ERROR;
     len = unorm_normalize (normalized, len, UNORM_NFC, 0, recomposed, ARRAY_LENGTH (recomposed), &icu_err);
     if (U_FAILURE (icu_err))
-      return FALSE;
+      return false;
     /* We expect that recomposed has exactly one character now. */
+    if (unlikely (u_countChar32 (recomposed, len) != 1))
+      return false;
     U16_GET_UNSAFE (recomposed, 0, *a);
-    ret = TRUE;
+    ret = true;
   }
 
   return ret;
 }
 
-extern HB_INTERNAL hb_unicode_funcs_t _hb_unicode_funcs_icu;
-hb_unicode_funcs_t _hb_icu_unicode_funcs = {
+static unsigned int
+hb_icu_unicode_decompose_compatibility (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+					hb_codepoint_t      u,
+					hb_codepoint_t     *decomposed,
+					void               *user_data HB_UNUSED)
+{
+  UChar utf16[2], normalized[2 * HB_UNICODE_MAX_DECOMPOSITION_LEN + 1];
+  int len;
+  int32_t utf32_len;
+  hb_bool_t err;
+  UErrorCode icu_err;
+
+  /* Copy @u into a UTF-16 array to be passed to ICU. */
+  len = 0;
+  err = FALSE;
+  U16_APPEND (utf16, len, ARRAY_LENGTH (utf16), u, err);
+  if (err)
+    return 0;
+
+  /* Normalise the codepoint using NFKD mode. */
+  icu_err = U_ZERO_ERROR;
+  len = unorm_normalize (utf16, len, UNORM_NFKD, 0, normalized, ARRAY_LENGTH (normalized), &icu_err);
+  if (icu_err)
+    return 0;
+
+  /* Convert the decomposed form from UTF-16 to UTF-32. */
+  icu_err = U_ZERO_ERROR;
+  u_strToUTF32 ((UChar32*) decomposed, HB_UNICODE_MAX_DECOMPOSITION_LEN, &utf32_len, normalized, len, &icu_err);
+  if (icu_err)
+    return 0;
+
+  return utf32_len;
+}
+
+
+extern HB_INTERNAL const hb_unicode_funcs_t _hb_icu_unicode_funcs;
+const hb_unicode_funcs_t _hb_icu_unicode_funcs = {
   HB_OBJECT_HEADER_STATIC,
 
   NULL, /* parent */
-  TRUE, /* immutable */
+  true, /* immutable */
   {
 #define HB_UNICODE_FUNC_IMPLEMENT(name) hb_icu_unicode_##name,
     HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
 #undef HB_UNICODE_FUNC_IMPLEMENT
   }
 };
 
 hb_unicode_funcs_t *
 hb_icu_get_unicode_funcs (void)
 {
-  return &_hb_icu_unicode_funcs;
+  return const_cast<hb_unicode_funcs_t *> (&_hb_icu_unicode_funcs);
 }
 
 
diff --git a/gfx/harfbuzz/src/hb-mutex-private.hh b/gfx/harfbuzz/src/hb-mutex-private.hh
--- a/gfx/harfbuzz/src/hb-mutex-private.hh
+++ b/gfx/harfbuzz/src/hb-mutex-private.hh
@@ -1,12 +1,12 @@
 /*
  * Copyright © 2007  Chris Wilson
  * Copyright © 2009,2010  Red Hat, Inc.
- * Copyright © 2011  Google, Inc.
+ * Copyright © 2011,2012  Google, Inc.
  *
  *  This is part of HarfBuzz, a text shaping library.
  *
  * Permission is hereby granted, without written agreement and without
  * license or royalty fees, to use, copy, modify, and distribute this
  * software and its documentation for any purpose, provided that the
  * above copyright notice and the following two paragraphs appear in
  * all copies of this software.
@@ -45,75 +45,105 @@
 #elif !defined(HB_NO_MT) && defined(_MSC_VER) || defined(__MINGW32__)
 
 #include <windows.h>
 typedef CRITICAL_SECTION hb_mutex_impl_t;
 #define HB_MUTEX_IMPL_INIT	{ NULL, 0, 0, NULL, NULL, 0 }
 #define hb_mutex_impl_init(M)	InitializeCriticalSection (M)
 #define hb_mutex_impl_lock(M)	EnterCriticalSection (M)
 #define hb_mutex_impl_unlock(M)	LeaveCriticalSection (M)
-#define hb_mutex_impl_free(M)	DeleteCriticalSection (M)
+#define hb_mutex_impl_finish(M)	DeleteCriticalSection (M)
 
 
-#elif !defined(HB_NO_MT) && defined(__APPLE__)
+#elif !defined(HB_NO_MT) && (defined(HAVE_PTHREAD) || defined(__APPLE__))
 
 #include <pthread.h>
 typedef pthread_mutex_t hb_mutex_impl_t;
 #define HB_MUTEX_IMPL_INIT	PTHREAD_MUTEX_INITIALIZER
 #define hb_mutex_impl_init(M)	pthread_mutex_init (M, NULL)
 #define hb_mutex_impl_lock(M)	pthread_mutex_lock (M)
 #define hb_mutex_impl_unlock(M)	pthread_mutex_unlock (M)
-#define hb_mutex_impl_free(M)	pthread_mutex_destroy (M)
+#define hb_mutex_impl_finish(M)	pthread_mutex_destroy (M)
 
 
 #elif !defined(HB_NO_MT) && defined(HAVE_GLIB)
 
 #include <glib.h>
+#if !GLIB_CHECK_VERSION(2,32,0)
 typedef GStaticMutex hb_mutex_impl_t;
 #define HB_MUTEX_IMPL_INIT	G_STATIC_MUTEX_INIT
 #define hb_mutex_impl_init(M)	g_static_mutex_init (M)
 #define hb_mutex_impl_lock(M)	g_static_mutex_lock (M)
 #define hb_mutex_impl_unlock(M)	g_static_mutex_unlock (M)
-#define hb_mutex_impl_free(M)	g_static_mutex_free (M)
+#define hb_mutex_impl_finish(M)	g_static_mutex_free (M)
+#else
+typedef GMutex hb_mutex_impl_t;
+#define HB_MUTEX_IMPL_INIT	{0}
+#define hb_mutex_impl_init(M)	g_mutex_init (M)
+#define hb_mutex_impl_lock(M)	g_mutex_lock (M)
+#define hb_mutex_impl_unlock(M)	g_mutex_unlock (M)
+#define hb_mutex_impl_finish(M)	g_mutex_clear (M)
+#endif
 
 
+#elif !defined(HB_NO_MT) && defined(HAVE_INTEL_ATOMIC_PRIMITIVES)
+
+#if defined(HAVE_SCHED_H) && defined(HAVE_SCHED_YIELD)
+# include <sched.h>
+# define HB_SCHED_YIELD() sched_yield ()
 #else
+# define HB_SCHED_YIELD() HB_STMT_START {} HB_STMT_END
+#endif
 
-#define HB_MUTEX_IMPL_NIL 1
+/* This actually is not a totally awful implementation. */
 typedef volatile int hb_mutex_impl_t;
 #define HB_MUTEX_IMPL_INIT	0
-#define hb_mutex_impl_init(M)	((void) (*(M) = 0))
-#define hb_mutex_impl_lock(M)	((void) (*(M) = 1))
-#define hb_mutex_impl_unlock(M)	((void) (*(M) = 0))
-#define hb_mutex_impl_free(M)	((void) (*(M) = 2))
+#define hb_mutex_impl_init(M)	*(M) = 0
+#define hb_mutex_impl_lock(M)	HB_STMT_START { while (__sync_lock_test_and_set((M), 1)) HB_SCHED_YIELD (); } HB_STMT_END
+#define hb_mutex_impl_unlock(M)	__sync_lock_release (M)
+#define hb_mutex_impl_finish(M)	HB_STMT_START {} HB_STMT_END
+
+
+#elif !defined(HB_NO_MT)
+
+#if defined(HAVE_SCHED_H) && defined(HAVE_SCHED_YIELD)
+# include <sched.h>
+# define HB_SCHED_YIELD() sched_yield ()
+#else
+# define HB_SCHED_YIELD() HB_STMT_START {} HB_STMT_END
+#endif
+
+#define HB_MUTEX_INT_NIL 1 /* Warn that fallback implementation is in use. */
+typedef volatile int hb_mutex_impl_t;
+#define HB_MUTEX_IMPL_INIT	0
+#define hb_mutex_impl_init(M)	*(M) = 0
+#define hb_mutex_impl_lock(M)	HB_STMT_START { while (*(M)) HB_SCHED_YIELD (); (*(M))++; } HB_STMT_END
+#define hb_mutex_impl_unlock(M)	(*(M))--;
+#define hb_mutex_impl_finish(M)	HB_STMT_START {} HB_STMT_END
+
+
+#else /* HB_NO_MT */
+
+typedef int hb_mutex_impl_t;
+#define HB_MUTEX_IMPL_INIT	0
+#define hb_mutex_impl_init(M)	HB_STMT_START {} HB_STMT_END
+#define hb_mutex_impl_lock(M)	HB_STMT_START {} HB_STMT_END
+#define hb_mutex_impl_unlock(M)	HB_STMT_START {} HB_STMT_END
+#define hb_mutex_impl_finish(M)	HB_STMT_START {} HB_STMT_END
 
 #endif
 
 
+#define HB_MUTEX_INIT		{HB_MUTEX_IMPL_INIT}
 struct hb_mutex_t
 {
+  /* TODO Add tracing. */
+
   hb_mutex_impl_t m;
 
   inline void init   (void) { hb_mutex_impl_init   (&m); }
   inline void lock   (void) { hb_mutex_impl_lock   (&m); }
   inline void unlock (void) { hb_mutex_impl_unlock (&m); }
-  inline void free   (void) { hb_mutex_impl_free   (&m); }
+  inline void finish (void) { hb_mutex_impl_finish (&m); }
 };
 
-#define HB_MUTEX_INIT		{HB_MUTEX_IMPL_INIT}
-#define hb_mutex_init(M)	(M)->init ()
-#define hb_mutex_lock(M)	(M)->lock ()
-#define hb_mutex_unlock(M)	(M)->unlock ()
-#define hb_mutex_free(M)	(M)->free ()
-
-
-struct hb_static_mutex_t : hb_mutex_t
-{
-  hb_static_mutex_t (void)  { this->init (); }
-  ~hb_static_mutex_t (void) { this->free (); }
-
-  private:
-  NO_COPY (hb_static_mutex_t);
-};
-
-
 
 #endif /* HB_MUTEX_PRIVATE_HH */
diff --git a/gfx/harfbuzz/src/hb-object-private.hh b/gfx/harfbuzz/src/hb-object-private.hh
--- a/gfx/harfbuzz/src/hb-object-private.hh
+++ b/gfx/harfbuzz/src/hb-object-private.hh
@@ -1,12 +1,12 @@
 /*
  * Copyright © 2007  Chris Wilson
  * Copyright © 2009,2010  Red Hat, Inc.
- * Copyright © 2011  Google, Inc.
+ * Copyright © 2011,2012  Google, Inc.
  *
  *  This is part of HarfBuzz, a text shaping library.
  *
  * Permission is hereby granted, without written agreement and without
  * license or royalty fees, to use, copy, modify, and distribute this
  * software and its documentation for any purpose, provided that the
  * above copyright notice and the following two paragraphs appear in
  * all copies of this software.
@@ -42,82 +42,90 @@
 
 #ifndef HB_DEBUG_OBJECT
 #define HB_DEBUG_OBJECT (HB_DEBUG+0)
 #endif
 
 
 /* reference_count */
 
-typedef struct {
+#define HB_REFERENCE_COUNT_INVALID_VALUE ((hb_atomic_int_t) -1)
+#define HB_REFERENCE_COUNT_INVALID {HB_REFERENCE_COUNT_INVALID_VALUE}
+struct hb_reference_count_t
+{
   hb_atomic_int_t ref_count;
 
-#define HB_REFERENCE_COUNT_INVALID_VALUE ((hb_atomic_int_t) -1)
-#define HB_REFERENCE_COUNT_INVALID {HB_REFERENCE_COUNT_INVALID_VALUE}
+  inline void init (int v) { ref_count = v; }
+  inline int inc (void) { return hb_atomic_int_add (const_cast<hb_atomic_int_t &> (ref_count),  1); }
+  inline int dec (void) { return hb_atomic_int_add (const_cast<hb_atomic_int_t &> (ref_count), -1); }
+  inline void finish (void) { ref_count = HB_REFERENCE_COUNT_INVALID_VALUE; }
 
-  inline void init (int v) { ref_count = v; /* non-atomic is fine */ }
-  inline int inc (void) { return hb_atomic_int_add (ref_count,  1); }
-  inline int dec (void) { return hb_atomic_int_add (ref_count, -1); }
-
-  inline int get (void) { return hb_atomic_int_get (ref_count); }
-  inline int get_unsafe (void) const { return ref_count; }
   inline bool is_invalid (void) const { return ref_count == HB_REFERENCE_COUNT_INVALID_VALUE; }
 
-} hb_reference_count_t;
+};
 
 
 /* user_data */
 
-struct hb_user_data_array_t {
+#define HB_USER_DATA_ARRAY_INIT {HB_LOCKABLE_SET_INIT}
+struct hb_user_data_array_t
+{
+  /* TODO Add tracing. */
 
   struct hb_user_data_item_t {
     hb_user_data_key_t *key;
     void *data;
     hb_destroy_func_t destroy;
 
     inline bool operator == (hb_user_data_key_t *other_key) const { return key == other_key; }
     inline bool operator == (hb_user_data_item_t &other) const { return key == other.key; }
 
     void finish (void) { if (destroy) destroy (data); }
   };
 
-  hb_lockable_set_t<hb_user_data_item_t, hb_static_mutex_t> items;
+  hb_lockable_set_t<hb_user_data_item_t, hb_mutex_t> items;
+
+  inline void init (void) { items.init (); }
 
   HB_INTERNAL bool set (hb_user_data_key_t *key,
 			void *              data,
 			hb_destroy_func_t   destroy,
-			hb_bool_t           replace);
+			hb_bool_t           replace,
+			hb_mutex_t         &lock);
 
-  HB_INTERNAL void *get (hb_user_data_key_t *key);
+  HB_INTERNAL void *get (hb_user_data_key_t *key,
+			hb_mutex_t          &lock);
 
-  HB_INTERNAL void finish (void);
+  HB_INTERNAL void finish (hb_mutex_t &lock);
 };
 
 
 /* object_header */
 
-typedef struct _hb_object_header_t hb_object_header_t;
-
-struct _hb_object_header_t {
+struct hb_object_header_t
+{
   hb_reference_count_t ref_count;
+  hb_mutex_t mutex;
   hb_user_data_array_t user_data;
 
-#define HB_OBJECT_HEADER_STATIC {HB_REFERENCE_COUNT_INVALID}
+#define HB_OBJECT_HEADER_STATIC {HB_REFERENCE_COUNT_INVALID, HB_MUTEX_INIT, HB_USER_DATA_ARRAY_INIT}
 
   static inline void *create (unsigned int size) {
     hb_object_header_t *obj = (hb_object_header_t *) calloc (1, size);
 
     if (likely (obj))
       obj->init ();
 
     return obj;
   }
 
   inline void init (void) {
     ref_count.init (1);
+    mutex.init ();
+    user_data.init ();
   }
 
   inline bool is_inert (void) const {
     return unlikely (ref_count.is_invalid ());
   }
 
   inline void reference (void) {
     if (unlikely (!this || this->is_inert ()))
@@ -126,47 +134,60 @@ struct _hb_object_header_t {
   }
 
   inline bool destroy (void) {
     if (unlikely (!this || this->is_inert ()))
       return false;
     if (ref_count.dec () != 1)
       return false;
 
-    ref_count.init (HB_REFERENCE_COUNT_INVALID_VALUE);
-
-    user_data.finish ();
+    ref_count.finish (); /* Do this before user_data */
+    user_data.finish (mutex);
+    mutex.finish ();
 
     return true;
   }
 
+  inline void lock (void) {
+    mutex.lock ();
+  }
+
+  inline void unlock (void) {
+    mutex.unlock ();
+  }
+
   inline bool set_user_data (hb_user_data_key_t *key,
 			     void *              data,
 			     hb_destroy_func_t   destroy_func,
 			     hb_bool_t           replace) {
     if (unlikely (!this || this->is_inert ()))
       return false;
 
-    return user_data.set (key, data, destroy_func, replace);
+    return user_data.set (key, data, destroy_func, replace, mutex);
   }
 
   inline void *get_user_data (hb_user_data_key_t *key) {
-    return user_data.get (key);
+    if (unlikely (!this || this->is_inert ()))
+      return NULL;
+
+    return user_data.get (key, mutex);
   }
 
   inline void trace (const char *function) const {
     if (unlikely (!this)) return;
-    /* XXX We cannot use DEBUG_MSG_FUNC here since that one currecntly only
+    /* TODO We cannot use DEBUG_MSG_FUNC here since that one currently only
      * prints the class name and throws away the template info. */
     DEBUG_MSG (OBJECT, (void *) this,
 	       "%s refcount=%d",
 	       function,
-	       this ? ref_count.get_unsafe () : 0);
+	       this ? ref_count.ref_count : 0);
   }
 
+  private:
+  ASSERT_POD ();
 };
 
 
 /* object */
 
 template <typename Type>
 static inline void hb_object_trace (const Type *obj, const char *function)
 {
@@ -193,16 +214,28 @@ static inline Type *hb_object_reference 
 }
 template <typename Type>
 static inline bool hb_object_destroy (Type *obj)
 {
   hb_object_trace (obj, HB_FUNC);
   return obj->header.destroy ();
 }
 template <typename Type>
+static inline void hb_object_lock (Type *obj)
+{
+  hb_object_trace (obj, HB_FUNC);
+  return obj->header.lock ();
+}
+template <typename Type>
+static inline void hb_object_unlock (Type *obj)
+{
+  hb_object_trace (obj, HB_FUNC);
+  return obj->header.unlock ();
+}
+template <typename Type>
 static inline bool hb_object_set_user_data (Type               *obj,
 					    hb_user_data_key_t *key,
 					    void *              data,
 					    hb_destroy_func_t   destroy,
 					    hb_bool_t           replace)
 {
   return obj->header.set_user_data (key, data, destroy, replace);
 }
diff --git a/gfx/harfbuzz/src/hb-old.cc b/gfx/harfbuzz/src/hb-old.cc
new file mode 100644
--- /dev/null
+++ b/gfx/harfbuzz/src/hb-old.cc
@@ -0,0 +1,407 @@
+/*
+ * Copyright © 2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#define HB_SHAPER old
+#define hb_old_shaper_face_data_t HB_FaceRec_
+#define hb_old_shaper_font_data_t HB_Font_
+#include "hb-shaper-impl-private.hh"
+
+#include <harfbuzz.h>
+
+
+#ifndef HB_DEBUG_OLD
+#define HB_DEBUG_OLD (HB_DEBUG+0)
+#endif
+
+
+static HB_Script
+hb_old_script_from_script (hb_script_t script)
+{
+  switch ((hb_tag_t) script)
+  {
+    default:
+    case HB_SCRIPT_COMMON:		return HB_Script_Common;
+    case HB_SCRIPT_GREEK:		return HB_Script_Greek;
+    case HB_SCRIPT_CYRILLIC:		return HB_Script_Cyrillic;
+    case HB_SCRIPT_ARMENIAN:		return HB_Script_Armenian;
+    case HB_SCRIPT_HEBREW:		return HB_Script_Hebrew;
+    case HB_SCRIPT_ARABIC:		return HB_Script_Arabic;
+    case HB_SCRIPT_SYRIAC:		return HB_Script_Syriac;
+    case HB_SCRIPT_THAANA:		return HB_Script_Thaana;
+    case HB_SCRIPT_DEVANAGARI:		return HB_Script_Devanagari;
+    case HB_SCRIPT_BENGALI:		return HB_Script_Bengali;
+    case HB_SCRIPT_GURMUKHI:		return HB_Script_Gurmukhi;
+    case HB_SCRIPT_GUJARATI:		return HB_Script_Gujarati;
+    case HB_SCRIPT_ORIYA:		return HB_Script_Oriya;
+    case HB_SCRIPT_TAMIL:		return HB_Script_Tamil;
+    case HB_SCRIPT_TELUGU:		return HB_Script_Telugu;
+    case HB_SCRIPT_KANNADA:		return HB_Script_Kannada;
+    case HB_SCRIPT_MALAYALAM:		return HB_Script_Malayalam;
+    case HB_SCRIPT_SINHALA:		return HB_Script_Sinhala;
+    case HB_SCRIPT_THAI:		return HB_Script_Thai;
+    case HB_SCRIPT_LAO:			return HB_Script_Lao;
+    case HB_SCRIPT_TIBETAN:		return HB_Script_Tibetan;
+    case HB_SCRIPT_MYANMAR:		return HB_Script_Myanmar;
+    case HB_SCRIPT_GEORGIAN:		return HB_Script_Georgian;
+    case HB_SCRIPT_HANGUL:		return HB_Script_Hangul;
+    case HB_SCRIPT_OGHAM:		return HB_Script_Ogham;
+    case HB_SCRIPT_RUNIC:		return HB_Script_Runic;
+    case HB_SCRIPT_KHMER:		return HB_Script_Khmer;
+    case HB_SCRIPT_NKO:			return HB_Script_Nko;
+    case HB_SCRIPT_INHERITED:		return HB_Script_Inherited;
+  }
+}
+
+
+static HB_Bool
+hb_old_convertStringToGlyphIndices (HB_Font old_font,
+				    const HB_UChar16 *string,
+				    hb_uint32 length,
+				    HB_Glyph *glyphs,
+				    hb_uint32 *numGlyphs,
+				    HB_Bool rightToLeft)
+{
+  hb_font_t *font = (hb_font_t *) old_font->userData;
+
+  for (unsigned int i = 0; i < length; i++)
+  {
+    hb_codepoint_t u;
+
+    /* XXX Handle UTF-16.  Ugh */
+    u = string[i];
+
+    if (rightToLeft)
+      u = hb_unicode_funcs_get_default ()->mirroring (u);
+
+    font->get_glyph (u, 0, &u); /* TODO Variation selectors */
+
+    glyphs[i] = u;
+  }
+  *numGlyphs = length; // XXX
+
+  return true;
+}
+
+static void
+hb_old_getGlyphAdvances (HB_Font old_font,
+			 const HB_Glyph *glyphs,
+			 hb_uint32 numGlyphs,
+			 HB_Fixed *advances,
+			 int flags /*HB_ShaperFlag*/)
+{
+  hb_font_t *font = (hb_font_t *) old_font->userData;
+
+  for (unsigned int i = 0; i < numGlyphs; i++)
+    advances[i] = font->get_glyph_h_advance (glyphs[i]);
+}
+
+static HB_Bool
+hb_old_canRender (HB_Font old_font,
+		  const HB_UChar16 *string,
+		  hb_uint32 length)
+{
+  return true; // TODO
+}
+
+static HB_Error
+hb_old_getPointInOutline (HB_Font old_font,
+			  HB_Glyph glyph,
+			  int flags /*HB_ShaperFlag*/,
+			  hb_uint32 point,
+			  HB_Fixed *xpos,
+			  HB_Fixed *ypos,
+			  hb_uint32 *nPoints)
+{
+  return HB_Err_Ok; // TODO
+}
+
+static void
+hb_old_getGlyphMetrics (HB_Font old_font,
+			HB_Glyph glyph,
+			HB_GlyphMetrics *metrics)
+{
+  hb_font_t *font = (hb_font_t *) old_font->userData;
+
+  hb_glyph_extents_t extents;
+
+  font->get_glyph_extents (glyph, &extents);
+
+  metrics->x       = extents.x_bearing;
+  metrics->y       = extents.y_bearing;
+  metrics->width   = extents.width;
+  metrics->height  = -extents.height;
+  metrics->xOffset = font->get_glyph_h_advance (glyph);
+  metrics->yOffset = 0;
+}
+
+static HB_Fixed
+hb_old_getFontMetric (HB_Font old_font,
+		      HB_FontMetric metric)
+{
+  hb_font_t *font = (hb_font_t *) old_font->userData;
+
+  switch (metric)
+  {
+    case HB_FontAscent:
+       return font->y_scale; /* XXX We don't have ascent data yet. */
+
+    default:
+      return 0;
+  }
+}
+
+static const HB_FontClass hb_old_font_class = {
+  hb_old_convertStringToGlyphIndices,
+  hb_old_getGlyphAdvances,
+  hb_old_canRender,
+  hb_old_getPointInOutline,
+  hb_old_getGlyphMetrics,
+  hb_old_getFontMetric
+};
+
+
+
+static HB_Error
+table_func (void *font, HB_Tag tag, HB_Byte *buffer, HB_UInt *length)
+{
+  hb_face_t *face = (hb_face_t *) font;
+  hb_blob_t *blob = hb_face_reference_table (face, (hb_tag_t) tag);
+  unsigned int capacity = *length;
+  *length = hb_blob_get_length (blob);
+  memcpy (buffer, hb_blob_get_data (blob, NULL), MIN (capacity, *length));
+  hb_blob_destroy (blob);
+ return HB_Err_Ok;
+}
+
+
+/*
+ * shaper face data
+ */
+
+hb_old_shaper_face_data_t *
+_hb_old_shaper_face_data_create (hb_face_t *face)
+{
+  return HB_NewFace (face, table_func);
+}
+
+void
+_hb_old_shaper_face_data_destroy (hb_old_shaper_face_data_t *data)
+{
+  HB_FreeFace (data);
+}
+
+
+/*
+ * shaper font data
+ */
+
+hb_old_shaper_font_data_t *
+_hb_old_shaper_font_data_create (hb_font_t *font)
+{
+  HB_FontRec *data = (HB_FontRec *) calloc (1, sizeof (HB_FontRec));
+  if (unlikely (!data)) {
+    DEBUG_MSG (OLD, font, "malloc()ing HB_Font failed");
+    return NULL;
+  }
+
+  data->klass = &hb_old_font_class;
+  data->x_ppem = font->x_ppem;
+  data->y_ppem = font->y_ppem;
+  data->x_scale = font->x_scale; // XXX
+  data->y_scale = font->y_scale; // XXX
+  data->userData = font;
+
+  return data;
+}
+
+void
+_hb_old_shaper_font_data_destroy (hb_old_shaper_font_data_t *data)
+{
+  free (data);
+}
+
+
+/*
+ * shaper shape_plan data
+ */
+
+struct hb_old_shaper_shape_plan_data_t {};
+
+hb_old_shaper_shape_plan_data_t *
+_hb_old_shaper_shape_plan_data_create (hb_shape_plan_t    *shape_plan,
+				       const hb_feature_t *user_features,
+				       unsigned int        num_user_features)
+{
+  return (hb_old_shaper_shape_plan_data_t *) HB_SHAPER_DATA_SUCCEEDED;
+}
+
+void
+_hb_old_shaper_shape_plan_data_destroy (hb_old_shaper_shape_plan_data_t *data)
+{
+}
+
+
+/*
+ * shaper
+ */
+
+hb_bool_t
+_hb_old_shape (hb_shape_plan_t    *shape_plan,
+	       hb_font_t          *font,
+	       hb_buffer_t        *buffer,
+	       const hb_feature_t *features,
+	       unsigned int        num_features)
+{
+  hb_face_t *face = font->face;
+  HB_Face old_face = HB_SHAPER_DATA_GET (face);
+  HB_Font old_font = HB_SHAPER_DATA_GET (font);
+
+  bool backward = HB_DIRECTION_IS_BACKWARD (buffer->props.direction);
+
+retry:
+
+  unsigned int scratch_size;
+  char *scratch = (char *) buffer->get_scratch_buffer (&scratch_size);
+
+#define utf16_index() var1.u32
+  HB_UChar16 *pchars = (HB_UChar16 *) scratch;
+  unsigned int chars_len = 0;
+  for (unsigned int i = 0; i < buffer->len; i++) {
+    hb_codepoint_t c = buffer->info[i].codepoint;
+    buffer->info[i].utf16_index() = chars_len;
+    if (likely (c < 0x10000))
+      pchars[chars_len++] = c;
+    else if (unlikely (c >= 0x110000))
+      pchars[chars_len++] = 0xFFFD;
+    else {
+      pchars[chars_len++] = 0xD800 + ((c - 0x10000) >> 10);
+      pchars[chars_len++] = 0xDC00 + ((c - 0x10000) & ((1 << 10) - 1));
+    }
+  }
+
+
+#define ALLOCATE_ARRAY(Type, name, len) \
+  name = (Type *) scratch; \
+  scratch += (len) * sizeof ((name)[0]); \
+  scratch_size -= (len) * sizeof ((name)[0]);
+
+
+  HB_ShaperItem item = {0};
+
+  ALLOCATE_ARRAY (const HB_UChar16, item.string, chars_len);
+  ALLOCATE_ARRAY (unsigned short, item.log_clusters, chars_len + 2);
+  item.stringLength = chars_len;
+  item.item.pos = 0;
+  item.item.length = item.stringLength;
+  item.item.script = hb_old_script_from_script (buffer->props.script);
+  item.item.bidiLevel = backward ? 1 : 0;
+
+  item.font = old_font;
+  item.face = old_face;
+  item.shaperFlags = 0;
+
+  item.glyphIndicesPresent = false;
+
+  /* TODO Alignment. */
+  unsigned int num_glyphs = scratch_size / (sizeof (HB_Glyph) +
+					    sizeof (HB_GlyphAttributes) +
+					    sizeof (HB_Fixed) +
+					    sizeof (HB_FixedPoint) +
+					    sizeof (uint32_t));
+
+  item.num_glyphs = num_glyphs;
+  ALLOCATE_ARRAY (HB_Glyph, item.glyphs, num_glyphs);
+  ALLOCATE_ARRAY (HB_GlyphAttributes, item.attributes, num_glyphs);
+  ALLOCATE_ARRAY (HB_Fixed, item.advances, num_glyphs);
+  ALLOCATE_ARRAY (HB_FixedPoint, item.offsets, num_glyphs);
+  uint32_t *vis_clusters;
+  ALLOCATE_ARRAY (uint32_t, vis_clusters, num_glyphs);
+
+#undef ALLOCATE_ARRAY
+
+  if (!HB_ShapeItem (&item))
+  {
+    if (unlikely (item.num_glyphs > num_glyphs))
+    {
+      buffer->ensure (buffer->allocated * 2);
+      if (buffer->in_error)
+        return false;
+      goto retry;
+    }
+    return false;
+  }
+  num_glyphs = item.num_glyphs;
+
+  /* Ok, we've got everything we need, now compose output buffer,
+   * very, *very*, carefully! */
+
+  /* Calculate visual-clusters.  That's what we ship. */
+  for (unsigned int i = 0; i < num_glyphs; i++)
+    vis_clusters[i] = -1;
+  for (unsigned int i = 0; i < buffer->len; i++) {
+    uint32_t *p = &vis_clusters[item.log_clusters[buffer->info[i].utf16_index()]];
+    *p = MIN (*p, buffer->info[i].cluster);
+  }
+  for (unsigned int i = 1; i < num_glyphs; i++)
+    if (vis_clusters[i] == -1)
+      vis_clusters[i] = vis_clusters[i - 1];
+
+#undef utf16_index
+
+  buffer->ensure (num_glyphs);
+  if (buffer->in_error)
+    return false;
+
+
+  buffer->len = num_glyphs;
+  hb_glyph_info_t *info = buffer->info;
+  for (unsigned int i = 0; i < num_glyphs; i++)
+  {
+    info[i].codepoint = item.glyphs[i];
+    info[i].cluster = vis_clusters[i];
+
+    info[i].mask = item.advances[i];
+    info[i].var1.u32 = item.offsets[i].x;
+    info[i].var2.u32 = item.offsets[i].y;
+  }
+
+  buffer->clear_positions ();
+
+  for (unsigned int i = 0; i < num_glyphs; ++i) {
+    hb_glyph_info_t *info = &buffer->info[i];
+    hb_glyph_position_t *pos = &buffer->pos[i];
+
+    /* TODO vertical */
+    pos->x_advance = info->mask;
+    pos->x_offset = info->var1.u32;
+    pos->y_offset = info->var2.u32;
+  }
+
+  if (HB_DIRECTION_IS_BACKWARD (buffer->props.direction))
+    buffer->reverse ();
+
+  return true;
+}
diff --git a/gfx/harfbuzz/src/hb-open-file-private.hh b/gfx/harfbuzz/src/hb-open-file-private.hh
--- a/gfx/harfbuzz/src/hb-open-file-private.hh
+++ b/gfx/harfbuzz/src/hb-open-file-private.hh
@@ -100,17 +100,17 @@ typedef struct OffsetTable
   }
 
   public:
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) && c->check_array (tables, TableRecord::static_size, numTables));
   }
 
-  private:
+  protected:
   Tag		sfnt_version;	/* '\0\001\0\00' if TrueType / 'OTTO' if CFF */
   USHORT	numTables;	/* Number of tables. */
   USHORT	searchRange;	/* (Maximum power of 2 <= numTables) x 16 */
   USHORT	entrySelector;	/* Log2(maximum power of 2 <= numTables). */
   USHORT	rangeShift;	/* NumTables x 16-searchRange. */
   TableRecord	tables[VAR];	/* TableRecord entries. numTables items */
   public:
   DEFINE_SIZE_ARRAY (12, tables);
@@ -128,17 +128,17 @@ struct TTCHeaderVersion1
   inline unsigned int get_face_count (void) const { return table.len; }
   inline const OpenTypeFontFace& get_face (unsigned int i) const { return this+table[i]; }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (table.sanitize (c, this));
   }
 
-  private:
+  protected:
   Tag		ttcTag;		/* TrueType Collection ID string: 'ttcf' */
   FixedVersion	version;	/* Version of the TTC Header (1.0),
 				 * 0x00010000 */
   LongOffsetLongArrayOf<OffsetTable>
 		table;		/* Array of offsets to the OffsetTable for each font
 				 * from the beginning of the file */
   public:
   DEFINE_SIZE_ARRAY (12, table);
@@ -172,17 +172,17 @@ struct TTCHeader
     if (unlikely (!u.header.version.sanitize (c))) return TRACE_RETURN (false);
     switch (u.header.version.major) {
     case 2: /* version 2 is compatible with version 1 */
     case 1: return TRACE_RETURN (u.version1.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   struct {
   Tag		ttcTag;		/* TrueType Collection ID string: 'ttcf' */
   FixedVersion	version;	/* Version of the TTC Header (1.0 or 2.0),
 				 * 0x00010000 or 0x00020000 */
   }			header;
   TTCHeaderVersion1	version1;
   } u;
@@ -237,17 +237,17 @@ struct OpenTypeFontFile
     case TrueTag:
     case Typ1Tag:
     case TrueTypeTag:	return TRACE_RETURN (u.fontFace.sanitize (c));
     case TTCTag:	return TRACE_RETURN (u.ttcHeader.sanitize (c));
     default:		return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   Tag			tag;		/* 4-byte identifier. */
   OpenTypeFontFace	fontFace;
   TTCHeader		ttcHeader;
   } u;
   public:
   DEFINE_SIZE_UNION (4, tag);
 };
diff --git a/gfx/harfbuzz/src/hb-open-type-private.hh b/gfx/harfbuzz/src/hb-open-type-private.hh
--- a/gfx/harfbuzz/src/hb-open-type-private.hh
+++ b/gfx/harfbuzz/src/hb-open-type-private.hh
@@ -75,58 +75,67 @@ inline Type& StructAfter(TObject &X)
 
 
 
 /*
  * Size checking
  */
 
 /* Check _assertion in a method environment */
-#define _DEFINE_SIZE_ASSERTION(_assertion) \
-  inline void _size_assertion (void) const \
-  { ASSERT_STATIC (_assertion); }
+#define _DEFINE_INSTANCE_ASSERTION1(_line, _assertion) \
+  inline void _instance_assertion_on_line_##_line (void) const \
+  { \
+    ASSERT_STATIC (_assertion); \
+    ASSERT_INSTANCE_POD (*this); /* Make sure it's POD. */ \
+  }
+# define _DEFINE_INSTANCE_ASSERTION0(_line, _assertion) _DEFINE_INSTANCE_ASSERTION1 (_line, _assertion)
+# define DEFINE_INSTANCE_ASSERTION(_assertion) _DEFINE_INSTANCE_ASSERTION0 (__LINE__, _assertion)
+
 /* Check that _code compiles in a method environment */
-#define _DEFINE_COMPILES_ASSERTION(_code) \
-  inline void _compiles_assertion (void) const \
+#define _DEFINE_COMPILES_ASSERTION1(_line, _code) \
+  inline void _compiles_assertion_on_line_##_line (void) const \
   { _code; }
+# define _DEFINE_COMPILES_ASSERTION0(_line, _code) _DEFINE_COMPILES_ASSERTION1 (_line, _code)
+# define DEFINE_COMPILES_ASSERTION(_code) _DEFINE_COMPILES_ASSERTION0 (__LINE__, _code)
 
 
 #define DEFINE_SIZE_STATIC(size) \
-  _DEFINE_SIZE_ASSERTION (sizeof (*this) == (size)); \
+  DEFINE_INSTANCE_ASSERTION (sizeof (*this) == (size)); \
   static const unsigned int static_size = (size); \
   static const unsigned int min_size = (size)
 
 /* Size signifying variable-sized array */
 #define VAR 1
 
 #define DEFINE_SIZE_UNION(size, _member) \
-  _DEFINE_SIZE_ASSERTION (this->u._member.static_size == (size)); \
+  DEFINE_INSTANCE_ASSERTION (this->u._member.static_size == (size)); \
   static const unsigned int min_size = (size)
 
 #define DEFINE_SIZE_MIN(size) \
-  _DEFINE_SIZE_ASSERTION (sizeof (*this) >= (size)); \
+  DEFINE_INSTANCE_ASSERTION (sizeof (*this) >= (size)); \
   static const unsigned int min_size = (size)
 
 #define DEFINE_SIZE_ARRAY(size, array) \
-  _DEFINE_SIZE_ASSERTION (sizeof (*this) == (size) + sizeof (array[0])); \
-  _DEFINE_COMPILES_ASSERTION ((void) array[0].static_size) \
+  DEFINE_INSTANCE_ASSERTION (sizeof (*this) == (size) + sizeof (array[0])); \
+  DEFINE_COMPILES_ASSERTION ((void) array[0].static_size) \
   static const unsigned int min_size = (size)
 
 #define DEFINE_SIZE_ARRAY2(size, array1, array2) \
-  _DEFINE_SIZE_ASSERTION (sizeof (*this) == (size) + sizeof (this->array1[0]) + sizeof (this->array2[0])); \
-  _DEFINE_COMPILES_ASSERTION ((void) array1[0].static_size; (void) array2[0].static_size) \
+  DEFINE_INSTANCE_ASSERTION (sizeof (*this) == (size) + sizeof (this->array1[0]) + sizeof (this->array2[0])); \
+  DEFINE_COMPILES_ASSERTION ((void) array1[0].static_size; (void) array2[0].static_size) \
   static const unsigned int min_size = (size)
 
 
 
 /*
  * Null objects
  */
 
 /* Global nul-content Null pool.  Enlarge as necessary. */
+/* TODO This really should be a extern HB_INTERNAL and defined somewhere... */
 static const void *_NullPool[64 / sizeof (void *)];
 
 /* Generic nul-content Null objects. */
 template <typename Type>
 static inline const Type& Null (void) {
   ASSERT_STATIC (Type::min_size <= sizeof (_NullPool));
   return *CastP<Type> (_NullPool);
 }
@@ -328,18 +337,16 @@ struct Sanitizer
 
 /*
  * Int types
  */
 
 
 template <typename Type, int Bytes> struct BEInt;
 
-/* LONGTERMTODO: On machines allowing unaligned access, we can make the
- * following tighter by using byteswap instructions on ints directly. */
 template <typename Type>
 struct BEInt<Type, 2>
 {
   public:
   inline void set (Type i) { hb_be_uint16_put (v,i); }
   inline operator Type (void) const { return hb_be_uint16_get (v); }
   inline bool operator == (const BEInt<Type, 2>& o) const { return hb_be_uint16_eq (v, o.v); }
   inline bool operator != (const BEInt<Type, 2>& o) const { return !(*this == o); }
@@ -684,19 +691,28 @@ struct HeadlessArrayOf
 
 
 /* An array with sorted elements.  Supports binary searching. */
 template <typename Type>
 struct SortedArrayOf : ArrayOf<Type> {
 
   template <typename SearchType>
   inline int search (const SearchType &x) const {
-    struct Cmp {
-      static int cmp (const SearchType *a, const Type *b) { return b->cmp (*a); }
-    };
-    const Type *p = (const Type *) bsearch (&x, this->array, this->len, sizeof (this->array[0]), (hb_compare_func_t) Cmp::cmp);
-    return p ? p - this->array : -1;
+    unsigned int count = this->len;
+    /* Linear search is *much* faster for small counts. */
+    if (likely (count < 32)) {
+      for (unsigned int i = 0; i < count; i++)
+	if (this->array[i].cmp (x) == 0)
+	  return i;
+      return -1;
+    } else {
+      struct Cmp {
+	static int cmp (const SearchType *a, const Type *b) { return b->cmp (*a); }
+      };
+      const Type *p = (const Type *) bsearch (&x, this->array, this->len, sizeof (this->array[0]), (hb_compare_func_t) Cmp::cmp);
+      return p ? p - this->array : -1;
+    }
   }
 };
 
 
 
 #endif /* HB_OPEN_TYPE_PRIVATE_HH */
diff --git a/gfx/harfbuzz/src/hb-ot-head-table.hh b/gfx/harfbuzz/src/hb-ot-head-table.hh
--- a/gfx/harfbuzz/src/hb-ot-head-table.hh
+++ b/gfx/harfbuzz/src/hb-ot-head-table.hh
@@ -49,17 +49,17 @@ struct head
     return 16 <= upem && upem <= 16384 ? upem : 1000;
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) && likely (version.major == 1));
   }
 
-  private:
+  protected:
   FixedVersion	version;		/* Version of the head table--currently
 					 * 0x00010000 for version 1.0. */
   FixedVersion	fontRevision;		/* Set by font manufacturer. */
   ULONG		checkSumAdjustment;	/* To compute: set it to 0, sum the
 					 * entire font as ULONG, then store
 					 * 0xB1B0AFBA - sum. */
   ULONG		magicNumber;		/* Set to 0x5F0F3CF5. */
   USHORT	flags;			/* Bit 0: Baseline for font at y=0;
diff --git a/gfx/harfbuzz/src/hb-ot-hhea-table.hh b/gfx/harfbuzz/src/hb-ot-hhea-table.hh
--- a/gfx/harfbuzz/src/hb-ot-hhea-table.hh
+++ b/gfx/harfbuzz/src/hb-ot-hhea-table.hh
@@ -42,17 +42,17 @@ struct hhea
 {
   static const hb_tag_t Tag	= HB_OT_TAG_hhea;
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) && likely (version.major == 1));
   }
 
-  private:
+  protected:
   FixedVersion	version;		/* 0x00010000 for version 1.0. */
   FWORD		ascender;		/* Typographic ascent. <a
 					 * href="http://developer.apple.com/fonts/TTRefMan/RM06/Chap6hhea.html">
 					 * (Distance from baseline of highest
 					 * ascender)</a> */
   FWORD		descender;		/* Typographic descent. <a
 					 * href="http://developer.apple.com/fonts/TTRefMan/RM06/Chap6hhea.html">
 					 * (Distance from baseline of lowest
diff --git a/gfx/harfbuzz/src/hb-ot-hmtx-table.hh b/gfx/harfbuzz/src/hb-ot-hmtx-table.hh
--- a/gfx/harfbuzz/src/hb-ot-hmtx-table.hh
+++ b/gfx/harfbuzz/src/hb-ot-hmtx-table.hh
@@ -52,17 +52,17 @@ struct hmtx
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     /* We don't check for anything specific here.  The users of the
      * struct do all the hard work... */
     return TRACE_RETURN (true);
   }
 
-  private:
+  protected:
   LongHorMetric	longHorMetric[VAR];	/* Paired advance width and left side
 					 * bearing values for each glyph. The
 					 * value numOfHMetrics comes from
 					 * the 'hhea' table. If the font is
 					 * monospaced, only one entry need
 					 * be in the array, but that entry is
 					 * required. The last entry applies to
 					 * all subsequent glyphs. */
diff --git a/gfx/harfbuzz/src/hb-ot-layout-common-private.hh b/gfx/harfbuzz/src/hb-ot-layout-common-private.hh
--- a/gfx/harfbuzz/src/hb-ot-layout-common-private.hh
+++ b/gfx/harfbuzz/src/hb-ot-layout-common-private.hh
@@ -29,17 +29,17 @@
 #ifndef HB_OT_LAYOUT_COMMON_PRIVATE_HH
 #define HB_OT_LAYOUT_COMMON_PRIVATE_HH
 
 #include "hb-ot-layout-private.hh"
 #include "hb-open-type-private.hh"
 #include "hb-set-private.hh"
 
 
-#define NOT_COVERED		((unsigned int) 0x110000)
+#define NOT_COVERED		((unsigned int) -1)
 #define MAX_NESTING_LEVEL	8
 
 
 
 /*
  *
  * OpenType Layout Common Table Formats
  *
@@ -129,16 +129,21 @@ struct RangeRecord
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this));
   }
 
   inline bool intersects (const hb_set_t *glyphs) const {
     return glyphs->intersects (start, end);
   }
 
+  template <typename set_t>
+  inline void add_coverage (set_t *glyphs) const {
+    glyphs->add_range (start, end);
+  }
+
   GlyphID	start;		/* First GlyphID in the range */
   GlyphID	end;		/* Last GlyphID in the range */
   USHORT	value;		/* Value */
   public:
   DEFINE_SIZE_STATIC (6);
 };
 DEFINE_NULL_DATA (RangeRecord, "\000\001");
 
@@ -222,17 +227,17 @@ struct Script
   inline bool has_default_lang_sys (void) const { return defaultLangSys != 0; }
   inline const LangSys& get_default_lang_sys (void) const { return this+defaultLangSys; }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (defaultLangSys.sanitize (c, this) && langSys.sanitize (c, this));
   }
 
-  private:
+  protected:
   OffsetTo<LangSys>
 		defaultLangSys;	/* Offset to DefaultLangSys table--from
 				 * beginning of Script table--may be Null */
   RecordArrayOf<LangSys>
 		langSys;	/* Array of LangSysRecords--listed
 				 * alphabetically by LangSysTag */
   public:
   DEFINE_SIZE_ARRAY (4, langSys);
@@ -304,16 +309,17 @@ struct Lookup
     }
     return flag;
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     /* Real sanitize of the subtables is done by GSUB/GPOS/... */
     if (!(c->check_struct (this) && subTable.sanitize (c))) return TRACE_RETURN (false);
+    if (!subTable.len) TRACE_RETURN (false);
     if (unlikely (lookupFlag & LookupFlag::UseMarkFilteringSet))
     {
       USHORT &markFilteringSet = StructAfter<USHORT> (subTable);
       if (!markFilteringSet.sanitize (c)) return TRACE_RETURN (false);
     }
     return TRACE_RETURN (true);
   }
 
@@ -338,43 +344,49 @@ typedef OffsetListOf<Lookup> LookupList;
 struct CoverageFormat1
 {
   friend struct Coverage;
 
   private:
   inline unsigned int get_coverage (hb_codepoint_t glyph_id) const
   {
     int i = glyphArray.search (glyph_id);
-    if (i != -1)
-        return i;
-    return NOT_COVERED;
+    ASSERT_STATIC (((unsigned int) -1) == NOT_COVERED);
+    return i;
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (glyphArray.sanitize (c));
   }
 
   inline bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const {
     return glyphs->has (glyphArray[index]);
   }
 
+  template <typename set_t>
+  inline void add_coverage (set_t *glyphs) const {
+    unsigned int count = glyphArray.len;
+    for (unsigned int i = 0; i < count; i++)
+      glyphs->add (glyphArray[i]);
+  }
+
   struct Iter {
     inline void init (const struct CoverageFormat1 &c_) { c = &c_; i = 0; };
     inline bool more (void) { return i < c->glyphArray.len; }
     inline void next (void) { i++; }
     inline uint16_t get_glyph (void) { return c->glyphArray[i]; }
     inline uint16_t get_coverage (void) { return i; }
 
     private:
     const struct CoverageFormat1 *c;
     unsigned int i;
   };
 
-  private:
+  protected:
   USHORT	coverageFormat;	/* Format identifier--format = 1 */
   SortedArrayOf<GlyphID>
 		glyphArray;	/* Array of GlyphIDs--in numerical order */
   public:
   DEFINE_SIZE_ARRAY (4, glyphArray);
 };
 
 struct CoverageFormat2
@@ -407,16 +419,23 @@ struct CoverageFormat2
 	  range.intersects (glyphs))
         return true;
       else if (index < range.value)
         return false;
     }
     return false;
   }
 
+  template <typename set_t>
+  inline void add_coverage (set_t *glyphs) const {
+    unsigned int count = rangeRecord.len;
+    for (unsigned int i = 0; i < count; i++)
+      rangeRecord[i].add_coverage (glyphs);
+  }
+
   struct Iter {
     inline void init (const CoverageFormat2 &c_) {
       c = &c_;
       coverage = 0;
       i = 0;
       j = c->rangeRecord.len ? c_.rangeRecord[0].start : 0;
     }
     inline bool more (void) { return i < c->rangeRecord.len; }
@@ -433,17 +452,17 @@ struct CoverageFormat2
     inline uint16_t get_glyph (void) { return j; }
     inline uint16_t get_coverage (void) { return coverage; }
 
     private:
     const struct CoverageFormat2 *c;
     unsigned int i, j, coverage;
   };
 
-  private:
+  protected:
   USHORT	coverageFormat;	/* Format identifier--format = 2 */
   SortedArrayOf<RangeRecord>
 		rangeRecord;	/* Array of glyph ranges--ordered by
 				 * Start GlyphID. rangeCount entries
 				 * long */
   public:
   DEFINE_SIZE_ARRAY (4, rangeRecord);
 };
@@ -484,16 +503,25 @@ struct Coverage
   inline bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const {
     switch (u.format) {
     case 1: return u.format1.intersects_coverage (glyphs, index);
     case 2: return u.format2.intersects_coverage (glyphs, index);
     default:return false;
     }
   }
 
+  template <typename set_t>
+  inline void add_coverage (set_t *glyphs) const {
+    switch (u.format) {
+    case 1: u.format1.add_coverage (glyphs); break;
+    case 2: u.format2.add_coverage (glyphs); break;
+    default:                                 break;
+    }
+  }
+
   struct Iter {
     Iter (void) : format (0) {};
     inline void init (const Coverage &c_) {
       format = c_.u.format;
       switch (format) {
       case 1: return u.format1.init (c_.u.format1);
       case 2: return u.format2.init (c_.u.format2);
       default:return;
@@ -531,17 +559,17 @@ struct Coverage
     private:
     unsigned int format;
     union {
     CoverageFormat1::Iter	format1;
     CoverageFormat2::Iter	format2;
     } u;
   };
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   CoverageFormat1	format1;
   CoverageFormat2	format2;
   } u;
   public:
   DEFINE_SIZE_UNION (2, format);
 };
@@ -553,17 +581,17 @@ struct Coverage
 
 struct ClassDefFormat1
 {
   friend struct ClassDef;
 
   private:
   inline unsigned int get_class (hb_codepoint_t glyph_id) const
   {
-    if ((unsigned int) (glyph_id - startGlyph) < classValue.len)
+    if (unlikely ((unsigned int) (glyph_id - startGlyph) < classValue.len))
       return classValue[glyph_id - startGlyph];
     return 0;
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) && classValue.sanitize (c));
   }
@@ -571,16 +599,17 @@ struct ClassDefFormat1
   inline bool intersects_class (const hb_set_t *glyphs, unsigned int klass) const {
     unsigned int count = classValue.len;
     for (unsigned int i = 0; i < count; i++)
       if (classValue[i] == klass && glyphs->has (startGlyph + i))
         return true;
     return false;
   }
 
+  protected:
   USHORT	classFormat;		/* Format identifier--format = 1 */
   GlyphID	startGlyph;		/* First GlyphID of the classValueArray */
   ArrayOf<USHORT>
 		classValue;		/* Array of Class Values--one per GlyphID */
   public:
   DEFINE_SIZE_ARRAY (6, classValue);
 };
 
@@ -605,16 +634,17 @@ struct ClassDefFormat2
   inline bool intersects_class (const hb_set_t *glyphs, unsigned int klass) const {
     unsigned int count = rangeRecord.len;
     for (unsigned int i = 0; i < count; i++)
       if (rangeRecord[i].value == klass && rangeRecord[i].intersects (glyphs))
         return true;
     return false;
   }
 
+  protected:
   USHORT	classFormat;	/* Format identifier--format = 2 */
   SortedArrayOf<RangeRecord>
 		rangeRecord;	/* Array of glyph ranges--ordered by
 				 * Start GlyphID */
   public:
   DEFINE_SIZE_ARRAY (4, rangeRecord);
 };
 
@@ -644,17 +674,17 @@ struct ClassDef
   inline bool intersects_class (const hb_set_t *glyphs, unsigned int klass) const {
     switch (u.format) {
     case 1: return u.format1.intersects_class (glyphs, klass);
     case 2: return u.format2.intersects_class (glyphs, klass);
     default:return false;
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   ClassDefFormat1	format1;
   ClassDefFormat2	format2;
   } u;
   public:
   DEFINE_SIZE_UNION (2, format);
 };
@@ -715,17 +745,17 @@ struct Device
     return USHORT::static_size * (4 + ((endSize - startSize) >> (4 - f)));
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) && c->check_range (this, this->get_size ()));
   }
 
-  private:
+  protected:
   USHORT	startSize;		/* Smallest size to correct--in ppem */
   USHORT	endSize;		/* Largest size to correct--in ppem */
   USHORT	deltaFormat;		/* Format of DeltaValue array data: 1, 2, or 3
 					 * 1	Signed 2-bit value, 8 values per uint16
 					 * 2	Signed 4-bit value, 4 values per uint16
 					 * 3	Signed 8-bit value, 2 values per uint16
 					 */
   USHORT	deltaValue[VAR];	/* Array of compressed data */
diff --git a/gfx/harfbuzz/src/hb-ot-layout-gdef-table.hh b/gfx/harfbuzz/src/hb-ot-layout-gdef-table.hh
--- a/gfx/harfbuzz/src/hb-ot-layout-gdef-table.hh
+++ b/gfx/harfbuzz/src/hb-ot-layout-gdef-table.hh
@@ -69,17 +69,17 @@ struct AttachList
     return points.len;
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (coverage.sanitize (c, this) && attachPoint.sanitize (c, this));
   }
 
-  private:
+  protected:
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table -- from
 					 * beginning of AttachList table */
   OffsetArrayOf<AttachPoint>
 		attachPoint;		/* Array of AttachPoint tables
 					 * in Coverage Index order */
   public:
   DEFINE_SIZE_ARRAY (4, attachPoint);
@@ -99,43 +99,43 @@ struct CaretValueFormat1
     return HB_DIRECTION_IS_HORIZONTAL (direction) ? font->em_scale_x (coordinate) : font->em_scale_y (coordinate);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this));
   }
 
-  private:
+  protected:
   USHORT	caretValueFormat;	/* Format identifier--format = 1 */
   SHORT		coordinate;		/* X or Y value, in design units */
   public:
   DEFINE_SIZE_STATIC (4);
 };
 
 struct CaretValueFormat2
 {
   friend struct CaretValue;
 
   private:
   inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id) const
   {
     hb_position_t x, y;
-    if (hb_font_get_glyph_contour_point_for_origin (font, glyph_id, caretValuePoint, direction, &x, &y))
+    if (font->get_glyph_contour_point_for_origin (glyph_id, caretValuePoint, direction, &x, &y))
       return HB_DIRECTION_IS_HORIZONTAL (direction) ? x : y;
     else
       return 0;
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this));
   }
 
-  private:
+  protected:
   USHORT	caretValueFormat;	/* Format identifier--format = 2 */
   USHORT	caretValuePoint;	/* Contour point index on glyph */
   public:
   DEFINE_SIZE_STATIC (4);
 };
 
 struct CaretValueFormat3
 {
@@ -148,17 +148,17 @@ struct CaretValueFormat3
            font->em_scale_y (coordinate) + (this+deviceTable).get_y_delta (font);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) && deviceTable.sanitize (c, this));
   }
 
-  private:
+  protected:
   USHORT	caretValueFormat;	/* Format identifier--format = 3 */
   SHORT		coordinate;		/* X or Y value, in design units */
   OffsetTo<Device>
 		deviceTable;		/* Offset to Device table for X or Y
 					 * value--from beginning of CaretValue
 					 * table */
   public:
   DEFINE_SIZE_STATIC (6);
@@ -182,17 +182,17 @@ struct CaretValue
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     case 2: return TRACE_RETURN (u.format2.sanitize (c));
     case 3: return TRACE_RETURN (u.format3.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   CaretValueFormat1	format1;
   CaretValueFormat2	format2;
   CaretValueFormat3	format3;
   } u;
   public:
   DEFINE_SIZE_UNION (2, format);
@@ -217,17 +217,17 @@ struct LigGlyph
     return carets.len;
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (carets.sanitize (c, this));
   }
 
-  private:
+  protected:
   OffsetArrayOf<CaretValue>
 		carets;			/* Offset array of CaretValue tables
 					 * --from beginning of LigGlyph table
 					 * --in increasing coordinate order */
   public:
   DEFINE_SIZE_ARRAY (2, carets);
 };
 
@@ -251,17 +251,17 @@ struct LigCaretList
     return lig_glyph.get_lig_carets (font, direction, glyph_id, start_offset, caret_count, caret_array);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (coverage.sanitize (c, this) && ligGlyph.sanitize (c, this));
   }
 
-  private:
+  protected:
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of LigCaretList table */
   OffsetArrayOf<LigGlyph>
 		ligGlyph;		/* Array of LigGlyph tables
 					 * in Coverage Index order */
   public:
   DEFINE_SIZE_ARRAY (4, ligGlyph);
@@ -273,17 +273,17 @@ struct MarkGlyphSetsFormat1
   inline bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const
   { return (this+coverage[set_index]).get_coverage (glyph_id) != NOT_COVERED; }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (coverage.sanitize (c, this));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   LongOffsetArrayOf<Coverage>
 		coverage;		/* Array of long offsets to mark set
 					 * coverage tables */
   public:
   DEFINE_SIZE_ARRAY (4, coverage);
 };
 
@@ -301,17 +301,17 @@ struct MarkGlyphSets
     TRACE_SANITIZE ();
     if (!u.format.sanitize (c)) return TRACE_RETURN (false);
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   MarkGlyphSetsFormat1	format1;
   } u;
   public:
   DEFINE_SIZE_UNION (2, format);
 };
 
@@ -387,17 +387,17 @@ struct GDEF
     case ComponentGlyph:	return HB_OT_LAYOUT_GLYPH_CLASS_COMPONENT;
     case MarkGlyph:
 	  klass = get_mark_attachment_type (glyph);
 	  return HB_OT_LAYOUT_GLYPH_CLASS_MARK | (klass << 8);
     }
   }
 
 
-  private:
+  protected:
   FixedVersion	version;		/* Version of the GDEF table--currently
 					 * 0x00010002 */
   OffsetTo<ClassDef>
 		glyphClassDef;		/* Offset to class definition table
 					 * for glyph type--from beginning of
 					 * GDEF header (may be Null) */
   OffsetTo<AttachList>
 		attachList;		/* Offset to list of glyphs with
diff --git a/gfx/harfbuzz/src/hb-ot-layout-gpos-table.hh b/gfx/harfbuzz/src/hb-ot-layout-gpos-table.hh
--- a/gfx/harfbuzz/src/hb-ot-layout-gpos-table.hh
+++ b/gfx/harfbuzz/src/hb-ot-layout-gpos-table.hh
@@ -220,17 +220,17 @@ struct AnchorFormat1
       *y = font->em_scale_y (yCoordinate);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   SHORT		xCoordinate;		/* Horizontal value--in design units */
   SHORT		yCoordinate;		/* Vertical value--in design units */
   public:
   DEFINE_SIZE_STATIC (6);
 };
 
 struct AnchorFormat2
@@ -242,27 +242,27 @@ struct AnchorFormat2
 			  hb_position_t *x, hb_position_t *y) const
   {
       unsigned int x_ppem = font->x_ppem;
       unsigned int y_ppem = font->y_ppem;
       hb_position_t cx, cy;
       hb_bool_t ret = false;
 
       if (x_ppem || y_ppem)
-	ret = hb_font_get_glyph_contour_point_for_origin (font, glyph_id, anchorPoint, HB_DIRECTION_LTR, &cx, &cy);
+	ret = font->get_glyph_contour_point_for_origin (glyph_id, anchorPoint, HB_DIRECTION_LTR, &cx, &cy);
       *x = x_ppem && ret ? cx : font->em_scale_x (xCoordinate);
       *y = y_ppem && ret ? cy : font->em_scale_y (yCoordinate);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 2 */
   SHORT		xCoordinate;		/* Horizontal value--in design units */
   SHORT		yCoordinate;		/* Vertical value--in design units */
   USHORT	anchorPoint;		/* Index to glyph contour point */
   public:
   DEFINE_SIZE_STATIC (8);
 };
 
@@ -283,17 +283,17 @@ struct AnchorFormat3
 	*y += (this+yDeviceTable).get_x_delta (font);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) && xDeviceTable.sanitize (c, this) && yDeviceTable.sanitize (c, this));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 3 */
   SHORT		xCoordinate;		/* Horizontal value--in design units */
   SHORT		yCoordinate;		/* Vertical value--in design units */
   OffsetTo<Device>
 		xDeviceTable;		/* Offset to Device table for X
 					 * coordinate-- from beginning of
 					 * Anchor table (may be NULL) */
   OffsetTo<Device>
@@ -324,17 +324,17 @@ struct Anchor
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     case 2: return TRACE_RETURN (u.format2.sanitize (c));
     case 3: return TRACE_RETURN (u.format3.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   AnchorFormat1		format1;
   AnchorFormat2		format2;
   AnchorFormat3		format3;
   } u;
   public:
   DEFINE_SIZE_UNION (2, format);
@@ -355,17 +355,17 @@ struct AnchorMatrix
     unsigned int count = rows * cols;
     if (!c->check_array (matrix, matrix[0].static_size, count)) return TRACE_RETURN (false);
     for (unsigned int i = 0; i < count; i++)
       if (!matrix[i].sanitize (c, this)) return TRACE_RETURN (false);
     return TRACE_RETURN (true);
   }
 
   USHORT	rows;			/* Number of rows */
-  private:
+  protected:
   OffsetTo<Anchor>
 		matrix[VAR];		/* Matrix of offsets to Anchor tables--
 					 * from beginning of AnchorMatrix table */
   public:
   DEFINE_SIZE_ARRAY (2, matrix);
 };
 
 
@@ -373,17 +373,17 @@ struct MarkRecord
 {
   friend struct MarkArray;
 
   inline bool sanitize (hb_sanitize_context_t *c, void *base) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) && markAnchor.sanitize (c, base));
   }
 
-  private:
+  protected:
   USHORT	klass;			/* Class defined for this mark */
   OffsetTo<Anchor>
 		markAnchor;		/* Offset to Anchor table--from
 					 * beginning of MarkArray table */
   public:
   DEFINE_SIZE_STATIC (4);
 };
 
@@ -424,16 +424,22 @@ struct MarkArray : ArrayOf<MarkRecord>	/
 
 /* Lookups */
 
 struct SinglePosFormat1
 {
   friend struct SinglePos;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    return this+coverage;
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     unsigned int index = (this+coverage) (c->buffer->cur().codepoint);
     if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);
 
     valueFormat.apply_value (c->font, c->direction, this,
 			     values, c->buffer->cur_pos());
@@ -442,17 +448,17 @@ struct SinglePosFormat1
     return TRACE_RETURN (true);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) && coverage.sanitize (c, this) && valueFormat.sanitize_value (c, this, values));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of subtable */
   ValueFormat	valueFormat;		/* Defines the types of data in the
 					 * ValueRecord */
   ValueRecord	values;			/* Defines positioning
 					 * value(s)--applied to all glyphs in
@@ -461,16 +467,22 @@ struct SinglePosFormat1
   DEFINE_SIZE_ARRAY (6, values);
 };
 
 struct SinglePosFormat2
 {
   friend struct SinglePos;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    return this+coverage;
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     unsigned int index = (this+coverage) (c->buffer->cur().codepoint);
     if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);
 
     if (likely (index >= valueCount)) return TRACE_RETURN (false);
 
@@ -482,17 +494,17 @@ struct SinglePosFormat2
     return TRACE_RETURN (true);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) && coverage.sanitize (c, this) && valueFormat.sanitize_values (c, this, values, valueCount));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 2 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of subtable */
   ValueFormat	valueFormat;		/* Defines the types of data in the
 					 * ValueRecord */
   USHORT	valueCount;		/* Number of ValueRecords */
   ValueRecord	values;			/* Array of ValueRecords--positioning
@@ -501,16 +513,26 @@ struct SinglePosFormat2
   DEFINE_SIZE_ARRAY (8, values);
 };
 
 struct SinglePos
 {
   friend struct PosLookupSubTable;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.get_coverage ();
+    case 2: return u.format2.get_coverage ();
+    default:return Null(Coverage);
+    }
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.apply (c));
     case 2: return TRACE_RETURN (u.format2.apply (c));
     default:return TRACE_RETURN (false);
     }
@@ -521,30 +543,30 @@ struct SinglePos
     if (!u.format.sanitize (c)) return TRACE_RETURN (false);
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     case 2: return TRACE_RETURN (u.format2.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   SinglePosFormat1	format1;
   SinglePosFormat2	format2;
   } u;
 };
 
 
 struct PairValueRecord
 {
   friend struct PairSet;
 
-  private:
+  protected:
   GlyphID	secondGlyph;		/* GlyphID of second glyph in the
 					 * pair--first glyph is listed in the
 					 * Coverage table */
   ValueRecord	values;			/* Positioning data for the first glyph
 					 * followed by for second glyph */
   public:
   DEFINE_SIZE_ARRAY (2, values);
 };
@@ -596,29 +618,35 @@ struct PairSet
        && c->check_array (array, USHORT::static_size * closure->stride, len))) return TRACE_RETURN (false);
 
     unsigned int count = len;
     PairValueRecord *record = CastP<PairValueRecord> (array);
     return TRACE_RETURN (closure->valueFormats[0].sanitize_values_stride_unsafe (c, closure->base, &record->values[0], count, closure->stride)
 		      && closure->valueFormats[1].sanitize_values_stride_unsafe (c, closure->base, &record->values[closure->len1], count, closure->stride));
   }
 
-  private:
+  protected:
   USHORT	len;			/* Number of PairValueRecords */
   USHORT	array[VAR];		/* Array of PairValueRecords--ordered
 					 * by GlyphID of the second glyph */
   public:
   DEFINE_SIZE_ARRAY (2, array);
 };
 
 struct PairPosFormat1
 {
   friend struct PairPos;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    return this+coverage;
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     hb_apply_context_t::mark_skipping_forward_iterator_t skippy_iter (c, c->buffer->idx, 1);
     if (skippy_iter.has_no_chance ()) return TRACE_RETURN (false);
 
     unsigned int index = (this+coverage) (c->buffer->cur().codepoint);
     if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);
@@ -638,17 +666,17 @@ struct PairPosFormat1
       &valueFormat1,
       len1,
       1 + len1 + len2
     };
 
     return TRACE_RETURN (c->check_struct (this) && coverage.sanitize (c, this) && pairSet.sanitize (c, this, &closure));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of subtable */
   ValueFormat	valueFormat1;		/* Defines the types of data in
 					 * ValueRecord1--for the first glyph
 					 * in the pair--may be zero (0) */
   ValueFormat	valueFormat2;		/* Defines the types of data in
@@ -661,16 +689,22 @@ struct PairPosFormat1
   DEFINE_SIZE_ARRAY (10, pairSet);
 };
 
 struct PairPosFormat2
 {
   friend struct PairPos;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    return this+coverage;
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     hb_apply_context_t::mark_skipping_forward_iterator_t skippy_iter (c, c->buffer->idx, 1);
     if (skippy_iter.has_no_chance ()) return TRACE_RETURN (false);
 
     unsigned int index = (this+coverage) (c->buffer->cur().codepoint);
     if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);
@@ -710,17 +744,17 @@ struct PairPosFormat2
     unsigned int stride = len1 + len2;
     unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();
     unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;
     return TRACE_RETURN (c->check_array (values, record_size, count) &&
 			 valueFormat1.sanitize_values_stride_unsafe (c, this, &values[0], count, stride) &&
 			 valueFormat2.sanitize_values_stride_unsafe (c, this, &values[len1], count, stride));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 2 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of subtable */
   ValueFormat	valueFormat1;		/* ValueRecord definition--for the
 					 * first glyph of the pair--may be zero
 					 * (0) */
   ValueFormat	valueFormat2;		/* ValueRecord definition--for the
@@ -745,16 +779,26 @@ struct PairPosFormat2
   DEFINE_SIZE_ARRAY (16, values);
 };
 
 struct PairPos
 {
   friend struct PosLookupSubTable;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.get_coverage ();
+    case 2: return u.format2.get_coverage ();
+    default:return Null(Coverage);
+    }
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.apply (c));
     case 2: return TRACE_RETURN (u.format2.apply (c));
     default:return TRACE_RETURN (false);
     }
@@ -765,17 +809,17 @@ struct PairPos
     if (!u.format.sanitize (c)) return TRACE_RETURN (false);
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     case 2: return TRACE_RETURN (u.format2.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   PairPosFormat1	format1;
   PairPosFormat2	format2;
   } u;
 };
 
 
@@ -783,17 +827,17 @@ struct EntryExitRecord
 {
   friend struct CursivePosFormat1;
 
   inline bool sanitize (hb_sanitize_context_t *c, void *base) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (entryAnchor.sanitize (c, base) && exitAnchor.sanitize (c, base));
   }
 
-  private:
+  protected:
   OffsetTo<Anchor>
 		entryAnchor;		/* Offset to EntryAnchor table--from
 					 * beginning of CursivePos
 					 * subtable--may be NULL */
   OffsetTo<Anchor>
 		exitAnchor;		/* Offset to ExitAnchor table--from
 					 * beginning of CursivePos
 					 * subtable--may be NULL */
@@ -801,16 +845,22 @@ struct EntryExitRecord
   DEFINE_SIZE_STATIC (4);
 };
 
 struct CursivePosFormat1
 {
   friend struct CursivePos;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    return this+coverage;
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
 
     /* We don't handle mark glyphs here. */
     if (c->property & HB_OT_LAYOUT_GLYPH_CLASS_MARK) return TRACE_RETURN (false);
 
     hb_apply_context_t::mark_skipping_forward_iterator_t skippy_iter (c, c->buffer->idx, 1);
@@ -888,33 +938,42 @@ struct CursivePosFormat1
     return TRACE_RETURN (true);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (coverage.sanitize (c, this) && entryExitRecord.sanitize (c, this));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of subtable */
   ArrayOf<EntryExitRecord>
 		entryExitRecord;	/* Array of EntryExit records--in
 					 * Coverage Index order */
   public:
   DEFINE_SIZE_ARRAY (6, entryExitRecord);
 };
 
 struct CursivePos
 {
   friend struct PosLookupSubTable;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.get_coverage ();
+    default:return Null(Coverage);
+    }
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.apply (c));
     default:return TRACE_RETURN (false);
     }
   }
@@ -923,17 +982,17 @@ struct CursivePos
     TRACE_SANITIZE ();
     if (!u.format.sanitize (c)) return TRACE_RETURN (false);
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   CursivePosFormat1	format1;
   } u;
 };
 
 
 typedef AnchorMatrix BaseArray;		/* base-major--
@@ -941,43 +1000,54 @@ typedef AnchorMatrix BaseArray;		/* base
 					 * mark-minor--
 					 * ordered by class--zero-based. */
 
 struct MarkBasePosFormat1
 {
   friend struct MarkBasePos;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    return this+markCoverage;
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     unsigned int mark_index = (this+markCoverage) (c->buffer->cur().codepoint);
     if (likely (mark_index == NOT_COVERED)) return TRACE_RETURN (false);
 
     /* now we search backwards for a non-mark glyph */
     unsigned int property;
     hb_apply_context_t::mark_skipping_backward_iterator_t skippy_iter (c, c->buffer->idx, 1);
-    if (!skippy_iter.prev (&property, LookupFlag::IgnoreMarks)) return TRACE_RETURN (false);
+    do {
+      if (!skippy_iter.prev (&property, LookupFlag::IgnoreMarks)) return TRACE_RETURN (false);
+      /* We only want to attach to the first of a MultipleSubst sequence.  Reject others. */
+      if (0 == get_lig_comp (c->buffer->info[skippy_iter.idx])) break;
+      skippy_iter.reject ();
+    } while (1);
 
     /* The following assertion is too strong, so we've disabled it. */
     if (!(property & HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH)) {/*return TRACE_RETURN (false);*/}
 
     unsigned int base_index = (this+baseCoverage) (c->buffer->info[skippy_iter.idx].codepoint);
     if (base_index == NOT_COVERED) return TRACE_RETURN (false);
 
     return TRACE_RETURN ((this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, skippy_iter.idx));
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) && markCoverage.sanitize (c, this) && baseCoverage.sanitize (c, this) &&
 			 markArray.sanitize (c, this) && baseArray.sanitize (c, this, (unsigned int) classCount));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   OffsetTo<Coverage>
 		markCoverage;		/* Offset to MarkCoverage table--from
 					 * beginning of MarkBasePos subtable */
   OffsetTo<Coverage>
 		baseCoverage;		/* Offset to BaseCoverage table--from
 					 * beginning of MarkBasePos subtable */
   USHORT	classCount;		/* Number of classes defined for marks */
@@ -991,16 +1061,25 @@ struct MarkBasePosFormat1
   DEFINE_SIZE_STATIC (12);
 };
 
 struct MarkBasePos
 {
   friend struct PosLookupSubTable;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.get_coverage ();
+    default:return Null(Coverage);
+    }
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.apply (c));
     default:return TRACE_RETURN (false);
     }
   }
@@ -1009,17 +1088,17 @@ struct MarkBasePos
     TRACE_SANITIZE ();
     if (!u.format.sanitize (c)) return TRACE_RETURN (false);
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   MarkBasePosFormat1	format1;
   } u;
 };
 
 
 typedef AnchorMatrix LigatureAttach;	/* component-major--
@@ -1032,16 +1111,22 @@ typedef OffsetListOf<LigatureAttach> Lig
 					 * tables ordered by
 					 * LigatureCoverage Index */
 
 struct MarkLigPosFormat1
 {
   friend struct MarkLigPos;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    return this+markCoverage;
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     unsigned int mark_index = (this+markCoverage) (c->buffer->cur().codepoint);
     if (likely (mark_index == NOT_COVERED)) return TRACE_RETURN (false);
 
     /* now we search backwards for a non-mark glyph */
     unsigned int property;
@@ -1057,42 +1142,39 @@ struct MarkLigPosFormat1
 
     const LigatureArray& lig_array = this+ligatureArray;
     const LigatureAttach& lig_attach = lig_array[lig_index];
 
     /* Find component to attach to */
     unsigned int comp_count = lig_attach.rows;
     if (unlikely (!comp_count)) return TRACE_RETURN (false);
 
-    unsigned int comp_index;
     /* We must now check whether the ligature ID of the current mark glyph
      * is identical to the ligature ID of the found ligature.  If yes, we
      * can directly use the component index.  If not, we attach the mark
      * glyph to the last component of the ligature. */
-    if (get_lig_id (c->buffer->info[j]) &&
-	get_lig_id (c->buffer->cur()) &&
-	get_lig_comp (c->buffer->cur()) > 0)
-    {
-      comp_index = get_lig_comp (c->buffer->cur()) - 1;
-      if (comp_index >= comp_count)
-	comp_index = comp_count - 1;
-    }
+    unsigned int comp_index;
+    unsigned int lig_id = get_lig_id (c->buffer->info[j]);
+    unsigned int mark_id = get_lig_id (c->buffer->cur());
+    unsigned int mark_comp = get_lig_comp (c->buffer->cur());
+    if (lig_id && lig_id == mark_id && mark_comp > 0)
+      comp_index = MIN (comp_count, get_lig_comp (c->buffer->cur())) - 1;
     else
       comp_index = comp_count - 1;
 
     return TRACE_RETURN ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j));
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) && markCoverage.sanitize (c, this) && ligatureCoverage.sanitize (c, this) &&
 			 markArray.sanitize (c, this) && ligatureArray.sanitize (c, this, (unsigned int) classCount));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   OffsetTo<Coverage>
 		markCoverage;		/* Offset to Mark Coverage table--from
 					 * beginning of MarkLigPos subtable */
   OffsetTo<Coverage>
 		ligatureCoverage;	/* Offset to Ligature Coverage
 					 * table--from beginning of MarkLigPos
 					 * subtable */
@@ -1107,16 +1189,25 @@ struct MarkLigPosFormat1
   DEFINE_SIZE_STATIC (12);
 };
 
 struct MarkLigPos
 {
   friend struct PosLookupSubTable;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.get_coverage ();
+    default:return Null(Coverage);
+    }
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.apply (c));
     default:return TRACE_RETURN (false);
     }
   }
@@ -1125,17 +1216,17 @@ struct MarkLigPos
     TRACE_SANITIZE ();
     if (!u.format.sanitize (c)) return TRACE_RETURN (false);
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   MarkLigPosFormat1	format1;
   } u;
 };
 
 
 typedef AnchorMatrix Mark2Array;	/* mark2-major--
@@ -1143,53 +1234,72 @@ typedef AnchorMatrix Mark2Array;	/* mark
 					 * mark1-minor--
 					 * ordered by class--zero-based. */
 
 struct MarkMarkPosFormat1
 {
   friend struct MarkMarkPos;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    return this+mark1Coverage;
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     unsigned int mark1_index = (this+mark1Coverage) (c->buffer->cur().codepoint);
     if (likely (mark1_index == NOT_COVERED)) return TRACE_RETURN (false);
 
     /* now we search backwards for a suitable mark glyph until a non-mark glyph */
     unsigned int property;
     hb_apply_context_t::mark_skipping_backward_iterator_t skippy_iter (c, c->buffer->idx, 1);
     if (!skippy_iter.prev (&property)) return TRACE_RETURN (false);
 
     if (!(property & HB_OT_LAYOUT_GLYPH_CLASS_MARK)) return TRACE_RETURN (false);
 
     unsigned int j = skippy_iter.idx;
 
-    /* Two marks match only if they belong to the same base, or same component
-     * of the same ligature.  That is, the component numbers must match, and
-     * if those are non-zero, the ligid number should also match. */
-    if ((get_lig_comp (c->buffer->cur())) ||
-	(get_lig_comp (c->buffer->info[j]) > 0 &&
-	 get_lig_id (c->buffer->cur())))
-      return TRACE_RETURN (false);
+    unsigned int id1 = get_lig_id (c->buffer->cur());
+    unsigned int id2 = get_lig_id (c->buffer->info[j]);
+    unsigned int comp1 = get_lig_comp (c->buffer->cur());
+    unsigned int comp2 = get_lig_comp (c->buffer->info[j]);
 
+    if (likely (id1 == id2)) {
+      if (id1 == 0) /* Marks belonging to the same base. */
+	goto good;
+      else if (comp1 == comp2) /* Marks belonging to the same ligature component. */
+        goto good;
+    } else {
+      /* If ligature ids don't match, it may be the case that one of the marks
+       * itself is a ligature.  In which case match. */
+      if ((id1 > 0 && !comp1) || (id2 > 0 && !comp2))
+	goto good;
+    }
+
+    /* Didn't match. */
+    return TRACE_RETURN (false);
+
+    good:
     unsigned int mark2_index = (this+mark2Coverage) (c->buffer->info[j].codepoint);
     if (mark2_index == NOT_COVERED) return TRACE_RETURN (false);
 
     return TRACE_RETURN ((this+mark1Array).apply (c, mark1_index, mark2_index, this+mark2Array, classCount, j));
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) && mark1Coverage.sanitize (c, this) &&
 			 mark2Coverage.sanitize (c, this) && mark1Array.sanitize (c, this)
 			 && mark2Array.sanitize (c, this, (unsigned int) classCount));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   OffsetTo<Coverage>
 		mark1Coverage;		/* Offset to Combining Mark1 Coverage
 					 * table--from beginning of MarkMarkPos
 					 * subtable */
   OffsetTo<Coverage>
 		mark2Coverage;		/* Offset to Combining Mark2 Coverage
 					 * table--from beginning of MarkMarkPos
@@ -1205,16 +1315,25 @@ struct MarkMarkPosFormat1
   DEFINE_SIZE_STATIC (12);
 };
 
 struct MarkMarkPos
 {
   friend struct PosLookupSubTable;
 
   private:
+
+  inline const Coverage &get_coverage (void) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.get_coverage ();
+    default:return Null(Coverage);
+    }
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.apply (c));
     default:return TRACE_RETURN (false);
     }
   }
@@ -1223,17 +1342,17 @@ struct MarkMarkPos
     TRACE_SANITIZE ();
     if (!u.format.sanitize (c)) return TRACE_RETURN (false);
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   MarkMarkPosFormat1	format1;
   } u;
 };
 
 
 static inline bool position_lookup (hb_apply_context_t *c, unsigned int lookup_index);
@@ -1270,16 +1389,18 @@ struct ExtensionPos : Extension
   private:
   inline const struct PosLookupSubTable& get_subtable (void) const
   {
     unsigned int offset = get_offset ();
     if (unlikely (!offset)) return Null(PosLookupSubTable);
     return StructAtOffset<PosLookupSubTable> (this, offset);
   }
 
+  inline const Coverage &get_coverage (void) const;
+
   inline bool apply (hb_apply_context_t *c) const;
 
   inline bool sanitize (hb_sanitize_context_t *c);
 };
 
 
 
 /*
@@ -1298,99 +1419,137 @@ struct PosLookupSubTable
     MarkBase		= 4,
     MarkLig		= 5,
     MarkMark		= 6,
     Context		= 7,
     ChainContext	= 8,
     Extension		= 9
   };
 
+  inline const Coverage &get_coverage (unsigned int lookup_type) const
+  {
+    switch (lookup_type) {
+    case Single:		return u.single.get_coverage ();
+    case Pair:			return u.pair.get_coverage ();
+    case Cursive:		return u.cursive.get_coverage ();
+    case MarkBase:		return u.markBase.get_coverage ();
+    case MarkLig:		return u.markLig.get_coverage ();
+    case MarkMark:		return u.markMark.get_coverage ();
+    case Context:		return u.context.get_coverage ();
+    case ChainContext:		return u.chainContext.get_coverage ();
+    case Extension:		return u.extension.get_coverage ();
+    default:			return Null(Coverage);
+    }
+  }
+
   inline bool apply (hb_apply_context_t *c, unsigned int lookup_type) const
   {
     TRACE_APPLY ();
     switch (lookup_type) {
     case Single:		return TRACE_RETURN (u.single.apply (c));
     case Pair:			return TRACE_RETURN (u.pair.apply (c));
     case Cursive:		return TRACE_RETURN (u.cursive.apply (c));
     case MarkBase:		return TRACE_RETURN (u.markBase.apply (c));
     case MarkLig:		return TRACE_RETURN (u.markLig.apply (c));
     case MarkMark:		return TRACE_RETURN (u.markMark.apply (c));
-    case Context:		return TRACE_RETURN (u.c.apply (c));
+    case Context:		return TRACE_RETURN (u.context.apply (c));
     case ChainContext:		return TRACE_RETURN (u.chainContext.apply (c));
     case Extension:		return TRACE_RETURN (u.extension.apply (c));
     default:			return TRACE_RETURN (false);
     }
   }
 
   inline bool sanitize (hb_sanitize_context_t *c, unsigned int lookup_type) {
     TRACE_SANITIZE ();
+    if (!u.header.sub_format.sanitize (c))
+      return TRACE_RETURN (false);
     switch (lookup_type) {
     case Single:		return TRACE_RETURN (u.single.sanitize (c));
     case Pair:			return TRACE_RETURN (u.pair.sanitize (c));
     case Cursive:		return TRACE_RETURN (u.cursive.sanitize (c));
     case MarkBase:		return TRACE_RETURN (u.markBase.sanitize (c));
     case MarkLig:		return TRACE_RETURN (u.markLig.sanitize (c));
     case MarkMark:		return TRACE_RETURN (u.markMark.sanitize (c));
-    case Context:		return TRACE_RETURN (u.c.sanitize (c));
+    case Context:		return TRACE_RETURN (u.context.sanitize (c));
     case ChainContext:		return TRACE_RETURN (u.chainContext.sanitize (c));
     case Extension:		return TRACE_RETURN (u.extension.sanitize (c));
     default:			return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
-  USHORT		sub_format;
+  struct {
+    USHORT			sub_format;
+  } header;
   SinglePos		single;
   PairPos		pair;
   CursivePos		cursive;
   MarkBasePos		markBase;
   MarkLigPos		markLig;
   MarkMarkPos		markMark;
-  ContextPos		c;
+  ContextPos		context;
   ChainContextPos	chainContext;
   ExtensionPos		extension;
   } u;
   public:
-  DEFINE_SIZE_UNION (2, sub_format);
+  DEFINE_SIZE_UNION (2, header.sub_format);
 };
 
 
 struct PosLookup : Lookup
 {
   inline const PosLookupSubTable& get_subtable (unsigned int i) const
   { return this+CastR<OffsetArrayOf<PosLookupSubTable> > (subTable)[i]; }
 
+  template <typename set_t>
+  inline void add_coverage (set_t *glyphs) const
+  {
+    const Coverage *last = NULL;
+    unsigned int count = get_subtable_count ();
+    for (unsigned int i = 0; i < count; i++) {
+      const Coverage *c = &get_subtable (i).get_coverage (get_type ());
+      if (c != last) {
+        c->add_coverage (glyphs);
+        last = c;
+      }
+    }
+  }
+
   inline bool apply_once (hb_apply_context_t *c) const
   {
     unsigned int lookup_type = get_type ();
 
-    if (!_hb_ot_layout_check_glyph_property (c->face, &c->buffer->cur(), c->lookup_props, &c->property))
+    if (!c->check_glyph_property (&c->buffer->cur(), c->lookup_props, &c->property))
       return false;
 
-    for (unsigned int i = 0; i < get_subtable_count (); i++)
+    unsigned int count = get_subtable_count ();
+    for (unsigned int i = 0; i < count; i++)
       if (get_subtable (i).apply (c, lookup_type))
 	return true;
 
     return false;
   }
 
   inline bool apply_string (hb_apply_context_t *c) const
   {
     bool ret = false;
 
     if (unlikely (!c->buffer->len))
       return false;
 
     c->set_lookup (*this);
 
     c->buffer->idx = 0;
+
     while (c->buffer->idx < c->buffer->len)
     {
-      if ((c->buffer->cur().mask & c->lookup_mask) && apply_once (c))
+      if ((c->buffer->cur().mask & c->lookup_mask) &&
+	  c->digest.may_have (c->buffer->cur().codepoint) &&
+	  apply_once (c))
 	ret = true;
       else
 	c->buffer->idx++;
     }
 
     return ret;
   }
 
@@ -1410,21 +1569,25 @@ typedef OffsetListOf<PosLookup> PosLooku
 
 struct GPOS : GSUBGPOS
 {
   static const hb_tag_t Tag	= HB_OT_TAG_GPOS;
 
   inline const PosLookup& get_lookup (unsigned int i) const
   { return CastR<PosLookup> (GSUBGPOS::get_lookup (i)); }
 
+  template <typename set_t>
+  inline void add_coverage (set_t *glyphs, unsigned int lookup_index) const
+  { get_lookup (lookup_index).add_coverage (glyphs); }
+
   inline bool position_lookup (hb_apply_context_t *c, unsigned int lookup_index) const
   { return get_lookup (lookup_index).apply_string (c); }
 
-  static inline void position_start (hb_buffer_t *buffer);
-  static inline void position_finish (hb_buffer_t *buffer);
+  static inline void position_start (hb_font_t *font, hb_buffer_t *buffer);
+  static inline void position_finish (hb_font_t *font, hb_buffer_t *buffer, hb_bool_t zero_width_attahced_marks);
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     if (unlikely (!GSUBGPOS::sanitize (c))) return TRACE_RETURN (false);
     OffsetTo<PosLookupList> &list = CastR<OffsetTo<PosLookupList> > (lookupList);
     return TRACE_RETURN (list.sanitize (c, this));
   }
   public:
@@ -1447,73 +1610,80 @@ fix_cursive_minor_offset (hb_glyph_posit
 
     if (HB_DIRECTION_IS_HORIZONTAL (direction))
       pos[i].y_offset += pos[j].y_offset;
     else
       pos[i].x_offset += pos[j].x_offset;
 }
 
 static void
-fix_mark_attachment (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction)
+fix_mark_attachment (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, hb_bool_t zero_width_attached_marks)
 {
   if (likely (!(pos[i].attach_lookback())))
     return;
 
   unsigned int j = i - pos[i].attach_lookback();
 
-  pos[i].x_advance = 0;
-  pos[i].y_advance = 0;
+  if (zero_width_attached_marks) {
+    pos[i].x_advance = 0;
+    pos[i].y_advance = 0;
+  }
   pos[i].x_offset += pos[j].x_offset;
   pos[i].y_offset += pos[j].y_offset;
 
   if (HB_DIRECTION_IS_FORWARD (direction))
     for (unsigned int k = j; k < i; k++) {
       pos[i].x_offset -= pos[k].x_advance;
       pos[i].y_offset -= pos[k].y_advance;
     }
   else
     for (unsigned int k = j + 1; k < i + 1; k++) {
       pos[i].x_offset += pos[k].x_advance;
       pos[i].y_offset += pos[k].y_advance;
     }
 }
 
 void
-GPOS::position_start (hb_buffer_t *buffer)
+GPOS::position_start (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)
 {
   buffer->clear_positions ();
 
   unsigned int count = buffer->len;
   for (unsigned int i = 0; i < count; i++)
     buffer->pos[i].attach_lookback() = buffer->pos[i].cursive_chain() = 0;
 }
 
 void
-GPOS::position_finish (hb_buffer_t *buffer)
+GPOS::position_finish (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer, hb_bool_t zero_width_attached_marks)
 {
   unsigned int len;
   hb_glyph_position_t *pos = hb_buffer_get_glyph_positions (buffer, &len);
   hb_direction_t direction = buffer->props.direction;
 
   /* Handle cursive connections */
   for (unsigned int i = 0; i < len; i++)
     fix_cursive_minor_offset (pos, i, direction);
 
   /* Handle attachments */
   for (unsigned int i = 0; i < len; i++)
-    fix_mark_attachment (pos, i, direction);
+    fix_mark_attachment (pos, i, direction, zero_width_attached_marks);
 
   HB_BUFFER_DEALLOCATE_VAR (buffer, syllable);
   HB_BUFFER_DEALLOCATE_VAR (buffer, lig_props);
-  HB_BUFFER_DEALLOCATE_VAR (buffer, props_cache);
+  HB_BUFFER_DEALLOCATE_VAR (buffer, glyph_props);
 }
 
 
 /* Out-of-class implementation for methods recursing */
 
+inline const Coverage & ExtensionPos::get_coverage (void) const
+{
+  return get_subtable ().get_coverage (get_type ());
+}
+
 inline bool ExtensionPos::apply (hb_apply_context_t *c) const
 {
   TRACE_APPLY ();
   return TRACE_RETURN (get_subtable ().apply (c, get_type ()));
 }
 
 inline bool ExtensionPos::sanitize (hb_sanitize_context_t *c)
 {
@@ -1521,17 +1691,17 @@ inline bool ExtensionPos::sanitize (hb_s
   if (unlikely (!Extension::sanitize (c))) return TRACE_RETURN (false);
   unsigned int offset = get_offset ();
   if (unlikely (!offset)) return TRACE_RETURN (true);
   return TRACE_RETURN (StructAtOffset<PosLookupSubTable> (this, offset).sanitize (c, get_type ()));
 }
 
 static inline bool position_lookup (hb_apply_context_t *c, unsigned int lookup_index)
 {
-  const GPOS &gpos = *(c->face->ot_layout->gpos);
+  const GPOS &gpos = *(hb_ot_layout_from_face (c->face)->gpos);
   const PosLookup &l = gpos.get_lookup (lookup_index);
 
   if (unlikely (c->nesting_level_left == 0))
     return false;
 
   hb_apply_context_t new_c (*c);
   new_c.nesting_level_left--;
   new_c.set_lookup (l);
diff --git a/gfx/harfbuzz/src/hb-ot-layout-gsub-table.hh b/gfx/harfbuzz/src/hb-ot-layout-gsub-table.hh
--- a/gfx/harfbuzz/src/hb-ot-layout-gsub-table.hh
+++ b/gfx/harfbuzz/src/hb-ot-layout-gsub-table.hh
@@ -45,19 +45,19 @@ struct SingleSubstFormat1
     Coverage::Iter iter;
     for (iter.init (this+coverage); iter.more (); iter.next ()) {
       hb_codepoint_t glyph_id = iter.get_glyph ();
       if (c->glyphs->has (glyph_id))
 	c->glyphs->add ((glyph_id + deltaGlyphID) & 0xFFFF);
     }
   }
 
-  inline bool would_apply (hb_codepoint_t glyph_id) const
+  inline const Coverage &get_coverage (void) const
   {
-    return (this+coverage) (glyph_id) != NOT_COVERED;
+    return this+coverage;
   }
 
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     hb_codepoint_t glyph_id = c->buffer->cur().codepoint;
     unsigned int index = (this+coverage) (glyph_id);
     if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);
@@ -70,17 +70,17 @@ struct SingleSubstFormat1
     return TRACE_RETURN (true);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (coverage.sanitize (c, this) && deltaGlyphID.sanitize (c));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of Substitution table */
   SHORT		deltaGlyphID;		/* Add to original GlyphID to get
 					 * substitute GlyphID */
   public:
   DEFINE_SIZE_STATIC (6);
@@ -97,19 +97,19 @@ struct SingleSubstFormat2
     TRACE_CLOSURE ();
     Coverage::Iter iter;
     for (iter.init (this+coverage); iter.more (); iter.next ()) {
       if (c->glyphs->has (iter.get_glyph ()))
 	c->glyphs->add (substitute[iter.get_coverage ()]);
     }
   }
 
-  inline bool would_apply (hb_codepoint_t glyph_id) const
+  inline const Coverage &get_coverage (void) const
   {
-    return (this+coverage) (glyph_id) != NOT_COVERED;
+    return this+coverage;
   }
 
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     hb_codepoint_t glyph_id = c->buffer->cur().codepoint;
     unsigned int index = (this+coverage) (glyph_id);
     if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);
@@ -122,17 +122,17 @@ struct SingleSubstFormat2
     return TRACE_RETURN (true);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (coverage.sanitize (c, this) && substitute.sanitize (c));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 2 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of Substitution table */
   ArrayOf<GlyphID>
 		substitute;		/* Array of substitute
 					 * GlyphIDs--ordered by Coverage Index */
   public:
@@ -150,22 +150,22 @@ struct SingleSubst
     TRACE_CLOSURE ();
     switch (u.format) {
     case 1: u.format1.closure (c); break;
     case 2: u.format2.closure (c); break;
     default:                       break;
     }
   }
 
-  inline bool would_apply (hb_codepoint_t glyph_id) const
+  inline const Coverage &get_coverage (void) const
   {
     switch (u.format) {
-    case 1: return u.format1.would_apply (glyph_id);
-    case 2: return u.format2.would_apply (glyph_id);
-    default:return false;
+    case 1: return u.format1.get_coverage ();
+    case 2: return u.format2.get_coverage ();
+    default:return Null(Coverage);
     }
   }
 
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.apply (c));
@@ -179,17 +179,17 @@ struct SingleSubst
     if (!u.format.sanitize (c)) return TRACE_RETURN (false);
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     case 2: return TRACE_RETURN (u.format2.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   SingleSubstFormat1	format1;
   SingleSubstFormat2	format2;
   } u;
 };
 
 
@@ -208,28 +208,33 @@ struct Sequence
   }
 
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     if (unlikely (!substitute.len)) return TRACE_RETURN (false);
 
     unsigned int klass = c->property & HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE ? HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH : 0;
-    c->replace_glyphs_be16 (1, substitute.len, (const uint16_t *) substitute.array, klass);
+    unsigned int count = substitute.len;
+    for (unsigned int i = 0; i < count; i++) {
+      set_lig_props_for_component (c->buffer->cur(), i);
+      c->output_glyph (substitute.array[i], klass);
+    }
+    c->buffer->skip_glyph ();
 
     return TRACE_RETURN (true);
   }
 
   public:
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (substitute.sanitize (c));
   }
 
-  private:
+  protected:
   ArrayOf<GlyphID>
 		substitute;		/* String of GlyphIDs to substitute */
   public:
   DEFINE_SIZE_ARRAY (2, substitute);
 };
 
 struct MultipleSubstFormat1
 {
@@ -242,19 +247,19 @@ struct MultipleSubstFormat1
     TRACE_CLOSURE ();
     Coverage::Iter iter;
     for (iter.init (this+coverage); iter.more (); iter.next ()) {
       if (c->glyphs->has (iter.get_glyph ()))
 	(this+sequence[iter.get_coverage ()]).closure (c);
     }
   }
 
-  inline bool would_apply (hb_codepoint_t glyph_id) const
+  inline const Coverage &get_coverage (void) const
   {
-    return (this+coverage) (glyph_id) != NOT_COVERED;
+    return this+coverage;
   }
 
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
 
     unsigned int index = (this+coverage) (c->buffer->cur().codepoint);
     if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);
@@ -262,17 +267,17 @@ struct MultipleSubstFormat1
     return TRACE_RETURN ((this+sequence[index]).apply (c));
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (coverage.sanitize (c, this) && sequence.sanitize (c, this));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of Substitution table */
   OffsetArrayOf<Sequence>
 		sequence;		/* Array of Sequence tables
 					 * ordered by Coverage Index */
   public:
@@ -289,21 +294,21 @@ struct MultipleSubst
   {
     TRACE_CLOSURE ();
     switch (u.format) {
     case 1: u.format1.closure (c); break;
     default:                       break;
     }
   }
 
-  inline bool would_apply (hb_codepoint_t glyph_id) const
+  inline const Coverage &get_coverage (void) const
   {
     switch (u.format) {
-    case 1: return u.format1.would_apply (glyph_id);
-    default:return false;
+    case 1: return u.format1.get_coverage ();
+    default:return Null(Coverage);
     }
   }
 
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.apply (c));
@@ -315,17 +320,17 @@ struct MultipleSubst
     TRACE_SANITIZE ();
     if (!u.format.sanitize (c)) return TRACE_RETURN (false);
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   MultipleSubstFormat1	format1;
   } u;
 };
 
 
 typedef ArrayOf<GlyphID> AlternateSet;	/* Array of alternate GlyphIDs--in
@@ -346,19 +351,19 @@ struct AlternateSubstFormat1
 	const AlternateSet &alt_set = this+alternateSet[iter.get_coverage ()];
 	unsigned int count = alt_set.len;
 	for (unsigned int i = 0; i < count; i++)
 	  c->glyphs->add (alt_set[i]);
       }
     }
   }
 
-  inline bool would_apply (hb_codepoint_t glyph_id) const
+  inline const Coverage &get_coverage (void) const
   {
-    return (this+coverage) (glyph_id) != NOT_COVERED;
+    return this+coverage;
   }
 
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     hb_codepoint_t glyph_id = c->buffer->cur().codepoint;
 
     unsigned int index = (this+coverage) (glyph_id);
@@ -384,17 +389,17 @@ struct AlternateSubstFormat1
     return TRACE_RETURN (true);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (coverage.sanitize (c, this) && alternateSet.sanitize (c, this));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of Substitution table */
   OffsetArrayOf<AlternateSet>
 		alternateSet;		/* Array of AlternateSet tables
 					 * ordered by Coverage Index */
   public:
@@ -411,21 +416,21 @@ struct AlternateSubst
   {
     TRACE_CLOSURE ();
     switch (u.format) {
     case 1: u.format1.closure (c); break;
     default:                       break;
     }
   }
 
-  inline bool would_apply (hb_codepoint_t glyph_id) const
+  inline const Coverage &get_coverage (void) const
   {
     switch (u.format) {
-    case 1: return u.format1.would_apply (glyph_id);
-    default:return false;
+    case 1: return u.format1.get_coverage ();
+    default:return Null(Coverage);
     }
   }
 
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.apply (c));
@@ -437,17 +442,17 @@ struct AlternateSubst
     TRACE_SANITIZE ();
     if (!u.format.sanitize (c)) return TRACE_RETURN (false);
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   AlternateSubstFormat1	format1;
   } u;
 };
 
 
 struct Ligature
@@ -461,88 +466,166 @@ struct Ligature
     TRACE_CLOSURE ();
     unsigned int count = component.len;
     for (unsigned int i = 1; i < count; i++)
       if (!c->glyphs->has (component[i]))
         return;
     c->glyphs->add (ligGlyph);
   }
 
-  inline bool would_apply (hb_codepoint_t second) const
+  inline bool would_apply (hb_would_apply_context_t *c) const
   {
-    return component.len == 2 && component[1] == second;
+    return c->len == 1 || (c->len == 2 && component.len == 2 && component[1] == c->second);
   }
 
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     unsigned int count = component.len;
-    if (unlikely (count < 2)) return TRACE_RETURN (false);
+    if (unlikely (count < 1)) return TRACE_RETURN (false);
 
     hb_apply_context_t::mark_skipping_forward_iterator_t skippy_iter (c, c->buffer->idx, count - 1);
     if (skippy_iter.has_no_chance ()) return TRACE_RETURN (false);
 
-    bool first_was_mark = (c->property & HB_OT_LAYOUT_GLYPH_CLASS_MARK);
-    bool found_non_mark = false;
+    /*
+     * This is perhaps the trickiest part of GSUB...  Remarks:
+     *
+     * - If all components of the ligature were marks, we call this a mark ligature.
+     *
+     * - If there is no GDEF, and the ligature is NOT a mark ligature, we categorize
+     *   it as a ligature glyph.  Though, really, this will not really be used...
+     *
+     * - If it *is* a mark ligature, we don't allocate a new ligature id, and leave
+     *   the ligature to keep its old ligature id.  This will allow it to attach to
+     *   a base ligature in GPOS.  Eg. if the sequence is: LAM,LAM,SHADDA,FATHA,HEH,
+     *   and LAM,LAM,HEH for a ligature, they will leave SHADDA and FATHA wit a
+     *   ligature id and component value of 2.  Then if SHADDA,FATHA form a ligature
+     *   later, we don't want them to lose their ligature id/component, otherwise
+     *   GPOS will fail to correctly position the mark ligature on top of the
+     *   LAM,LAM,HEH ligature.  See:
+     *     https://bugzilla.gnome.org/show_bug.cgi?id=676343
+     *
+     * - If a ligature is formed of components that some of which are also ligatures
+     *   themselves, and those ligature components had marks attached to *their*
+     *   components, we have to attach the marks to the new ligature component
+     *   positions!  Now *that*'s tricky!  And these marks may be following the
+     *   last component of the whole sequence, so we should loop forward looking
+     *   for them and update them.
+     *
+     *   Eg. the sequence is LAM,LAM,SHADDA,FATHA,HEH, and the font first forms a
+     *   'calt' ligature of LAM,HEH, leaving the SHADDA and FATHA with a ligature
+     *   id and component == 1.  Now, during 'liga', the LAM and the LAM-HEH ligature
+     *   form a LAM-LAM-HEH ligature.  We need to reassign the SHADDA and FATHA to
+     *   the new ligature with a component value of 2.
+     *
+     *   This in fact happened to a font...  See:
+     *   https://bugzilla.gnome.org/show_bug.cgi?id=437633
+     *
+     * - Ligatures cannot be formed across glyphs attached to different components
+     *   of previous ligatures.  Eg. the sequence is LAM,SHADDA,LAM,FATHA,HEH, and
+     *   LAM,LAM,HEH form a ligature, leaving SHADDA,FATHA next to eachother.
+     *   However, it would be wrong to ligate that SHADDA,FATHA sequence.o
+     *   There is an exception to this: If a ligature tries ligating with marks that
+     *   belong to it itself, go ahead, assuming that the font designer knows what
+     *   they are doing (otherwise it can break Indic stuff when a matra wants to
+     *   ligate with a conjunct...)
+     */
+
+    bool is_mark_ligature = !!(c->property & HB_OT_LAYOUT_GLYPH_CLASS_MARK);
+
+    unsigned int total_component_count = 0;
+    total_component_count += get_lig_num_comps (c->buffer->cur());
+
+    unsigned int first_lig_id = get_lig_id (c->buffer->cur());
+    unsigned int first_lig_comp = get_lig_comp (c->buffer->cur());
 
     for (unsigned int i = 1; i < count; i++)
     {
       unsigned int property;
 
       if (!skippy_iter.next (&property)) return TRACE_RETURN (false);
 
-      found_non_mark |= !(property & HB_OT_LAYOUT_GLYPH_CLASS_MARK);
+      if (likely (c->buffer->info[skippy_iter.idx].codepoint != component[i])) return TRACE_RETURN (false);
 
-      if (likely (c->buffer->info[skippy_iter.idx].codepoint != component[i])) return TRACE_RETURN (false);
+      unsigned int this_lig_id = get_lig_id (c->buffer->info[skippy_iter.idx]);
+      unsigned int this_lig_comp = get_lig_comp (c->buffer->info[skippy_iter.idx]);
+
+      if (first_lig_id && first_lig_comp) {
+        /* If first component was attached to a previous ligature component,
+	 * all subsequent components should be attached to the same ligature
+	 * component, otherwise we shouldn't ligate them. */
+        if (first_lig_id != this_lig_id || first_lig_comp != this_lig_comp)
+	  return TRACE_RETURN (false);
+      } else {
+        /* If first component was NOT attached to a previous ligature component,
+	 * all subsequent components should also NOT be attached to any ligature
+	 * component, unless they are attached to the first component itself! */
+        if (this_lig_id && this_lig_comp && (this_lig_id != first_lig_id))
+	  return TRACE_RETURN (false);
+      }
+
+      is_mark_ligature = is_mark_ligature && (property & HB_OT_LAYOUT_GLYPH_CLASS_MARK);
+      total_component_count += get_lig_num_comps (c->buffer->info[skippy_iter.idx]);
     }
 
-    unsigned int klass = first_was_mark && found_non_mark ? HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE : 0;
+    /* Deal, we are forming the ligature. */
+    c->buffer->merge_clusters (c->buffer->idx, skippy_iter.idx + 1);
 
-    /* Allocate new ligature id */
-    unsigned int lig_id = allocate_lig_id (c->buffer);
-    set_lig_props (c->buffer->cur(), lig_id, 0);
+    unsigned int klass = is_mark_ligature ? 0 : HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE;
+    unsigned int lig_id = is_mark_ligature ? 0 : allocate_lig_id (c->buffer);
+    unsigned int last_lig_id = get_lig_id (c->buffer->cur());
+    unsigned int last_num_components = get_lig_num_comps (c->buffer->cur());
+    unsigned int components_so_far = last_num_components;
 
-    if (skippy_iter.idx < c->buffer->idx + count) /* No input glyphs skipped */
+    if (!is_mark_ligature)
+      set_lig_props_for_ligature (c->buffer->cur(), lig_id, total_component_count);
+    c->replace_glyph (ligGlyph, klass);
+
+    for (unsigned int i = 1; i < count; i++)
     {
-      c->replace_glyphs_be16 (count, 1, (const uint16_t *) &ligGlyph, klass);
+      while (c->should_mark_skip_current_glyph ())
+      {
+	if (!is_mark_ligature) {
+	  unsigned int new_lig_comp = components_so_far - last_num_components +
+				      MIN (MAX (get_lig_comp (c->buffer->cur()), 1u), last_num_components);
+	  set_lig_props_for_mark (c->buffer->cur(), lig_id, new_lig_comp);
+	}
+	c->buffer->next_glyph ();
+      }
+
+      last_lig_id = get_lig_id (c->buffer->cur());
+      last_num_components = get_lig_num_comps (c->buffer->cur());
+      components_so_far += last_num_components;
+
+      /* Skip the base glyph */
+      c->buffer->idx++;
     }
-    else
-    {
-      c->replace_glyph (ligGlyph);
 
-      /* Now we must do a second loop to copy the skipped glyphs to
-	 `out' and assign component values to it.  We start with the
-	 glyph after the first component.  Glyphs between component
-	 i and i+1 belong to component i.  Together with the lig_id
-	 value it is later possible to check whether a specific
-	 component value really belongs to a given ligature. */
-
-      for (unsigned int i = 1; i < count; i++)
-      {
-	while (c->should_mark_skip_current_glyph ())
-	{
-	  set_lig_props (c->buffer->cur(),  lig_id, i);
-	  c->replace_glyph (c->buffer->cur().codepoint);
-	}
-
-	/* Skip the base glyph */
-	c->buffer->idx++;
+    if (!is_mark_ligature && last_lig_id) {
+      /* Re-adjust components for any marks following. */
+      for (unsigned int i = c->buffer->idx; i < c->buffer->len; i++) {
+	if (last_lig_id == get_lig_id (c->buffer->info[i])) {
+	  unsigned int new_lig_comp = components_so_far - last_num_components +
+				      MIN (MAX (get_lig_comp (c->buffer->info[i]), 1u), last_num_components);
+	  set_lig_props_for_mark (c->buffer->info[i], lig_id, new_lig_comp);
+	} else
+	  break;
       }
     }
 
     return TRACE_RETURN (true);
   }
 
   public:
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (ligGlyph.sanitize (c) && component.sanitize (c));
   }
 
-  private:
+  protected:
   GlyphID	ligGlyph;		/* GlyphID of ligature to substitute */
   HeadlessArrayOf<GlyphID>
 		component;		/* Array of component GlyphIDs--start
 					 * with the second  component--ordered
 					 * in writing direction */
   public:
   DEFINE_SIZE_ARRAY (4, component);
 };
@@ -556,23 +639,23 @@ struct LigatureSet
   inline void closure (hb_closure_context_t *c) const
   {
     TRACE_CLOSURE ();
     unsigned int num_ligs = ligature.len;
     for (unsigned int i = 0; i < num_ligs; i++)
       (this+ligature[i]).closure (c);
   }
 
-  inline bool would_apply (hb_codepoint_t second) const
+  inline bool would_apply (hb_would_apply_context_t *c) const
   {
     unsigned int num_ligs = ligature.len;
     for (unsigned int i = 0; i < num_ligs; i++)
     {
       const Ligature &lig = this+ligature[i];
-      if (lig.would_apply (second))
+      if (lig.would_apply (c))
         return true;
     }
     return false;
   }
 
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
@@ -587,17 +670,17 @@ struct LigatureSet
   }
 
   public:
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (ligature.sanitize (c, this));
   }
 
-  private:
+  protected:
   OffsetArrayOf<Ligature>
 		ligature;		/* Array LigatureSet tables
 					 * ordered by preference */
   public:
   DEFINE_SIZE_ARRAY (2, ligature);
 };
 
 struct LigatureSubstFormat1
@@ -611,21 +694,24 @@ struct LigatureSubstFormat1
     TRACE_CLOSURE ();
     Coverage::Iter iter;
     for (iter.init (this+coverage); iter.more (); iter.next ()) {
       if (c->glyphs->has (iter.get_glyph ()))
 	(this+ligatureSet[iter.get_coverage ()]).closure (c);
     }
   }
 
-  inline bool would_apply (hb_codepoint_t first, hb_codepoint_t second) const
+  inline const Coverage &get_coverage (void) const
   {
-    unsigned int index;
-    return (index = (this+coverage) (first)) != NOT_COVERED &&
-	   (this+ligatureSet[index]).would_apply (second);
+    return this+coverage;
+  }
+
+  inline bool would_apply (hb_would_apply_context_t *c) const
+  {
+    return (this+ligatureSet[(this+coverage) (c->first)]).would_apply (c);
   }
 
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     hb_codepoint_t glyph_id = c->buffer->cur().codepoint;
 
     unsigned int index = (this+coverage) (glyph_id);
@@ -635,17 +721,17 @@ struct LigatureSubstFormat1
     return TRACE_RETURN (lig_set.apply (c));
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (coverage.sanitize (c, this) && ligatureSet.sanitize (c, this));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of Substitution table */
   OffsetArrayOf<LigatureSet>
 		ligatureSet;		/* Array LigatureSet tables
 					 * ordered by Coverage Index */
   public:
@@ -662,20 +748,28 @@ struct LigatureSubst
   {
     TRACE_CLOSURE ();
     switch (u.format) {
     case 1: u.format1.closure (c); break;
     default:                       break;
     }
   }
 
-  inline bool would_apply (hb_codepoint_t first, hb_codepoint_t second) const
+  inline const Coverage &get_coverage (void) const
   {
     switch (u.format) {
-    case 1: return u.format1.would_apply (first, second);
+    case 1: return u.format1.get_coverage ();
+    default:return Null(Coverage);
+    }
+  }
+
+  inline bool would_apply (hb_would_apply_context_t *c) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.would_apply (c);
     default:return false;
     }
   }
 
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     switch (u.format) {
@@ -688,17 +782,17 @@ struct LigatureSubst
     TRACE_SANITIZE ();
     if (!u.format.sanitize (c)) return TRACE_RETURN (false);
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   LigatureSubstFormat1	format1;
   } u;
 };
 
 
 static inline bool substitute_lookup (hb_apply_context_t *c, unsigned int lookup_index);
@@ -752,18 +846,20 @@ struct ExtensionSubst : Extension
   inline const struct SubstLookupSubTable& get_subtable (void) const
   {
     unsigned int offset = get_offset ();
     if (unlikely (!offset)) return Null(SubstLookupSubTable);
     return StructAtOffset<SubstLookupSubTable> (this, offset);
   }
 
   inline void closure (hb_closure_context_t *c) const;
-  inline bool would_apply (hb_codepoint_t glyph_id) const;
-  inline bool would_apply (hb_codepoint_t first, hb_codepoint_t second) const;
+
+  inline const Coverage &get_coverage (void) const;
+
+  inline bool would_apply (hb_would_apply_context_t *c) const;
 
   inline bool apply (hb_apply_context_t *c) const;
 
   inline bool sanitize (hb_sanitize_context_t *c);
 
   inline bool is_reverse (void) const;
 };
 
@@ -794,16 +890,21 @@ struct ReverseChainSingleSubstFormat1
     const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);
     Coverage::Iter iter;
     for (iter.init (this+coverage); iter.more (); iter.next ()) {
       if (c->glyphs->has (iter.get_glyph ()))
 	c->glyphs->add (substitute[iter.get_coverage ()]);
     }
   }
 
+  inline const Coverage &get_coverage (void) const
+  {
+    return this+coverage;
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     if (unlikely (c->nesting_level_left != MAX_NESTING_LEVEL))
       return TRACE_RETURN (false); /* No chaining to this type */
 
     unsigned int index = (this+coverage) (c->buffer->cur().codepoint);
     if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);
@@ -814,17 +915,17 @@ struct ReverseChainSingleSubstFormat1
     if (match_backtrack (c,
 			 backtrack.len, (USHORT *) backtrack.array,
 			 match_coverage, this) &&
         match_lookahead (c,
 			 lookahead.len, (USHORT *) lookahead.array,
 			 match_coverage, this,
 			 1))
     {
-      c->buffer->cur().codepoint = substitute[index];
+      c->replace_glyph_inplace (substitute[index]);
       c->buffer->idx--; /* Reverse! */
       return TRACE_RETURN (true);
     }
 
     return TRACE_RETURN (false);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
@@ -833,17 +934,17 @@ struct ReverseChainSingleSubstFormat1
       return TRACE_RETURN (false);
     OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);
     if (!lookahead.sanitize (c, this))
       return TRACE_RETURN (false);
     ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);
     return TRACE_RETURN (substitute.sanitize (c));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of table */
   OffsetArrayOf<Coverage>
 		backtrack;		/* Array of coverage tables
 					 * in backtracking sequence, in  glyph
 					 * sequence order */
@@ -868,16 +969,24 @@ struct ReverseChainSingleSubst
   {
     TRACE_CLOSURE ();
     switch (u.format) {
     case 1: u.format1.closure (c); break;
     default:                       break;
     }
   }
 
+  inline const Coverage &get_coverage (void) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.get_coverage ();
+    default:return Null(Coverage);
+    }
+  }
+
   inline bool apply (hb_apply_context_t *c) const
   {
     TRACE_APPLY ();
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.apply (c));
     default:return TRACE_RETURN (false);
     }
   }
@@ -886,17 +995,17 @@ struct ReverseChainSingleSubst
     TRACE_SANITIZE ();
     if (!u.format.sanitize (c)) return TRACE_RETURN (false);
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT				format;		/* Format identifier */
   ReverseChainSingleSubstFormat1	format1;
   } u;
 };
 
 
 
@@ -923,91 +1032,106 @@ struct SubstLookupSubTable
 		       unsigned int    lookup_type) const
   {
     TRACE_CLOSURE ();
     switch (lookup_type) {
     case Single:		u.single.closure (c); break;
     case Multiple:		u.multiple.closure (c); break;
     case Alternate:		u.alternate.closure (c); break;
     case Ligature:		u.ligature.closure (c); break;
-    case Context:		u.c.closure (c); break;
+    case Context:		u.context.closure (c); break;
     case ChainContext:		u.chainContext.closure (c); break;
     case Extension:		u.extension.closure (c); break;
     case ReverseChainSingle:	u.reverseChainContextSingle.closure (c); break;
     default:                    break;
     }
   }
 
-  inline bool would_apply (hb_codepoint_t glyph_id,
+  inline const Coverage &get_coverage (unsigned int lookup_type) const
+  {
+    switch (lookup_type) {
+    case Single:		return u.single.get_coverage ();
+    case Multiple:		return u.multiple.get_coverage ();
+    case Alternate:		return u.alternate.get_coverage ();
+    case Ligature:		return u.ligature.get_coverage ();
+    case Context:		return u.context.get_coverage ();
+    case ChainContext:		return u.chainContext.get_coverage ();
+    case Extension:		return u.extension.get_coverage ();
+    case ReverseChainSingle:	return u.reverseChainContextSingle.get_coverage ();
+    default:			return Null(Coverage);
+    }
+  }
+
+  inline bool would_apply (hb_would_apply_context_t *c,
 			   unsigned int lookup_type) const
   {
+    TRACE_WOULD_APPLY ();
+    if (get_coverage (lookup_type).get_coverage (c->first) == NOT_COVERED) return false;
+    if (c->len == 1) return true; /* Done! */
+
+    /* Only need to look further for lookups that support substitutions
+     * of input longer than 1. */
     switch (lookup_type) {
-    case Single:		return u.single.would_apply (glyph_id);
-    case Multiple:		return u.multiple.would_apply (glyph_id);
-    case Alternate:		return u.alternate.would_apply (glyph_id);
-    case Extension:		return u.extension.would_apply (glyph_id);
-    default:			return false;
-    }
-  }
-  inline bool would_apply (hb_codepoint_t first,
-			   hb_codepoint_t second,
-			   unsigned int lookup_type) const
-  {
-    switch (lookup_type) {
-    case Ligature:		return u.ligature.would_apply (first, second);
-    case Extension:		return u.extension.would_apply (first, second);
+    case Ligature:		return u.ligature.would_apply (c);
+    case Context:		return u.context.would_apply (c);
+    case ChainContext:		return u.chainContext.would_apply (c);
+    case Extension:		return u.extension.would_apply (c);
     default:			return false;
     }
   }
 
   inline bool apply (hb_apply_context_t *c, unsigned int lookup_type) const
   {
     TRACE_APPLY ();
     switch (lookup_type) {
     case Single:		return TRACE_RETURN (u.single.apply (c));
     case Multiple:		return TRACE_RETURN (u.multiple.apply (c));
     case Alternate:		return TRACE_RETURN (u.alternate.apply (c));
     case Ligature:		return TRACE_RETURN (u.ligature.apply (c));
-    case Context:		return TRACE_RETURN (u.c.apply (c));
+    case Context:		return TRACE_RETURN (u.context.apply (c));
     case ChainContext:		return TRACE_RETURN (u.chainContext.apply (c));
     case Extension:		return TRACE_RETURN (u.extension.apply (c));
     case ReverseChainSingle:	return TRACE_RETURN (u.reverseChainContextSingle.apply (c));
     default:			return TRACE_RETURN (false);
     }
   }
 
   inline bool sanitize (hb_sanitize_context_t *c, unsigned int lookup_type) {
     TRACE_SANITIZE ();
+    if (!u.header.sub_format.sanitize (c))
+      return TRACE_RETURN (false);
     switch (lookup_type) {
     case Single:		return TRACE_RETURN (u.single.sanitize (c));
     case Multiple:		return TRACE_RETURN (u.multiple.sanitize (c));
     case Alternate:		return TRACE_RETURN (u.alternate.sanitize (c));
     case Ligature:		return TRACE_RETURN (u.ligature.sanitize (c));
-    case Context:		return TRACE_RETURN (u.c.sanitize (c));
+    case Context:		return TRACE_RETURN (u.context.sanitize (c));
     case ChainContext:		return TRACE_RETURN (u.chainContext.sanitize (c));
     case Extension:		return TRACE_RETURN (u.extension.sanitize (c));
     case ReverseChainSingle:	return TRACE_RETURN (u.reverseChainContextSingle.sanitize (c));
     default:			return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
-  USHORT			sub_format;
+  struct {
+    USHORT			sub_format;
+  } header;
   SingleSubst			single;
   MultipleSubst			multiple;
   AlternateSubst		alternate;
   LigatureSubst			ligature;
-  ContextSubst			c;
+  ContextSubst			context;
   ChainContextSubst		chainContext;
   ExtensionSubst		extension;
   ReverseChainSingleSubst	reverseChainContextSingle;
   } u;
   public:
-  DEFINE_SIZE_UNION (2, sub_format);
+  DEFINE_SIZE_UNION (2, header.sub_format);
 };
 
 
 struct SubstLookup : Lookup
 {
   inline const SubstLookupSubTable& get_subtable (unsigned int i) const
   { return this+CastR<OffsetArrayOf<SubstLookupSubTable> > (subTable)[i]; }
 
@@ -1025,56 +1149,48 @@ struct SubstLookup : Lookup
   inline void closure (hb_closure_context_t *c) const
   {
     unsigned int lookup_type = get_type ();
     unsigned int count = get_subtable_count ();
     for (unsigned int i = 0; i < count; i++)
       get_subtable (i).closure (c, lookup_type);
   }
 
-  inline bool would_apply (hb_codepoint_t glyph_id) const
+  template <typename set_t>
+  inline void add_coverage (set_t *glyphs) const
   {
+    const Coverage *last = NULL;
+    unsigned int count = get_subtable_count ();
+    for (unsigned int i = 0; i < count; i++) {
+      const Coverage *c = &get_subtable (i).get_coverage (get_type ());
+      if (c != last) {
+        c->add_coverage (glyphs);
+        last = c;
+      }
+    }
+  }
+
+  inline bool would_apply (hb_would_apply_context_t *c) const
+  {
+    if (!c->digest.may_have (c->first)) return false;
     unsigned int lookup_type = get_type ();
     unsigned int count = get_subtable_count ();
     for (unsigned int i = 0; i < count; i++)
-      if (get_subtable (i).would_apply (glyph_id, lookup_type))
-	return true;
-    return false;
-  }
-  inline bool would_apply (hb_codepoint_t first, hb_codepoint_t second) const
-  {
-    unsigned int lookup_type = get_type ();
-    unsigned int count = get_subtable_count ();
-    for (unsigned int i = 0; i < count; i++)
-      if (get_subtable (i).would_apply (first, second, lookup_type))
+      if (get_subtable (i).would_apply (c, lookup_type))
 	return true;
     return false;
   }
 
   inline bool apply_once (hb_apply_context_t *c) const
   {
     unsigned int lookup_type = get_type ();
 
-    if (!_hb_ot_layout_check_glyph_property (c->face, &c->buffer->cur(), c->lookup_props, &c->property))
+    if (!c->check_glyph_property (&c->buffer->cur(), c->lookup_props, &c->property))
       return false;
 
-    if (unlikely (lookup_type == SubstLookupSubTable::Extension))
-    {
-      /* The spec says all subtables should have the same type.
-       * This is specially important if one has a reverse type!
-       *
-       * This is rather slow to do this here for every glyph,
-       * but it's easiest, and who uses extension lookups anyway?!*/
-      unsigned int type = get_subtable(0).u.extension.get_type ();
-      unsigned int count = get_subtable_count ();
-      for (unsigned int i = 1; i < count; i++)
-        if (get_subtable(i).u.extension.get_type () != type)
-	  return false;
-    }
-
     unsigned int count = get_subtable_count ();
     for (unsigned int i = 0; i < count; i++)
       if (get_subtable (i).apply (c, lookup_type))
 	return true;
 
     return false;
   }
 
@@ -1087,71 +1203,97 @@ struct SubstLookup : Lookup
 
     c->set_lookup (*this);
 
     if (likely (!is_reverse ()))
     {
 	/* in/out forward substitution */
 	c->buffer->clear_output ();
 	c->buffer->idx = 0;
+
 	while (c->buffer->idx < c->buffer->len)
 	{
-	  if ((c->buffer->cur().mask & c->lookup_mask) && apply_once (c))
+	  if ((c->buffer->cur().mask & c->lookup_mask) &&
+	      c->digest.may_have (c->buffer->cur().codepoint) &&
+	      apply_once (c))
 	    ret = true;
 	  else
 	    c->buffer->next_glyph ();
-
 	}
 	if (ret)
 	  c->buffer->swap_buffers ();
     }
     else
     {
 	/* in-place backward substitution */
 	c->buffer->idx = c->buffer->len - 1;
 	do
 	{
-	  if ((c->buffer->cur().mask & c->lookup_mask) && apply_once (c))
+	  if ((c->buffer->cur().mask & c->lookup_mask) &&
+	      c->digest.may_have (c->buffer->cur().codepoint) &&
+	      apply_once (c))
 	    ret = true;
 	  else
 	    c->buffer->idx--;
 
 	}
 	while ((int) c->buffer->idx >= 0);
     }
 
     return ret;
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     if (unlikely (!Lookup::sanitize (c))) return TRACE_RETURN (false);
     OffsetArrayOf<SubstLookupSubTable> &list = CastR<OffsetArrayOf<SubstLookupSubTable> > (subTable);
-    return TRACE_RETURN (list.sanitize (c, this, get_type ()));
+    if (unlikely (!list.sanitize (c, this, get_type ()))) return TRACE_RETURN (false);
+
+    if (unlikely (get_type () == SubstLookupSubTable::Extension))
+    {
+      /* The spec says all subtables of an Extension lookup should
+       * have the same type.  This is specially important if one has
+       * a reverse type!
+       *
+       * We just check that they are all either forward, or reverse. */
+      unsigned int type = get_subtable (0).u.extension.get_type ();
+      unsigned int count = get_subtable_count ();
+      for (unsigned int i = 1; i < count; i++)
+        if (get_subtable (i).u.extension.get_type () != type)
+	  return TRACE_RETURN (false);
+    }
+    return TRACE_RETURN (true);
   }
 };
 
 typedef OffsetListOf<SubstLookup> SubstLookupList;
 
 /*
  * GSUB -- The Glyph Substitution Table
  */
 
 struct GSUB : GSUBGPOS
 {
   static const hb_tag_t Tag	= HB_OT_TAG_GSUB;
 
   inline const SubstLookup& get_lookup (unsigned int i) const
   { return CastR<SubstLookup> (GSUBGPOS::get_lookup (i)); }
 
+  template <typename set_t>
+  inline void add_coverage (set_t *glyphs, unsigned int lookup_index) const
+  { get_lookup (lookup_index).add_coverage (glyphs); }
+
+  inline bool would_substitute_lookup (hb_would_apply_context_t *c, unsigned int lookup_index) const
+  { return get_lookup (lookup_index).would_apply (c); }
+
   inline bool substitute_lookup (hb_apply_context_t *c, unsigned int lookup_index) const
   { return get_lookup (lookup_index).apply_string (c); }
 
-  static inline void substitute_start (hb_buffer_t *buffer);
-  static inline void substitute_finish (hb_buffer_t *buffer);
+  static inline void substitute_start (hb_font_t *font, hb_buffer_t *buffer);
+  static inline void substitute_finish (hb_font_t *font, hb_buffer_t *buffer);
 
   inline void closure_lookup (hb_closure_context_t *c,
 			      unsigned int          lookup_index) const
   { return get_lookup (lookup_index).closure (c); }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     if (unlikely (!GSUBGPOS::sanitize (c))) return TRACE_RETURN (false);
@@ -1159,48 +1301,51 @@ struct GSUB : GSUBGPOS
     return TRACE_RETURN (list.sanitize (c, this));
   }
   public:
   DEFINE_SIZE_STATIC (10);
 };
 
 
 void
-GSUB::substitute_start (hb_buffer_t *buffer)
+GSUB::substitute_start (hb_font_t *font, hb_buffer_t *buffer)
 {
-  HB_BUFFER_ALLOCATE_VAR (buffer, props_cache);
+  HB_BUFFER_ALLOCATE_VAR (buffer, glyph_props);
   HB_BUFFER_ALLOCATE_VAR (buffer, lig_props);
   HB_BUFFER_ALLOCATE_VAR (buffer, syllable);
 
+  const GDEF &gdef = *hb_ot_layout_from_face (font->face)->gdef;
   unsigned int count = buffer->len;
-  for (unsigned int i = 0; i < count; i++)
-    buffer->info[i].props_cache() = buffer->info[i].lig_props() = buffer->info[i].syllable() = 0;
+  for (unsigned int i = 0; i < count; i++) {
+    buffer->info[i].lig_props() = buffer->info[i].syllable() = 0;
+    buffer->info[i].glyph_props() = gdef.get_glyph_props (buffer->info[i].codepoint);
+  }
 }
 
 void
-GSUB::substitute_finish (hb_buffer_t *buffer HB_UNUSED)
+GSUB::substitute_finish (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer HB_UNUSED)
 {
 }
 
 
 /* Out-of-class implementation for methods recursing */
 
 inline void ExtensionSubst::closure (hb_closure_context_t *c) const
 {
   get_subtable ().closure (c, get_type ());
 }
 
-inline bool ExtensionSubst::would_apply (hb_codepoint_t glyph_id) const
+inline const Coverage & ExtensionSubst::get_coverage (void) const
 {
-  return get_subtable ().would_apply (glyph_id, get_type ());
+  return get_subtable ().get_coverage (get_type ());
 }
 
-inline bool ExtensionSubst::would_apply (hb_codepoint_t first, hb_codepoint_t second) const
+inline bool ExtensionSubst::would_apply (hb_would_apply_context_t *c) const
 {
-  return get_subtable ().would_apply (first, second, get_type ());
+  return get_subtable ().would_apply (c, get_type ());
 }
 
 inline bool ExtensionSubst::apply (hb_apply_context_t *c) const
 {
   TRACE_APPLY ();
   return TRACE_RETURN (get_subtable ().apply (c, get_type ()));
 }
 
@@ -1218,30 +1363,30 @@ inline bool ExtensionSubst::is_reverse (
   unsigned int type = get_type ();
   if (unlikely (type == SubstLookupSubTable::Extension))
     return CastR<ExtensionSubst> (get_subtable()).is_reverse ();
   return SubstLookup::lookup_type_is_reverse (type);
 }
 
 static inline void closure_lookup (hb_closure_context_t *c, unsigned int lookup_index)
 {
-  const GSUB &gsub = *(c->face->ot_layout->gsub);
+  const GSUB &gsub = *(hb_ot_layout_from_face (c->face)->gsub);
   const SubstLookup &l = gsub.get_lookup (lookup_index);
 
   if (unlikely (c->nesting_level_left == 0))
     return;
 
   c->nesting_level_left--;
   l.closure (c);
   c->nesting_level_left++;
 }
 
 static inline bool substitute_lookup (hb_apply_context_t *c, unsigned int lookup_index)
 {
-  const GSUB &gsub = *(c->face->ot_layout->gsub);
+  const GSUB &gsub = *(hb_ot_layout_from_face (c->face)->gsub);
   const SubstLookup &l = gsub.get_lookup (lookup_index);
 
   if (unlikely (c->nesting_level_left == 0))
     return false;
 
   hb_apply_context_t new_c (*c);
   new_c.nesting_level_left--;
   new_c.set_lookup (l);
diff --git a/gfx/harfbuzz/src/hb-ot-layout-gsubgpos-private.hh b/gfx/harfbuzz/src/hb-ot-layout-gsubgpos-private.hh
--- a/gfx/harfbuzz/src/hb-ot-layout-gsubgpos-private.hh
+++ b/gfx/harfbuzz/src/hb-ot-layout-gsubgpos-private.hh
@@ -26,106 +26,114 @@
  * Google Author(s): Behdad Esfahbod
  */
 
 #ifndef HB_OT_LAYOUT_GSUBGPOS_PRIVATE_HH
 #define HB_OT_LAYOUT_GSUBGPOS_PRIVATE_HH
 
 #include "hb-buffer-private.hh"
 #include "hb-ot-layout-gdef-table.hh"
-
-
-
-/* unique ligature id */
-/* component number in the ligature (0 = base) */
-static inline void
-set_lig_props (hb_glyph_info_t &info, unsigned int lig_id, unsigned int lig_comp)
-{
-  info.lig_props() = (lig_id << 4) | (lig_comp & 0x0F);
-}
-static inline unsigned int
-get_lig_id (hb_glyph_info_t &info)
-{
-  return info.lig_props() >> 4;
-}
-static inline unsigned int
-get_lig_comp (hb_glyph_info_t &info)
-{
-  return info.lig_props() & 0x0F;
-}
-
-static inline uint8_t allocate_lig_id (hb_buffer_t *buffer) {
-  uint8_t lig_id = buffer->next_serial () & 0x0F;
-  if (unlikely (!lig_id))
-    lig_id = allocate_lig_id (buffer); /* in case of overflow */
-  return lig_id;
-}
+#include "hb-set-private.hh"
 
 
 
 #ifndef HB_DEBUG_CLOSURE
 #define HB_DEBUG_CLOSURE (HB_DEBUG+0)
 #endif
 
 #define TRACE_CLOSURE() \
 	hb_auto_trace_t<HB_DEBUG_CLOSURE> trace (&c->debug_depth, "CLOSURE", this, HB_FUNC, "");
 
 
-/* TODO Add TRACE_RETURN annotation for would_apply */
+/* TODO Add TRACE_RETURN annotation to gsub. */
+#ifndef HB_DEBUG_WOULD_APPLY
+#define HB_DEBUG_WOULD_APPLY (HB_DEBUG+0)
+#endif
+
+#define TRACE_WOULD_APPLY() \
+	hb_auto_trace_t<HB_DEBUG_WOULD_APPLY> trace (&c->debug_depth, "WOULD_APPLY", this, HB_FUNC, "first %u second %u", c->first, c->second);
 
 
 struct hb_closure_context_t
 {
   hb_face_t *face;
   hb_set_t *glyphs;
   unsigned int nesting_level_left;
   unsigned int debug_depth;
 
 
   hb_closure_context_t (hb_face_t *face_,
 			hb_set_t *glyphs_,
 		        unsigned int nesting_level_left_ = MAX_NESTING_LEVEL) :
-			  face (face_), glyphs (glyphs_),
+			  face (face_),
+			  glyphs (glyphs_),
 			  nesting_level_left (nesting_level_left_),
 			  debug_depth (0) {}
 };
 
 
 
+
+struct hb_would_apply_context_t
+{
+  hb_face_t *face;
+  hb_codepoint_t first;
+  hb_codepoint_t second;
+  unsigned int len;
+  const hb_set_digest_t digest;
+  unsigned int debug_depth;
+
+  hb_would_apply_context_t (hb_face_t *face_,
+			    hb_codepoint_t first_,
+			    hb_codepoint_t second_,
+			    const hb_set_digest_t *digest_
+			    ) :
+			      face (face_),
+			      first (first_), second (second_), len (second == (hb_codepoint_t) -1 ? 1 : 2),
+			      digest (*digest_),
+			      debug_depth (0) {};
+};
+
+
 #ifndef HB_DEBUG_APPLY
 #define HB_DEBUG_APPLY (HB_DEBUG+0)
 #endif
 
 #define TRACE_APPLY() \
-	hb_auto_trace_t<HB_DEBUG_APPLY> trace (&c->debug_depth, "APPLY", this, HB_FUNC, "idx %d codepoint %u", c->buffer->cur().codepoint);
-
+	hb_auto_trace_t<HB_DEBUG_APPLY> trace (&c->debug_depth, "APPLY", this, HB_FUNC, "idx %d codepoint %u", c->buffer->idx, c->buffer->cur().codepoint);
 
 
 struct hb_apply_context_t
 {
   hb_font_t *font;
   hb_face_t *face;
   hb_buffer_t *buffer;
   hb_direction_t direction;
   hb_mask_t lookup_mask;
   unsigned int nesting_level_left;
   unsigned int lookup_props;
   unsigned int property; /* propety of first glyph */
   unsigned int debug_depth;
+  const GDEF &gdef;
+  bool has_glyph_classes;
+  const hb_set_digest_t digest;
 
 
   hb_apply_context_t (hb_font_t *font_,
-		      hb_face_t *face_,
 		      hb_buffer_t *buffer_,
-		      hb_mask_t lookup_mask_) :
-			font (font_), face (face_), buffer (buffer_),
+		      hb_mask_t lookup_mask_,
+		      const hb_set_digest_t *digest_) :
+			font (font_), face (font->face), buffer (buffer_),
 			direction (buffer_->props.direction),
 			lookup_mask (lookup_mask_),
 			nesting_level_left (MAX_NESTING_LEVEL),
-			lookup_props (0), property (0), debug_depth (0) {}
+			lookup_props (0), property (0), debug_depth (0),
+			gdef (*hb_ot_layout_from_face (face)->gdef),
+			has_glyph_classes (gdef.has_glyph_classes ()),
+			digest (*digest_) {}
 
   void set_lookup (const Lookup &l) {
     lookup_props = l.get_props ();
   }
 
   struct mark_skipping_forward_iterator_t
   {
     inline mark_skipping_forward_iterator_t (hb_apply_context_t *c_,
@@ -139,36 +147,40 @@ struct hb_apply_context_t
       mask = context_match ? -1 : c->lookup_mask;
       syllable = context_match ? 0 : c->buffer->cur().syllable ();
       end = c->buffer->len;
     }
     inline bool has_no_chance (void) const
     {
       return unlikely (num_items && idx + num_items >= end);
     }
+    inline void reject (void)
+    {
+      num_items++;
+    }
     inline bool next (unsigned int *property_out,
-		      unsigned int lookup_props)
+		      unsigned int  lookup_props)
     {
       assert (num_items > 0);
       do
       {
 	if (has_no_chance ())
 	  return false;
 	idx++;
-      } while (_hb_ot_layout_skip_mark (c->face, &c->buffer->info[idx], lookup_props, property_out));
+      } while (c->should_skip_mark (&c->buffer->info[idx], lookup_props, property_out));
       num_items--;
       return (c->buffer->info[idx].mask & mask) && (!syllable || syllable == c->buffer->info[idx].syllable ());
     }
     inline bool next (unsigned int *property_out = NULL)
     {
       return next (property_out, c->lookup_props);
     }
 
     unsigned int idx;
-    private:
+    protected:
     hb_apply_context_t *c;
     unsigned int num_items;
     hb_mask_t mask;
     uint8_t syllable;
     unsigned int end;
   };
 
   struct mark_skipping_backward_iterator_t
@@ -184,62 +196,147 @@ struct hb_apply_context_t
       num_items = num_items_;
       mask = mask_ ? mask_ : c->lookup_mask;
       syllable = match_syllable_ ? c->buffer->cur().syllable () : 0;
     }
     inline bool has_no_chance (void) const
     {
       return unlikely (idx < num_items);
     }
+    inline void reject (void)
+    {
+      num_items++;
+    }
     inline bool prev (unsigned int *property_out,
-		      unsigned int lookup_props)
+		      unsigned int  lookup_props)
     {
       assert (num_items > 0);
       do
       {
 	if (has_no_chance ())
 	  return false;
 	idx--;
-      } while (_hb_ot_layout_skip_mark (c->face, &c->buffer->out_info[idx], lookup_props, property_out));
+      } while (c->should_skip_mark (&c->buffer->out_info[idx], lookup_props, property_out));
       num_items--;
       return (c->buffer->out_info[idx].mask & mask) && (!syllable || syllable == c->buffer->out_info[idx].syllable ());
     }
     inline bool prev (unsigned int *property_out = NULL)
     {
       return prev (property_out, c->lookup_props);
     }
 
     unsigned int idx;
-    private:
+    protected:
     hb_apply_context_t *c;
     unsigned int num_items;
     hb_mask_t mask;
     uint8_t syllable;
   };
 
+  inline bool
+  match_properties_mark (hb_codepoint_t  glyph,
+			 unsigned int    glyph_props,
+			 unsigned int    lookup_props) const
+  {
+    /* If using mark filtering sets, the high short of
+     * lookup_props has the set index.
+     */
+    if (lookup_props & LookupFlag::UseMarkFilteringSet)
+      return gdef.mark_set_covers (lookup_props >> 16, glyph);
+
+    /* The second byte of lookup_props has the meaning
+     * "ignore marks of attachment type different than
+     * the attachment type specified."
+     */
+    if (lookup_props & LookupFlag::MarkAttachmentType)
+      return (lookup_props & LookupFlag::MarkAttachmentType) == (glyph_props & LookupFlag::MarkAttachmentType);
+
+    return true;
+  }
+
+  inline bool
+  match_properties (hb_codepoint_t  glyph,
+		    unsigned int    glyph_props,
+		    unsigned int    lookup_props) const
+  {
+    /* Not covered, if, for example, glyph class is ligature and
+     * lookup_props includes LookupFlags::IgnoreLigatures
+     */
+    if (glyph_props & lookup_props & LookupFlag::IgnoreFlags)
+      return false;
+
+    if (unlikely (glyph_props & HB_OT_LAYOUT_GLYPH_CLASS_MARK))
+      return match_properties_mark (glyph, glyph_props, lookup_props);
+
+    return true;
+  }
+
+  inline bool
+  check_glyph_property (hb_glyph_info_t *info,
+			unsigned int  lookup_props,
+			unsigned int *property_out) const
+  {
+    unsigned int property;
+
+    property = info->glyph_props();
+    *property_out = property;
+
+    return match_properties (info->codepoint, property, lookup_props);
+  }
+
+  inline bool
+  should_skip_mark (hb_glyph_info_t *info,
+		   unsigned int  lookup_props,
+		   unsigned int *property_out) const
+  {
+    unsigned int property;
+
+    property = info->glyph_props();
+    if (property_out)
+      *property_out = property;
+
+    /* If it's a mark, skip it if we don't accept it. */
+    if (unlikely (property & HB_OT_LAYOUT_GLYPH_CLASS_MARK))
+      return !match_properties (info->codepoint, property, lookup_props);
+
+    /* If not a mark, don't skip. */
+    return false;
+  }
+
+
   inline bool should_mark_skip_current_glyph (void) const
   {
-    return _hb_ot_layout_skip_mark (face, &buffer->cur(), lookup_props, NULL);
+    return should_skip_mark (&buffer->cur(), lookup_props, NULL);
   }
 
+  inline void set_class (hb_codepoint_t glyph_index, unsigned int class_guess) const
+  {
+    if (likely (has_glyph_classes))
+      buffer->cur().glyph_props() = gdef.get_glyph_props (glyph_index);
+    else if (class_guess)
+      buffer->cur().glyph_props() = class_guess;
+  }
 
-
+  inline void output_glyph (hb_codepoint_t glyph_index,
+			    unsigned int class_guess = 0) const
+  {
+    set_class (glyph_index, class_guess);
+    buffer->output_glyph (glyph_index);
+  }
   inline void replace_glyph (hb_codepoint_t glyph_index,
-			     unsigned int klass = 0) const
+			     unsigned int class_guess = 0) const
   {
-    buffer->cur().props_cache() = klass; /*XXX if has gdef? */
+    set_class (glyph_index, class_guess);
     buffer->replace_glyph (glyph_index);
   }
-  inline void replace_glyphs_be16 (unsigned int num_in,
-				   unsigned int num_out,
-				   const uint16_t *glyph_data_be,
-				   unsigned int klass = 0) const
+  inline void replace_glyph_inplace (hb_codepoint_t glyph_index,
+				     unsigned int class_guess = 0) const
   {
-    buffer->cur().props_cache() = klass; /* XXX if has gdef? */
-    buffer->replace_glyphs_be16 (num_in, num_out, glyph_data_be);
+    set_class (glyph_index, class_guess);
+    buffer->cur().codepoint = glyph_index;
   }
 };
 
 
 
 typedef bool (*intersects_func_t) (hb_set_t *glyphs, const USHORT &value, const void *data);
 typedef bool (*match_func_t) (hb_codepoint_t glyph_id, const USHORT &value, const void *data);
 typedef void (*closure_lookup_func_t) (hb_closure_context_t *c, unsigned int lookup_index);
@@ -295,16 +392,31 @@ static inline bool match_class (hb_codep
 }
 static inline bool match_coverage (hb_codepoint_t glyph_id, const USHORT &value, const void *data)
 {
   const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;
   return (data+coverage).get_coverage (glyph_id) != NOT_COVERED;
 }
 
 
+static inline bool would_match_input (hb_would_apply_context_t *c,
+				      unsigned int count, /* Including the first glyph (not matched) */
+				      const USHORT input[], /* Array of input values--start with second glyph */
+				      match_func_t match_func,
+				      const void *match_data)
+{
+  if (count != c->len)
+    return false;
+
+  for (unsigned int i = 1; i < count; i++)
+    if (likely (!match_func (c->second, input[i - 1], match_data)))
+      return false;
+
+  return true;
+}
 static inline bool match_input (hb_apply_context_t *c,
 				unsigned int count, /* Including the first glyph (not matched) */
 				const USHORT input[], /* Array of input values--start with second glyph */
 				match_func_t match_func,
 				const void *match_data,
 				unsigned int *end_offset = NULL)
 {
   hb_apply_context_t::mark_skipping_forward_iterator_t skippy_iter (c, c->buffer->idx, count - 1);
@@ -483,16 +595,27 @@ static inline void context_closure_looku
 			inputCount ? inputCount - 1 : 0, input,
 			lookup_context.funcs.intersects, lookup_context.intersects_data))
     closure_lookup (c,
 		    lookupCount, lookupRecord,
 		    lookup_context.funcs.closure);
 }
 
 
+static inline bool context_would_apply_lookup (hb_would_apply_context_t *c,
+					       unsigned int inputCount, /* Including the first glyph (not matched) */
+					       const USHORT input[], /* Array of input values--start with second glyph */
+					       unsigned int lookupCount,
+					       const LookupRecord lookupRecord[],
+					       ContextApplyLookupContext &lookup_context)
+{
+  return would_match_input (c,
+			    inputCount, input,
+			    lookup_context.funcs.match, lookup_context.match_data);
+}
 static inline bool context_apply_lookup (hb_apply_context_t *c,
 					 unsigned int inputCount, /* Including the first glyph (not matched) */
 					 const USHORT input[], /* Array of input values--start with second glyph */
 					 unsigned int lookupCount,
 					 const LookupRecord lookupRecord[],
 					 ContextApplyLookupContext &lookup_context)
 {
   return match_input (c,
@@ -515,16 +638,23 @@ struct Rule
     TRACE_CLOSURE ();
     const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (input, input[0].static_size * (inputCount ? inputCount - 1 : 0));
     context_closure_lookup (c,
 			    inputCount, input,
 			    lookupCount, lookupRecord,
 			    lookup_context);
   }
 
+  inline bool would_apply (hb_would_apply_context_t *c, ContextApplyLookupContext &lookup_context) const
+  {
+    TRACE_WOULD_APPLY ();
+    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (input, input[0].static_size * (inputCount ? inputCount - 1 : 0));
+    return TRACE_RETURN (context_would_apply_lookup (c, inputCount, input, lookupCount, lookupRecord, lookup_context));
+  }
+
   inline bool apply (hb_apply_context_t *c, ContextApplyLookupContext &lookup_context) const
   {
     TRACE_APPLY ();
     const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (input, input[0].static_size * (inputCount ? inputCount - 1 : 0));
     return TRACE_RETURN (context_apply_lookup (c, inputCount, input, lookupCount, lookupRecord, lookup_context));
   }
 
   public:
@@ -532,17 +662,17 @@ struct Rule
     TRACE_SANITIZE ();
     return inputCount.sanitize (c)
 	&& lookupCount.sanitize (c)
 	&& c->check_range (input,
 			   input[0].static_size * inputCount
 			   + lookupRecordX[0].static_size * lookupCount);
   }
 
-  private:
+  protected:
   USHORT	inputCount;		/* Total number of glyphs in input
 					 * glyph sequence--includes the first
 					 * glyph */
   USHORT	lookupCount;		/* Number of LookupRecords */
   USHORT	input[VAR];		/* Array of match inputs--start with
 					 * second glyph */
   LookupRecord	lookupRecordX[VAR];	/* Array of LookupRecords--in
 					 * design order */
@@ -555,16 +685,28 @@ struct RuleSet
   inline void closure (hb_closure_context_t *c, ContextClosureLookupContext &lookup_context) const
   {
     TRACE_CLOSURE ();
     unsigned int num_rules = rule.len;
     for (unsigned int i = 0; i < num_rules; i++)
       (this+rule[i]).closure (c, lookup_context);
   }
 
+  inline bool would_apply (hb_would_apply_context_t *c, ContextApplyLookupContext &lookup_context) const
+  {
+    TRACE_WOULD_APPLY ();
+    unsigned int num_rules = rule.len;
+    for (unsigned int i = 0; i < num_rules; i++)
+    {
+      if ((this+rule[i]).would_apply (c, lookup_context))
+        return TRACE_RETURN (true);
+    }
+    return TRACE_RETURN (false);
+  }
+
   inline bool apply (hb_apply_context_t *c, ContextApplyLookupContext &lookup_context) const
   {
     TRACE_APPLY ();
     unsigned int num_rules = rule.len;
     for (unsigned int i = 0; i < num_rules; i++)
     {
       if ((this+rule[i]).apply (c, lookup_context))
         return TRACE_RETURN (true);
@@ -572,17 +714,17 @@ struct RuleSet
     return TRACE_RETURN (false);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (rule.sanitize (c, this));
   }
 
-  private:
+  protected:
   OffsetArrayOf<Rule>
 		rule;			/* Array of Rule tables
 					 * ordered by preference */
   public:
   DEFINE_SIZE_ARRAY (2, rule);
 };
 
 
@@ -606,16 +748,28 @@ struct ContextFormat1
     unsigned int count = ruleSet.len;
     for (unsigned int i = 0; i < count; i++)
       if (cov.intersects_coverage (c->glyphs, i)) {
 	const RuleSet &rule_set = this+ruleSet[i];
 	rule_set.closure (c, lookup_context);
       }
   }
 
+  inline bool would_apply (hb_would_apply_context_t *c) const
+  {
+    TRACE_WOULD_APPLY ();
+
+    const RuleSet &rule_set = this+ruleSet[(this+coverage) (c->first)];
+    struct ContextApplyLookupContext lookup_context = {
+      {match_glyph, NULL},
+      NULL
+    };
+    return TRACE_RETURN (rule_set.would_apply (c, lookup_context));
+  }
+
   inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
   {
     TRACE_APPLY ();
     unsigned int index = (this+coverage) (c->buffer->cur().codepoint);
     if (likely (index == NOT_COVERED))
       return TRACE_RETURN (false);
 
     const RuleSet &rule_set = this+ruleSet[index];
@@ -626,17 +780,17 @@ struct ContextFormat1
     return TRACE_RETURN (rule_set.apply (c, lookup_context));
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (coverage.sanitize (c, this) && ruleSet.sanitize (c, this));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of table */
   OffsetArrayOf<RuleSet>
 		ruleSet;		/* Array of RuleSet tables
 					 * ordered by Coverage Index */
   public:
@@ -666,16 +820,30 @@ struct ContextFormat2
     unsigned int count = ruleSet.len;
     for (unsigned int i = 0; i < count; i++)
       if (class_def.intersects_class (c->glyphs, i)) {
 	const RuleSet &rule_set = this+ruleSet[i];
 	rule_set.closure (c, lookup_context);
       }
   }
 
+  inline bool would_apply (hb_would_apply_context_t *c) const
+  {
+    TRACE_WOULD_APPLY ();
+
+    const ClassDef &class_def = this+classDef;
+    unsigned int index = class_def (c->first);
+    const RuleSet &rule_set = this+ruleSet[index];
+    struct ContextApplyLookupContext lookup_context = {
+      {match_class, NULL},
+      &class_def
+    };
+    return TRACE_RETURN (rule_set.would_apply (c, lookup_context));
+  }
+
   inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
   {
     TRACE_APPLY ();
     unsigned int index = (this+coverage) (c->buffer->cur().codepoint);
     if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);
 
     const ClassDef &class_def = this+classDef;
     index = class_def (c->buffer->cur().codepoint);
@@ -687,17 +855,17 @@ struct ContextFormat2
     return TRACE_RETURN (rule_set.apply (c, lookup_context));
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (coverage.sanitize (c, this) && classDef.sanitize (c, this) && ruleSet.sanitize (c, this));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 2 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of table */
   OffsetTo<ClassDef>
 		classDef;		/* Offset to glyph ClassDef table--from
 					 * beginning of table */
   OffsetArrayOf<RuleSet>
@@ -726,16 +894,28 @@ struct ContextFormat3
       this
     };
     context_closure_lookup (c,
 			    glyphCount, (const USHORT *) (coverage + 1),
 			    lookupCount, lookupRecord,
 			    lookup_context);
   }
 
+  inline bool would_apply (hb_would_apply_context_t *c) const
+  {
+    TRACE_WOULD_APPLY ();
+
+    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverage, coverage[0].static_size * glyphCount);
+    struct ContextApplyLookupContext lookup_context = {
+      {match_coverage, NULL},
+      this
+    };
+    return TRACE_RETURN (context_would_apply_lookup (c, glyphCount, (const USHORT *) (coverage + 1), lookupCount, lookupRecord, lookup_context));
+  }
+
   inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
   {
     TRACE_APPLY ();
     unsigned int index = (this+coverage[0]) (c->buffer->cur().codepoint);
     if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);
 
     const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverage, coverage[0].static_size * glyphCount);
     struct ContextApplyLookupContext lookup_context = {
@@ -744,24 +924,25 @@ struct ContextFormat3
     };
     return TRACE_RETURN (context_apply_lookup (c, glyphCount, (const USHORT *) (coverage + 1), lookupCount, lookupRecord, lookup_context));
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     if (!c->check_struct (this)) return TRACE_RETURN (false);
     unsigned int count = glyphCount;
+    if (unlikely (!glyphCount)) return TRACE_RETURN (false);
     if (!c->check_array (coverage, coverage[0].static_size, count)) return TRACE_RETURN (false);
     for (unsigned int i = 0; i < count; i++)
       if (!coverage[i].sanitize (c, this)) return TRACE_RETURN (false);
     LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverage, coverage[0].static_size * count);
     return TRACE_RETURN (c->check_array (lookupRecord, lookupRecord[0].static_size, lookupCount));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 3 */
   USHORT	glyphCount;		/* Number of glyphs in the input glyph
 					 * sequence */
   USHORT	lookupCount;		/* Number of LookupRecords */
   OffsetTo<Coverage>
 		coverage[VAR];		/* Array of offsets to Coverage
 					 * table in glyph sequence order */
   LookupRecord	lookupRecordX[VAR];	/* Array of LookupRecords--in
@@ -780,16 +961,36 @@ struct Context
     switch (u.format) {
     case 1: u.format1.closure (c, closure_func); break;
     case 2: u.format2.closure (c, closure_func); break;
     case 3: u.format3.closure (c, closure_func); break;
     default:                                     break;
     }
   }
 
+  inline const Coverage &get_coverage (void) const
+  {
+    switch (u.format) {
+    case 1: return this + u.format1.coverage;
+    case 2: return this + u.format2.coverage;
+    case 3: return this + u.format3.coverage[0];
+    default:return Null(Coverage);
+    }
+  }
+
+  inline bool would_apply (hb_would_apply_context_t *c) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.would_apply (c);
+    case 2: return u.format2.would_apply (c);
+    case 3: return u.format3.would_apply (c);
+    default:return false;
+    }
+  }
+
   inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
   {
     TRACE_APPLY ();
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.apply (c, apply_func));
     case 2: return TRACE_RETURN (u.format2.apply (c, apply_func));
     case 3: return TRACE_RETURN (u.format3.apply (c, apply_func));
     default:return TRACE_RETURN (false);
@@ -802,17 +1003,17 @@ struct Context
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     case 2: return TRACE_RETURN (u.format2.sanitize (c));
     case 3: return TRACE_RETURN (u.format3.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   ContextFormat1	format1;
   ContextFormat2	format2;
   ContextFormat3	format3;
   } u;
 };
 
@@ -851,35 +1052,53 @@ static inline void chain_context_closure
   && intersects_array (c,
 		       lookaheadCount, lookahead,
 		       lookup_context.funcs.intersects, lookup_context.intersects_data[2]))
     closure_lookup (c,
 		    lookupCount, lookupRecord,
 		    lookup_context.funcs.closure);
 }
 
+static inline bool chain_context_would_apply_lookup (hb_would_apply_context_t *c,
+						     unsigned int backtrackCount,
+						     const USHORT backtrack[],
+						     unsigned int inputCount, /* Including the first glyph (not matched) */
+						     const USHORT input[], /* Array of input values--start with second glyph */
+						     unsigned int lookaheadCount,
+						     const USHORT lookahead[],
+						     unsigned int lookupCount,
+						     const LookupRecord lookupRecord[],
+						     ChainContextApplyLookupContext &lookup_context)
+{
+  return !backtrackCount
+      && !lookaheadCount
+      && would_match_input (c,
+			    inputCount, input,
+			    lookup_context.funcs.match, lookup_context.match_data[1]);
+}
+
 static inline bool chain_context_apply_lookup (hb_apply_context_t *c,
 					       unsigned int backtrackCount,
 					       const USHORT backtrack[],
 					       unsigned int inputCount, /* Including the first glyph (not matched) */
 					       const USHORT input[], /* Array of input values--start with second glyph */
 					       unsigned int lookaheadCount,
 					       const USHORT lookahead[],
 					       unsigned int lookupCount,
 					       const LookupRecord lookupRecord[],
 					       ChainContextApplyLookupContext &lookup_context)
 {
   unsigned int lookahead_offset;
-  return match_backtrack (c,
-			  backtrackCount, backtrack,
-			  lookup_context.funcs.match, lookup_context.match_data[0])
-      && match_input (c,
+  return match_input (c,
 		      inputCount, input,
 		      lookup_context.funcs.match, lookup_context.match_data[1],
 		      &lookahead_offset)
+      && match_backtrack (c,
+			  backtrackCount, backtrack,
+			  lookup_context.funcs.match, lookup_context.match_data[0])
       && match_lookahead (c,
 			  lookaheadCount, lookahead,
 			  lookup_context.funcs.match, lookup_context.match_data[2],
 			  lookahead_offset)
       && apply_lookup (c,
 		       inputCount,
 		       lookupCount, lookupRecord,
 		       lookup_context.funcs.apply);
@@ -900,16 +1119,29 @@ struct ChainRule
     chain_context_closure_lookup (c,
 				  backtrack.len, backtrack.array,
 				  input.len, input.array,
 				  lookahead.len, lookahead.array,
 				  lookup.len, lookup.array,
 				  lookup_context);
   }
 
+  inline bool would_apply (hb_would_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const
+  {
+    TRACE_WOULD_APPLY ();
+    const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);
+    const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);
+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);
+    return TRACE_RETURN (chain_context_would_apply_lookup (c,
+							   backtrack.len, backtrack.array,
+							   input.len, input.array,
+							   lookahead.len, lookahead.array, lookup.len,
+							   lookup.array, lookup_context));
+  }
+
   inline bool apply (hb_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const
   {
     TRACE_APPLY ();
     const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);
     const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);
     const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);
     return TRACE_RETURN (chain_context_apply_lookup (c,
 						     backtrack.len, backtrack.array,
@@ -925,17 +1157,17 @@ struct ChainRule
     HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);
     if (!input.sanitize (c)) return TRACE_RETURN (false);
     ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);
     if (!lookahead.sanitize (c)) return TRACE_RETURN (false);
     ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);
     return TRACE_RETURN (lookup.sanitize (c));
   }
 
-  private:
+  protected:
   ArrayOf<USHORT>
 		backtrack;		/* Array of backtracking values
 					 * (to be matched before the input
 					 * sequence) */
   HeadlessArrayOf<USHORT>
 		inputX;			/* Array of input values (start with
 					 * second glyph) */
   ArrayOf<USHORT>
@@ -953,33 +1185,44 @@ struct ChainRuleSet
   inline void closure (hb_closure_context_t *c, ChainContextClosureLookupContext &lookup_context) const
   {
     TRACE_CLOSURE ();
     unsigned int num_rules = rule.len;
     for (unsigned int i = 0; i < num_rules; i++)
       (this+rule[i]).closure (c, lookup_context);
   }
 
+  inline bool would_apply (hb_would_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const
+  {
+    TRACE_WOULD_APPLY ();
+    unsigned int num_rules = rule.len;
+    for (unsigned int i = 0; i < num_rules; i++)
+      if ((this+rule[i]).would_apply (c, lookup_context))
+        return TRACE_RETURN (true);
+
+    return TRACE_RETURN (false);
+  }
+
   inline bool apply (hb_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const
   {
     TRACE_APPLY ();
     unsigned int num_rules = rule.len;
     for (unsigned int i = 0; i < num_rules; i++)
       if ((this+rule[i]).apply (c, lookup_context))
         return TRACE_RETURN (true);
 
     return TRACE_RETURN (false);
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (rule.sanitize (c, this));
   }
 
-  private:
+  protected:
   OffsetArrayOf<ChainRule>
 		rule;			/* Array of ChainRule tables
 					 * ordered by preference */
   public:
   DEFINE_SIZE_ARRAY (2, rule);
 };
 
 struct ChainContextFormat1
@@ -1001,16 +1244,28 @@ struct ChainContextFormat1
     unsigned int count = ruleSet.len;
     for (unsigned int i = 0; i < count; i++)
       if (cov.intersects_coverage (c->glyphs, i)) {
 	const ChainRuleSet &rule_set = this+ruleSet[i];
 	rule_set.closure (c, lookup_context);
       }
   }
 
+  inline bool would_apply (hb_would_apply_context_t *c) const
+  {
+    TRACE_WOULD_APPLY ();
+
+    const ChainRuleSet &rule_set = this+ruleSet[(this+coverage) (c->first)];
+    struct ChainContextApplyLookupContext lookup_context = {
+      {match_glyph, NULL},
+      {NULL, NULL, NULL}
+    };
+    return TRACE_RETURN (rule_set.would_apply (c, lookup_context));
+  }
+
   inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
   {
     TRACE_APPLY ();
     unsigned int index = (this+coverage) (c->buffer->cur().codepoint);
     if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);
 
     const ChainRuleSet &rule_set = this+ruleSet[index];
     struct ChainContextApplyLookupContext lookup_context = {
@@ -1020,17 +1275,17 @@ struct ChainContextFormat1
     return TRACE_RETURN (rule_set.apply (c, lookup_context));
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (coverage.sanitize (c, this) && ruleSet.sanitize (c, this));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 1 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of table */
   OffsetArrayOf<ChainRuleSet>
 		ruleSet;		/* Array of ChainRuleSet tables
 					 * ordered by Coverage Index */
   public:
@@ -1063,16 +1318,31 @@ struct ChainContextFormat2
     unsigned int count = ruleSet.len;
     for (unsigned int i = 0; i < count; i++)
       if (input_class_def.intersects_class (c->glyphs, i)) {
 	const ChainRuleSet &rule_set = this+ruleSet[i];
 	rule_set.closure (c, lookup_context);
       }
   }
 
+  inline bool would_apply (hb_would_apply_context_t *c) const
+  {
+    TRACE_WOULD_APPLY ();
+
+    const ClassDef &input_class_def = this+inputClassDef;
+
+    unsigned int index = input_class_def (c->first);
+    const ChainRuleSet &rule_set = this+ruleSet[index];
+    struct ChainContextApplyLookupContext lookup_context = {
+      {match_class, NULL},
+      {NULL, &input_class_def, NULL}
+    };
+    return TRACE_RETURN (rule_set.would_apply (c, lookup_context));
+  }
+
   inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
   {
     TRACE_APPLY ();
     unsigned int index = (this+coverage) (c->buffer->cur().codepoint);
     if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);
 
     const ClassDef &backtrack_class_def = this+backtrackClassDef;
     const ClassDef &input_class_def = this+inputClassDef;
@@ -1091,17 +1361,17 @@ struct ChainContextFormat2
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (coverage.sanitize (c, this) && backtrackClassDef.sanitize (c, this) &&
 			 inputClassDef.sanitize (c, this) && lookaheadClassDef.sanitize (c, this) &&
 			 ruleSet.sanitize (c, this));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 2 */
   OffsetTo<Coverage>
 		coverage;		/* Offset to Coverage table--from
 					 * beginning of table */
   OffsetTo<ClassDef>
 		backtrackClassDef;	/* Offset to glyph ClassDef table
 					 * containing backtrack sequence
 					 * data--from beginning of table */
@@ -1143,16 +1413,40 @@ struct ChainContextFormat3
     chain_context_closure_lookup (c,
 				  backtrack.len, (const USHORT *) backtrack.array,
 				  input.len, (const USHORT *) input.array + 1,
 				  lookahead.len, (const USHORT *) lookahead.array,
 				  lookup.len, lookup.array,
 				  lookup_context);
   }
 
+  inline const Coverage &get_coverage (void) const
+  {
+    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);
+    return this+input[0];
+  }
+
+  inline bool would_apply (hb_would_apply_context_t *c) const
+  {
+    TRACE_WOULD_APPLY ();
+
+    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);
+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);
+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);
+    struct ChainContextApplyLookupContext lookup_context = {
+      {match_coverage, NULL},
+      {this, this, this}
+    };
+    return TRACE_RETURN (chain_context_would_apply_lookup (c,
+							   backtrack.len, (const USHORT *) backtrack.array,
+							   input.len, (const USHORT *) input.array + 1,
+							   lookahead.len, (const USHORT *) lookahead.array,
+							   lookup.len, lookup.array, lookup_context));
+  }
+
   inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
   {
     TRACE_APPLY ();
     const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);
 
     unsigned int index = (this+input[0]) (c->buffer->cur().codepoint);
     if (likely (index == NOT_COVERED)) return TRACE_RETURN (false);
 
@@ -1169,23 +1463,24 @@ struct ChainContextFormat3
 						     lookup.len, lookup.array, lookup_context));
   }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     if (!backtrack.sanitize (c, this)) return TRACE_RETURN (false);
     OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);
     if (!input.sanitize (c, this)) return TRACE_RETURN (false);
+    if (unlikely (!input.len)) return TRACE_RETURN (false);
     OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);
     if (!lookahead.sanitize (c, this)) return TRACE_RETURN (false);
     ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);
     return TRACE_RETURN (lookup.sanitize (c));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier--format = 3 */
   OffsetArrayOf<Coverage>
 		backtrack;		/* Array of coverage tables
 					 * in backtracking sequence, in  glyph
 					 * sequence order */
   OffsetArrayOf<Coverage>
 		inputX		;	/* Array of coverage
 					 * tables in input sequence, in glyph
@@ -1211,16 +1506,36 @@ struct ChainContext
     switch (u.format) {
     case 1: u.format1.closure (c, closure_func); break;
     case 2: u.format2.closure (c, closure_func); break;
     case 3: u.format3.closure (c, closure_func); break;
     default:                                     break;
     }
   }
 
+  inline const Coverage &get_coverage (void) const
+  {
+    switch (u.format) {
+    case 1: return this + u.format1.coverage;
+    case 2: return this + u.format2.coverage;
+    case 3: return u.format3.get_coverage ();
+    default:return Null(Coverage);
+    }
+  }
+
+  inline bool would_apply (hb_would_apply_context_t *c) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.would_apply (c);
+    case 2: return u.format2.would_apply (c);
+    case 3: return u.format3.would_apply (c);
+    default:return false;
+    }
+  }
+
   inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
   {
     TRACE_APPLY ();
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.apply (c, apply_func));
     case 2: return TRACE_RETURN (u.format2.apply (c, apply_func));
     case 3: return TRACE_RETURN (u.format3.apply (c, apply_func));
     default:return TRACE_RETURN (false);
@@ -1233,17 +1548,17 @@ struct ChainContext
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     case 2: return TRACE_RETURN (u.format2.sanitize (c));
     case 3: return TRACE_RETURN (u.format3.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;	/* Format identifier */
   ChainContextFormat1	format1;
   ChainContextFormat2	format2;
   ChainContextFormat3	format3;
   } u;
 };
 
@@ -1256,17 +1571,17 @@ struct ExtensionFormat1
   inline unsigned int get_type (void) const { return extensionLookupType; }
   inline unsigned int get_offset (void) const { return extensionOffset; }
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this));
   }
 
-  private:
+  protected:
   USHORT	format;			/* Format identifier. Set to 1. */
   USHORT	extensionLookupType;	/* Lookup type of subtable referenced
 					 * by ExtensionOffset (i.e. the
 					 * extension subtable). */
   ULONG		extensionOffset;	/* Offset to the extension subtable,
 					 * of lookup type subtable. */
   public:
   DEFINE_SIZE_STATIC (8);
@@ -1293,17 +1608,17 @@ struct Extension
     TRACE_SANITIZE ();
     if (!u.format.sanitize (c)) return TRACE_RETURN (false);
     switch (u.format) {
     case 1: return TRACE_RETURN (u.format1.sanitize (c));
     default:return TRACE_RETURN (true);
     }
   }
 
-  private:
+  protected:
   union {
   USHORT		format;		/* Format identifier */
   ExtensionFormat1	format1;
   } u;
 };
 
 
 /*
diff --git a/gfx/harfbuzz/src/hb-ot-layout-private.hh b/gfx/harfbuzz/src/hb-ot-layout-private.hh
--- a/gfx/harfbuzz/src/hb-ot-layout-private.hh
+++ b/gfx/harfbuzz/src/hb-ot-layout-private.hh
@@ -1,10 +1,11 @@
 /*
  * Copyright © 2007,2008,2009  Red Hat, Inc.
+ * Copyright © 2012  Google, Inc.
  *
  *  This is part of HarfBuzz, a text shaping library.
  *
  * Permission is hereby granted, without written agreement and without
  * license or royalty fees, to use, copy, modify, and distribute this
  * software and its documentation for any purpose, provided that the
  * above copyright notice and the following two paragraphs appear in
  * all copies of this software.
@@ -17,76 +18,192 @@
  *
  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  *
  * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
  */
 
 #ifndef HB_OT_LAYOUT_PRIVATE_HH
 #define HB_OT_LAYOUT_PRIVATE_HH
 
 #include "hb-private.hh"
 
 #include "hb-ot-layout.h"
 
 #include "hb-font-private.hh"
 #include "hb-buffer-private.hh"
-#include "hb-ot-shape-complex-private.hh"
+#include "hb-set-private.hh"
 
 
+/* buffer var allocations, used during the GSUB/GPOS processing */
+#define glyph_props()		var1.u16[1] /* GDEF glyph properties */
+#define syllable()		var2.u8[0] /* GSUB/GPOS shaping boundaries */
+#define lig_props()		var2.u8[1] /* GSUB/GPOS ligature tracking */
+
+#define hb_ot_layout_from_face(face) ((hb_ot_layout_t *) face->shaper_data.ot)
 
 /*
  * GDEF
  */
 
-/* XXX cleanup */
 typedef enum {
   HB_OT_LAYOUT_GLYPH_CLASS_UNCLASSIFIED	= 0x0001,
   HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH	= 0x0002,
   HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE	= 0x0004,
   HB_OT_LAYOUT_GLYPH_CLASS_MARK		= 0x0008,
   HB_OT_LAYOUT_GLYPH_CLASS_COMPONENT	= 0x0010
 } hb_ot_layout_glyph_class_t;
 
 
-HB_INTERNAL unsigned int
-_hb_ot_layout_get_glyph_property (hb_face_t       *face,
-				  hb_glyph_info_t *info);
+
+/*
+ * GSUB/GPOS
+ */
+
+/* lig_id / lig_comp
+ *
+ * When a ligature is formed:
+ *
+ *   - The ligature glyph and any marks in between all the same newly allocated
+ *     lig_id,
+ *   - The ligature glyph will get lig_num_comps set to the number of components
+ *   - The marks get lig_comp > 0, reflecting which component of the ligature
+ *     they were applied to.
+ *   - This is used in GPOS to attach marks to the right component of a ligature
+ *     in MarkLigPos.
+ *
+ * When a multiple-substitution is done:
+ *
+ *   - All resulting glyphs will have lig_id = 0,
+ *   - The resulting glyphs will have lig_comp = 0, 1, 2, ... respectively.
+ *   - This is used in GPOS to attach marks to the first component of a
+ *     multiple substitution in MarkBasePos.
+ *
+ * The numbers are also used in GPOS to do mark-to-mark positioning only
+ * to marks that belong to the same component of a ligature in MarkMarPos.
+ */
+#define IS_LIG_BASE 0x10
+static inline void
+set_lig_props_for_ligature (hb_glyph_info_t &info, unsigned int lig_id, unsigned int lig_num_comps)
+{
+  info.lig_props() = (lig_id << 5) | IS_LIG_BASE | (lig_num_comps & 0x0F);
+}
+static inline void
+set_lig_props_for_mark (hb_glyph_info_t &info, unsigned int lig_id, unsigned int lig_comp)
+{
+  info.lig_props() = (lig_id << 5) | (lig_comp & 0x0F);
+}
+static inline void
+set_lig_props_for_component (hb_glyph_info_t &info, unsigned int comp)
+{
+  set_lig_props_for_mark (info, 0, comp);
+}
+
+static inline unsigned int
+get_lig_id (const hb_glyph_info_t &info)
+{
+  return info.lig_props() >> 5;
+}
+static inline bool
+is_a_ligature (const hb_glyph_info_t &info)
+{
+  return !!(info.lig_props() & IS_LIG_BASE);
+}
+static inline unsigned int
+get_lig_comp (const hb_glyph_info_t &info)
+{
+  if (is_a_ligature (info))
+    return 0;
+  else
+    return info.lig_props() & 0x0F;
+}
+static inline unsigned int
+get_lig_num_comps (const hb_glyph_info_t &info)
+{
+  if ((info.glyph_props() & HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE) && is_a_ligature (info))
+    return info.lig_props() & 0x0F;
+  else
+    return 1;
+}
+
+static inline uint8_t allocate_lig_id (hb_buffer_t *buffer) {
+  uint8_t lig_id = buffer->next_serial () & 0x07;
+  if (unlikely (!lig_id))
+    lig_id = allocate_lig_id (buffer); /* in case of overflow */
+  return lig_id;
+}
+
 
 HB_INTERNAL hb_bool_t
-_hb_ot_layout_check_glyph_property (hb_face_t    *face,
-				    hb_glyph_info_t *ginfo,
-				    unsigned int  lookup_props,
-				    unsigned int *property_out);
+hb_ot_layout_would_substitute_lookup_fast (hb_face_t            *face,
+					   const hb_codepoint_t *glyphs,
+					   unsigned int          glyphs_length,
+					   unsigned int          lookup_index);
+
+
+/* Should be called before all the substitute_lookup's are done. */
+HB_INTERNAL void
+hb_ot_layout_substitute_start (hb_font_t    *font,
+			       hb_buffer_t  *buffer);
 
 HB_INTERNAL hb_bool_t
-_hb_ot_layout_skip_mark (hb_face_t    *face,
-			 hb_glyph_info_t *ginfo,
-			 unsigned int  lookup_props,
-			 unsigned int *property_out);
+hb_ot_layout_substitute_lookup (hb_font_t    *font,
+				hb_buffer_t  *buffer,
+				unsigned int  lookup_index,
+				hb_mask_t     mask);
+
+/* Should be called after all the substitute_lookup's are done */
+HB_INTERNAL void
+hb_ot_layout_substitute_finish (hb_font_t    *font,
+				hb_buffer_t  *buffer);
+
+
+/* Should be called before all the position_lookup's are done.  Resets positions to zero. */
+HB_INTERNAL void
+hb_ot_layout_position_start (hb_font_t    *font,
+			     hb_buffer_t  *buffer);
+
+HB_INTERNAL hb_bool_t
+hb_ot_layout_position_lookup (hb_font_t    *font,
+			      hb_buffer_t  *buffer,
+			      unsigned int  lookup_index,
+			      hb_mask_t     mask);
+
+/* Should be called after all the position_lookup's are done */
+HB_INTERNAL void
+hb_ot_layout_position_finish (hb_font_t    *font,
+			      hb_buffer_t  *buffer,
+			      hb_bool_t     zero_width_attached_marks);
 
 
 
 /*
  * hb_ot_layout_t
  */
 
 struct hb_ot_layout_t
 {
   hb_blob_t *gdef_blob;
   hb_blob_t *gsub_blob;
   hb_blob_t *gpos_blob;
 
   const struct GDEF *gdef;
   const struct GSUB *gsub;
   const struct GPOS *gpos;
+
+  unsigned int gsub_lookup_count;
+  unsigned int gpos_lookup_count;
+
+  hb_set_digest_t *gsub_digests;
+  hb_set_digest_t *gpos_digests;
 };
 
 
 HB_INTERNAL hb_ot_layout_t *
 _hb_ot_layout_create (hb_face_t *face);
 
 HB_INTERNAL void
 _hb_ot_layout_destroy (hb_ot_layout_t *layout);
diff --git a/gfx/harfbuzz/src/hb-ot-layout.cc b/gfx/harfbuzz/src/hb-ot-layout.cc
--- a/gfx/harfbuzz/src/hb-ot-layout.cc
+++ b/gfx/harfbuzz/src/hb-ot-layout.cc
@@ -1,12 +1,13 @@
 /*
  * Copyright © 1998-2004  David Turner and Werner Lemberg
  * Copyright © 2006  Behdad Esfahbod
  * Copyright © 2007,2008,2009  Red Hat, Inc.
+ * Copyright © 2012  Google, Inc.
  *
  *  This is part of HarfBuzz, a text shaping library.
  *
  * Permission is hereby granted, without written agreement and without
  * license or royalty fees, to use, copy, modify, and distribute this
  * software and its documentation for any purpose, provided that the
  * above copyright notice and the following two paragraphs appear in
  * all copies of this software.
@@ -19,165 +20,113 @@
  *
  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  *
  * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
  */
 
 #include "hb-ot-layout-private.hh"
 
 #include "hb-ot-layout-gdef-table.hh"
 #include "hb-ot-layout-gsub-table.hh"
 #include "hb-ot-layout-gpos-table.hh"
 #include "hb-ot-maxp-table.hh"
-#include "hb-ot-shape-private.hh"
 
 
 #include <stdlib.h>
 #include <string.h>
 
 
+HB_SHAPER_DATA_ENSURE_DECLARE(ot, face)
 
 hb_ot_layout_t *
 _hb_ot_layout_create (hb_face_t *face)
 {
-  /* TODO Remove this object altogether */
   hb_ot_layout_t *layout = (hb_ot_layout_t *) calloc (1, sizeof (hb_ot_layout_t));
+  if (unlikely (!layout))
+    return NULL;
 
   layout->gdef_blob = Sanitizer<GDEF>::sanitize (hb_face_reference_table (face, HB_OT_TAG_GDEF));
   layout->gdef = Sanitizer<GDEF>::lock_instance (layout->gdef_blob);
 
   layout->gsub_blob = Sanitizer<GSUB>::sanitize (hb_face_reference_table (face, HB_OT_TAG_GSUB));
   layout->gsub = Sanitizer<GSUB>::lock_instance (layout->gsub_blob);
 
   layout->gpos_blob = Sanitizer<GPOS>::sanitize (hb_face_reference_table (face, HB_OT_TAG_GPOS));
   layout->gpos = Sanitizer<GPOS>::lock_instance (layout->gpos_blob);
 
+  layout->gsub_lookup_count = layout->gsub->get_lookup_count ();
+  layout->gpos_lookup_count = layout->gpos->get_lookup_count ();
+
+  layout->gsub_digests = (hb_set_digest_t *) calloc (layout->gsub->get_lookup_count (), sizeof (hb_set_digest_t));
+  layout->gpos_digests = (hb_set_digest_t *) calloc (layout->gpos->get_lookup_count (), sizeof (hb_set_digest_t));
+
+  if (unlikely ((layout->gsub_lookup_count && !layout->gsub_digests) ||
+		(layout->gpos_lookup_count && !layout->gpos_digests)))
+  {
+    _hb_ot_layout_destroy (layout);
+    return NULL;
+  }
+
+  for (unsigned int i = 0; i < layout->gsub_lookup_count; i++)
+    layout->gsub->add_coverage (&layout->gsub_digests[i], i);
+  for (unsigned int i = 0; i < layout->gpos_lookup_count; i++)
+    layout->gpos->add_coverage (&layout->gpos_digests[i], i);
+
   return layout;
 }
 
 void
 _hb_ot_layout_destroy (hb_ot_layout_t *layout)
 {
   hb_blob_destroy (layout->gdef_blob);
   hb_blob_destroy (layout->gsub_blob);
   hb_blob_destroy (layout->gpos_blob);
 
+  free (layout->gsub_digests);
+  free (layout->gpos_digests);
+
   free (layout);
 }
 
 static inline const GDEF&
 _get_gdef (hb_face_t *face)
 {
-  return likely (face->ot_layout && face->ot_layout->gdef) ? *face->ot_layout->gdef : Null(GDEF);
+  if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(GDEF);
+  return *hb_ot_layout_from_face (face)->gdef;
 }
 static inline const GSUB&
 _get_gsub (hb_face_t *face)
 {
-  return likely (face->ot_layout && face->ot_layout->gsub) ? *face->ot_layout->gsub : Null(GSUB);
+  if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(GSUB);
+  return *hb_ot_layout_from_face (face)->gsub;
 }
 static inline const GPOS&
 _get_gpos (hb_face_t *face)
 {
-  return likely (face->ot_layout && face->ot_layout->gpos) ? *face->ot_layout->gpos : Null(GPOS);
+  if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(GPOS);
+  return *hb_ot_layout_from_face (face)->gpos;
 }
 
 
 /*
  * GDEF
  */
 
 hb_bool_t
 hb_ot_layout_has_glyph_classes (hb_face_t *face)
 {
   return _get_gdef (face).has_glyph_classes ();
 }
 
-unsigned int
-_hb_ot_layout_get_glyph_property (hb_face_t       *face,
-				  hb_glyph_info_t *info)
-{
-  if (!info->props_cache())
-  {
-    const GDEF &gdef = _get_gdef (face);
-    info->props_cache() = gdef.get_glyph_props (info->codepoint);
-  }
-
-  return info->props_cache();
-}
-
-static hb_bool_t
-_hb_ot_layout_match_properties (hb_face_t      *face,
-				hb_codepoint_t  codepoint,
-				unsigned int    glyph_props,
-				unsigned int    lookup_props)
-{
-  /* Not covered, if, for example, glyph class is ligature and
-   * lookup_props includes LookupFlags::IgnoreLigatures
-   */
-  if (glyph_props & lookup_props & LookupFlag::IgnoreFlags)
-    return false;
-
-  if (glyph_props & HB_OT_LAYOUT_GLYPH_CLASS_MARK)
-  {
-    /* If using mark filtering sets, the high short of
-     * lookup_props has the set index.
-     */
-    if (lookup_props & LookupFlag::UseMarkFilteringSet)
-      return _get_gdef (face).mark_set_covers (lookup_props >> 16, codepoint);
-
-    /* The second byte of lookup_props has the meaning
-     * "ignore marks of attachment type different than
-     * the attachment type specified."
-     */
-    if (lookup_props & LookupFlag::MarkAttachmentType && glyph_props & LookupFlag::MarkAttachmentType)
-      return (lookup_props & LookupFlag::MarkAttachmentType) == (glyph_props & LookupFlag::MarkAttachmentType);
-  }
-
-  return true;
-}
-
-hb_bool_t
-_hb_ot_layout_check_glyph_property (hb_face_t    *face,
-				    hb_glyph_info_t *ginfo,
-				    unsigned int  lookup_props,
-				    unsigned int *property_out)
-{
-  unsigned int property;
-
-  property = _hb_ot_layout_get_glyph_property (face, ginfo);
-  (void) (property_out && (*property_out = property));
-
-  return _hb_ot_layout_match_properties (face, ginfo->codepoint, property, lookup_props);
-}
-
-hb_bool_t
-_hb_ot_layout_skip_mark (hb_face_t    *face,
-			 hb_glyph_info_t *ginfo,
-			 unsigned int  lookup_props,
-			 unsigned int *property_out)
-{
-  unsigned int property;
-
-  property = _hb_ot_layout_get_glyph_property (face, ginfo);
-  (void) (property_out && (*property_out = property));
-
-  /* If it's a mark, skip it we don't accept it. */
-  if (unlikely (property & HB_OT_LAYOUT_GLYPH_CLASS_MARK))
-    return !_hb_ot_layout_match_properties (face, ginfo->codepoint, property, lookup_props);
-
-  /* If not a mark, don't skip. */
-  return false;
-}
-
-
 
 unsigned int
 hb_ot_layout_get_attach_points (hb_face_t      *face,
 				hb_codepoint_t  glyph,
 				unsigned int    start_offset,
 				unsigned int   *point_count /* IN/OUT */,
 				unsigned int   *point_array /* OUT */)
 {
@@ -190,16 +139,17 @@ hb_ot_layout_get_ligature_carets (hb_fon
 				  hb_codepoint_t  glyph,
 				  unsigned int    start_offset,
 				  unsigned int   *caret_count /* IN/OUT */,
 				  int            *caret_array /* OUT */)
 {
   return _get_gdef (font->face).get_lig_carets (font, direction, glyph, start_offset, caret_count, caret_array);
 }
 
+
 /*
  * GSUB/GPOS
  */
 
 static const GSUBGPOS&
 get_gsubgpos_table (hb_face_t *face,
 		    hb_tag_t   table_tag)
 {
@@ -228,29 +178,29 @@ hb_ot_layout_table_find_script (hb_face_
 				hb_tag_t      table_tag,
 				hb_tag_t      script_tag,
 				unsigned int *script_index)
 {
   ASSERT_STATIC (Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX);
   const GSUBGPOS &g = get_gsubgpos_table (face, table_tag);
 
   if (g.find_script_index (script_tag, script_index))
-    return TRUE;
+    return true;
 
   /* try finding 'DFLT' */
   if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index))
-    return FALSE;
+    return false;
 
   /* try with 'dflt'; MS site has had typos and many fonts use it now :(.
    * including many versions of DejaVu Sans Mono! */
   if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index))
-    return FALSE;
+    return false;
 
   if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
-  return FALSE;
+  return false;
 }
 
 hb_bool_t
 hb_ot_layout_table_choose_script (hb_face_t      *face,
 				  hb_tag_t        table_tag,
 				  const hb_tag_t *script_tags,
 				  unsigned int   *script_index,
 				  hb_tag_t       *chosen_script)
@@ -258,48 +208,48 @@ hb_ot_layout_table_choose_script (hb_fac
   ASSERT_STATIC (Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX);
   const GSUBGPOS &g = get_gsubgpos_table (face, table_tag);
 
   while (*script_tags)
   {
     if (g.find_script_index (*script_tags, script_index)) {
       if (chosen_script)
         *chosen_script = *script_tags;
-      return TRUE;
+      return true;
     }
     script_tags++;
   }
 
   /* try finding 'DFLT' */
   if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index)) {
     if (chosen_script)
       *chosen_script = HB_OT_TAG_DEFAULT_SCRIPT;
-    return FALSE;
+    return false;
   }
 
   /* try with 'dflt'; MS site has had typos and many fonts use it now :( */
   if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index)) {
     if (chosen_script)
       *chosen_script = HB_OT_TAG_DEFAULT_LANGUAGE;
-    return FALSE;
+    return false;
   }
 
   /* try with 'latn'; some old fonts put their features there even though
      they're really trying to support Thai, for example :( */
 #define HB_OT_TAG_LATIN_SCRIPT		HB_TAG ('l', 'a', 't', 'n')
   if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index)) {
     if (chosen_script)
       *chosen_script = HB_OT_TAG_LATIN_SCRIPT;
-    return FALSE;
+    return false;
   }
 
   if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
   if (chosen_script)
     *chosen_script = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
-  return FALSE;
+  return false;
 }
 
 unsigned int
 hb_ot_layout_table_get_feature_tags (hb_face_t    *face,
 				     hb_tag_t      table_tag,
 				     unsigned int  start_offset,
 				     unsigned int *feature_count /* IN/OUT */,
 				     hb_tag_t     *feature_tags /* OUT */)
@@ -329,24 +279,24 @@ hb_ot_layout_script_find_language (hb_fa
 				   unsigned int  script_index,
 				   hb_tag_t      language_tag,
 				   unsigned int *language_index)
 {
   ASSERT_STATIC (Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX);
   const Script &s = get_gsubgpos_table (face, table_tag).get_script (script_index);
 
   if (s.find_lang_sys_index (language_tag, language_index))
-    return TRUE;
+    return true;
 
   /* try with 'dflt'; MS site has had typos and many fonts use it now :( */
   if (s.find_lang_sys_index (HB_OT_TAG_DEFAULT_LANGUAGE, language_index))
-    return FALSE;
+    return false;
 
   if (language_index) *language_index = HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX;
-  return FALSE;
+  return false;
 }
 
 hb_bool_t
 hb_ot_layout_language_get_required_feature_index (hb_face_t    *face,
 						  hb_tag_t      table_tag,
 						  unsigned int  script_index,
 						  unsigned int  language_index,
 						  unsigned int *feature_index)
@@ -411,22 +361,22 @@ hb_ot_layout_language_find_feature (hb_f
   const LangSys &l = g.get_script (script_index).get_lang_sys (language_index);
 
   unsigned int num_features = l.get_feature_count ();
   for (unsigned int i = 0; i < num_features; i++) {
     unsigned int f_index = l.get_feature_index (i);
 
     if (feature_tag == g.get_feature_tag (f_index)) {
       if (feature_index) *feature_index = f_index;
-      return TRUE;
+      return true;
     }
   }
 
   if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;
-  return FALSE;
+  return false;
 }
 
 unsigned int
 hb_ot_layout_feature_get_lookup_indexes (hb_face_t    *face,
 					 hb_tag_t      table_tag,
 					 unsigned int  feature_index,
 					 unsigned int  start_offset,
 					 unsigned int *lookup_count /* IN/OUT */,
@@ -444,36 +394,59 @@ hb_ot_layout_feature_get_lookup_indexes 
  */
 
 hb_bool_t
 hb_ot_layout_has_substitution (hb_face_t *face)
 {
   return &_get_gsub (face) != &Null(GSUB);
 }
 
-void
-hb_ot_layout_substitute_start (hb_buffer_t  *buffer)
+hb_bool_t
+hb_ot_layout_would_substitute_lookup (hb_face_t            *face,
+				      const hb_codepoint_t *glyphs,
+				      unsigned int          glyphs_length,
+				      unsigned int          lookup_index)
 {
-  GSUB::substitute_start (buffer);
+  if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return false;
+  return hb_ot_layout_would_substitute_lookup_fast (face, glyphs, glyphs_length, lookup_index);
 }
 
 hb_bool_t
-hb_ot_layout_substitute_lookup (hb_face_t    *face,
+hb_ot_layout_would_substitute_lookup_fast (hb_face_t            *face,
+					   const hb_codepoint_t *glyphs,
+					   unsigned int          glyphs_length,
+					   unsigned int          lookup_index)
+{
+  if (unlikely (glyphs_length < 1 || glyphs_length > 2)) return false;
+  if (unlikely (lookup_index >= hb_ot_layout_from_face (face)->gsub_lookup_count)) return false;
+  hb_would_apply_context_t c (face, glyphs[0], glyphs_length == 2 ? glyphs[1] : -1, &hb_ot_layout_from_face (face)->gsub_digests[lookup_index]);
+  return hb_ot_layout_from_face (face)->gsub->would_substitute_lookup (&c, lookup_index);
+}
+
+void
+hb_ot_layout_substitute_start (hb_font_t *font, hb_buffer_t *buffer)
+{
+  GSUB::substitute_start (font, buffer);
+}
+
+hb_bool_t
+hb_ot_layout_substitute_lookup (hb_font_t    *font,
 				hb_buffer_t  *buffer,
 				unsigned int  lookup_index,
 				hb_mask_t     mask)
 {
-  hb_apply_context_t c (NULL, face, buffer, mask);
-  return _get_gsub (face).substitute_lookup (&c, lookup_index);
+  if (unlikely (lookup_index >= hb_ot_layout_from_face (font->face)->gsub_lookup_count)) return false;
+  hb_apply_context_t c (font, buffer, mask, &hb_ot_layout_from_face (font->face)->gsub_digests[lookup_index]);
+  return hb_ot_layout_from_face (font->face)->gsub->substitute_lookup (&c, lookup_index);
 }
 
 void
-hb_ot_layout_substitute_finish (hb_buffer_t  *buffer HB_UNUSED)
+hb_ot_layout_substitute_finish (hb_font_t *font, hb_buffer_t *buffer)
 {
-  GSUB::substitute_finish (buffer);
+  GSUB::substitute_finish (font, buffer);
 }
 
 void
 hb_ot_layout_substitute_closure_lookup (hb_face_t    *face,
 				        hb_set_t     *glyphs,
 				        unsigned int  lookup_index)
 {
   hb_closure_context_t c (face, glyphs);
@@ -486,55 +459,29 @@ hb_ot_layout_substitute_closure_lookup (
 
 hb_bool_t
 hb_ot_layout_has_positioning (hb_face_t *face)
 {
   return &_get_gpos (face) != &Null(GPOS);
 }
 
 void
-hb_ot_layout_position_start (hb_buffer_t  *buffer)
+hb_ot_layout_position_start (hb_font_t *font, hb_buffer_t *buffer)
 {
-  GPOS::position_start (buffer);
+  GPOS::position_start (font, buffer);
 }
 
 hb_bool_t
-hb_ot_layout_position_lookup   (hb_font_t    *font,
-				hb_buffer_t  *buffer,
-				unsigned int  lookup_index,
-				hb_mask_t     mask)
+hb_ot_layout_position_lookup (hb_font_t    *font,
+			      hb_buffer_t  *buffer,
+			      unsigned int  lookup_index,
+			      hb_mask_t     mask)
 {
-  hb_apply_context_t c (font, font->face, buffer, mask);
-  return _get_gpos (font->face).position_lookup (&c, lookup_index);
+  if (unlikely (lookup_index >= hb_ot_layout_from_face (font->face)->gpos_lookup_count)) return false;
+  hb_apply_context_t c (font, buffer, mask, &hb_ot_layout_from_face (font->face)->gpos_digests[lookup_index]);
+  return hb_ot_layout_from_face (font->face)->gpos->position_lookup (&c, lookup_index);
 }
 
 void
-hb_ot_layout_position_finish (hb_face_t *face, hb_buffer_t *buffer)
+hb_ot_layout_position_finish (hb_font_t *font, hb_buffer_t *buffer, hb_bool_t zero_width_attached_marks)
 {
-  /* force diacritics to have zero width */
-  unsigned int count = buffer->len;
-  const hb_glyph_info_t *info = buffer->info;
-  hb_glyph_position_t *positions = buffer->pos;
-  /*
-   * Forcibly zero widths of chars with GC=Mn; we don't use the GDEF 'Mark' class
-   * because some fonts (e.g. C-DAC Yogesh) classify spacing Indic matras as 'Mark'
-   * but we don't want to force their width to zero.
-   */
-  if (buffer->props.direction == HB_DIRECTION_RTL) {
-    for (unsigned int i = 1; i < count; i++) {
-      if (_hb_glyph_info_get_general_category (&info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK) {
-        positions[i].x_advance = 0;
-      }
-    }
-  } else {
-    for (unsigned int i = 1; i < count; i++) {
-      if (_hb_glyph_info_get_general_category (&info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK) {
-        hb_glyph_position_t& pos = positions[i];
-        pos.x_offset -= pos.x_advance;
-        pos.x_advance = 0;
-      }
-    }
-  }
-
-  GPOS::position_finish (buffer);
+  GPOS::position_finish (font, buffer, zero_width_attached_marks);
 }
-
-
diff --git a/gfx/harfbuzz/src/hb-ot-layout.h b/gfx/harfbuzz/src/hb-ot-layout.h
--- a/gfx/harfbuzz/src/hb-ot-layout.h
+++ b/gfx/harfbuzz/src/hb-ot-layout.h
@@ -37,16 +37,17 @@
 
 HB_BEGIN_DECLS
 
 
 #define HB_OT_TAG_GDEF HB_TAG('G','D','E','F')
 #define HB_OT_TAG_GSUB HB_TAG('G','S','U','B')
 #define HB_OT_TAG_GPOS HB_TAG('G','P','O','S')
 
+
 /*
  * GDEF
  */
 
 hb_bool_t
 hb_ot_layout_has_glyph_classes (hb_face_t *face);
 
 /* Not that useful.  Provides list of attach points for a glyph that a
@@ -163,53 +164,31 @@ hb_ot_layout_feature_get_lookup_indexes 
 
 /*
  * GSUB
  */
 
 hb_bool_t
 hb_ot_layout_has_substitution (hb_face_t *face);
 
-/* Should be called before all the substitute_lookup's are done. */
-void
-hb_ot_layout_substitute_start (hb_buffer_t  *buffer);
-
+/* Supports length 1 or 2 right now. */
 hb_bool_t
-hb_ot_layout_substitute_lookup (hb_face_t    *face,
-				hb_buffer_t  *buffer,
-				unsigned int  lookup_index,
-				hb_mask_t     mask);
-
-/* Should be called after all the substitute_lookup's are done */
-void
-hb_ot_layout_substitute_finish (hb_buffer_t  *buffer);
-
+hb_ot_layout_would_substitute_lookup (hb_face_t            *face,
+				      const hb_codepoint_t *glyphs,
+				      unsigned int          glyphs_length,
+				      unsigned int          lookup_index);
 
 void
 hb_ot_layout_substitute_closure_lookup (hb_face_t    *face,
 				        hb_set_t     *glyphs,
 				        unsigned int  lookup_index);
 
 /*
  * GPOS
  */
 
 hb_bool_t
 hb_ot_layout_has_positioning (hb_face_t *face);
 
-/* Should be called before all the position_lookup's are done.  Resets positions to zero. */
-void
-hb_ot_layout_position_start (hb_buffer_t  *buffer);
-
-hb_bool_t
-hb_ot_layout_position_lookup (hb_font_t    *font,
-			      hb_buffer_t  *buffer,
-			      unsigned int  lookup_index,
-			      hb_mask_t     mask);
-
-/* Should be called after all the position_lookup's are done */
-void
-hb_ot_layout_position_finish (hb_face_t *face, hb_buffer_t  *buffer);
-
 
 HB_END_DECLS
 
 #endif /* HB_OT_LAYOUT_H */
diff --git a/gfx/harfbuzz/src/hb-ot-map-private.hh b/gfx/harfbuzz/src/hb-ot-map-private.hh
--- a/gfx/harfbuzz/src/hb-ot-map-private.hh
+++ b/gfx/harfbuzz/src/hb-ot-map-private.hh
@@ -1,11 +1,11 @@
 /*
  * Copyright © 2009,2010  Red Hat, Inc.
- * Copyright © 2010,2011  Google, Inc.
+ * Copyright © 2010,2011,2012  Google, Inc.
  *
  *  This is part of HarfBuzz, a text shaping library.
  *
  * Permission is hereby granted, without written agreement and without
  * license or royalty fees, to use, copy, modify, and distribute this
  * software and its documentation for any purpose, provided that the
  * above copyright notice and the following two paragraphs appear in
  * all copies of this software.
@@ -26,68 +26,27 @@
  * Google Author(s): Behdad Esfahbod
  */
 
 #ifndef HB_OT_MAP_PRIVATE_HH
 #define HB_OT_MAP_PRIVATE_HH
 
 #include "hb-buffer-private.hh"
 
-#include "hb-ot-layout.h"
-
+#include "hb-ot-layout-private.hh"
 
 
 static const hb_tag_t table_tags[2] = {HB_OT_TAG_GSUB, HB_OT_TAG_GPOS};
 
 struct hb_ot_map_t
 {
   friend struct hb_ot_map_builder_t;
 
   public:
 
-  hb_ot_map_t (void) { memset (this, 0, sizeof (*this)); }
-
-  typedef void (*gsub_pause_func_t) (const hb_ot_map_t *map, hb_face_t *face, hb_buffer_t *buffer, void *user_data);
-  typedef void (*gpos_pause_func_t) (const hb_ot_map_t *map, hb_font_t *font, hb_buffer_t *buffer, void *user_data);
-
-  inline hb_mask_t get_global_mask (void) const { return global_mask; }
-
-  inline hb_mask_t get_mask (hb_tag_t tag, unsigned int *shift = NULL) const {
-    const feature_map_t *map = features.bsearch (&tag);
-    if (shift) *shift = map ? map->shift : 0;
-    return map ? map->mask : 0;
-  }
-
-  inline hb_mask_t get_1_mask (hb_tag_t tag) const {
-    const feature_map_t *map = features.bsearch (&tag);
-    return map ? map->_1_mask : 0;
-  }
-
-  inline hb_tag_t get_chosen_script (unsigned int table_index) const
-  { return chosen_script[table_index]; }
-
-  inline void substitute (hb_face_t *face, hb_buffer_t *buffer) const
-  { apply (0, (hb_ot_map_t::apply_lookup_func_t) hb_ot_layout_substitute_lookup, face, buffer); }
-  inline void position (hb_font_t *font, hb_buffer_t *buffer) const
-  { apply (1, (hb_ot_map_t::apply_lookup_func_t) hb_ot_layout_position_lookup, font, buffer); }
-
-  HB_INTERNAL void substitute_closure (hb_face_t *face,
-				       hb_set_t *glyphs) const;
-
-
-  inline void finish (void) {
-    features.finish ();
-    lookups[0].finish ();
-    lookups[1].finish ();
-    pauses[0].finish ();
-    pauses[1].finish ();
-  }
-
-  private:
-
   struct feature_map_t {
     hb_tag_t tag; /* should be first for our bsearch to work */
     unsigned int index[2]; /* GSUB/GPOS */
     unsigned int stage[2]; /* GSUB/GPOS */
     unsigned int shift;
     hb_mask_t mask;
     hb_mask_t _1_mask; /* mask for value=1, for quick access */
 
@@ -98,42 +57,86 @@ struct hb_ot_map_t
   struct lookup_map_t {
     unsigned int index;
     hb_mask_t mask;
 
     static int cmp (const lookup_map_t *a, const lookup_map_t *b)
     { return a->index < b->index ? -1 : a->index > b->index ? 1 : 0; }
   };
 
-  typedef void (*pause_func_t) (const hb_ot_map_t *map, void *face_or_font, hb_buffer_t *buffer, void *user_data);
-  typedef struct {
-    pause_func_t func;
-    void *user_data;
-  } pause_callback_t;
+  typedef void (*pause_func_t) (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer);
 
   struct pause_map_t {
     unsigned int num_lookups; /* Cumulative */
-    pause_callback_t callback;
+    pause_func_t callback;
   };
 
-  typedef hb_bool_t (*apply_lookup_func_t) (void *face_or_font,
-					    hb_buffer_t  *buffer,
-					    unsigned int  lookup_index,
-					    hb_mask_t     mask);
+
+  hb_ot_map_t (void) { memset (this, 0, sizeof (*this)); }
+
+  inline hb_mask_t get_global_mask (void) const { return global_mask; }
+
+  inline hb_mask_t get_mask (hb_tag_t feature_tag, unsigned int *shift = NULL) const {
+    const feature_map_t *map = features.bsearch (&feature_tag);
+    if (shift) *shift = map ? map->shift : 0;
+    return map ? map->mask : 0;
+  }
+
+  inline hb_mask_t get_1_mask (hb_tag_t feature_tag) const {
+    const feature_map_t *map = features.bsearch (&feature_tag);
+    return map ? map->_1_mask : 0;
+  }
+
+  inline unsigned int get_feature_index (unsigned int table_index, hb_tag_t feature_tag) const {
+    const feature_map_t *map = features.bsearch (&feature_tag);
+    return map ? map->index[table_index] : HB_OT_LAYOUT_NO_FEATURE_INDEX;
+  }
+
+  inline unsigned int get_feature_stage (unsigned int table_index, hb_tag_t feature_tag) const {
+    const feature_map_t *map = features.bsearch (&feature_tag);
+    return map ? map->stage[table_index] : (unsigned int) -1;
+  }
+
+  inline void get_stage_lookups (unsigned int table_index, unsigned int stage,
+				 const struct lookup_map_t **plookups, unsigned int *lookup_count) const {
+    if (unlikely (stage == (unsigned int) -1)) {
+      *plookups = NULL;
+      *lookup_count = 0;
+      return;
+    }
+    assert (stage <= pauses[table_index].len);
+    unsigned int start = stage ? pauses[table_index][stage - 1].num_lookups : 0;
+    unsigned int end   = stage < pauses[table_index].len ? pauses[table_index][stage].num_lookups : lookups[table_index].len;
+    *plookups = &lookups[table_index][start];
+    *lookup_count = end - start;
+  }
+
+  inline hb_tag_t get_chosen_script (unsigned int table_index) const
+  { return chosen_script[table_index]; }
+
+  HB_INTERNAL void substitute_closure (const struct hb_ot_shape_plan_t *plan, hb_face_t *face, hb_set_t *glyphs) const;
+  HB_INTERNAL void substitute (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const;
+  HB_INTERNAL void position (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const;
+
+  inline void finish (void) {
+    features.finish ();
+    lookups[0].finish ();
+    lookups[1].finish ();
+    pauses[0].finish ();
+    pauses[1].finish ();
+  }
+
+
+  private:
 
   HB_INTERNAL void add_lookups (hb_face_t    *face,
 				unsigned int  table_index,
 				unsigned int  feature_index,
 				hb_mask_t     mask);
 
-  HB_INTERNAL void apply (unsigned int table_index,
-			  hb_ot_map_t::apply_lookup_func_t apply_lookup_func,
-			  void *face_or_font,
-			  hb_buffer_t *buffer) const;
-
   hb_mask_t global_mask;
 
   hb_tag_t chosen_script[2];
   hb_prealloced_array_t<feature_map_t, 8> features;
   hb_prealloced_array_t<lookup_map_t, 32> lookups[2]; /* GSUB/GPOS */
   hb_prealloced_array_t<pause_map_t, 1> pauses[2]; /* GSUB/GPOS */
 };
 
@@ -144,20 +147,20 @@ struct hb_ot_map_builder_t
 
   hb_ot_map_builder_t (void) { memset (this, 0, sizeof (*this)); }
 
   HB_INTERNAL void add_feature (hb_tag_t tag, unsigned int value, bool global);
 
   inline void add_bool_feature (hb_tag_t tag, bool global = true)
   { add_feature (tag, 1, global); }
 
-  inline void add_gsub_pause (hb_ot_map_t::gsub_pause_func_t pause_func, void *user_data)
-  { add_pause (0, (hb_ot_map_t::pause_func_t) pause_func, user_data); }
-  inline void add_gpos_pause (hb_ot_map_t::gpos_pause_func_t pause_func, void *user_data)
-  { add_pause (1, (hb_ot_map_t::pause_func_t) pause_func, user_data); }
+  inline void add_gsub_pause (hb_ot_map_t::pause_func_t pause_func)
+  { add_pause (0, pause_func); }
+  inline void add_gpos_pause (hb_ot_map_t::pause_func_t pause_func)
+  { add_pause (1, pause_func); }
 
   HB_INTERNAL void compile (hb_face_t *face,
 			    const hb_segment_properties_t *props,
 			    struct hb_ot_map_t &m);
 
   inline void finish (void) {
     feature_infos.finish ();
     pauses[0].finish ();
@@ -175,20 +178,20 @@ struct hb_ot_map_builder_t
     unsigned int stage[2]; /* GSUB/GPOS */
 
     static int cmp (const feature_info_t *a, const feature_info_t *b)
     { return (a->tag != b->tag) ?  (a->tag < b->tag ? -1 : 1) : (a->seq < b->seq ? -1 : 1); }
   };
 
   struct pause_info_t {
     unsigned int stage;
-    hb_ot_map_t::pause_callback_t callback;
+    hb_ot_map_t::pause_func_t callback;
   };
 
-  HB_INTERNAL void add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func, void *user_data);
+  HB_INTERNAL void add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func);
 
   unsigned int current_stage[2]; /* GSUB/GPOS */
   hb_prealloced_array_t<feature_info_t,16> feature_infos;
   hb_prealloced_array_t<pause_info_t, 1> pauses[2]; /* GSUB/GPOS */
 };
 
 
 
diff --git a/gfx/harfbuzz/src/hb-ot-map.cc b/gfx/harfbuzz/src/hb-ot-map.cc
--- a/gfx/harfbuzz/src/hb-ot-map.cc
+++ b/gfx/harfbuzz/src/hb-ot-map.cc
@@ -23,19 +23,16 @@
  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  *
  * Red Hat Author(s): Behdad Esfahbod
  * Google Author(s): Behdad Esfahbod
  */
 
 #include "hb-ot-map-private.hh"
 
-#include "hb-ot-shape-private.hh"
-
-
 
 void
 hb_ot_map_t::add_lookups (hb_face_t    *face,
 			  unsigned int  table_index,
 			  unsigned int  feature_index,
 			  hb_mask_t     mask)
 {
   unsigned int lookup_indices[32];
@@ -71,60 +68,77 @@ void hb_ot_map_builder_t::add_feature (h
   info->seq = feature_infos.len;
   info->max_value = value;
   info->global = global;
   info->default_value = global ? value : 0;
   info->stage[0] = current_stage[0];
   info->stage[1] = current_stage[1];
 }
 
-void hb_ot_map_t::apply (unsigned int table_index,
-			 hb_ot_map_t::apply_lookup_func_t apply_lookup_func,
-			 void *face_or_font,
-			 hb_buffer_t *buffer) const
+/* Keep the next two functions in sync. */
+
+void hb_ot_map_t::substitute (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const
 {
+  const unsigned int table_index = 0;
   unsigned int i = 0;
 
   for (unsigned int pause_index = 0; pause_index < pauses[table_index].len; pause_index++) {
     const pause_map_t *pause = &pauses[table_index][pause_index];
     for (; i < pause->num_lookups; i++)
-      apply_lookup_func (face_or_font, buffer, lookups[table_index][i].index, lookups[table_index][i].mask);
+      hb_ot_layout_substitute_lookup (font, buffer, lookups[table_index][i].index, lookups[table_index][i].mask);
 
-    pause->callback.func (this, face_or_font, buffer, pause->callback.user_data);
+    buffer->clear_output ();
+
+    if (pause->callback)
+      pause->callback (plan, font, buffer);
   }
 
   for (; i < lookups[table_index].len; i++)
-    apply_lookup_func (face_or_font, buffer, lookups[table_index][i].index, lookups[table_index][i].mask);
+    hb_ot_layout_substitute_lookup (font, buffer, lookups[table_index][i].index, lookups[table_index][i].mask);
 }
 
-void hb_ot_map_t::substitute_closure (hb_face_t *face,
-				      hb_set_t *glyphs) const
+void hb_ot_map_t::position (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const
+{
+  const unsigned int table_index = 1;
+  unsigned int i = 0;
+
+  for (unsigned int pause_index = 0; pause_index < pauses[table_index].len; pause_index++) {
+    const pause_map_t *pause = &pauses[table_index][pause_index];
+    for (; i < pause->num_lookups; i++)
+      hb_ot_layout_position_lookup (font, buffer, lookups[table_index][i].index, lookups[table_index][i].mask);
+
+    if (pause->callback)
+      pause->callback (plan, font, buffer);
+  }
+
+  for (; i < lookups[table_index].len; i++)
+    hb_ot_layout_position_lookup (font, buffer, lookups[table_index][i].index, lookups[table_index][i].mask);
+}
+
+void hb_ot_map_t::substitute_closure (const hb_ot_shape_plan_t *plan, hb_face_t *face, hb_set_t *glyphs) const
 {
   unsigned int table_index = 0;
   unsigned int i = 0;
 
   for (unsigned int pause_index = 0; pause_index < pauses[table_index].len; pause_index++) {
     const pause_map_t *pause = &pauses[table_index][pause_index];
     for (; i < pause->num_lookups; i++)
       hb_ot_layout_substitute_closure_lookup (face, glyphs, lookups[table_index][i].index);
   }
 
   for (; i < lookups[table_index].len; i++)
     hb_ot_layout_substitute_closure_lookup (face, glyphs, lookups[table_index][i].index);
 }
 
-void hb_ot_map_builder_t::add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func, void *user_data)
+void hb_ot_map_builder_t::add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func)
 {
-  if (pause_func) {
-    pause_info_t *p = pauses[table_index].push ();
-    if (likely (p)) {
-      p->stage = current_stage[table_index];
-      p->callback.func = pause_func;
-      p->callback.user_data = user_data;
-    }
+  pause_info_t *p = pauses[table_index].push ();
+  if (likely (p)) {
+    p->stage = current_stage[table_index];
+    p->callback = pause_func;
   }
 
   current_stage[table_index]++;
 }
 
 void
 hb_ot_map_builder_t::compile (hb_face_t *face,
 			      const hb_segment_properties_t *props,
@@ -228,18 +242,18 @@ hb_ot_map_builder_t::compile (hb_face_t 
 	m.global_mask |= (info->default_value << map->shift) & map->mask;
     }
     map->_1_mask = (1 << map->shift) & map->mask;
 
   }
   feature_infos.shrink (0); /* Done with these */
 
 
-  add_gsub_pause (NULL, NULL);
-  add_gpos_pause (NULL, NULL);
+  add_gsub_pause (NULL);
+  add_gpos_pause (NULL);
 
   for (unsigned int table_index = 0; table_index < 2; table_index++) {
     hb_tag_t table_tag = table_tags[table_index];
 
     /* Collect lookup indices for features */
 
     unsigned int required_feature_index;
     if (hb_ot_layout_language_get_required_feature_index (face,
@@ -280,10 +294,8 @@ hb_ot_map_builder_t::compile (hb_face_t 
 	  pause_map->callback = pauses[table_index][pause_index].callback;
 	}
 
 	pause_index++;
       }
     }
   }
 }
-
-
diff --git a/gfx/harfbuzz/src/hb-ot-maxp-table.hh b/gfx/harfbuzz/src/hb-ot-maxp-table.hh
--- a/gfx/harfbuzz/src/hb-ot-maxp-table.hh
+++ b/gfx/harfbuzz/src/hb-ot-maxp-table.hh
@@ -47,17 +47,17 @@ struct maxp
 
   inline bool sanitize (hb_sanitize_context_t *c) {
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) &&
 			 likely (version.major == 1 || (version.major == 0 && version.minor == 0x5000)));
   }
 
   /* We only implement version 0.5 as none of the extra fields in version 1.0 are useful. */
-  private:
+  protected:
   FixedVersion	version;		/* Version of the maxp table (0.5 or 1.0),
 					 * 0x00005000 or 0x00010000. */
   USHORT	numGlyphs;		/* The number of glyphs in the font. */
   public:
   DEFINE_SIZE_STATIC (6);
 };
 
 
diff --git a/gfx/harfbuzz/src/hb-ot-name-table.hh b/gfx/harfbuzz/src/hb-ot-name-table.hh
--- a/gfx/harfbuzz/src/hb-ot-name-table.hh
+++ b/gfx/harfbuzz/src/hb-ot-name-table.hh
@@ -109,17 +109,17 @@ struct name
     TRACE_SANITIZE ();
     return TRACE_RETURN (c->check_struct (this) &&
 			 likely (format == 0 || format == 1) &&
 			 c->check_array (nameRecord, nameRecord[0].static_size, count) &&
 			 sanitize_records (c));
   }
 
   /* We only implement format 0 for now. */
-  private:
+  protected:
   USHORT	format;			/* Format selector (=0/1). */
   USHORT	count;			/* Number of name records. */
   Offset	stringOffset;		/* Offset to start of string storage (from start of table). */
   NameRecord	nameRecord[VAR];	/* The name records where count is the number of records. */
   public:
   DEFINE_SIZE_ARRAY (6, nameRecord);
 };
 
diff --git a/gfx/harfbuzz/src/hb-ot-shape-complex-arabic.cc b/gfx/harfbuzz/src/hb-ot-shape-complex-arabic.cc
--- a/gfx/harfbuzz/src/hb-ot-shape-complex-arabic.cc
+++ b/gfx/harfbuzz/src/hb-ot-shape-complex-arabic.cc
@@ -159,96 +159,91 @@ static const struct arabic_state_table_e
   { {NONE,NONE,0}, {ISOL,ISOL,1}, {ISOL,ISOL,2}, {ISOL,FIN2,5}, {ISOL,ISOL,6}, },
 
   /* State 6: prev was DALATH/RISH, not willing to join. */
   { {NONE,NONE,0}, {NONE,ISOL,1}, {NONE,ISOL,2}, {NONE,FIN3,5}, {NONE,ISOL,6}, }
 };
 
 
 
-void
-_hb_ot_shape_complex_collect_features_arabic (hb_ot_map_builder_t *map,
-					      const hb_segment_properties_t *props)
+static void
+collect_features_arabic (hb_ot_shape_planner_t *plan)
 {
+  hb_ot_map_builder_t *map = &plan->map;
+
   /* For Language forms (in ArabicOT speak), we do the iso/fina/medi/init together,
    * then rlig and calt each in their own stage.  This makes IranNastaliq's ALLAH
    * ligature work correctly. It's unfortunate though...
    *
    * This also makes Arial Bold in Windows7 work.  See:
    * https://bugzilla.mozilla.org/show_bug.cgi?id=644184
    *
    * TODO: Add test cases for these two.
    */
 
   map->add_bool_feature (HB_TAG('c','c','m','p'));
   map->add_bool_feature (HB_TAG('l','o','c','l'));
 
-  map->add_gsub_pause (NULL, NULL);
+  map->add_gsub_pause (NULL);
 
-  unsigned int num_features = props->script == HB_SCRIPT_SYRIAC ? SYRIAC_NUM_FEATURES : COMMON_NUM_FEATURES;
+  unsigned int num_features = plan->props.script == HB_SCRIPT_SYRIAC ? SYRIAC_NUM_FEATURES : COMMON_NUM_FEATURES;
   for (unsigned int i = 0; i < num_features; i++)
     map->add_bool_feature (arabic_syriac_features[i], false);
 
-  map->add_gsub_pause (NULL, NULL);
+  map->add_gsub_pause (NULL);
 
   map->add_bool_feature (HB_TAG('r','l','i','g'));
-  map->add_gsub_pause (NULL, NULL);
+  map->add_gsub_pause (NULL);
 
   map->add_bool_feature (HB_TAG('c','a','l','t'));
-  map->add_gsub_pause (NULL, NULL);
+  map->add_gsub_pause (NULL);
 
   /* ArabicOT spec enables 'cswh' for Arabic where as for basic shaper it's disabled by default. */
   map->add_bool_feature (HB_TAG('c','s','w','h'));
 }
 
-hb_ot_shape_normalization_mode_t
-_hb_ot_shape_complex_normalization_preference_arabic (void)
-{
-  return HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS;
-}
-
 
 static void
 arabic_fallback_shape (hb_font_t *font, hb_buffer_t *buffer)
 {
   unsigned int count = buffer->len;
   hb_codepoint_t glyph;
 
   /* Shape to presentation forms */
   for (unsigned int i = 0; i < count; i++) {
     hb_codepoint_t u = buffer->info[i].codepoint;
     hb_codepoint_t shaped = get_arabic_shape (u, buffer->info[i].arabic_shaping_action());
-    if (shaped != u && hb_font_get_glyph (font, shaped, 0, &glyph))
+    if (shaped != u && font->get_glyph (shaped, 0, &glyph))
       buffer->info[i].codepoint = shaped;
   }
 
   /* Mandatory ligatures */
   buffer->clear_output ();
   for (buffer->idx = 0; buffer->idx + 1 < count;) {
     hb_codepoint_t ligature = get_ligature (buffer->cur().codepoint,
 					    buffer->cur(+1).codepoint);
-    if (likely (!ligature) || !(hb_font_get_glyph (font, ligature, 0, &glyph))) {
+    if (likely (!ligature) || !(font->get_glyph (ligature, 0, &glyph))) {
       buffer->next_glyph ();
       continue;
     }
 
     buffer->replace_glyphs (2, 1, &ligature);
 
     /* Technically speaking we can skip marks and stuff, like the GSUB path does.
      * But who cares, we're in fallback! */
   }
   for (; buffer->idx < count;)
       buffer->next_glyph ();
   buffer->swap_buffers ();
 }
 
-void
-_hb_ot_shape_complex_setup_masks_arabic (hb_ot_map_t *map,
-					 hb_buffer_t *buffer,
-					 hb_font_t *font)
+static void
+setup_masks_arabic (const hb_ot_shape_plan_t *plan,
+		    hb_buffer_t              *buffer,
+		    hb_font_t                *font)
 {
   unsigned int count = buffer->len;
   unsigned int prev = 0, state = 0;
 
   HB_BUFFER_ALLOCATE_VAR (buffer, arabic_shaping_action);
 
   for (unsigned int i = 0; i < count; i++)
   {
@@ -269,17 +264,17 @@ void
     prev = i;
     state = entry->next_state;
   }
 
   hb_mask_t mask_array[TOTAL_NUM_FEATURES + 1] = {0};
   hb_mask_t total_masks = 0;
   unsigned int num_masks = buffer->props.script == HB_SCRIPT_SYRIAC ? SYRIAC_NUM_FEATURES : COMMON_NUM_FEATURES;
   for (unsigned int i = 0; i < num_masks; i++) {
-    mask_array[i] = map->get_1_mask (arabic_syriac_features[i]);
+    mask_array[i] = plan->map.get_1_mask (arabic_syriac_features[i]);
     total_masks |= mask_array[i];
   }
 
   if (total_masks) {
     /* Has OpenType tables */
     for (unsigned int i = 0; i < count; i++)
       buffer->info[i].mask |= mask_array[buffer->info[i].arabic_shaping_action()];
   } else if (buffer->props.script == HB_SCRIPT_ARABIC) {
@@ -291,9 +286,19 @@ void
      *   still mean Arabic shaping, although they do not have to.
      */
     arabic_fallback_shape (font, buffer);
   }
 
   HB_BUFFER_DEALLOCATE_VAR (buffer, arabic_shaping_action);
 }
 
-
+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_arabic =
+{
+  "arabic",
+  collect_features_arabic,
+  NULL, /* override_features */
+  NULL, /* data_create */
+  NULL, /* data_destroy */
+  NULL, /* normalization_preference */
+  setup_masks_arabic,
+  true, /* zero_width_attached_marks */
+};
diff --git a/gfx/harfbuzz/src/hb-ot-shape-complex-indic-machine.hh b/gfx/harfbuzz/src/hb-ot-shape-complex-indic-machine.hh
--- a/gfx/harfbuzz/src/hb-ot-shape-complex-indic-machine.hh
+++ b/gfx/harfbuzz/src/hb-ot-shape-complex-indic-machine.hh
@@ -26,183 +26,772 @@
  * Google Author(s): Behdad Esfahbod
  */
 
 #ifndef HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH
 #define HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH
 
 #include "hb-private.hh"
 
-HB_BEGIN_DECLS
 
-
-#line 38 "hb-ot-shape-complex-indic-machine.hh.tmp"
+#line 36 "hb-ot-shape-complex-indic-machine.hh.tmp"
 static const unsigned char _indic_syllable_machine_trans_keys[] = {
-	5u, 5u, 1u, 2u, 1u, 2u, 5u, 5u, 1u, 5u, 1u, 2u, 5u, 5u, 1u, 13u, 
-	4u, 11u, 4u, 11u, 5u, 11u, 1u, 10u, 1u, 10u, 10u, 10u, 10u, 10u, 4u, 10u, 
-	5u, 10u, 8u, 10u, 5u, 10u, 6u, 10u, 9u, 10u, 4u, 11u, 1u, 13u, 4u, 10u, 
-	4u, 10u, 5u, 10u, 4u, 10u, 5u, 10u, 8u, 10u, 10u, 10u, 10u, 10u, 4u, 10u, 
-	4u, 10u, 5u, 10u, 4u, 10u, 5u, 10u, 8u, 10u, 10u, 10u, 10u, 10u, 0
+	1u, 16u, 13u, 13u, 4u, 14u, 5u, 7u, 7u, 7u, 5u, 7u, 5u, 7u, 7u, 7u, 
+	5u, 7u, 5u, 7u, 7u, 7u, 5u, 7u, 5u, 7u, 7u, 7u, 4u, 4u, 6u, 6u, 
+	16u, 16u, 4u, 7u, 6u, 6u, 16u, 16u, 4u, 7u, 6u, 6u, 16u, 16u, 4u, 7u, 
+	6u, 6u, 16u, 16u, 4u, 14u, 4u, 14u, 4u, 14u, 4u, 14u, 4u, 14u, 4u, 14u, 
+	4u, 14u, 4u, 14u, 4u, 14u, 1u, 16u, 13u, 13u, 4u, 14u, 5u, 7u, 7u, 7u, 
+	5u, 7u, 5u, 7u, 7u, 7u, 5u, 7u, 5u, 7u, 7u, 7u, 5u, 7u, 5u, 7u, 
+	7u, 7u, 4u, 4u, 6u, 6u, 16u, 16u, 4u, 7u, 6u, 6u, 16u, 16u, 4u, 7u, 
+	6u, 6u, 16u, 16u, 4u, 7u, 6u, 6u, 16u, 16u, 4u, 14u, 4u, 14u, 4u, 14u, 
+	4u, 14u, 4u, 14u, 4u, 14u, 4u, 14u, 4u, 14u, 4u, 14u, 1u, 16u, 13u, 13u, 
+	4u, 14u, 5u, 7u, 7u, 7u, 5u, 7u, 5u, 7u, 7u, 7u, 5u, 7u, 5u, 7u, 
+	7u, 7u, 5u, 7u, 5u, 7u, 7u, 7u, 4u, 4u, 6u, 6u, 16u, 16u, 4u, 7u, 
+	6u, 6u, 16u, 16u, 4u, 7u, 6u, 6u, 16u, 16u, 4u, 7u, 6u, 6u, 16u, 16u, 
+	4u, 14u, 4u, 14u, 4u, 14u, 4u, 14u, 4u, 14u, 4u, 14u, 4u, 14u, 4u, 14u, 
+	4u, 14u, 1u, 16u, 3u, 14u, 3u, 14u, 4u, 14u, 1u, 16u, 3u, 14u, 3u, 14u, 
+	4u, 14u, 1u, 16u, 3u, 14u, 3u, 14u, 4u, 14u, 1u, 16u, 3u, 14u, 3u, 14u, 
+	4u, 14u, 1u, 16u, 3u, 14u, 3u, 14u, 4u, 14u, 5u, 14u, 8u, 14u, 5u, 14u, 
+	9u, 14u, 9u, 9u, 3u, 13u, 3u, 9u, 9u, 9u, 3u, 9u, 6u, 14u, 3u, 14u, 
+	4u, 14u, 5u, 14u, 3u, 14u, 4u, 14u, 5u, 14u, 3u, 14u, 4u, 14u, 5u, 14u, 
+	3u, 14u, 4u, 14u, 4u, 14u, 1u, 16u, 3u, 14u, 1u, 16u, 1u, 16u, 1u, 16u, 
+	3u, 14u, 1u, 16u, 1u, 16u, 1u, 16u, 3u, 14u, 1u, 16u, 1u, 16u, 1u, 16u, 
+	3u, 14u, 1u, 16u, 1u, 16u, 1u, 16u, 3u, 14u, 3u, 14u, 3u, 14u, 4u, 14u, 
+	1u, 16u, 3u, 14u, 3u, 14u, 4u, 14u, 1u, 16u, 3u, 14u, 3u, 14u, 4u, 14u, 
+	1u, 16u, 3u, 14u, 3u, 14u, 4u, 14u, 1u, 16u, 3u, 14u, 3u, 14u, 4u, 14u, 
+	5u, 14u, 8u, 14u, 5u, 14u, 9u, 14u, 9u, 9u, 3u, 13u, 3u, 9u, 9u, 9u, 
+	3u, 9u, 6u, 14u, 3u, 14u, 4u, 14u, 5u, 14u, 3u, 14u, 4u, 14u, 5u, 14u, 
+	3u, 14u, 4u, 14u, 5u, 14u, 3u, 14u, 4u, 14u, 1u, 16u, 3u, 14u, 1u, 16u, 
+	1u, 16u, 1u, 16u, 3u, 14u, 1u, 16u, 1u, 16u, 1u, 16u, 3u, 14u, 1u, 16u, 
+	1u, 16u, 1u, 16u, 3u, 14u, 1u, 16u, 1u, 16u, 4u, 14u, 1u, 16u, 3u, 14u, 
+	3u, 14u, 3u, 14u, 4u, 14u, 1u, 16u, 3u, 14u, 3u, 14u, 4u, 14u, 1u, 16u, 
+	3u, 14u, 3u, 14u, 4u, 14u, 1u, 16u, 3u, 14u, 3u, 14u, 4u, 14u, 1u, 16u, 
+	3u, 14u, 3u, 14u, 4u, 14u, 5u, 14u, 8u, 14u, 5u, 14u, 9u, 14u, 9u, 9u, 
+	3u, 13u, 3u, 9u, 9u, 9u, 3u, 9u, 6u, 14u, 3u, 14u, 4u, 14u, 5u, 14u, 
+	3u, 14u, 4u, 14u, 5u, 14u, 3u, 14u, 4u, 14u, 5u, 14u, 3u, 14u, 4u, 14u, 
+	1u, 16u, 3u, 14u, 1u, 16u, 1u, 16u, 1u, 16u, 3u, 14u, 1u, 16u, 1u, 16u, 
+	1u, 16u, 3u, 14u, 1u, 16u, 1u, 16u, 1u, 16u, 3u, 14u, 1u, 16u, 1u, 16u, 
+	1u, 16u, 3u, 14u, 1u, 16u, 3u, 14u, 1u, 16u, 0
 };
 
 static const char _indic_syllable_machine_key_spans[] = {
-	1, 2, 2, 1, 5, 2, 1, 13, 
-	8, 8, 7, 10, 10, 1, 1, 7, 
-	6, 3, 6, 5, 2, 8, 13, 7, 
-	7, 6, 7, 6, 3, 1, 1, 7, 
-	7, 6, 7, 6, 3, 1, 1
+	16, 1, 11, 3, 1, 3, 3, 1, 
+	3, 3, 1, 3, 3, 1, 1, 1, 
+	1, 4, 1, 1, 4, 1, 1, 4, 
+	1, 1, 11, 11, 11, 11, 11, 11, 
+	11, 11, 11, 16, 1, 11, 3, 1, 
+	3, 3, 1, 3, 3, 1, 3, 3, 
+	1, 1, 1, 1, 4, 1, 1, 4, 
+	1, 1, 4, 1, 1, 11, 11, 11, 
+	11, 11, 11, 11, 11, 11, 16, 1, 
+	11, 3, 1, 3, 3, 1, 3, 3, 
+	1, 3, 3, 1, 1, 1, 1, 4, 
+	1, 1, 4, 1, 1, 4, 1, 1, 
+	11, 11, 11, 11, 11, 11, 11, 11, 
+	11, 16, 12, 12, 11, 16, 12, 12, 
+	11, 16, 12, 12, 11, 16, 12, 12, 
+	11, 16, 12, 12, 11, 10, 7, 10, 
+	6, 1, 11, 7, 1, 7, 9, 12, 
+	11, 10, 12, 11, 10, 12, 11, 10, 
+	12, 11, 11, 16, 12, 16, 16, 16, 
+	12, 16, 16, 16, 12, 16, 16, 16, 
+	12, 16, 16, 16, 12, 12, 12, 11, 
+	16, 12, 12, 11, 16, 12, 12, 11, 
+	16, 12, 12, 11, 16, 12, 12, 11, 
+	10, 7, 10, 6, 1, 11, 7, 1, 
+	7, 9, 12, 11, 10, 12, 11, 10, 
+	12, 11, 10, 12, 11, 16, 12, 16, 
+	16, 16, 12, 16, 16, 16, 12, 16, 
+	16, 16, 12, 16, 16, 11, 16, 12, 
+	12, 12, 11, 16, 12, 12, 11, 16, 
+	12, 12, 11, 16, 12, 12, 11, 16, 
+	12, 12, 11, 10, 7, 10, 6, 1, 
+	11, 7, 1, 7, 9, 12, 11, 10, 
+	12, 11, 10, 12, 11, 10, 12, 11, 
+	16, 12, 16, 16, 16, 12, 16, 16, 
+	16, 12, 16, 16, 16, 12, 16, 16, 
+	16, 12, 16, 12, 16
 };
 
-static const unsigned char _indic_syllable_machine_index_offsets[] = {
-	0, 2, 5, 8, 10, 16, 19, 21, 
-	35, 44, 53, 61, 72, 83, 85, 87, 
-	95, 102, 106, 113, 119, 122, 131, 145, 
-	153, 161, 168, 176, 183, 187, 189, 191, 
-	199, 207, 214, 222, 229, 233, 235
+static const short _indic_syllable_machine_index_offsets[] = {
+	0, 17, 19, 31, 35, 37, 41, 45, 
+	47, 51, 55, 57, 61, 65, 67, 69, 
+	71, 73, 78, 80, 82, 87, 89, 91, 
+	96, 98, 100, 112, 124, 136, 148, 160, 
+	172, 184, 196, 208, 225, 227, 239, 243, 
+	245, 249, 253, 255, 259, 263, 265, 269, 
+	273, 275, 277, 279, 281, 286, 288, 290, 
+	295, 297, 299, 304, 306, 308, 320, 332, 
+	344, 356, 368, 380, 392, 404, 416, 433, 
+	435, 447, 451, 453, 457, 461, 463, 467, 
+	471, 473, 477, 481, 483, 485, 487, 489, 
+	494, 496, 498, 503, 505, 507, 512, 514, 
+	516, 528, 540, 552, 564, 576, 588, 600, 
+	612, 624, 641, 654, 667, 679, 696, 709, 
+	722, 734, 751, 764, 777, 789, 806, 819, 
+	832, 844, 861, 874, 887, 899, 910, 918, 
+	929, 936, 938, 950, 958, 960, 968, 978, 
+	991, 1003, 1014, 1027, 1039, 1050, 1063, 1075, 
+	1086, 1099, 1111, 1123, 1140, 1153, 1170, 1187, 
+	1204, 1217, 1234, 1251, 1268, 1281, 1298, 1315, 
+	1332, 1345, 1362, 1379, 1396, 1409, 1422, 1435, 
+	1447, 1464, 1477, 1490, 1502, 1519, 1532, 1545, 
+	1557, 1574, 1587, 1600, 1612, 1629, 1642, 1655, 
+	1667, 1678, 1686, 1697, 1704, 1706, 1718, 1726, 
+	1728, 1736, 1746, 1759, 1771, 1782, 1795, 1807, 
+	1818, 1831, 1843, 1854, 1867, 1879, 1896, 1909, 
+	1926, 1943, 1960, 1973, 1990, 2007, 2024, 2037, 
+	2054, 2071, 2088, 2101, 2118, 2135, 2147, 2164, 
+	2177, 2190, 2203, 2215, 2232, 2245, 2258, 2270, 
+	2287, 2300, 2313, 2325, 2342, 2355, 2368, 2380, 
+	2397, 2410, 2423, 2435, 2446, 2454, 2465, 2472, 
+	2474, 2486, 2494, 2496, 2504, 2514, 2527, 2539, 
+	2550, 2563, 2575, 2586, 2599, 2611, 2622, 2635, 
+	2647, 2664, 2677, 2694, 2711, 2728, 2741, 2758, 
+	2775, 2792, 2805, 2822, 2839, 2856, 2869, 2886, 
+	2903, 2920, 2933, 2950, 2963
 };
 
-static const char _indic_syllable_machine_indicies[] = {
-	1, 0, 2, 2, 0, 4, 4, 3, 
-	5, 3, 4, 4, 3, 3, 5, 3, 
-	7, 7, 6, 8, 6, 2, 10, 11, 
-	9, 9, 9, 9, 9, 9, 9, 9, 
-	12, 12, 9, 14, 15, 16, 16, 17, 
-	18, 19, 20, 13, 21, 15, 16, 16, 
-	17, 18, 19, 20, 13, 15, 16, 16, 
-	17, 18, 19, 20, 13, 2, 2, 13, 
-	13, 13, 22, 22, 13, 18, 19, 13, 
-	2, 2, 13, 13, 13, 13, 13, 13, 
-	18, 19, 13, 19, 13, 23, 13, 24, 
-	25, 13, 13, 17, 18, 19, 13, 25, 
-	13, 13, 17, 18, 19, 13, 17, 18, 
-	19, 13, 26, 13, 13, 17, 18, 19, 
-	13, 27, 27, 13, 18, 19, 13, 18, 
-	19, 13, 14, 28, 16, 16, 17, 18, 
-	19, 20, 13, 2, 2, 11, 13, 13, 
-	22, 22, 13, 18, 19, 13, 12, 12, 
-	13, 30, 5, 31, 32, 33, 34, 35, 
-	29, 4, 5, 31, 32, 33, 34, 35, 
-	29, 5, 31, 32, 33, 34, 35, 29, 
-	36, 37, 29, 29, 33, 34, 35, 29, 
-	37, 29, 29, 33, 34, 35, 29, 33, 
-	34, 35, 29, 35, 29, 38, 29, 40, 
-	8, 41, 41, 42, 43, 44, 39, 7, 
-	8, 41, 41, 42, 43, 44, 39, 8, 
-	41, 41, 42, 43, 44, 39, 45, 46, 
-	39, 39, 42, 43, 44, 39, 46, 39, 
-	39, 42, 43, 44, 39, 42, 43, 44, 
-	39, 44, 39, 47, 39, 0
+static const short _indic_syllable_machine_indicies[] = {
+	1, 2, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 1, 
+	0, 3, 0, 4, 5, 5, 6, 0, 
+	0, 0, 0, 0, 0, 4, 0, 7, 
+	7, 6, 0, 6, 0, 8, 8, 9, 
+	0, 10, 10, 9, 0, 9, 0, 11, 
+	11, 12, 0, 13, 13, 12, 0, 12, 
+	0, 14, 14, 15, 0, 16, 16, 15, 
+	0, 15, 0, 17, 0, 18, 0, 19, 
+	0, 20, 14, 14, 15, 0, 21, 0, 
+	22, 0, 23, 11, 11, 12, 0, 24, 
+	0, 25, 0, 26, 8, 8, 9, 0, 
+	27, 0, 28, 0, 4, 5, 5, 6, 
+	0, 0, 0, 0, 0, 29, 4, 0, 
+	30, 5, 5, 6, 0, 0, 0, 0, 
+	0, 0, 30, 0, 30, 5, 5, 6, 
+	0, 0, 0, 0, 0, 31, 30, 0, 
+	32, 5, 5, 6, 0, 0, 0, 0, 
+	0, 0, 32, 0, 32, 5, 5, 6, 
+	0, 0, 0, 0, 0, 33, 32, 0, 
+	34, 5, 5, 6, 0, 0, 0, 0, 
+	0, 0, 34, 0, 34, 5, 5, 6, 
+	0, 0, 0, 0, 0, 35, 34, 0, 
+	36, 5, 5, 6, 0, 0, 0, 0, 
+	0, 0, 36, 0, 36, 5, 5, 6, 
+	0, 0, 0, 0, 0, 37, 36, 0, 
+	39, 40, 38, 38, 38, 38, 38, 38, 
+	38, 38, 38, 38, 38, 38, 38, 39, 
+	38, 41, 38, 42, 43, 43, 44, 38, 
+	38, 38, 38, 38, 38, 42, 38, 45, 
+	45, 44, 38, 44, 38, 46, 46, 47, 
+	38, 48, 48, 47, 38, 47, 38, 49, 
+	49, 50, 38, 51, 51, 50, 38, 50, 
+	38, 52, 52, 53, 38, 54, 54, 53, 
+	38, 53, 38, 55, 38, 56, 38, 57, 
+	38, 58, 52, 52, 53, 38, 59, 38, 
+	60, 38, 61, 49, 49, 50, 38, 62, 
+	38, 63, 38, 64, 46, 46, 47, 38, 
+	65, 38, 66, 38, 42, 43, 43, 44, 
+	38, 38, 38, 38, 38, 67, 42, 38, 
+	68, 43, 43, 44, 38, 38, 38, 38, 
+	38, 38, 68, 38, 68, 43, 43, 44, 
+	38, 38, 38, 38, 38, 69, 68, 38, 
+	70, 43, 43, 44, 38, 38, 38, 38, 
+	38, 38, 70, 38, 70, 43, 43, 44, 
+	38, 38, 38, 38, 38, 71, 70, 38, 
+	72, 43, 43, 44, 38, 38, 38, 38, 
+	38, 38, 72, 38, 72, 43, 43, 44, 
+	38, 38, 38, 38, 38, 73, 72, 38, 
+	74, 43, 43, 44, 38, 38, 38, 38, 
+	38, 38, 74, 38, 74, 43, 43, 44, 
+	38, 38, 38, 38, 38, 75, 74, 38, 
+	77, 78, 76, 76, 76, 76, 76, 76, 
+	76, 76, 76, 76, 76, 76, 76, 77, 
+	76, 79, 76, 80, 81, 81, 82, 76, 
+	76, 76, 76, 76, 76, 80, 76, 83, 
+	83, 82, 76, 82, 76, 84, 84, 85, 
+	76, 86, 86, 85, 76, 85, 76, 87, 
+	87, 88, 76, 89, 89, 88, 76, 88, 
+	76, 90, 90, 91, 76, 92, 92, 91, 
+	76, 91, 76, 93, 76, 94, 76, 95, 
+	76, 96, 90, 90, 91, 76, 97, 76, 
+	98, 76, 99, 87, 87, 88, 76, 100, 
+	76, 101, 76, 102, 84, 84, 85, 76, 
+	103, 76, 104, 76, 80, 81, 81, 82, 
+	76, 76, 76, 76, 76, 105, 80, 76, 
+	106, 81, 81, 82, 76, 76, 76, 76, 
+	76, 76, 106, 76, 106, 81, 81, 82, 
+	76, 76, 76, 76, 76, 107, 106, 76, 
+	108, 81, 81, 82, 76, 76, 76, 76, 
+	76, 76, 108, 76, 108, 81, 81, 82, 
+	76, 76, 76, 76, 76, 109, 108, 76, 
+	110, 81, 81, 82, 76, 76, 76, 76, 
+	76, 76, 110, 76, 110, 81, 81, 82, 
+	76, 76, 76, 76, 76, 111, 110, 76, 
+	112, 81, 81, 82, 76, 76, 76, 76, 
+	76, 76, 112, 76, 112, 81, 81, 82, 
+	76, 76, 76, 76, 76, 113, 112, 76, 
+	115, 116, 114, 114, 114, 114, 114, 114, 
+	114, 114, 117, 117, 114, 114, 118, 119, 
+	114, 121, 122, 123, 124, 6, 125, 126, 
+	127, 120, 120, 37, 128, 120, 129, 122, 
+	124, 124, 6, 125, 126, 127, 120, 120, 
+	120, 128, 120, 122, 124, 124, 6, 125, 
+	126, 127, 120, 120, 120, 128, 120, 130, 
+	120, 120, 120, 19, 131, 120, 125, 126, 
+	120, 120, 120, 120, 132, 120, 130, 120, 
+	133, 134, 135, 136, 6, 125, 126, 127, 
+	120, 120, 35, 137, 120, 138, 134, 136, 
+	136, 6, 125, 126, 127, 120, 120, 120, 
+	137, 120, 134, 136, 136, 6, 125, 126, 
+	127, 120, 120, 120, 137, 120, 139, 120, 
+	120, 120, 19, 140, 120, 125, 126, 120, 
+	120, 120, 120, 132, 120, 139, 120, 141, 
+	142, 143, 144, 6, 125, 126, 127, 120, 
+	120, 33, 145, 120, 146, 142, 144, 144, 
+	6, 125, 126, 127, 120, 120, 120, 145, 
+	120, 142, 144, 144, 6, 125, 126, 127, 
+	120, 120, 120, 145, 120, 147, 120, 120, 
+	120, 19, 148, 120, 125, 126, 120, 120, 
+	120, 120, 132, 120, 147, 120, 149, 150, 
+	151, 152, 6, 125, 126, 127, 120, 120, 
+	31, 153, 120, 154, 150, 152, 152, 6, 
+	125, 126, 127, 120, 120, 120, 153, 120, 
+	150, 152, 152, 6, 125, 126, 127, 120, 
+	120, 120, 153, 120, 155, 120, 120, 120, 
+	19, 156, 120, 125, 126, 120, 120, 120, 
+	120, 132, 120, 155, 120, 157, 158, 159, 
+	160, 6, 125, 126, 127, 120, 120, 29, 
+	161, 120, 162, 158, 160, 160, 6, 125, 
+	126, 127, 120, 120, 120, 161, 120, 158, 
+	160, 160, 6, 125, 126, 127, 120, 120, 
+	120, 161, 120, 19, 19, 120, 125, 126, 
+	120, 120, 120, 120, 132, 120, 125, 126, 
+	120, 120, 120, 120, 132, 120, 163, 120, 
+	120, 120, 126, 120, 120, 120, 120, 132, 
+	120, 126, 120, 120, 120, 120, 132, 120, 
+	164, 120, 165, 120, 166, 120, 120, 120, 
+	126, 120, 120, 120, 3, 120, 2, 120, 
+	120, 120, 120, 120, 126, 120, 126, 120, 
+	165, 120, 120, 120, 120, 120, 126, 120, 
+	19, 120, 125, 126, 120, 120, 120, 120, 
+	132, 120, 167, 28, 168, 169, 9, 125, 
+	126, 120, 120, 120, 120, 132, 120, 28, 
+	168, 169, 9, 125, 126, 120, 120, 120, 
+	120, 132, 120, 168, 168, 9, 125, 126, 
+	120, 120, 120, 120, 132, 120, 170, 25, 
+	171, 172, 12, 125, 126, 120, 120, 120, 
+	120, 132, 120, 25, 171, 172, 12, 125, 
+	126, 120, 120, 120, 120, 132, 120, 171, 
+	171, 12, 125, 126, 120, 120, 120, 120, 
+	132, 120, 173, 22, 174, 175, 15, 125, 
+	126, 120, 120, 120, 120, 132, 120, 22, 
+	174, 175, 15, 125, 126, 120, 120, 120, 
+	120, 132, 120, 174, 174, 15, 125, 126, 
+	120, 120, 120, 120, 132, 120, 176, 19, 
+	120, 177, 120, 125, 126, 120, 120, 120, 
+	120, 132, 120, 19, 120, 177, 120, 125, 
+	126, 120, 120, 120, 120, 132, 120, 158, 
+	160, 160, 6, 125, 126, 120, 120, 120, 
+	120, 161, 120, 1, 2, 120, 120, 19, 
+	19, 120, 125, 126, 120, 120, 120, 120, 
+	132, 120, 1, 120, 157, 158, 160, 160, 
+	6, 125, 126, 127, 120, 120, 120, 161, 
+	120, 155, 120, 120, 120, 120, 120, 120, 
+	125, 126, 120, 120, 120, 120, 132, 120, 
+	155, 120, 155, 120, 120, 120, 120, 156, 
+	120, 125, 126, 120, 120, 120, 120, 132, 
+	120, 155, 120, 155, 2, 120, 120, 19, 
+	156, 120, 125, 126, 120, 120, 120, 120, 
+	132, 120, 155, 120, 149, 150, 152, 152, 
+	6, 125, 126, 127, 120, 120, 120, 153, 
+	120, 147, 120, 120, 120, 120, 120, 120, 
+	125, 126, 120, 120, 120, 120, 132, 120, 
+	147, 120, 147, 120, 120, 120, 120, 148, 
+	120, 125, 126, 120, 120, 120, 120, 132, 
+	120, 147, 120, 147, 2, 120, 120, 19, 
+	148, 120, 125, 126, 120, 120, 120, 120, 
+	132, 120, 147, 120, 141, 142, 144, 144, 
+	6, 125, 126, 127, 120, 120, 120, 145, 
+	120, 139, 120, 120, 120, 120, 120, 120, 
+	125, 126, 120, 120, 120, 120, 132, 120, 
+	139, 120, 139, 120, 120, 120, 120, 140, 
+	120, 125, 126, 120, 120, 120, 120, 132, 
+	120, 139, 120, 139, 2, 120, 120, 19, 
+	140, 120, 125, 126, 120, 120, 120, 120, 
+	132, 120, 139, 120, 133, 134, 136, 136, 
+	6, 125, 126, 127, 120, 120, 120, 137, 
+	120, 130, 120, 120, 120, 120, 120, 120, 
+	125, 126, 120, 120, 120, 120, 132, 120, 
+	130, 120, 130, 120, 120, 120, 120, 131, 
+	120, 125, 126, 120, 120, 120, 120, 132, 
+	120, 130, 120, 130, 2, 120, 120, 19, 
+	131, 120, 125, 126, 120, 120, 120, 120, 
+	132, 120, 130, 120, 121, 122, 124, 124, 
+	6, 125, 126, 127, 120, 120, 120, 128, 
+	120, 179, 180, 181, 182, 44, 183, 184, 
+	178, 178, 178, 75, 185, 178, 186, 180, 
+	187, 182, 44, 183, 184, 178, 178, 178, 
+	178, 185, 178, 180, 187, 182, 44, 183, 
+	184, 178, 178, 178, 178, 185, 178, 188, 
+	178, 178, 178, 57, 189, 178, 183, 184, 
+	178, 178, 178, 178, 190, 178, 188, 178, 
+	191, 192, 193, 194, 44, 183, 184, 178, 
+	178, 178, 73, 195, 178, 196, 192, 194, 
+	194, 44, 183, 184, 178, 178, 178, 178, 
+	195, 178, 192, 194, 194, 44, 183, 184, 
+	178, 178, 178, 178, 195, 178, 197, 178, 
+	178, 178, 57, 198, 178, 183, 184, 178, 
+	178, 178, 178, 190, 178, 197, 178, 199, 
+	200, 201, 202, 44, 183, 184, 178, 178, 
+	178, 71, 203, 178, 204, 200, 202, 202, 
+	44, 183, 184, 178, 178, 178, 178, 203, 
+	178, 200, 202, 202, 44, 183, 184, 178, 
+	178, 178, 178, 203, 178, 205, 178, 178, 
+	178, 57, 206, 178, 183, 184, 178, 178, 
+	178, 178, 190, 178, 205, 178, 207, 208, 
+	209, 210, 44, 183, 184, 178, 178, 178, 
+	69, 211, 178, 212, 208, 210, 210, 44, 
+	183, 184, 178, 178, 178, 178, 211, 178, 
+	208, 210, 210, 44, 183, 184, 178, 178, 
+	178, 178, 211, 178, 213, 178, 178, 178, 
+	57, 214, 178, 183, 184, 178, 178, 178, 
+	178, 190, 178, 213, 178, 215, 216, 217, 
+	218, 44, 183, 184, 178, 178, 178, 67, 
+	219, 178, 220, 216, 218, 218, 44, 183, 
+	184, 178, 178, 178, 178, 219, 178, 216, 
+	218, 218, 44, 183, 184, 178, 178, 178, 
+	178, 219, 178, 57, 57, 178, 183, 184, 
+	178, 178, 178, 178, 190, 178, 183, 184, 
+	178, 178, 178, 178, 190, 178, 221, 178, 
+	178, 178, 184, 178, 178, 178, 178, 190, 
+	178, 184, 178, 178, 178, 178, 190, 178, 
+	222, 178, 223, 178, 224, 178, 178, 178, 
+	184, 178, 178, 178, 41, 178, 40, 178, 
+	178, 178, 178, 178, 184, 178, 184, 178, 
+	223, 178, 178, 178, 178, 178, 184, 178, 
+	57, 178, 183, 184, 178, 178, 178, 178, 
+	190, 178, 225, 66, 226, 227, 47, 183, 
+	184, 178, 178, 178, 178, 190, 178, 66, 
+	226, 227, 47, 183, 184, 178, 178, 178, 
+	178, 190, 178, 226, 226, 47, 183, 184, 
+	178, 178, 178, 178, 190, 178, 228, 63, 
+	229, 230, 50, 183, 184, 178, 178, 178, 
+	178, 190, 178, 63, 229, 230, 50, 183, 
+	184, 178, 178, 178, 178, 190, 178, 229, 
+	229, 50, 183, 184, 178, 178, 178, 178, 
+	190, 178, 231, 60, 232, 233, 53, 183, 
+	184, 178, 178, 178, 178, 190, 178, 60, 
+	232, 233, 53, 183, 184, 178, 178, 178, 
+	178, 190, 178, 232, 232, 53, 183, 184, 
+	178, 178, 178, 178, 190, 178, 234, 57, 
+	178, 235, 178, 183, 184, 178, 178, 178, 
+	178, 190, 178, 57, 178, 235, 178, 183, 
+	184, 178, 178, 178, 178, 190, 178, 39, 
+	40, 178, 178, 57, 57, 178, 183, 184, 
+	178, 178, 178, 178, 190, 178, 39, 178, 
+	215, 216, 218, 218, 44, 183, 184, 178, 
+	178, 178, 178, 219, 178, 213, 178, 178, 
+	178, 178, 178, 178, 183, 184, 178, 178, 
+	178, 178, 190, 178, 213, 178, 213, 178, 
+	178, 178, 178, 214, 178, 183, 184, 178, 
+	178, 178, 178, 190, 178, 213, 178, 213, 
+	40, 178, 178, 57, 214, 178, 183, 184, 
+	178, 178, 178, 178, 190, 178, 213, 178, 
+	207, 208, 210, 210, 44, 183, 184, 178, 
+	178, 178, 178, 211, 178, 205, 178, 178, 
+	178, 178, 178, 178, 183, 184, 178, 178, 
+	178, 178, 190, 178, 205, 178, 205, 178, 
+	178, 178, 178, 206, 178, 183, 184, 178, 
+	178, 178, 178, 190, 178, 205, 178, 205, 
+	40, 178, 178, 57, 206, 178, 183, 184, 
+	178, 178, 178, 178, 190, 178, 205, 178, 
+	199, 200, 202, 202, 44, 183, 184, 178, 
+	178, 178, 178, 203, 178, 197, 178, 178, 
+	178, 178, 178, 178, 183, 184, 178, 178, 
+	178, 178, 190, 178, 197, 178, 197, 178, 
+	178, 178, 178, 198, 178, 183, 184, 178, 
+	178, 178, 178, 190, 178, 197, 178, 197, 
+	40, 178, 178, 57, 198, 178, 183, 184, 
+	178, 178, 178, 178, 190, 178, 197, 178, 
+	191, 192, 194, 194, 44, 183, 184, 178, 
+	178, 178, 178, 195, 178, 188, 178, 178, 
+	178, 178, 178, 178, 183, 184, 178, 178, 
+	178, 178, 190, 178, 188, 178, 188, 178, 
+	178, 178, 178, 189, 178, 183, 184, 178, 
+	178, 178, 178, 190, 178, 188, 178, 74, 
+	43, 43, 44, 178, 178, 178, 178, 178, 
+	178, 74, 178, 188, 40, 178, 178, 57, 
+	189, 178, 183, 184, 178, 178, 178, 178, 
+	190, 178, 188, 178, 179, 180, 187, 182, 
+	44, 183, 184, 178, 178, 178, 178, 185, 
+	178, 237, 238, 239, 240, 82, 241, 242, 
+	236, 236, 236, 113, 243, 236, 244, 238, 
+	240, 240, 82, 241, 242, 236, 236, 236, 
+	236, 243, 236, 238, 240, 240, 82, 241, 
+	242, 236, 236, 236, 236, 243, 236, 245, 
+	236, 236, 236, 95, 246, 236, 241, 242, 
+	236, 236, 236, 236, 247, 236, 245, 236, 
+	248, 249, 250, 251, 82, 241, 242, 236, 
+	236, 236, 111, 252, 236, 253, 249, 251, 
+	251, 82, 241, 242, 236, 236, 236, 236, 
+	252, 236, 249, 251, 251, 82, 241, 242, 
+	236, 236, 236, 236, 252, 236, 254, 236, 
+	236, 236, 95, 255, 236, 241, 242, 236, 
+	236, 236, 236, 247, 236, 254, 236, 256, 
+	257, 258, 259, 82, 241, 242, 236, 236, 
+	236, 109, 260, 236, 261, 257, 259, 259, 
+	82, 241, 242, 236, 236, 236, 236, 260, 
+	236, 257, 259, 259, 82, 241, 242, 236, 
+	236, 236, 236, 260, 236, 262, 236, 236, 
+	236, 95, 263, 236, 241, 242, 236, 236, 
+	236, 236, 247, 236, 262, 236, 264, 265, 
+	266, 267, 82, 241, 242, 236, 236, 236, 
+	107, 268, 236, 269, 265, 267, 267, 82, 
+	241, 242, 236, 236, 236, 236, 268, 236, 
+	265, 267, 267, 82, 241, 242, 236, 236, 
+	236, 236, 268, 236, 270, 236, 236, 236, 
+	95, 271, 236, 241, 242, 236, 236, 236, 
+	236, 247, 236, 270, 236, 272, 273, 274, 
+	275, 82, 241, 242, 236, 236, 236, 105, 
+	276, 236, 277, 273, 275, 275, 82, 241, 
+	242, 236, 236, 236, 236, 276, 236, 273, 
+	275, 275, 82, 241, 242, 236, 236, 236, 
+	236, 276, 236, 95, 95, 236, 241, 242, 
+	236, 236, 236, 236, 247, 236, 241, 242, 
+	236, 236, 236, 236, 247, 236, 278, 236, 
+	236, 236, 242, 236, 236, 236, 236, 247, 
+	236, 242, 236, 236, 236, 236, 247, 236, 
+	279, 236, 280, 236, 281, 236, 236, 236, 
+	242, 236, 236, 236, 79, 236, 78, 236, 
+	236, 236, 236, 236, 242, 236, 242, 236, 
+	280, 236, 236, 236, 236, 236, 242, 236, 
+	95, 236, 241, 242, 236, 236, 236, 236, 
+	247, 236, 282, 104, 283, 284, 85, 241, 
+	242, 236, 236, 236, 236, 247, 236, 104, 
+	283, 284, 85, 241, 242, 236, 236, 236, 
+	236, 247, 236, 283, 283, 85, 241, 242, 
+	236, 236, 236, 236, 247, 236, 285, 101, 
+	286, 287, 88, 241, 242, 236, 236, 236, 
+	236, 247, 236, 101, 286, 287, 88, 241, 
+	242, 236, 236, 236, 236, 247, 236, 286, 
+	286, 88, 241, 242, 236, 236, 236, 236, 
+	247, 236, 288, 98, 289, 290, 91, 241, 
+	242, 236, 236, 236, 236, 247, 236, 98, 
+	289, 290, 91, 241, 242, 236, 236, 236, 
+	236, 247, 236, 289, 289, 91, 241, 242, 
+	236, 236, 236, 236, 247, 236, 291, 95, 
+	236, 292, 236, 241, 242, 236, 236, 236, 
+	236, 247, 236, 95, 236, 292, 236, 241, 
+	242, 236, 236, 236, 236, 247, 236, 77, 
+	78, 236, 236, 95, 95, 236, 241, 242, 
+	236, 236, 236, 236, 247, 236, 77, 236, 
+	272, 273, 275, 275, 82, 241, 242, 236, 
+	236, 236, 236, 276, 236, 270, 236, 236, 
+	236, 236, 236, 236, 241, 242, 236, 236, 
+	236, 236, 247, 236, 270, 236, 270, 236, 
+	236, 236, 236, 271, 236, 241, 242, 236, 
+	236, 236, 236, 247, 236, 270, 236, 270, 
+	78, 236, 236, 95, 271, 236, 241, 242, 
+	236, 236, 236, 236, 247, 236, 270, 236, 
+	264, 265, 267, 267, 82, 241, 242, 236, 
+	236, 236, 236, 268, 236, 262, 236, 236, 
+	236, 236, 236, 236, 241, 242, 236, 236, 
+	236, 236, 247, 236, 262, 236, 262, 236, 
+	236, 236, 236, 263, 236, 241, 242, 236, 
+	236, 236, 236, 247, 236, 262, 236, 262, 
+	78, 236, 236, 95, 263, 236, 241, 242, 
+	236, 236, 236, 236, 247, 236, 262, 236, 
+	256, 257, 259, 259, 82, 241, 242, 236, 
+	236, 236, 236, 260, 236, 254, 236, 236, 
+	236, 236, 236, 236, 241, 242, 236, 236, 
+	236, 236, 247, 236, 254, 236, 254, 236, 
+	236, 236, 236, 255, 236, 241, 242, 236, 
+	236, 236, 236, 247, 236, 254, 236, 254, 
+	78, 236, 236, 95, 255, 236, 241, 242, 
+	236, 236, 236, 236, 247, 236, 254, 236, 
+	248, 249, 251, 251, 82, 241, 242, 236, 
+	236, 236, 236, 252, 236, 245, 236, 236, 
+	236, 236, 236, 236, 241, 242, 236, 236, 
+	236, 236, 247, 236, 245, 236, 245, 236, 
+	236, 236, 236, 246, 236, 241, 242, 236, 
+	236, 236, 236, 247, 236, 245, 236, 245, 
+	78, 236, 236, 95, 246, 236, 241, 242, 
+	236, 236, 236, 236, 247, 236, 245, 236, 
+	237, 238, 240, 240, 82, 241, 242, 236, 
+	236, 236, 236, 243, 236, 115, 116, 293, 
+	293, 293, 293, 293, 293, 293, 293, 117, 
+	117, 293, 293, 293, 115, 293, 121, 294, 
+	123, 124, 6, 125, 126, 127, 120, 120, 
+	37, 128, 120, 130, 116, 120, 120, 19, 
+	131, 120, 125, 126, 120, 117, 117, 120, 
+	132, 120, 130, 120, 0
 };
 
-static const char _indic_syllable_machine_trans_targs[] = {
-	7, 1, 8, 7, 25, 2, 7, 33, 
-	5, 7, 21, 23, 31, 7, 9, 11, 
-	0, 15, 13, 14, 18, 10, 12, 7, 
-	16, 17, 19, 20, 22, 7, 24, 3, 
-	4, 26, 29, 30, 27, 28, 7, 7, 
-	32, 6, 34, 37, 38, 35, 36, 7
+static const short _indic_syllable_machine_trans_targs[] = {
+	105, 130, 132, 133, 134, 3, 135, 4, 
+	6, 138, 7, 9, 141, 10, 12, 144, 
+	13, 15, 16, 126, 18, 19, 143, 21, 
+	22, 140, 24, 25, 137, 148, 150, 152, 
+	154, 156, 158, 160, 162, 164, 105, 189, 
+	191, 192, 193, 38, 194, 39, 41, 197, 
+	42, 44, 200, 45, 47, 203, 48, 50, 
+	51, 185, 53, 54, 202, 56, 57, 199, 
+	59, 60, 196, 206, 208, 210, 212, 214, 
+	216, 218, 220, 223, 105, 248, 250, 251, 
+	252, 73, 253, 74, 76, 256, 77, 79, 
+	259, 80, 82, 262, 83, 85, 86, 244, 
+	88, 89, 261, 91, 92, 258, 94, 95, 
+	255, 265, 267, 269, 271, 273, 275, 277, 
+	279, 281, 105, 106, 165, 224, 282, 283, 
+	105, 107, 109, 34, 33, 127, 129, 146, 
+	163, 108, 110, 161, 0, 111, 113, 32, 
+	31, 159, 112, 114, 157, 115, 117, 30, 
+	29, 155, 116, 118, 153, 119, 121, 28, 
+	27, 151, 120, 122, 149, 123, 125, 26, 
+	2, 147, 124, 128, 105, 131, 1, 136, 
+	5, 23, 139, 8, 20, 142, 11, 17, 
+	145, 14, 105, 166, 168, 69, 221, 186, 
+	188, 222, 167, 68, 169, 219, 35, 170, 
+	172, 67, 66, 217, 171, 173, 215, 174, 
+	176, 65, 64, 213, 175, 177, 211, 178, 
+	180, 63, 62, 209, 179, 181, 207, 182, 
+	184, 61, 37, 205, 183, 187, 105, 190, 
+	36, 195, 40, 58, 198, 43, 55, 201, 
+	46, 52, 204, 49, 105, 225, 227, 104, 
+	103, 245, 247, 280, 226, 228, 278, 70, 
+	229, 231, 102, 101, 276, 230, 232, 274, 
+	233, 235, 100, 99, 272, 234, 236, 270, 
+	237, 239, 98, 97, 268, 238, 240, 266, 
+	241, 243, 96, 72, 264, 242, 246, 105, 
+	249, 71, 254, 75, 93, 257, 78, 90, 
+	260, 81, 87, 263, 84, 105, 284
 };
 
 static const char _indic_syllable_machine_trans_actions[] = {
-	1, 0, 2, 3, 2, 0, 4, 2, 
-	0, 7, 2, 2, 2, 8, 2, 0, 
-	0, 0, 0, 0, 0, 2, 0, 9, 
-	0, 0, 0, 0, 0, 10, 2, 0, 
-	0, 0, 0, 0, 0, 0, 11, 12, 
-	2, 0, 0, 0, 0, 0, 0, 13
+	1, 2, 0, 0, 2, 0, 2, 0, 
+	0, 2, 0, 0, 2, 0, 0, 2, 
+	0, 0, 0, 2, 0, 0, 2, 0, 
+	0, 2, 0, 0, 2, 2, 2, 2, 
+	2, 2, 2, 2, 2, 2, 3, 2, 
+	0, 0, 2, 0, 2, 0, 0, 2, 
+	0, 0, 2, 0, 0, 2, 0, 0, 
+	0, 2, 0, 0, 2, 0, 0, 2, 
+	0, 0, 2, 2, 2, 2, 2, 2, 
+	2, 2, 2, 2, 4, 2, 0, 0, 
+	2, 0, 2, 0, 0, 2, 0, 0, 
+	2, 0, 0, 2, 0, 0, 0, 2, 
+	0, 0, 2, 0, 0, 2, 0, 0, 
+	2, 2, 2, 2, 2, 2, 2, 2, 
+	2, 2, 7, 2, 2, 2, 0, 2, 
+	8, 2, 2, 0, 0, 2, 0, 2, 
+	2, 2, 2, 2, 0, 2, 2, 0, 
+	0, 2, 2, 2, 2, 2, 2, 0, 
+	0, 2, 2, 2, 2, 2, 2, 0, 
+	0, 2, 2, 2, 2, 2, 2, 0, 
+	0, 2, 2, 2, 9, 0, 0, 2, 
+	0, 0, 2, 0, 0, 2, 0, 0, 
+	2, 0, 10, 2, 2, 0, 2, 2, 
+	0, 2, 2, 0, 2, 2, 0, 2, 
+	2, 0, 0, 2, 2, 2, 2, 2, 
+	2, 0, 0, 2, 2, 2, 2, 2, 
+	2, 0, 0, 2, 2, 2, 2, 2, 
+	2, 0, 0, 2, 2, 2, 11, 0, 
+	0, 2, 0, 0, 2, 0, 0, 2, 
+	0, 0, 2, 0, 12, 2, 2, 0, 
+	0, 2, 0, 2, 2, 2, 2, 0, 
+	2, 2, 0, 0, 2, 2, 2, 2, 
+	2, 2, 0, 0, 2, 2, 2, 2, 
+	2, 2, 0, 0, 2, 2, 2, 2, 
+	2, 2, 0, 0, 2, 2, 2, 13, 
+	0, 0, 2, 0, 0, 2, 0, 0, 
+	2, 0, 0, 2, 0, 14, 2
 };
 
 static const char _indic_syllable_machine_to_state_actions[] = {
-	0, 0, 0, 0, 0, 0, 0, 5, 
 	0, 0, 0, 0, 0, 0, 0, 0, 
 	0, 0, 0, 0, 0, 0, 0, 0, 
 	0, 0, 0, 0, 0, 0, 0, 0, 
-	0, 0, 0, 0, 0, 0, 0
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 5, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0
 };
 
 static const char _indic_syllable_machine_from_state_actions[] = {
-	0, 0, 0, 0, 0, 0, 0, 6, 
 	0, 0, 0, 0, 0, 0, 0, 0, 
 	0, 0, 0, 0, 0, 0, 0, 0, 
 	0, 0, 0, 0, 0, 0, 0, 0, 
-	0, 0, 0, 0, 0, 0, 0
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 6, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0, 0, 0, 0, 
+	0, 0, 0, 0, 0
 };
 
-static const unsigned char _indic_syllable_machine_eof_trans[] = {
-	1, 1, 4, 4, 4, 7, 7, 0, 
-	14, 14, 14, 14, 14, 14, 14, 14, 
-	14, 14, 14, 14, 14, 14, 14, 30, 
-	30, 30, 30, 30, 30, 30, 30, 40, 
-	40, 40, 40, 40, 40, 40, 40
+static const short _indic_syllable_machine_eof_trans[] = {
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	1, 1, 1, 39, 39, 39, 39, 39, 
+	39, 39, 39, 39, 39, 39, 39, 39, 
+	39, 39, 39, 39, 39, 39, 39, 39, 
+	39, 39, 39, 39, 39, 39, 39, 39, 
+	39, 39, 39, 39, 39, 39, 77, 77, 
+	77, 77, 77, 77, 77, 77, 77, 77, 
+	77, 77, 77, 77, 77, 77, 77, 77, 
+	77, 77, 77, 77, 77, 77, 77, 77, 
+	77, 77, 77, 77, 77, 77, 77, 77, 
+	77, 0, 121, 121, 121, 121, 121, 121, 
+	121, 121, 121, 121, 121, 121, 121, 121, 
+	121, 121, 121, 121, 121, 121, 121, 121, 
+	121, 121, 121, 121, 121, 121, 121, 121, 
+	121, 121, 121, 121, 121, 121, 121, 121, 
+	121, 121, 121, 121, 121, 121, 121, 121, 
+	121, 121, 121, 121, 121, 121, 121, 121, 
+	121, 121, 121, 121, 121, 179, 179, 179, 
+	179, 179, 179, 179, 179, 179, 179, 179, 
+	179, 179, 179, 179, 179, 179, 179, 179, 
+	179, 179, 179, 179, 179, 179, 179, 179, 
+	179, 179, 179, 179, 179, 179, 179, 179, 
+	179, 179, 179, 179, 179, 179, 179, 179, 
+	179, 179, 179, 179, 179, 179, 179, 179, 
+	179, 179, 179, 179, 179, 179, 179, 179, 
+	237, 237, 237, 237, 237, 237, 237, 237, 
+	237, 237, 237, 237, 237, 237, 237, 237, 
+	237, 237, 237, 237, 237, 237, 237, 237, 
+	237, 237, 237, 237, 237, 237, 237, 237, 
+	237, 237, 237, 237, 237, 237, 237, 237, 
+	237, 237, 237, 237, 237, 237, 237, 237, 
+	237, 237, 237, 237, 237, 237, 237, 237, 
+	237, 237, 294, 121, 121
 };
 
-static const int indic_syllable_machine_start = 7;
-static const int indic_syllable_machine_first_final = 7;
+static const int indic_syllable_machine_start = 105;
+static const int indic_syllable_machine_first_final = 105;
 static const int indic_syllable_machine_error = -1;
 
-static const int indic_syllable_machine_en_main = 7;
+static const int indic_syllable_machine_en_main = 105;
 
 
-#line 38 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 36 "../../src/hb-ot-shape-complex-indic-machine.rl"
 
 
 
-#line 79 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 88 "../../src/hb-ot-shape-complex-indic-machine.rl"
 
 
 #define process_syllable(func) \
   HB_STMT_START { \
-    /* fprintf (stderr, "syllable %d..%d %s\n", last, p+1, #func); */ \
+    if (0) fprintf (stderr, "syllable %d..%d %s\n", last, p+1, #func); \
     for (unsigned int i = last; i < p+1; i++) \
       info[i].syllable() = syllable_serial; \
-    PASTE (initial_reordering_, func) (map, buffer, mask_array, last, p+1); \
+    PASTE (initial_reordering_, func) (plan, buffer, last, p+1); \
     last = p+1; \
     syllable_serial++; \
     if (unlikely (!syllable_serial)) syllable_serial++; \
   } HB_STMT_END
 
 static void
-find_syllables (const hb_ot_map_t *map, hb_buffer_t *buffer, hb_mask_t *mask_array)
+find_syllables (const hb_ot_shape_plan_t *plan, hb_buffer_t *buffer)
 {
   unsigned int p, pe, eof, ts, te, act;
   int cs;
   hb_glyph_info_t *info = buffer->info;
   
-#line 170 "hb-ot-shape-complex-indic-machine.hh.tmp"
+#line 759 "hb-ot-shape-complex-indic-machine.hh.tmp"
 	{
 	cs = indic_syllable_machine_start;
 	ts = 0;
 	te = 0;
 	act = 0;
 	}
 
-#line 101 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 110 "../../src/hb-ot-shape-complex-indic-machine.rl"
 
 
   p = 0;
   pe = eof = buffer->len;
 
   unsigned int last = 0;
   uint8_t syllable_serial = 1;
   
-#line 187 "hb-ot-shape-complex-indic-machine.hh.tmp"
+#line 776 "hb-ot-shape-complex-indic-machine.hh.tmp"
 	{
 	int _slen;
 	int _trans;
 	const unsigned char *_keys;
-	const char *_inds;
+	const short *_inds;
 	if ( p == pe )
 		goto _test_eof;
 _resume:
 	switch ( _indic_syllable_machine_from_state_actions[cs] ) {
 	case 6:
 #line 1 "NONE"
 	{ts = p;}
 	break;
-#line 201 "hb-ot-shape-complex-indic-machine.hh.tmp"
+#line 790 "hb-ot-shape-complex-indic-machine.hh.tmp"
 	}
 
 	_keys = _indic_syllable_machine_trans_keys + (cs<<1);
 	_inds = _indic_syllable_machine_indicies + _indic_syllable_machine_index_offsets[cs];
 
 	_slen = _indic_syllable_machine_key_spans[cs];
 	_trans = _inds[ _slen > 0 && _keys[0] <=( info[p].indic_category()) &&
 		( info[p].indic_category()) <= _keys[1] ?
@@ -215,79 +804,81 @@ find_syllables (const hb_ot_map_t *map, 
 		goto _again;
 
 	switch ( _indic_syllable_machine_trans_actions[_trans] ) {
 	case 2:
 #line 1 "NONE"
 	{te = p+1;}
 	break;
 	case 9:
-#line 72 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 81 "../../src/hb-ot-shape-complex-indic-machine.rl"
 	{te = p+1;{ process_syllable (consonant_syllable); }}
 	break;
 	case 11:
-#line 73 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 82 "../../src/hb-ot-shape-complex-indic-machine.rl"
 	{te = p+1;{ process_syllable (vowel_syllable); }}
 	break;
 	case 13:
-#line 74 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 83 "../../src/hb-ot-shape-complex-indic-machine.rl"
 	{te = p+1;{ process_syllable (standalone_cluster); }}
 	break;
 	case 7:
-#line 75 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 84 "../../src/hb-ot-shape-complex-indic-machine.rl"
 	{te = p+1;{ process_syllable (non_indic); }}
 	break;
 	case 8:
-#line 72 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 81 "../../src/hb-ot-shape-complex-indic-machine.rl"
 	{te = p;p--;{ process_syllable (consonant_syllable); }}
 	break;
 	case 10:
-#line 73 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 82 "../../src/hb-ot-shape-complex-indic-machine.rl"
 	{te = p;p--;{ process_syllable (vowel_syllable); }}
 	break;
 	case 12:
-#line 74 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 83 "../../src/hb-ot-shape-complex-indic-machine.rl"
 	{te = p;p--;{ process_syllable (standalone_cluster); }}
 	break;
+	case 14:
+#line 84 "../../src/hb-ot-shape-complex-indic-machine.rl"
+	{te = p;p--;{ process_syllable (non_indic); }}
+	break;
 	case 1:
-#line 72 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 81 "../../src/hb-ot-shape-complex-indic-machine.rl"
 	{{p = ((te))-1;}{ process_syllable (consonant_syllable); }}
 	break;
 	case 3:
-#line 73 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 82 "../../src/hb-ot-shape-complex-indic-machine.rl"
 	{{p = ((te))-1;}{ process_syllable (vowel_syllable); }}
 	break;
 	case 4:
-#line 74 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 83 "../../src/hb-ot-shape-complex-indic-machine.rl"
 	{{p = ((te))-1;}{ process_syllable (standalone_cluster); }}
 	break;
-#line 263 "hb-ot-shape-complex-indic-machine.hh.tmp"
+#line 856 "hb-ot-shape-complex-indic-machine.hh.tmp"
 	}
 
 _again:
 	switch ( _indic_syllable_machine_to_state_actions[cs] ) {
 	case 5:
 #line 1 "NONE"
 	{ts = 0;}
 	break;
-#line 272 "hb-ot-shape-complex-indic-machine.hh.tmp"
+#line 865 "hb-ot-shape-complex-indic-machine.hh.tmp"
 	}
 
 	if ( ++p != pe )
 		goto _resume;
 	_test_eof: {}
 	if ( p == eof )
 	{
 	if ( _indic_syllable_machine_eof_trans[cs] > 0 ) {
 		_trans = _indic_syllable_machine_eof_trans[cs] - 1;
 		goto _eof_trans;
 	}
 	}
 
 	}
 
-#line 110 "../../src/hb-ot-shape-complex-indic-machine.rl"
+#line 119 "../../src/hb-ot-shape-complex-indic-machine.rl"
 
 }
 
-HB_END_DECLS
-
 #endif /* HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH */
diff --git a/gfx/harfbuzz/src/hb-ot-shape-complex-indic-machine.rl b/gfx/harfbuzz/src/hb-ot-shape-complex-indic-machine.rl
--- a/gfx/harfbuzz/src/hb-ot-shape-complex-indic-machine.rl
+++ b/gfx/harfbuzz/src/hb-ot-shape-complex-indic-machine.rl
@@ -24,78 +24,87 @@
  * Google Author(s): Behdad Esfahbod
  */
 
 #ifndef HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH
 #define HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH
 
 #include "hb-private.hh"
 
-HB_BEGIN_DECLS
-
 %%{
   machine indic_syllable_machine;
   alphtype unsigned char;
   write data;
 }%%
 
 %%{
 
 # Same order as enum indic_category_t.  Not sure how to avoid duplication.
 X    = 0;
 C    = 1;
-Ra   = 2;
-V    = 3;
-N    = 4;
-H    = 5;
-ZWNJ = 6;
-ZWJ  = 7;
-M    = 8;
-SM   = 9;
-VD   = 10;
-A    = 11;
-NBSP = 12;
-DOTTEDCIRCLE = 13;
+V    = 2;
+N    = 3;
+H    = 4;
+ZWNJ = 5;
+ZWJ  = 6;
+M    = 7;
+SM   = 8;
+VD   = 9;
+A    = 10;
+NBSP = 11;
+DOTTEDCIRCLE = 12;
+RS   = 13;
+Coeng = 14;
+Repha = 15;
+Ra    = 16;
 
-c = C | Ra;
-n = N N?;
-z = ZWJ|ZWNJ;
-matra_group = M N? H?;
-syllable_tail = SM? (VD VD?)?;
+c = (C | Ra);			# is_consonant
+n = ((ZWNJ?.RS)? (N.N?)?);	# is_consonant_modifier
+z = ZWJ|ZWNJ;			# is_joiner
+h = H | Coeng;			# is_halant_or_coeng
+reph = (Ra H | Repha);		# possible reph
+
+cn = c.n?;
+forced_rakar = ZWJ H ZWJ Ra;
+matra_group = z{0,3}.M.N?.(H | forced_rakar)?;
+syllable_tail = (SM.ZWNJ?)? (Coeng (cn|V))? (VD VD?)?;
 place_holder = NBSP | DOTTEDCIRCLE;
+halant_group = (z?.h.ZWJ?);
+final_halant_group = halant_group | h.ZWNJ;
+halant_or_matra_group = (final_halant_group | matra_group{0,4});
 
 
-consonant_syllable =	(c.n? (H.z?|z.H))* c.n? A? (H.z? | matra_group*)? syllable_tail;
-vowel_syllable =	(Ra H)? V n? (z?.H.c | ZWJ.c)* matra_group* syllable_tail;
-standalone_cluster =	(Ra H)? place_holder n? (z? H c)* matra_group* syllable_tail;
+consonant_syllable =	Repha? (cn.halant_group){0,4} cn A? halant_or_matra_group? syllable_tail;
+vowel_syllable =	reph? V.n? (ZWJ | (halant_group.cn){0,4} halant_or_matra_group? syllable_tail);
+standalone_cluster =	reph? place_holder.n? (halant_group.cn){0,4} halant_or_matra_group? syllable_tail;
 other =			any;
 
 main := |*
 	consonant_syllable	=> { process_syllable (consonant_syllable); };
 	vowel_syllable		=> { process_syllable (vowel_syllable); };
 	standalone_cluster	=> { process_syllable (standalone_cluster); };
 	other			=> { process_syllable (non_indic); };
 *|;
 
 
 }%%
 
 #define process_syllable(func) \
   HB_STMT_START { \
-    /* fprintf (stderr, "syllable %d..%d %s\n", last, p+1, #func); */ \
+    if (0) fprintf (stderr, "syllable %d..%d %s\n", last, p+1, #func); \
     for (unsigned int i = last; i < p+1; i++) \
       info[i].syllable() = syllable_serial; \
-    PASTE (initial_reordering_, func) (map, buffer, mask_array, last, p+1); \
+    PASTE (initial_reordering_, func) (plan, buffer, last, p+1); \
     last = p+1; \
     syllable_serial++; \
     if (unlikely (!syllable_serial)) syllable_serial++; \
   } HB_STMT_END
 
 static void
-find_syllables (const hb_ot_map_t *map, hb_buffer_t *buffer, hb_mask_t *mask_array)
+find_syllables (const hb_ot_shape_plan_t *plan, hb_buffer_t *buffer)
 {
   unsigned int p, pe, eof, ts, te, act;
   int cs;
   hb_glyph_info_t *info = buffer->info;
   %%{
     write init;
     getkey info[p].indic_category();
   }%%
@@ -105,11 +114,9 @@ find_syllables (const hb_ot_map_t *map, 
 
   unsigned int last = 0;
   uint8_t syllable_serial = 1;
   %%{
     write exec;
   }%%
 }
 
-HB_END_DECLS
-
 #endif /* HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH */
diff --git a/gfx/harfbuzz/src/hb-ot-shape-complex-indic-private.hh b/gfx/harfbuzz/src/hb-ot-shape-complex-indic-private.hh
--- a/gfx/harfbuzz/src/hb-ot-shape-complex-indic-private.hh
+++ b/gfx/harfbuzz/src/hb-ot-shape-complex-indic-private.hh
@@ -26,245 +26,362 @@
 
 #ifndef HB_OT_SHAPE_COMPLEX_INDIC_PRIVATE_HH
 #define HB_OT_SHAPE_COMPLEX_INDIC_PRIVATE_HH
 
 #include "hb-private.hh"
 
 
 #include "hb-ot-shape-complex-private.hh"
+#include "hb-ot-shape-private.hh" /* XXX Remove */
 
 
 /* buffer var allocations */
 #define indic_category() complex_var_persistent_u8_0() /* indic_category_t */
 #define indic_position() complex_var_persistent_u8_1() /* indic_matra_category_t */
 
+
 #define INDIC_TABLE_ELEMENT_TYPE uint8_t
 
 /* Cateories used in the OpenType spec:
  * https://www.microsoft.com/typography/otfntdev/devanot/shaping.aspx
  */
 /* Note: This enum is duplicated in the -machine.rl source file.
  * Not sure how to avoid duplication. */
 enum indic_category_t {
   OT_X = 0,
   OT_C,
-  OT_Ra, /* Not explicitly listed in the OT spec, but used in the grammar. */
   OT_V,
   OT_N,
   OT_H,
   OT_ZWNJ,
   OT_ZWJ,
   OT_M,
   OT_SM,
   OT_VD,
   OT_A,
   OT_NBSP,
-  OT_DOTTEDCIRCLE /* Not in the spec, but special in Uniscribe. /Very very/ special! */
+  OT_DOTTEDCIRCLE, /* Not in the spec, but special in Uniscribe. /Very very/ special! */
+  OT_RS, /* Register Shifter, used in Khmer OT spec */
+  OT_Coeng,
+  OT_Repha,
+  OT_Ra /* Not explicitly listed in the OT spec, but used in the grammar. */
 };
 
 /* Visual positions in a syllable from left to right. */
 enum indic_position_t {
+  POS_START,
+
   POS_RA_TO_BECOME_REPH,
   POS_PRE_M,
   POS_PRE_C,
+
   POS_BASE_C,
+  POS_AFTER_MAIN,
+
   POS_ABOVE_C,
+
+  POS_BEFORE_SUB,
   POS_BELOW_C,
-  POS_ABOVE_M,
-  POS_BELOW_M,
+  POS_AFTER_SUB,
+
+  POS_BEFORE_POST,
   POS_POST_C,
-  POS_POST_M,
-  POS_SMVD
+  POS_AFTER_POST,
+
+  POS_FINAL_C,
+  POS_SMVD,
+
+  POS_END
 };
 
 /* Categories used in IndicSyllabicCategory.txt from UCD. */
 enum indic_syllabic_category_t {
   INDIC_SYLLABIC_CATEGORY_OTHER			= OT_X,
 
   INDIC_SYLLABIC_CATEGORY_AVAGRAHA		= OT_X,
   INDIC_SYLLABIC_CATEGORY_BINDU			= OT_SM,
   INDIC_SYLLABIC_CATEGORY_CONSONANT		= OT_C,
   INDIC_SYLLABIC_CATEGORY_CONSONANT_DEAD	= OT_C,
   INDIC_SYLLABIC_CATEGORY_CONSONANT_FINAL	= OT_C,
   INDIC_SYLLABIC_CATEGORY_CONSONANT_HEAD_LETTER	= OT_C,
   INDIC_SYLLABIC_CATEGORY_CONSONANT_MEDIAL	= OT_C,
   INDIC_SYLLABIC_CATEGORY_CONSONANT_PLACEHOLDER	= OT_NBSP,
   INDIC_SYLLABIC_CATEGORY_CONSONANT_SUBJOINED	= OT_C,
-  INDIC_SYLLABIC_CATEGORY_CONSONANT_REPHA	= OT_C,
+  INDIC_SYLLABIC_CATEGORY_CONSONANT_REPHA	= OT_Repha,
   INDIC_SYLLABIC_CATEGORY_MODIFYING_LETTER	= OT_X,
   INDIC_SYLLABIC_CATEGORY_NUKTA			= OT_N,
-  INDIC_SYLLABIC_CATEGORY_REGISTER_SHIFTER	= OT_X,
+  INDIC_SYLLABIC_CATEGORY_REGISTER_SHIFTER	= OT_RS,
   INDIC_SYLLABIC_CATEGORY_TONE_LETTER		= OT_X,
   INDIC_SYLLABIC_CATEGORY_TONE_MARK		= OT_X,
   INDIC_SYLLABIC_CATEGORY_VIRAMA		= OT_H,
   INDIC_SYLLABIC_CATEGORY_VISARGA		= OT_SM,
   INDIC_SYLLABIC_CATEGORY_VOWEL			= OT_V,
   INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT	= OT_M,
   INDIC_SYLLABIC_CATEGORY_VOWEL_INDEPENDENT	= OT_V
 };
 
 /* Categories used in IndicSMatraCategory.txt from UCD */
 enum indic_matra_category_t {
-  INDIC_MATRA_CATEGORY_NOT_APPLICABLE		= POS_BASE_C,
+  INDIC_MATRA_CATEGORY_NOT_APPLICABLE		= POS_END,
 
-  INDIC_MATRA_CATEGORY_LEFT			= POS_PRE_M,
-  INDIC_MATRA_CATEGORY_TOP			= POS_ABOVE_M,
-  INDIC_MATRA_CATEGORY_BOTTOM			= POS_BELOW_M,
-  INDIC_MATRA_CATEGORY_RIGHT			= POS_POST_M,
+  INDIC_MATRA_CATEGORY_LEFT			= POS_PRE_C,
+  INDIC_MATRA_CATEGORY_TOP			= POS_ABOVE_C,
+  INDIC_MATRA_CATEGORY_BOTTOM			= POS_BELOW_C,
+  INDIC_MATRA_CATEGORY_RIGHT			= POS_POST_C,
 
-  /* We don't really care much about these since we decompose them
-   * in the generic pre-shaping layer.  They will only be used if
-   * the font does not cover the decomposition.  In which case, we
-   * define these as aliases to the place we want the split-matra
-   * glyph to show up.  Quite arbitrary.
-   *
-   * TODO: There are some split matras without Unicode decompositions.
-   * We have to figure out what to do with them.
-   */
-  INDIC_MATRA_CATEGORY_BOTTOM_AND_RIGHT		= POS_POST_M,
-  INDIC_MATRA_CATEGORY_LEFT_AND_RIGHT		= POS_PRE_M,
-  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM		= POS_BELOW_M,
-  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM_AND_RIGHT	= POS_POST_M,
-  INDIC_MATRA_CATEGORY_TOP_AND_LEFT		= POS_PRE_M,
-  INDIC_MATRA_CATEGORY_TOP_AND_LEFT_AND_RIGHT	= POS_PRE_M,
-  INDIC_MATRA_CATEGORY_TOP_AND_RIGHT		= POS_POST_M,
+  /* These should resolve to the position of the last part of the split sequence. */
+  INDIC_MATRA_CATEGORY_BOTTOM_AND_RIGHT		= INDIC_MATRA_CATEGORY_RIGHT,
+  INDIC_MATRA_CATEGORY_LEFT_AND_RIGHT		= INDIC_MATRA_CATEGORY_RIGHT,
+  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM		= INDIC_MATRA_CATEGORY_BOTTOM,
+  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM_AND_RIGHT	= INDIC_MATRA_CATEGORY_RIGHT,
+  INDIC_MATRA_CATEGORY_TOP_AND_LEFT		= INDIC_MATRA_CATEGORY_TOP,
+  INDIC_MATRA_CATEGORY_TOP_AND_LEFT_AND_RIGHT	= INDIC_MATRA_CATEGORY_RIGHT,
+  INDIC_MATRA_CATEGORY_TOP_AND_RIGHT		= INDIC_MATRA_CATEGORY_RIGHT,
 
   INDIC_MATRA_CATEGORY_INVISIBLE		= INDIC_MATRA_CATEGORY_NOT_APPLICABLE,
   INDIC_MATRA_CATEGORY_OVERSTRUCK		= INDIC_MATRA_CATEGORY_NOT_APPLICABLE,
   INDIC_MATRA_CATEGORY_VISUAL_ORDER_LEFT	= INDIC_MATRA_CATEGORY_NOT_APPLICABLE
 };
 
 /* Note: We use ASSERT_STATIC_EXPR_ZERO() instead of ASSERT_STATIC_EXPR() and the comma operation
  * because gcc fails to optimize the latter and fills the table in at runtime. */
 #define INDIC_COMBINE_CATEGORIES(S,M) \
   (ASSERT_STATIC_EXPR_ZERO (M == INDIC_MATRA_CATEGORY_NOT_APPLICABLE || (S == INDIC_SYLLABIC_CATEGORY_VIRAMA || S == INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT)) + \
    ASSERT_STATIC_EXPR_ZERO (S < 16 && M < 16) + \
    ((M << 4) | S))
 
 
 #include "hb-ot-shape-complex-indic-table.hh"
 
-/* XXX
- * This is a hack for now.  We should:
- * 1. Move this data into the main Indic table,
- * and/or
- * 2. Probe font lookups to determine consonant positions.
- */
-static const struct consonant_position_t {
-  hb_codepoint_t u;
-  indic_position_t position;
-} consonant_positions[] = {
-  {0x0930, POS_BELOW_C},
-  {0x09AC, POS_BELOW_C},
-  {0x09AF, POS_POST_C},
-  {0x09B0, POS_BELOW_C},
-  {0x09F0, POS_BELOW_C},
-  {0x0A2F, POS_POST_C},
-  {0x0A30, POS_BELOW_C},
-  {0x0A35, POS_BELOW_C},
-  {0x0A39, POS_BELOW_C},
-  {0x0AB0, POS_BELOW_C},
-  {0x0B24, POS_BELOW_C},
-  {0x0B28, POS_BELOW_C},
-  {0x0B2C, POS_BELOW_C},
-  {0x0B2D, POS_BELOW_C},
-  {0x0B2E, POS_BELOW_C},
-  {0x0B2F, POS_POST_C},
-  {0x0B30, POS_BELOW_C},
-  {0x0B32, POS_BELOW_C},
-  {0x0B33, POS_BELOW_C},
-  {0x0B5F, POS_POST_C},
-  {0x0B71, POS_BELOW_C},
-  {0x0C15, POS_BELOW_C},
-  {0x0C16, POS_BELOW_C},
-  {0x0C17, POS_BELOW_C},
-  {0x0C18, POS_BELOW_C},
-  {0x0C19, POS_BELOW_C},
-  {0x0C1A, POS_BELOW_C},
-  {0x0C1B, POS_BELOW_C},
-  {0x0C1C, POS_BELOW_C},
-  {0x0C1D, POS_BELOW_C},
-  {0x0C1E, POS_BELOW_C},
-  {0x0C1F, POS_BELOW_C},
-  {0x0C20, POS_BELOW_C},
-  {0x0C21, POS_BELOW_C},
-  {0x0C22, POS_BELOW_C},
-  {0x0C23, POS_BELOW_C},
-  {0x0C24, POS_BELOW_C},
-  {0x0C25, POS_BELOW_C},
-  {0x0C26, POS_BELOW_C},
-  {0x0C27, POS_BELOW_C},
-  {0x0C28, POS_BELOW_C},
-  {0x0C2A, POS_BELOW_C},
-  {0x0C2B, POS_BELOW_C},
-  {0x0C2C, POS_BELOW_C},
-  {0x0C2D, POS_BELOW_C},
-  {0x0C2E, POS_BELOW_C},
-  {0x0C2F, POS_BELOW_C},
-  {0x0C30, POS_BELOW_C},
-  {0x0C32, POS_BELOW_C},
-  {0x0C33, POS_BELOW_C},
-  {0x0C35, POS_BELOW_C},
-  {0x0C36, POS_BELOW_C},
-  {0x0C37, POS_BELOW_C},
-  {0x0C38, POS_BELOW_C},
-  {0x0C39, POS_BELOW_C},
-  {0x0C95, POS_BELOW_C},
-  {0x0C96, POS_BELOW_C},
-  {0x0C97, POS_BELOW_C},
-  {0x0C98, POS_BELOW_C},
-  {0x0C99, POS_BELOW_C},
-  {0x0C9A, POS_BELOW_C},
-  {0x0C9B, POS_BELOW_C},
-  {0x0C9C, POS_BELOW_C},
-  {0x0C9D, POS_BELOW_C},
-  {0x0C9E, POS_BELOW_C},
-  {0x0C9F, POS_BELOW_C},
-  {0x0CA0, POS_BELOW_C},
-  {0x0CA1, POS_BELOW_C},
-  {0x0CA2, POS_BELOW_C},
-  {0x0CA3, POS_BELOW_C},
-  {0x0CA4, POS_BELOW_C},
-  {0x0CA5, POS_BELOW_C},
-  {0x0CA6, POS_BELOW_C},
-  {0x0CA7, POS_BELOW_C},
-  {0x0CA8, POS_BELOW_C},
-  {0x0CAA, POS_BELOW_C},
-  {0x0CAB, POS_BELOW_C},
-  {0x0CAC, POS_BELOW_C},
-  {0x0CAD, POS_BELOW_C},
-  {0x0CAE, POS_BELOW_C},
-  {0x0CAF, POS_BELOW_C},
-  {0x0CB0, POS_BELOW_C},
-  {0x0CB2, POS_BELOW_C},
-  {0x0CB3, POS_BELOW_C},
-  {0x0CB5, POS_BELOW_C},
-  {0x0CB6, POS_BELOW_C},
-  {0x0CB7, POS_BELOW_C},
-  {0x0CB8, POS_BELOW_C},
-  {0x0CB9, POS_BELOW_C},
-  {0x0CDE, POS_BELOW_C},
-  {0x0D2F, POS_POST_C},
-  {0x0D30, POS_POST_C},
-  {0x0D32, POS_BELOW_C},
-  {0x0D35, POS_POST_C},
-};
+
+#define IN_HALF_BLOCK(u, Base) (((u) & ~0x7F) == (Base))
+
+#define IS_DEVA(u) (IN_HALF_BLOCK (u, 0x0900))
+#define IS_BENG(u) (IN_HALF_BLOCK (u, 0x0980))
+#define IS_GURU(u) (IN_HALF_BLOCK (u, 0x0A00))
+#define IS_GUJR(u) (IN_HALF_BLOCK (u, 0x0A80))
+#define IS_ORYA(u) (IN_HALF_BLOCK (u, 0x0B00))
+#define IS_TAML(u) (IN_HALF_BLOCK (u, 0x0B80))
+#define IS_TELU(u) (IN_HALF_BLOCK (u, 0x0C00))
+#define IS_KNDA(u) (IN_HALF_BLOCK (u, 0x0C80))
+#define IS_MLYM(u) (IN_HALF_BLOCK (u, 0x0D00))
+#define IS_SINH(u) (IN_HALF_BLOCK (u, 0x0D80))
+#define IS_KHMR(u) (IN_HALF_BLOCK (u, 0x1780))
+
+
+#define MATRA_POS_LEFT(u)	POS_PRE_M
+#define MATRA_POS_RIGHT(u)	( \
+				  IS_DEVA(u) ? POS_AFTER_SUB  : \
+				  IS_BENG(u) ? POS_AFTER_POST : \
+				  IS_GURU(u) ? POS_AFTER_POST : \
+				  IS_GUJR(u) ? POS_AFTER_POST : \
+				  IS_ORYA(u) ? POS_AFTER_POST : \
+				  IS_TAML(u) ? POS_AFTER_POST : \
+				  IS_TELU(u) ? (u <= 0x0C42 ? POS_BEFORE_SUB : POS_AFTER_SUB) : \
+				  IS_KNDA(u) ? (u < 0x0CC3 || u > 0xCD6 ? POS_BEFORE_SUB : POS_AFTER_SUB) : \
+				  IS_MLYM(u) ? POS_AFTER_POST : \
+				  IS_SINH(u) ? POS_AFTER_SUB  : \
+				  IS_KHMR(u) ? POS_AFTER_POST : \
+				  /*default*/  POS_AFTER_SUB    \
+				)
+#define MATRA_POS_TOP(u)	( /* BENG and MLYM don't have top matras. */ \
+				  IS_DEVA(u) ? POS_AFTER_SUB  : \
+				  IS_GURU(u) ? POS_AFTER_POST : /* Deviate from spec */ \
+				  IS_GUJR(u) ? POS_AFTER_SUB  : \
+				  IS_ORYA(u) ? POS_AFTER_MAIN : \
+				  IS_TAML(u) ? POS_AFTER_SUB  : \
+				  IS_TELU(u) ? POS_BEFORE_SUB : \
+				  IS_KNDA(u) ? POS_BEFORE_SUB : \
+				  IS_SINH(u) ? POS_AFTER_SUB  : \
+				  IS_KHMR(u) ? POS_AFTER_POST : \
+				  /*default*/  POS_AFTER_SUB    \
+				)
+#define MATRA_POS_BOTTOM(u)	( \
+				  IS_DEVA(u) ? POS_AFTER_SUB  : \
+				  IS_BENG(u) ? POS_AFTER_SUB  : \
+				  IS_GURU(u) ? POS_AFTER_POST : \
+				  IS_GUJR(u) ? POS_AFTER_POST : \
+				  IS_ORYA(u) ? POS_AFTER_SUB  : \
+				  IS_TAML(u) ? POS_AFTER_POST : \
+				  IS_TELU(u) ? POS_BEFORE_SUB : \
+				  IS_KNDA(u) ? POS_BEFORE_SUB : \
+				  IS_MLYM(u) ? POS_AFTER_POST : \
+				  IS_SINH(u) ? POS_AFTER_SUB  : \
+				  IS_KHMR(u) ? POS_AFTER_POST : \
+				  /*default*/  POS_AFTER_SUB    \
+				)
+
+
+static inline indic_position_t
+matra_position (hb_codepoint_t u, indic_position_t side)
+{
+  switch ((int) side)
+  {
+    case POS_PRE_C:	return MATRA_POS_LEFT (u);
+    case POS_POST_C:	return MATRA_POS_RIGHT (u);
+    case POS_ABOVE_C:	return MATRA_POS_TOP (u);
+    case POS_BELOW_C:	return MATRA_POS_BOTTOM (u);
+  };
+  abort ();
+}
+
+
 
 /* XXX
  * This is a hack for now.  We should move this data into the main Indic table.
  * Or completely remove it and just check in the tables.
  */
 static const hb_codepoint_t ra_chars[] = {
   0x0930, /* Devanagari */
   0x09B0, /* Bengali */
   0x09F0, /* Bengali */
   0x0A30, /* Gurmukhi */	/* No Reph */
   0x0AB0, /* Gujarati */
   0x0B30, /* Oriya */
   0x0BB0, /* Tamil */		/* No Reph */
-  0x0C30, /* Telugu */		/* No Reph */
+  0x0C30, /* Telugu */		/* Reph formed only with ZWJ */
   0x0CB0, /* Kannada */
-  0x0D30, /* Malayalam */	/* No Reph */
+  0x0D30, /* Malayalam */	/* No Reph, Logical Repha */
+
+  0x0DBB, /* Sinhala */		/* Reph formed only with ZWJ */
+
+  0x179A, /* Khmer */		/* No Reph, Visual Repha */
 };
 
+static inline indic_position_t
+consonant_position (hb_codepoint_t  u)
+{
+  if ((u & ~0x007F) == 0x1780)
+    return POS_BELOW_C; /* In Khmer coeng model, post and below forms should not be reordered. */
+  return POS_BASE_C; /* Will recategorize later based on font lookups. */
+}
+
+static inline bool
+is_ra (hb_codepoint_t u)
+{
+  for (unsigned int i = 0; i < ARRAY_LENGTH (ra_chars); i++)
+    if (u == ra_chars[i])
+      return true;
+  return false;
+}
+
+
+static inline bool
+is_one_of (const hb_glyph_info_t &info, unsigned int flags)
+{
+  /* If it ligated, all bets are off. */
+  if (is_a_ligature (info)) return false;
+  return !!(FLAG (info.indic_category()) & flags);
+}
+
+#define JOINER_FLAGS (FLAG (OT_ZWJ) | FLAG (OT_ZWNJ))
+static inline bool
+is_joiner (const hb_glyph_info_t &info)
+{
+  return is_one_of (info, JOINER_FLAGS);
+}
+
+/* Note:
+ *
+ * We treat Vowels and placeholders as if they were consonants.  This is safe because Vowels
+ * cannot happen in a consonant syllable.  The plus side however is, we can call the
+ * consonant syllable logic from the vowel syllable function and get it all right! */
+#define CONSONANT_FLAGS (FLAG (OT_C) | FLAG (OT_Ra) | FLAG (OT_V) | FLAG (OT_NBSP) | FLAG (OT_DOTTEDCIRCLE))
+static inline bool
+is_consonant (const hb_glyph_info_t &info)
+{
+  return is_one_of (info, CONSONANT_FLAGS);
+}
+
+#define HALANT_OR_COENG_FLAGS (FLAG (OT_H) | FLAG (OT_Coeng))
+static inline bool
+is_halant_or_coeng (const hb_glyph_info_t &info)
+{
+  return is_one_of (info, HALANT_OR_COENG_FLAGS);
+}
+
+static inline void
+set_indic_properties (hb_glyph_info_t   &info)
+{
+  hb_codepoint_t u = info.codepoint;
+  unsigned int type = get_indic_categories (u);
+  indic_category_t cat = (indic_category_t) (type & 0x0F);
+  indic_position_t pos = (indic_position_t) (type >> 4);
+
+
+  /*
+   * Re-assign category
+   */
+
+
+  /* The spec says U+0952 is OT_A.  However, testing shows that Uniscribe
+   * treats U+0951..U+0952 all as OT_VD.
+   * TESTS:
+   * U+092E,U+0947,U+0952
+   * U+092E,U+0952,U+0947
+   * U+092E,U+0947,U+0951
+   * U+092E,U+0951,U+0947
+   * */
+  if (unlikely (hb_in_range<hb_codepoint_t> (u, 0x0951, 0x0954)))
+    cat = OT_VD;
+
+  if (unlikely (u == 0x17D1))
+    cat = OT_X;
+  if (cat == OT_X &&
+      unlikely (hb_in_range<hb_codepoint_t> (u, 0x17CB, 0x17D3))) /* Khmer Various signs */
+  {
+    /* These are like Top Matras. */
+    cat = OT_M;
+    pos = POS_ABOVE_C;
+  }
+  if (u == 0x17C6) /* Khmer Bindu doesn't like to be repositioned. */
+    cat = OT_N;
+
+  if (unlikely (u == 0x17D2)) cat = OT_Coeng; /* Khmer coeng */
+  else if (unlikely (u == 0x200C)) cat = OT_ZWNJ;
+  else if (unlikely (u == 0x200D)) cat = OT_ZWJ;
+  else if (unlikely (u == 0x25CC)) cat = OT_DOTTEDCIRCLE;
+  else if (unlikely (u == 0x0A71)) cat = OT_SM; /* GURMUKHI ADDAK.  More like consonant medial. like 0A75. */
+
+  if (cat == OT_Repha) {
+    /* There are two kinds of characters marked as Repha:
+     * - The ones that are GenCat=Mn are already positioned visually, ie. after base. (eg. Khmer)
+     * - The ones that are GenCat=Lo is encoded logically, ie. beginning of syllable. (eg. Malayalam)
+     *
+     * We recategorize the first kind to look like a Nukta and attached to the base directly.
+     */
+    if (_hb_glyph_info_get_general_category (&info) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)
+      cat = OT_N;
+  }
+
+
+
+  /*
+   * Re-assign position.
+   */
+
+  if ((FLAG (cat) & CONSONANT_FLAGS))
+  {
+    pos = consonant_position (u);
+    if (is_ra (u))
+      cat = OT_Ra;
+  }
+  else if (cat == OT_M)
+  {
+    pos = matra_position (u, pos);
+  }
+  else if (cat == OT_SM || cat == OT_VD)
+  {
+    pos = POS_SMVD;
+  }
+
+  if (unlikely (u == 0x0B01)) pos = POS_BEFORE_SUB; /* Oriya Bindu is BeforeSub in the spec. */
+
+
+
+  info.indic_category() = cat;
+  info.indic_position() = pos;
+}
+
+
 
 #endif /* HB_OT_SHAPE_COMPLEX_INDIC_PRIVATE_HH */
diff --git a/gfx/harfbuzz/src/hb-ot-shape-complex-indic.cc b/gfx/harfbuzz/src/hb-ot-shape-complex-indic.cc
--- a/gfx/harfbuzz/src/hb-ot-shape-complex-indic.cc
+++ b/gfx/harfbuzz/src/hb-ot-shape-complex-indic.cc
@@ -20,239 +20,395 @@
  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  *
  * Google Author(s): Behdad Esfahbod
  */
 
 #include "hb-ot-shape-complex-indic-private.hh"
-#include "hb-ot-shape-private.hh"
+#include "hb-ot-layout-private.hh"
 
-static const struct indic_options_t
+
+/*
+ * Global Indic shaper options.
+ */
+
+struct indic_options_t
 {
-  indic_options_t (void)
-  {
-    char *c = getenv ("HB_OT_INDIC_OPTIONS");
-    uniscribe_bug_compatible = c && strstr (c, "uniscribe-bug-compatible");
+  int initialized : 1;
+  int uniscribe_bug_compatible : 1;
+};
+
+union indic_options_union_t {
+  int i;
+  indic_options_t opts;
+};
+ASSERT_STATIC (sizeof (int) == sizeof (indic_options_union_t));
+
+static indic_options_union_t
+indic_options_init (void)
+{
+  indic_options_union_t u;
+  u.i = 0;
+  u.opts.initialized = 1;
+
+  char *c = getenv ("HB_OT_INDIC_OPTIONS");
+  u.opts.uniscribe_bug_compatible = c && strstr (c, "uniscribe-bug-compatible");
+
+  return u;
+}
+
+inline indic_options_t
+indic_options (void)
+{
+  static indic_options_union_t options;
+
+  if (unlikely (!options.i)) {
+    /* This is idempotent and threadsafe. */
+    options = indic_options_init ();
   }
 
-  bool uniscribe_bug_compatible;
-} options;
-
-static int
-compare_codepoint (const void *pa, const void *pb)
-{
-  hb_codepoint_t a = * (hb_codepoint_t *) pa;
-  hb_codepoint_t b = * (hb_codepoint_t *) pb;
-
-  return a < b ? -1 : a == b ? 0 : +1;
+  return options.opts;
 }
 
-static indic_position_t
-consonant_position (hb_codepoint_t u)
+
+/*
+ * Indic configurations.  Note that we do not want to keep every single script-specific
+ * behavior in these tables necessarily.  This should mainly be used for per-script
+ * properties that are cheaper keeping here, than in the code.  Ie. if, say, one and
+ * only one script has an exception, that one script can be if'ed directly in the code,
+ * instead of adding a new flag in these structs.
+ */
+
+enum base_position_t {
+  BASE_POS_FIRST,
+  BASE_POS_LAST
+};
+enum reph_position_t {
+  REPH_POS_DEFAULT     = POS_BEFORE_POST,
+
+  REPH_POS_AFTER_MAIN  = POS_AFTER_MAIN,
+  REPH_POS_BEFORE_SUB  = POS_BEFORE_SUB,
+  REPH_POS_AFTER_SUB   = POS_AFTER_SUB,
+  REPH_POS_BEFORE_POST = POS_BEFORE_POST,
+  REPH_POS_AFTER_POST  = POS_AFTER_POST
+};
+enum reph_mode_t {
+  REPH_MODE_IMPLICIT,  /* Reph formed out of initial Ra,H sequence. */
+  REPH_MODE_EXPLICIT,  /* Reph formed out of initial Ra,H,ZWJ sequence. */
+  REPH_MODE_VIS_REPHA, /* Encoded Repha character, no reordering needed. */
+  REPH_MODE_LOG_REPHA  /* Encoded Repha character, needs reordering. */
+};
+struct indic_config_t
 {
-  consonant_position_t *record;
+  hb_script_t     script;
+  bool            has_old_spec;
+  hb_codepoint_t  virama;
+  base_position_t base_pos;
+  reph_position_t reph_pos;
+  reph_mode_t     reph_mode;
+};
 
-  record = (consonant_position_t *) bsearch (&u, consonant_positions,
-					     ARRAY_LENGTH (consonant_positions),
-					     sizeof (consonant_positions[0]),
-					     compare_codepoint);
+static const indic_config_t indic_configs[] =
+{
+  /* Default.  Should be first. */
+  {HB_SCRIPT_INVALID,	false,     0,BASE_POS_LAST, REPH_POS_DEFAULT,    REPH_MODE_IMPLICIT},
+  {HB_SCRIPT_DEVANAGARI,true, 0x094D,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT},
+  {HB_SCRIPT_BENGALI,	true, 0x09CD,BASE_POS_LAST, REPH_POS_AFTER_SUB,  REPH_MODE_IMPLICIT},
+  {HB_SCRIPT_GURMUKHI,	true, 0x0A4D,BASE_POS_LAST, REPH_POS_BEFORE_SUB, REPH_MODE_IMPLICIT},
+  {HB_SCRIPT_GUJARATI,	true, 0x0ACD,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT},
+  {HB_SCRIPT_ORIYA,	true, 0x0B4D,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_IMPLICIT},
+  {HB_SCRIPT_TAMIL,	true, 0x0BCD,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT},
+  {HB_SCRIPT_TELUGU,	true, 0x0C4D,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT},
+  {HB_SCRIPT_KANNADA,	true, 0x0CCD,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT},
+  {HB_SCRIPT_MALAYALAM,	true, 0x0D4D,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_LOG_REPHA},
+  {HB_SCRIPT_SINHALA,	false,0x0DCA,BASE_POS_FIRST,REPH_POS_AFTER_MAIN, REPH_MODE_EXPLICIT},
+  {HB_SCRIPT_KHMER,	false,0x17D2,BASE_POS_FIRST,REPH_POS_DEFAULT,    REPH_MODE_VIS_REPHA},
+};
 
-  return record ? record->position : POS_BASE_C;
-}
 
-static bool
-is_ra (hb_codepoint_t u)
-{
-  return !!bsearch (&u, ra_chars,
-		    ARRAY_LENGTH (ra_chars),
-		    sizeof (ra_chars[0]),
-		    compare_codepoint);
-}
 
-static bool
-is_joiner (const hb_glyph_info_t &info)
-{
-  return !!(FLAG (info.indic_category()) & (FLAG (OT_ZWJ) | FLAG (OT_ZWNJ)));
-}
-
-static bool
-is_consonant (const hb_glyph_info_t &info)
-{
-  /* Note:
-   *
-   * We treat Vowels and placeholders as if they were consonants.  This is safe because Vowels
-   * cannot happen in a consonant syllable.  The plus side however is, we can call the
-   * consonant syllable logic from the vowel syllable function and get it all right! */
-  return !!(FLAG (info.indic_category()) & (FLAG (OT_C) | FLAG (OT_Ra) | FLAG (OT_V) | FLAG (OT_NBSP) | FLAG (OT_DOTTEDCIRCLE)));
-}
+/*
+ * Indic shaper.
+ */
 
 struct feature_list_t {
   hb_tag_t tag;
   hb_bool_t is_global;
 };
 
 static const feature_list_t
-indic_basic_features[] =
+indic_features[] =
 {
+  /*
+   * Basic features.
+   * These features are applied in order, one at a time, after initial_reordering.
+   */
   {HB_TAG('n','u','k','t'), true},
-  {HB_TAG('a','k','h','n'), false},
+  {HB_TAG('a','k','h','n'), true},
   {HB_TAG('r','p','h','f'), false},
   {HB_TAG('r','k','r','f'), true},
   {HB_TAG('p','r','e','f'), false},
   {HB_TAG('b','l','w','f'), false},
   {HB_TAG('h','a','l','f'), false},
+  {HB_TAG('a','b','v','f'), false},
   {HB_TAG('p','s','t','f'), false},
-  {HB_TAG('c','j','c','t'), false},
+  {HB_TAG('c','f','a','r'), false},
+  {HB_TAG('c','j','c','t'), true},
   {HB_TAG('v','a','t','u'), true},
-};
-
-/* Same order as the indic_basic_features array */
-enum {
-  _NUKT,
-  AKHN,
-  RPHF,
-  _RKRF,
-  PREF,
-  BLWF,
-  HALF,
-  PSTF,
-  CJCT,
-  VATU
-};
-
-static const feature_list_t
-indic_other_features[] =
-{
+  /*
+   * Other features.
+   * These features are applied all at once, after final_reordering.
+   */
   {HB_TAG('i','n','i','t'), false},
   {HB_TAG('p','r','e','s'), true},
   {HB_TAG('a','b','v','s'), true},
   {HB_TAG('b','l','w','s'), true},
   {HB_TAG('p','s','t','s'), true},
   {HB_TAG('h','a','l','n'), true},
-
+  /* Positioning features, though we don't care about the types. */
   {HB_TAG('d','i','s','t'), true},
   {HB_TAG('a','b','v','m'), true},
   {HB_TAG('b','l','w','m'), true},
 };
 
-/* Same order as the indic_other_features array */
+/*
+ * Must be in the same order as the indic_features array.
+ */
 enum {
-  INIT
+  _NUKT,
+  _AKHN,
+  RPHF,
+  _RKRF,
+  PREF,
+  BLWF,
+  HALF,
+  ABVF,
+  PSTF,
+  CFAR,
+  _CJCT,
+  _VATU,
+
+  INIT,
+  _PRES,
+  _ABVS,
+  _BLWS,
+  _PSTS,
+  _HALN,
+  _DIST,
+  _ABVM,
+  _BLWM,
+
+  INDIC_NUM_FEATURES,
+  INDIC_BASIC_FEATURES = INIT /* Don't forget to update this! */
 };
 
+static void
+initial_reordering (const hb_ot_shape_plan_t *plan,
+		    hb_font_t *font,
+		    hb_buffer_t *buffer);
+static void
+final_reordering (const hb_ot_shape_plan_t *plan,
+		  hb_font_t *font,
+		  hb_buffer_t *buffer);
 
 static void
-initial_reordering (const hb_ot_map_t *map,
-		    hb_face_t *face,
-		    hb_buffer_t *buffer,
-		    void *user_data HB_UNUSED);
-static void
-final_reordering (const hb_ot_map_t *map,
-		  hb_face_t *face,
-		  hb_buffer_t *buffer,
-		  void *user_data HB_UNUSED);
+collect_features_indic (hb_ot_shape_planner_t *plan)
+{
+  hb_ot_map_builder_t *map = &plan->map;
 
-void
-_hb_ot_shape_complex_collect_features_indic (hb_ot_map_builder_t *map,
-					     const hb_segment_properties_t *props HB_UNUSED)
-{
   map->add_bool_feature (HB_TAG('l','o','c','l'));
   /* The Indic specs do not require ccmp, but we apply it here since if
    * there is a use of it, it's typically at the beginning. */
   map->add_bool_feature (HB_TAG('c','c','m','p'));
 
-  map->add_gsub_pause (initial_reordering, NULL);
 
-  for (unsigned int i = 0; i < ARRAY_LENGTH (indic_basic_features); i++) {
-    map->add_bool_feature (indic_basic_features[i].tag, indic_basic_features[i].is_global);
-    map->add_gsub_pause (NULL, NULL);
+  unsigned int i = 0;
+  map->add_gsub_pause (initial_reordering);
+  for (; i < INDIC_BASIC_FEATURES; i++) {
+    map->add_bool_feature (indic_features[i].tag, indic_features[i].is_global);
+    map->add_gsub_pause (NULL);
   }
-
-  map->add_gsub_pause (final_reordering, NULL);
-
-  for (unsigned int i = 0; i < ARRAY_LENGTH (indic_other_features); i++) {
-    map->add_bool_feature (indic_other_features[i].tag, indic_other_features[i].is_global);
-    map->add_gsub_pause (NULL, NULL);
+  map->add_gsub_pause (final_reordering);
+  for (; i < INDIC_NUM_FEATURES; i++) {
+    map->add_bool_feature (indic_features[i].tag, indic_features[i].is_global);
   }
 }
 
-
-hb_ot_shape_normalization_mode_t
-_hb_ot_shape_complex_normalization_preference_indic (void)
+static void
+override_features_indic (hb_ot_shape_planner_t *plan)
 {
-  /* We want split matras decomposed by the common shaping logic. */
-  return HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED;
+  /* Uniscribe does not apply 'kern'. */
+  if (indic_options ().uniscribe_bug_compatible)
+    plan->map.add_feature (HB_TAG('k','e','r','n'), 0, true);
 }
 
 
-void
-_hb_ot_shape_complex_setup_masks_indic (hb_ot_map_t *map HB_UNUSED,
-					hb_buffer_t *buffer,
-					hb_font_t *font HB_UNUSED)
+struct would_substitute_feature_t
+{
+  inline void init (const hb_ot_map_t *map, hb_tag_t feature_tag)
+  {
+    map->get_stage_lookups (0/*GSUB*/,
+			    map->get_feature_stage (0/*GSUB*/, feature_tag),
+			    &lookups, &count);
+  }
+
+  inline bool would_substitute (hb_codepoint_t    *glyphs,
+				unsigned int       glyphs_count,
+				hb_face_t         *face) const
+  {
+    for (unsigned int i = 0; i < count; i++)
+      if (hb_ot_layout_would_substitute_lookup_fast (face, glyphs, glyphs_count, lookups[i].index))
+	return true;
+    return false;
+  }
+
+  private:
+  const hb_ot_map_t::lookup_map_t *lookups;
+  unsigned int count;
+};
+
+struct indic_shape_plan_t
+{
+  ASSERT_POD ();
+
+  inline bool get_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const
+  {
+    hb_codepoint_t glyph = virama_glyph;
+    if (unlikely (virama_glyph == (hb_codepoint_t) -1))
+    {
+      if (!config->virama || !font->get_glyph (config->virama, 0, &glyph))
+	glyph = 0;
+      /* Technically speaking, the spec says we should apply 'locl' to virama too.
+       * Maybe one day... */
+
+      /* Our get_glyph() function needs a font, so we can't get the virama glyph
+       * during shape planning...  Instead, overwrite it here.  It's safe.  Don't worry! */
+      (const_cast<indic_shape_plan_t *> (this))->virama_glyph = glyph;
+    }
+
+    *pglyph = glyph;
+    return glyph != 0;
+  }
+
+  const indic_config_t *config;
+
+  bool is_old_spec;
+  hb_codepoint_t virama_glyph;
+
+  would_substitute_feature_t pref;
+  would_substitute_feature_t blwf;
+  would_substitute_feature_t pstf;
+
+  hb_mask_t mask_array[INDIC_NUM_FEATURES];
+};
+
+static void *
+data_create_indic (const hb_ot_shape_plan_t *plan)
+{
+  indic_shape_plan_t *indic_plan = (indic_shape_plan_t *) calloc (1, sizeof (indic_shape_plan_t));
+  if (unlikely (!indic_plan))
+    return NULL;
+
+  indic_plan->config = &indic_configs[0];
+  for (unsigned int i = 1; i < ARRAY_LENGTH (indic_configs); i++)
+    if (plan->props.script == indic_configs[i].script) {
+      indic_plan->config = &indic_configs[i];
+      break;
+    }
+
+  indic_plan->is_old_spec = indic_plan->config->has_old_spec && ((plan->map.get_chosen_script (0) & 0x000000FF) != '2');
+  indic_plan->virama_glyph = (hb_codepoint_t) -1;
+
+  indic_plan->pref.init (&plan->map, HB_TAG('p','r','e','f'));
+  indic_plan->blwf.init (&plan->map, HB_TAG('b','l','w','f'));
+  indic_plan->pstf.init (&plan->map, HB_TAG('p','s','t','f'));
+
+  for (unsigned int i = 0; i < ARRAY_LENGTH (indic_plan->mask_array); i++)
+    indic_plan->mask_array[i] = indic_features[i].is_global ? 0 : plan->map.get_1_mask (indic_features[i].tag);
+
+  return indic_plan;
+}
+
+static void
+data_destroy_indic (void *data)
+{
+  free (data);
+}
+
+static indic_position_t
+consonant_position_from_face (const indic_shape_plan_t *indic_plan,
+			      hb_codepoint_t *glyphs, unsigned int glyphs_len,
+			      hb_face_t      *face)
+{
+  if (indic_plan->pref.would_substitute (glyphs, glyphs_len, face)) return POS_BELOW_C;
+  if (indic_plan->blwf.would_substitute (glyphs, glyphs_len, face)) return POS_BELOW_C;
+  if (indic_plan->pstf.would_substitute (glyphs, glyphs_len, face)) return POS_POST_C;
+  return POS_BASE_C;
+}
+
+
+static void
+setup_masks_indic (const hb_ot_shape_plan_t *plan HB_UNUSED,
+		   hb_buffer_t              *buffer,
+		   hb_font_t                *font HB_UNUSED)
 {
   HB_BUFFER_ALLOCATE_VAR (buffer, indic_category);
   HB_BUFFER_ALLOCATE_VAR (buffer, indic_position);
 
   /* We cannot setup masks here.  We save information about characters
    * and setup masks later on in a pause-callback. */
 
   unsigned int count = buffer->len;
   for (unsigned int i = 0; i < count; i++)
-  {
-    hb_glyph_info_t &info = buffer->info[i];
-    unsigned int type = get_indic_categories (info.codepoint);
-
-    info.indic_category() = type & 0x0F;
-    info.indic_position() = type >> 4;
-
-    /* The spec says U+0952 is OT_A.  However, testing shows that Uniscribe
-     * treats U+0951..U+0952 all as OT_VD.
-     * TESTS:
-     * U+092E,U+0947,U+0952
-     * U+092E,U+0952,U+0947
-     * U+092E,U+0947,U+0951
-     * U+092E,U+0951,U+0947
-     * */
-    if (unlikely (hb_in_range<hb_codepoint_t> (info.codepoint, 0x0951, 0x0954)))
-      info.indic_category() = OT_VD;
-
-    if (info.indic_category() == OT_C) {
-      info.indic_position() = consonant_position (info.codepoint);
-      if (is_ra (info.codepoint))
-	info.indic_category() = OT_Ra;
-    } else if (info.indic_category() == OT_SM ||
-	       info.indic_category() == OT_VD) {
-      info.indic_position() = POS_SMVD;
-    } else if (unlikely (info.codepoint == 0x200C))
-      info.indic_category() = OT_ZWNJ;
-    else if (unlikely (info.codepoint == 0x200D))
-      info.indic_category() = OT_ZWJ;
-    else if (unlikely (info.codepoint == 0x25CC))
-      info.indic_category() = OT_DOTTEDCIRCLE;
-  }
+    set_indic_properties (buffer->info[i]);
 }
 
 static int
 compare_indic_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)
 {
   int a = pa->indic_position();
   int b = pb->indic_position();
 
   return a < b ? -1 : a == b ? 0 : +1;
 }
 
+
+
+static void
+update_consonant_positions (const hb_ot_shape_plan_t *plan,
+			    hb_font_t         *font,
+			    hb_buffer_t       *buffer)
+{
+  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;
+
+  unsigned int consonant_pos = indic_plan->is_old_spec ? 0 : 1;
+  hb_codepoint_t glyphs[2];
+  if (indic_plan->get_virama_glyph (font, &glyphs[1 - consonant_pos]))
+  {
+    hb_face_t *face = font->face;
+    unsigned int count = buffer->len;
+    for (unsigned int i = 0; i < count; i++)
+      if (buffer->info[i].indic_position() == POS_BASE_C) {
+	glyphs[consonant_pos] = buffer->info[i].codepoint;
+	buffer->info[i].indic_position() = consonant_position_from_face (indic_plan, glyphs, 2, face);
+      }
+  }
+}
+
+
 /* Rules from:
  * https://www.microsoft.com/typography/otfntdev/devanot/shaping.aspx */
 
 static void
-initial_reordering_consonant_syllable (const hb_ot_map_t *map, hb_buffer_t *buffer, hb_mask_t *mask_array,
+initial_reordering_consonant_syllable (const hb_ot_shape_plan_t *plan, hb_buffer_t *buffer,
 				       unsigned int start, unsigned int end)
 {
+  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;
   hb_glyph_info_t *info = buffer->info;
 
 
   /* 1. Find base consonant:
    *
    * The shaping engine finds the base consonant of the syllable, using the
    * following algorithm: starting from the end of the syllable, move backwards
    * until a consonant is found that does not have a below-base or post-base
@@ -268,69 +424,126 @@ initial_reordering_consonant_syllable (c
   unsigned int base = end;
   bool has_reph = false;
 
   {
     /* -> If the syllable starts with Ra + Halant (in a script that has Reph)
      *    and has more than one consonant, Ra is excluded from candidates for
      *    base consonants. */
     unsigned int limit = start;
-    if (mask_array[RPHF] &&
+    if (indic_plan->mask_array[RPHF] &&
 	start + 3 <= end &&
 	info[start].indic_category() == OT_Ra &&
 	info[start + 1].indic_category() == OT_H &&
-	!is_joiner (info[start + 2]))
+	(/* TODO Handle other Reph modes. */
+	 (indic_plan->config->reph_mode == REPH_MODE_IMPLICIT && !is_joiner (info[start + 2])) ||
+	 (indic_plan->config->reph_mode == REPH_MODE_EXPLICIT && info[start + 2].indic_category() == OT_ZWJ)
+	))
     {
       limit += 2;
+      while (limit < end && is_joiner (info[limit]))
+        limit++;
       base = start;
       has_reph = true;
     };
 
-    /* -> starting from the end of the syllable, move backwards */
-    unsigned int i = end;
-    do {
-      i--;
-      /* -> until a consonant is found */
-      if (is_consonant (info[i]))
+    switch (indic_plan->config->base_pos == BASE_POS_LAST)
+    {
+      case BASE_POS_LAST:
       {
-	/* -> that does not have a below-base or post-base form
-	 * (post-base forms have to follow below-base forms), */
-	if (info[i].indic_position() != POS_BELOW_C &&
-	    info[i].indic_position() != POS_POST_C)
-	{
-	  base = i;
-	  break;
-	}
+	/* -> starting from the end of the syllable, move backwards */
+	unsigned int i = end;
+	bool seen_below = false;
+	do {
+	  i--;
+	  /* -> until a consonant is found */
+	  if (is_consonant (info[i]))
+	  {
+	    /* -> that does not have a below-base or post-base form
+	     * (post-base forms have to follow below-base forms), */
+	    if (info[i].indic_position() != POS_BELOW_C &&
+		(info[i].indic_position() != POS_POST_C || seen_below))
+	    {
+	      base = i;
+	      break;
+	    }
+	    if (info[i].indic_position() == POS_BELOW_C)
+	      seen_below = true;
 
-	/* -> or that is not a pre-base reordering Ra,
-	 *
-	 * TODO
-	 */
+	    /* -> or that is not a pre-base reordering Ra,
+	     *
+	     * IMPLEMENTATION NOTES:
+	     *
+	     * Our pre-base reordering Ra's are marked POS_BELOW, so will be skipped
+	     * by the logic above already.
+	     */
 
-	/* -> or arrive at the first consonant. The consonant stopped at will
-	 * be the base. */
-	base = i;
+	    /* -> or arrive at the first consonant. The consonant stopped at will
+	     * be the base. */
+	    base = i;
+	  }
+	  else
+	  {
+	    /* A ZWJ after a Halant stops the base search, and requests an explicit
+	     * half form.
+	     * A ZWJ before a Halant, requests a subjoined form instead, and hence
+	     * search continues.  This is particularly important for Bengali
+	     * sequence Ra,H,Ya that shouls form Ya-Phalaa by subjoining Ya. */
+	    if (start < i &&
+		info[i].indic_category() == OT_ZWJ &&
+		info[i - 1].indic_category() == OT_H)
+	      break;
+	  }
+	} while (i > limit);
       }
-      else
-	if (is_joiner (info[i]))
-	  break;
-    } while (i > limit);
-    if (base < start)
-      base = start; /* Just in case... */
+      break;
 
+      case BASE_POS_FIRST:
+      {
+	/* In scripts without half forms (eg. Khmer), the first consonant is always the base. */
+
+	if (!has_reph)
+	  base = limit;
+
+	/* Find the last base consonant that is not blocked by ZWJ.  If there is
+	 * a ZWJ right before a base consonant, that would request a subjoined form. */
+	for (unsigned int i = limit; i < end; i++)
+	  if (is_consonant (info[i]) && info[i].indic_position() == POS_BASE_C)
+	  {
+	    if (limit < i && info[i - 1].indic_category() == OT_ZWJ)
+	      break;
+	    else
+	      base = i;
+	  }
+
+	/* Mark all subsequent consonants as below. */
+	for (unsigned int i = base + 1; i < end; i++)
+	  if (is_consonant (info[i]) && info[i].indic_position() == POS_BASE_C)
+	    info[i].indic_position() = POS_BELOW_C;
+      }
+      break;
+
+      default:
+      abort ();
+    }
 
     /* -> If the syllable starts with Ra + Halant (in a script that has Reph)
      *    and has more than one consonant, Ra is excluded from candidates for
-     *    base consonants. */
-    if (has_reph && base == start) {
+     *    base consonants.
+     *
+     *  Only do this for unforced Reph. (ie. not for Ra,H,ZWJ. */
+    if (has_reph && base == start && start + 2 == limit) {
       /* Have no other consonant, so Reph is not formed and Ra becomes base. */
       has_reph = false;
     }
   }
 
+  if (base < end)
+    info[base].indic_position() = POS_BASE_C;
+
 
   /* 2. Decompose and reorder Matras:
    *
    * Each matra and any syllable modifier sign in the cluster are moved to the
    * appropriate position relative to the consonant(s) in the cluster. The
    * shaping engine decomposes two- or three-part matras into their constituent
    * parts before any repositioning. Matra characters are classified by which
    * consonant in a conjunct they have affinity for and are reordered to the
@@ -357,71 +570,101 @@ initial_reordering_consonant_syllable (c
    *
    * We don't need to do this: the normalize() routine already did this for us.
    */
 
 
   /* Reorder characters */
 
   for (unsigned int i = start; i < base; i++)
-    info[i].indic_position() = POS_PRE_C;
-  info[base].indic_position() = POS_BASE_C;
+    info[i].indic_position() = MIN (POS_PRE_C, (indic_position_t) info[i].indic_position());
+
+  if (base < end)
+    info[base].indic_position() = POS_BASE_C;
+
+  /* Mark final consonants.  A final consonant is one appearing after a matra,
+   * like in Khmer. */
+  for (unsigned int i = base + 1; i < end; i++)
+    if (info[i].indic_category() == OT_M) {
+      for (unsigned int j = i + 1; j < end; j++)
+        if (is_consonant (info[j])) {
+	  info[j].indic_position() = POS_FINAL_C;
+	  break;
+	}
+      break;
+    }
 
   /* Handle beginning Ra */
   if (has_reph)
     info[start].indic_position() = POS_RA_TO_BECOME_REPH;
 
   /* For old-style Indic script tags, move the first post-base Halant after
    * last consonant. */
-  if ((map->get_chosen_script (0) & 0x000000FF) != '2') {
-    /* We should only do this for Indic scripts which have a version two I guess. */
+  if (indic_plan->is_old_spec) {
     for (unsigned int i = base + 1; i < end; i++)
       if (info[i].indic_category() == OT_H) {
         unsigned int j;
         for (j = end - 1; j > i; j--)
 	  if (is_consonant (info[j]))
 	    break;
 	if (j > i) {
 	  /* Move Halant to after last consonant. */
 	  hb_glyph_info_t t = info[i];
 	  memmove (&info[i], &info[i + 1], (j - i) * sizeof (info[0]));
 	  info[j] = t;
 	}
         break;
       }
   }
 
-  /* Attach ZWJ, ZWNJ, nukta, and halant to previous char to move with them. */
-  if (!options.uniscribe_bug_compatible)
+  /* Attach misc marks to previous char to move with them. */
   {
-    /* Please update the Uniscribe branch when touching this! */
-    for (unsigned int i = start + 1; i < end; i++)
-      if ((FLAG (info[i].indic_category()) & (FLAG (OT_ZWNJ) | FLAG (OT_ZWJ) | FLAG (OT_N) | FLAG (OT_H))))
-	info[i].indic_position() = info[i - 1].indic_position();
-  } else {
-    /*
-     * Uniscribe doesn't move the Halant with Left Matra.
-     * TEST: U+092B,U+093F,U+094DE
-     */
-    /* Please update the non-Uniscribe branch when touching this! */
-    for (unsigned int i = start + 1; i < end; i++)
-      if ((FLAG (info[i].indic_category()) & (FLAG (OT_ZWNJ) | FLAG (OT_ZWJ) | FLAG (OT_N) | FLAG (OT_H)))) {
-	info[i].indic_position() = info[i - 1].indic_position();
-	if (info[i].indic_category() == OT_H && info[i].indic_position() == POS_PRE_M)
+    indic_position_t last_pos = POS_START;
+    for (unsigned int i = start; i < end; i++)
+    {
+      if ((FLAG (info[i].indic_category()) & (JOINER_FLAGS | FLAG (OT_N) | FLAG (OT_RS) | HALANT_OR_COENG_FLAGS)))
+      {
+	info[i].indic_position() = last_pos;
+	if (unlikely (indic_options ().uniscribe_bug_compatible &&
+		      info[i].indic_category() == OT_H &&
+		      info[i].indic_position() == POS_PRE_M))
+	{
+	  /*
+	   * Uniscribe doesn't move the Halant with Left Matra.
+	   * TEST: U+092B,U+093F,U+094DE
+	   */
 	  for (unsigned int j = i; j > start; j--)
 	    if (info[j - 1].indic_position() != POS_PRE_M) {
 	      info[i].indic_position() = info[j - 1].indic_position();
 	      break;
 	    }
+	}
+      } else if (info[i].indic_position() != POS_SMVD) {
+        last_pos = (indic_position_t) info[i].indic_position();
+      }
+    }
+  }
+  /* Re-attach ZWJ, ZWNJ, and halant to next char, for after-base consonants. */
+  {
+    unsigned int last_halant = end;
+    for (unsigned int i = base + 1; i < end; i++)
+      if (is_halant_or_coeng (info[i]))
+        last_halant = i;
+      else if (is_consonant (info[i])) {
+	for (unsigned int j = last_halant; j < i; j++)
+	  if (info[j].indic_position() != POS_SMVD)
+	    info[j].indic_position() = info[i].indic_position();
       }
   }
 
-  /* We do bubble-sort, skip malicious clusters attempts */
-  if (end - start < 64)
   {
+    /* Things are out-of-control for post base positions, they may shuffle
+     * around like crazy, so merge clusters.  For pre-base stuff, we handle
+     * cluster issues in final reordering. */
+    buffer->merge_clusters (base, end);
     /* Sit tight, rock 'n roll! */
     hb_bubble_sort (info + start, end - start, compare_indic_order);
     /* Find base again */
     base = end;
     for (unsigned int i = start; i < end; i++)
       if (info[i].indic_position() == POS_BASE_C) {
         base = i;
 	break;
@@ -430,170 +673,209 @@ initial_reordering_consonant_syllable (c
 
   /* Setup masks now */
 
   {
     hb_mask_t mask;
 
     /* Reph */
     for (unsigned int i = start; i < end && info[i].indic_position() == POS_RA_TO_BECOME_REPH; i++)
-      info[i].mask |= mask_array[RPHF];
+      info[i].mask |= indic_plan->mask_array[RPHF];
 
     /* Pre-base */
-    mask = mask_array[HALF] | mask_array[AKHN] | mask_array[CJCT];
+    mask = indic_plan->mask_array[HALF];
     for (unsigned int i = start; i < base; i++)
       info[i].mask  |= mask;
     /* Base */
-    mask = mask_array[AKHN] | mask_array[CJCT];
-    info[base].mask |= mask;
+    mask = 0;
+    if (base < end)
+      info[base].mask |= mask;
     /* Post-base */
-    mask = mask_array[BLWF] | mask_array[PSTF] | mask_array[CJCT];
+    mask = indic_plan->mask_array[BLWF] | indic_plan->mask_array[ABVF] | indic_plan->mask_array[PSTF];
     for (unsigned int i = base + 1; i < end; i++)
       info[i].mask  |= mask;
   }
 
+  /* XXX This will not match for old-Indic spec since the Halant-Ra order is reversed already. */
+  if (indic_plan->mask_array[PREF] && base + 2 < end)
+  {
+    /* Find a Halant,Ra sequence and mark it for pre-base reordering processing. */
+    for (unsigned int i = base + 1; i + 1 < end; i++)
+      if (is_halant_or_coeng (info[i]) &&
+	  info[i + 1].indic_category() == OT_Ra)
+      {
+	info[i++].mask |= indic_plan->mask_array[PREF];
+	info[i++].mask |= indic_plan->mask_array[PREF];
+
+	/* Mark the subsequent stuff with 'cfar'.  Used in Khmer.
+	 * Read the feature spec.
+	 * This allows distinguishing the following cases with MS Khmer fonts:
+	 * U+1784,U+17D2,U+179A,U+17D2,U+1782
+	 * U+1784,U+17D2,U+1782,U+17D2,U+179A
+	 */
+	for (; i < end; i++)
+	  info[i].mask |= indic_plan->mask_array[CFAR];
+
+	break;
+      }
+  }
+
   /* Apply ZWJ/ZWNJ effects */
   for (unsigned int i = start + 1; i < end; i++)
     if (is_joiner (info[i])) {
       bool non_joiner = info[i].indic_category() == OT_ZWNJ;
       unsigned int j = i;
 
       do {
 	j--;
 
-	info[j].mask &= ~mask_array[CJCT];
+	/* A ZWJ disables CJCT, however, it's mere presence is enough
+	 * to disable ligation.  No explicit action needed. */
+
+	/* A ZWNJ disables HALF. */
 	if (non_joiner)
-	  info[j].mask &= ~mask_array[HALF];
+	  info[j].mask &= ~indic_plan->mask_array[HALF];
 
       } while (j > start && !is_consonant (info[j]));
     }
 }
 
 
 static void
-initial_reordering_vowel_syllable (const hb_ot_map_t *map,
+initial_reordering_vowel_syllable (const hb_ot_shape_plan_t *plan,
 				   hb_buffer_t *buffer,
-				   hb_mask_t *mask_array,
 				   unsigned int start, unsigned int end)
 {
   /* We made the vowels look like consonants.  So let's call the consonant logic! */
-  initial_reordering_consonant_syllable (map, buffer, mask_array, start, end);
+  initial_reordering_consonant_syllable (plan, buffer, start, end);
 }
 
 static void
-initial_reordering_standalone_cluster (const hb_ot_map_t *map,
+initial_reordering_standalone_cluster (const hb_ot_shape_plan_t *plan,
 				       hb_buffer_t *buffer,
-				       hb_mask_t *mask_array,
 				       unsigned int start, unsigned int end)
 {
   /* We treat NBSP/dotted-circle as if they are consonants, so we should just chain.
    * Only if not in compatibility mode that is... */
 
-  if (options.uniscribe_bug_compatible)
+  if (indic_options ().uniscribe_bug_compatible)
   {
     /* For dotted-circle, this is what Uniscribe does:
      * If dotted-circle is the last glyph, it just does nothing.
      * Ie. It doesn't form Reph. */
     if (buffer->info[end - 1].indic_category() == OT_DOTTEDCIRCLE)
       return;
   }
 
-  initial_reordering_consonant_syllable (map, buffer, mask_array, start, end);
+  initial_reordering_consonant_syllable (plan, buffer, start, end);
 }
 
 static void
-initial_reordering_non_indic (const hb_ot_map_t *map HB_UNUSED,
+initial_reordering_non_indic (const hb_ot_shape_plan_t *plan HB_UNUSED,
 			      hb_buffer_t *buffer HB_UNUSED,
-			      hb_mask_t *mask_array HB_UNUSED,
 			      unsigned int start HB_UNUSED, unsigned int end HB_UNUSED)
 {
   /* Nothing to do right now.  If we ever switch to using the output
    * buffer in the reordering process, we'd need to next_glyph() here. */
 }
 
 #include "hb-ot-shape-complex-indic-machine.hh"
 
 static void
-initial_reordering (const hb_ot_map_t *map,
-		    hb_face_t *face HB_UNUSED,
-		    hb_buffer_t *buffer,
-		    void *user_data HB_UNUSED)
+initial_reordering (const hb_ot_shape_plan_t *plan,
+		    hb_font_t *font,
+		    hb_buffer_t *buffer)
 {
-  hb_mask_t mask_array[ARRAY_LENGTH (indic_basic_features)] = {0};
-  unsigned int num_masks = ARRAY_LENGTH (indic_basic_features);
-  for (unsigned int i = 0; i < num_masks; i++)
-    mask_array[i] = map->get_1_mask (indic_basic_features[i].tag);
-
-  find_syllables (map, buffer, mask_array);
+  update_consonant_positions (plan, font, buffer);
+  find_syllables (plan, buffer);
 }
 
 static void
-final_reordering_syllable (hb_buffer_t *buffer, hb_mask_t *mask_array,
+final_reordering_syllable (const hb_ot_shape_plan_t *plan,
+			   hb_buffer_t *buffer,
 			   unsigned int start, unsigned int end)
 {
+  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;
   hb_glyph_info_t *info = buffer->info;
 
   /* 4. Final reordering:
    *
    * After the localized forms and basic shaping forms GSUB features have been
    * applied (see below), the shaping engine performs some final glyph
    * reordering before applying all the remaining font features to the entire
    * cluster.
    */
 
   /* Find base again */
-  unsigned int base = end;
-  for (unsigned int i = start; i < end; i++)
-    if (info[i].indic_position() == POS_BASE_C) {
-      base = i;
+  unsigned int base;
+  for (base = start; base < end; base++)
+    if (info[base].indic_position() >= POS_BASE_C) {
+      if (start < base && info[base].indic_position() > POS_BASE_C)
+        base--;
       break;
     }
 
-  if (base == start) {
-    /* There's no Reph, and no left Matra to reposition.  Just merge the cluster
-     * and go home. */
-    buffer->merge_clusters (start, end);
-    return;
-  }
-
-  unsigned int start_of_last_cluster = base;
 
   /*   o Reorder matras:
    *
    *     If a pre-base matra character had been reordered before applying basic
    *     features, the glyph can be moved closer to the main consonant based on
    *     whether half-forms had been formed. Actual position for the matra is
    *     defined as “after last standalone halant glyph, after initial matra
    *     position and before the main consonant”. If ZWJ or ZWNJ follow this
    *     halant, position is moved after it.
    */
 
+  if (start + 1 < end && start < base) /* Otherwise there can't be any pre-base matra characters. */
   {
-    unsigned int new_matra_pos = base - 1;
-    while (new_matra_pos > start &&
-	   !(FLAG (info[new_matra_pos].indic_category()) & (FLAG (OT_M) | FLAG (OT_H))))
-      new_matra_pos--;
-    /* If we found no Halant we are done.  Otherwise only proceed if the Halant does
-     * not belong to the Matra itself! */
-    if (info[new_matra_pos].indic_category() == OT_H &&
-	info[new_matra_pos].indic_position() != POS_PRE_M) {
-      /* -> If ZWJ or ZWNJ follow this halant, position is moved after it. */
-      if (new_matra_pos + 1 < end && is_joiner (info[new_matra_pos + 1]))
-	new_matra_pos++;
+    /* If we lost track of base, alas, position before last thingy. */
+    unsigned int new_pos = base == end ? base - 2 : base - 1;
 
+    /* Malayalam does not have "half" forms or explicit virama forms.
+     * The glyphs formed by 'half' are Chillus.  We want to position
+     * matra after them all.
+     */
+    if (buffer->props.script != HB_SCRIPT_MALAYALAM)
+    {
+      while (new_pos > start &&
+	     !(is_one_of (info[new_pos], (FLAG (OT_M) | FLAG (OT_H) | FLAG (OT_Coeng)))))
+	new_pos--;
+
+      /* If we found no Halant we are done.
+       * Otherwise only proceed if the Halant does
+       * not belong to the Matra itself! */
+      if (is_halant_or_coeng (info[new_pos]) &&
+	  info[new_pos].indic_position() != POS_PRE_M)
+      {
+	/* -> If ZWJ or ZWNJ follow this halant, position is moved after it. */
+	if (new_pos + 1 < end && is_joiner (info[new_pos + 1]))
+	  new_pos++;
+      }
+      else
+        new_pos = start; /* No move. */
+    }
+
+    if (start < new_pos)
+    {
       /* Now go see if there's actually any matras... */
-      for (unsigned int i = new_matra_pos; i > start; i--)
+      for (unsigned int i = new_pos; i > start; i--)
 	if (info[i - 1].indic_position () == POS_PRE_M)
 	{
-	  unsigned int old_matra_pos = i - 1;
-	  hb_glyph_info_t matra = info[old_matra_pos];
-	  memmove (&info[old_matra_pos], &info[old_matra_pos + 1], (new_matra_pos - old_matra_pos) * sizeof (info[0]));
-	  info[new_matra_pos] = matra;
-	  start_of_last_cluster = MIN (new_matra_pos, start_of_last_cluster);
-	  new_matra_pos--;
+	  unsigned int old_pos = i - 1;
+	  hb_glyph_info_t tmp = info[old_pos];
+	  memmove (&info[old_pos], &info[old_pos + 1], (new_pos - old_pos) * sizeof (info[0]));
+	  info[new_pos] = tmp;
+	  new_pos--;
+	}
+      buffer->merge_clusters (new_pos, MIN (end, base + 1));
+    } else {
+      for (unsigned int i = start; i < base; i++)
+	if (info[i].indic_position () == POS_PRE_M) {
+	  buffer->merge_clusters (i, MIN (end, base + 1));
+	  break;
 	}
     }
   }
 
 
   /*   o Reorder reph:
    *
    *     Reph’s original position is always at the beginning of the syllable,
@@ -605,59 +887,25 @@ final_reordering_syllable (hb_buffer_t *
 
   /* If there's anything after the Ra that has the REPH pos, it ought to be halant.
    * Which means that the font has failed to ligate the Reph.  In which case, we
    * shouldn't move. */
   if (start + 1 < end &&
       info[start].indic_position() == POS_RA_TO_BECOME_REPH &&
       info[start + 1].indic_position() != POS_RA_TO_BECOME_REPH)
   {
-      unsigned int new_reph_pos;
+    unsigned int new_reph_pos;
+    reph_position_t reph_pos = indic_plan->config->reph_pos;
 
-     enum reph_position_t {
-       REPH_AFTER_MAIN,
-       REPH_BEFORE_SUBSCRIPT,
-       REPH_AFTER_SUBSCRIPT,
-       REPH_BEFORE_POSTSCRIPT,
-       REPH_AFTER_POSTSCRIPT
-     } reph_pos;
-
-     /* XXX Figure out old behavior too */
-     switch ((hb_tag_t) buffer->props.script)
-     {
-       case HB_SCRIPT_MALAYALAM:
-       case HB_SCRIPT_ORIYA:
-	 reph_pos = REPH_AFTER_MAIN;
-	 break;
-
-       case HB_SCRIPT_GURMUKHI:
-	 reph_pos = REPH_BEFORE_SUBSCRIPT;
-	 break;
-
-       case HB_SCRIPT_BENGALI:
-	 reph_pos = REPH_AFTER_SUBSCRIPT;
-	 break;
-
-       default:
-       case HB_SCRIPT_DEVANAGARI:
-       case HB_SCRIPT_GUJARATI:
-	 reph_pos = REPH_BEFORE_POSTSCRIPT;
-	 break;
-
-       case HB_SCRIPT_KANNADA:
-       case HB_SCRIPT_TAMIL:
-       case HB_SCRIPT_TELUGU:
-	 reph_pos = REPH_AFTER_POSTSCRIPT;
-	 break;
-     }
+    /* XXX Figure out old behavior too */
 
     /*       1. If reph should be positioned after post-base consonant forms,
      *          proceed to step 5.
      */
-    if (reph_pos == REPH_AFTER_POSTSCRIPT)
+    if (reph_pos == REPH_POS_AFTER_POST)
     {
       goto reph_step_5;
     }
 
     /*       2. If the reph repositioning class is not after post-base: target
      *          position is after the first explicit halant glyph between the
      *          first post-reph consonant and last main consonant. If ZWJ or ZWNJ
      *          are following this halant, position is moved after it. If such
@@ -665,181 +913,228 @@ final_reordering_syllable (hb_buffer_t *
      *          proceed to the next step.
      *
      *          Note: in old-implementation fonts, where classifications were
      *          fixed in shaping engine, there was no case where reph position
      *          will be found on this step.
      */
     {
       new_reph_pos = start + 1;
-      while (new_reph_pos < base && info[new_reph_pos].indic_category() != OT_H)
+      while (new_reph_pos < base && !is_halant_or_coeng (info[new_reph_pos]))
 	new_reph_pos++;
 
-      if (new_reph_pos < base && info[new_reph_pos].indic_category() == OT_H) {
+      if (new_reph_pos < base && is_halant_or_coeng (info[new_reph_pos])) {
 	/* ->If ZWJ or ZWNJ are following this halant, position is moved after it. */
 	if (new_reph_pos + 1 < base && is_joiner (info[new_reph_pos + 1]))
 	  new_reph_pos++;
 	goto reph_move;
       }
     }
 
     /*       3. If reph should be repositioned after the main consonant: find the
      *          first consonant not ligated with main, or find the first
      *          consonant that is not a potential pre-base reordering Ra.
      */
-    if (reph_pos == REPH_AFTER_MAIN)
+    if (reph_pos == REPH_POS_AFTER_MAIN)
     {
-      /* XXX */
+      new_reph_pos = base;
+      /* XXX Skip potential pre-base reordering Ra. */
+      while (new_reph_pos + 1 < end && info[new_reph_pos + 1].indic_position() <= POS_AFTER_MAIN)
+	new_reph_pos++;
+      if (new_reph_pos < end)
+        goto reph_move;
     }
 
     /*       4. If reph should be positioned before post-base consonant, find
      *          first post-base classified consonant not ligated with main. If no
      *          consonant is found, the target position should be before the
      *          first matra, syllable modifier sign or vedic sign.
      */
     /* This is our take on what step 4 is trying to say (and failing, BADLY). */
-    if (reph_pos == REPH_AFTER_SUBSCRIPT)
+    if (reph_pos == REPH_POS_AFTER_SUB)
     {
       new_reph_pos = base;
       while (new_reph_pos < end &&
-	     !( FLAG (info[new_reph_pos + 1].indic_position()) & (FLAG (POS_POST_C) | FLAG (POS_POST_M) | FLAG (POS_SMVD))))
+	     !( FLAG (info[new_reph_pos + 1].indic_position()) & (FLAG (POS_POST_C) | FLAG (POS_AFTER_POST) | FLAG (POS_SMVD))))
 	new_reph_pos++;
       if (new_reph_pos < end)
         goto reph_move;
     }
 
     /*       5. If no consonant is found in steps 3 or 4, move reph to a position
      *          immediately before the first post-base matra, syllable modifier
      *          sign or vedic sign that has a reordering class after the intended
      *          reph position. For example, if the reordering position for reph
      *          is post-main, it will skip above-base matras that also have a
      *          post-main position.
      */
     reph_step_5:
     {
-      /* XXX */
+      /* Copied from step 2. */
+      new_reph_pos = start + 1;
+      while (new_reph_pos < base && !is_halant_or_coeng (info[new_reph_pos]))
+	new_reph_pos++;
+
+      if (new_reph_pos < base && is_halant_or_coeng (info[new_reph_pos])) {
+	/* ->If ZWJ or ZWNJ are following this halant, position is moved after it. */
+	if (new_reph_pos + 1 < base && is_joiner (info[new_reph_pos + 1]))
+	  new_reph_pos++;
+	goto reph_move;
+      }
     }
 
     /*       6. Otherwise, reorder reph to the end of the syllable.
      */
     {
       new_reph_pos = end - 1;
       while (new_reph_pos > start && info[new_reph_pos].indic_position() == POS_SMVD)
 	new_reph_pos--;
 
       /*
        * If the Reph is to be ending up after a Matra,Halant sequence,
        * position it before that Halant so it can interact with the Matra.
        * However, if it's a plain Consonant,Halant we shouldn't do that.
        * Uniscribe doesn't do this.
        * TEST: U+0930,U+094D,U+0915,U+094B,U+094D
        */
-      if (!options.uniscribe_bug_compatible &&
-	  unlikely (info[new_reph_pos].indic_category() == OT_H)) {
+      if (!indic_options ().uniscribe_bug_compatible &&
+	  unlikely (is_halant_or_coeng (info[new_reph_pos]))) {
 	for (unsigned int i = base + 1; i < new_reph_pos; i++)
 	  if (info[i].indic_category() == OT_M) {
 	    /* Ok, got it. */
 	    new_reph_pos--;
 	  }
       }
       goto reph_move;
     }
 
     reph_move:
     {
+      /* Yay, one big cluster! Merge before moving. */
+      buffer->merge_clusters (start, end);
+
       /* Move */
       hb_glyph_info_t reph = info[start];
       memmove (&info[start], &info[start + 1], (new_reph_pos - start) * sizeof (info[0]));
       info[new_reph_pos] = reph;
-      start_of_last_cluster = start; /* Yay, one big cluster! */
     }
   }
 
 
   /*   o Reorder pre-base reordering consonants:
    *
    *     If a pre-base reordering consonant is found, reorder it according to
    *     the following rules:
-   *
-   *       1. Only reorder a glyph produced by substitution during application
-   *          of the feature. (Note that a font may shape a Ra consonant with
-   *          the feature generally but block it in certain contexts.)
-   *
-   *       2. Try to find a target position the same way as for pre-base matra.
-   *          If it is found, reorder pre-base consonant glyph.
-   *
-   *       3. If position is not found, reorder immediately before main
-   *          consonant.
    */
 
-  /* TODO */
+  if (indic_plan->mask_array[PREF] && base + 1 < end) /* Otherwise there can't be any pre-base reordering Ra. */
+  {
+    for (unsigned int i = base + 1; i < end; i++)
+      if ((info[i].mask & indic_plan->mask_array[PREF]) != 0)
+      {
+	/*       1. Only reorder a glyph produced by substitution during application
+	 *          of the <pref> feature. (Note that a font may shape a Ra consonant with
+	 *          the feature generally but block it in certain contexts.)
+	 */
+	if (i + 1 == end || (info[i + 1].mask & indic_plan->mask_array[PREF]) == 0)
+	{
+	  /*
+	   *       2. Try to find a target position the same way as for pre-base matra.
+	   *          If it is found, reorder pre-base consonant glyph.
+	   *
+	   *       3. If position is not found, reorder immediately before main
+	   *          consonant.
+	   */
 
+	  unsigned int new_pos = base;
+	  while (new_pos > start &&
+		 !(is_one_of (info[new_pos - 1], FLAG(OT_M) | HALANT_OR_COENG_FLAGS)))
+	    new_pos--;
+
+	  /* In Khmer coeng model, a V,Ra can go *after* matras.  If it goes after a
+	   * split matra, it should be reordered to *before* the left part of such matra. */
+	  if (new_pos > start && info[new_pos - 1].indic_category() == OT_M)
+	  {
+	    unsigned int old_pos = i;
+	    for (unsigned int i = base + 1; i < old_pos; i++)
+	      if (info[i].indic_category() == OT_M)
+	      {
+		new_pos--;
+		break;
+	      }
+	  }
+
+	  if (new_pos > start && is_halant_or_coeng (info[new_pos - 1]))
+	    /* -> If ZWJ or ZWNJ follow this halant, position is moved after it. */
+	    if (new_pos < end && is_joiner (info[new_pos]))
+	      new_pos++;
+
+	  {
+	    unsigned int old_pos = i;
+	    buffer->merge_clusters (new_pos, old_pos + 1);
+	    hb_glyph_info_t tmp = info[old_pos];
+	    memmove (&info[new_pos + 1], &info[new_pos], (old_pos - new_pos) * sizeof (info[0]));
+	    info[new_pos] = tmp;
+	  }
+	}
+
+        break;
+      }
+  }
 
 
   /* Apply 'init' to the Left Matra if it's a word start. */
   if (info[start].indic_position () == POS_PRE_M &&
       (!start ||
        !(FLAG (_hb_glyph_info_get_general_category (&info[start - 1])) &
-	 (FLAG (HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER) |
-	  FLAG (HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER) |
-	  FLAG (HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER) |
-	  FLAG (HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER) |
-	  FLAG (HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER) |
-	  FLAG (HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK) |
-	  FLAG (HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK) |
-	  FLAG (HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)))))
-    info[start].mask |= mask_array[INIT];
+	 FLAG_RANGE (HB_UNICODE_GENERAL_CATEGORY_FORMAT, HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK))))
+    info[start].mask |= indic_plan->mask_array[INIT];
 
 
-
-  /* Finish off the clusters and go home! */
-
-  if (!options.uniscribe_bug_compatible)
+  /*
+   * Finish off the clusters and go home!
+   */
+  if (indic_options ().uniscribe_bug_compatible)
   {
-    /* This is what Uniscribe does.  Ie. add cluster boundaries after Halant,ZWNJ.
+    /* Uniscribe merges the entire cluster.
      * This means, half forms are submerged into the main consonants cluster.
      * This is unnecessary, and makes cursor positioning harder, but that's what
      * Uniscribe does. */
-    unsigned int cluster_start = start;
-    for (unsigned int i = start + 1; i < start_of_last_cluster; i++)
-      if (info[i - 1].indic_category() == OT_H && info[i].indic_category() == OT_ZWNJ) {
-        i++;
-	buffer->merge_clusters (cluster_start, i);
-	cluster_start = i;
-      }
-    start_of_last_cluster = cluster_start;
+    buffer->merge_clusters (start, end);
   }
-
-  buffer->merge_clusters (start_of_last_cluster, end);
 }
 
 
 static void
-final_reordering (const hb_ot_map_t *map,
-		  hb_face_t *face HB_UNUSED,
-		  hb_buffer_t *buffer,
-		  void *user_data HB_UNUSED)
+final_reordering (const hb_ot_shape_plan_t *plan,
+		  hb_font_t *font,
+		  hb_buffer_t *buffer)
 {
   unsigned int count = buffer->len;
   if (!count) return;
 
-  hb_mask_t mask_array[ARRAY_LENGTH (indic_other_features)] = {0};
-  unsigned int num_masks = ARRAY_LENGTH (indic_other_features);
-  for (unsigned int i = 0; i < num_masks; i++)
-    mask_array[i] = map->get_1_mask (indic_other_features[i].tag);
-
   hb_glyph_info_t *info = buffer->info;
   unsigned int last = 0;
   unsigned int last_syllable = info[0].syllable();
   for (unsigned int i = 1; i < count; i++)
     if (last_syllable != info[i].syllable()) {
-      final_reordering_syllable (buffer, mask_array, last, i);
+      final_reordering_syllable (plan, buffer, last, i);
       last = i;
       last_syllable = info[last].syllable();
     }
-  final_reordering_syllable (buffer, mask_array, last, count);
+  final_reordering_syllable (plan, buffer, last, count);
 
   HB_BUFFER_DEALLOCATE_VAR (buffer, indic_category);
   HB_BUFFER_DEALLOCATE_VAR (buffer, indic_position);
 }
 
 
-
+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_indic =
+{
+  "indic",
+  collect_features_indic,
+  override_features_indic,
+  data_create_indic,
+  data_destroy_indic,
+  NULL, /* normalization_preference */
+  setup_masks_indic,
+  false, /* zero_width_attached_marks */
+};
diff --git a/gfx/harfbuzz/src/hb-ot-shape-complex-misc.cc b/gfx/harfbuzz/src/hb-ot-shape-complex-misc.cc
--- a/gfx/harfbuzz/src/hb-ot-shape-complex-misc.cc
+++ b/gfx/harfbuzz/src/hb-ot-shape-complex-misc.cc
@@ -24,132 +24,135 @@
  * Google Author(s): Behdad Esfahbod
  */
 
 #include "hb-ot-shape-complex-private.hh"
 
 
 /* TODO Add kana, and other small shapers here */
 
-/* When adding trivial shapers, eg. kana, hangul, etc, we can either
- * add a full shaper enum value for them, or switch on the script in
- * the default complex shaper.  The former is faster, so I think that's
- * what we would do, and hence the default complex shaper shall remain
- * empty.
- */
 
-void
-_hb_ot_shape_complex_collect_features_default (hb_ot_map_builder_t *map HB_UNUSED,
-					       const hb_segment_properties_t *props HB_UNUSED)
-{
-}
-
-hb_ot_shape_normalization_mode_t
-_hb_ot_shape_complex_normalization_preference_default (void)
-{
-  return HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS;
-}
-
-void
-_hb_ot_shape_complex_setup_masks_default (hb_ot_map_t *map HB_UNUSED,
-					  hb_buffer_t *buffer HB_UNUSED,
-					  hb_font_t *font HB_UNUSED)
-{
-}
-
-
-
-/* Hangul shaper */
+/* The default shaper *only* adds additional per-script features.*/
 
 static const hb_tag_t hangul_features[] =
 {
   HB_TAG('l','j','m','o'),
   HB_TAG('v','j','m','o'),
   HB_TAG('t','j','m','o'),
+  HB_TAG_NONE
 };
 
-void
-_hb_ot_shape_complex_collect_features_hangul (hb_ot_map_builder_t *map,
-					      const hb_segment_properties_t *props HB_UNUSED)
+static const hb_tag_t tibetan_features[] =
 {
-  for (unsigned int i = 0; i < ARRAY_LENGTH (hangul_features); i++)
-    map->add_bool_feature (hangul_features[i]);
+  HB_TAG('a','b','v','s'),
+  HB_TAG('b','l','w','s'),
+  HB_TAG('a','b','v','m'),
+  HB_TAG('b','l','w','m'),
+  HB_TAG_NONE
+};
+
+static void
+collect_features_default (hb_ot_shape_planner_t *plan)
+{
+  const hb_tag_t *script_features = NULL;
+
+  switch ((hb_tag_t) plan->props.script)
+  {
+    /* Unicode-1.1 additions */
+    case HB_SCRIPT_HANGUL:
+      script_features = hangul_features;
+      break;
+
+    /* Unicode-2.0 additions */
+    case HB_SCRIPT_TIBETAN:
+      script_features = tibetan_features;
+      break;
+  }
+
+  for (; script_features && *script_features; script_features++)
+    plan->map.add_bool_feature (*script_features);
 }
 
-hb_ot_shape_normalization_mode_t
-_hb_ot_shape_complex_normalization_preference_hangul (void)
+static hb_ot_shape_normalization_mode_t
+normalization_preference_default (const hb_ot_shape_plan_t *plan)
 {
-  return HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_FULL;
+  switch ((hb_tag_t) plan->props.script)
+  {
+    /* Unicode-1.1 additions */
+    case HB_SCRIPT_HANGUL:
+      return HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_FULL;
+  }
+  return HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS;
 }
 
-void
-_hb_ot_shape_complex_setup_masks_hangul (hb_ot_map_t *map HB_UNUSED,
-					 hb_buffer_t *buffer HB_UNUSED,
-					 hb_font_t *font HB_UNUSED)
+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_default =
 {
-}
-
+  "default",
+  collect_features_default,
+  NULL, /* override_features */
+  NULL, /* data_create */
+  NULL, /* data_destroy */
+  normalization_preference_default,
+  NULL, /* setup_masks */
+  true, /* zero_width_attached_marks */
+};
 
 
 /* Thai / Lao shaper */
 
-void
-_hb_ot_shape_complex_collect_features_thai (hb_ot_map_builder_t *map HB_UNUSED,
-					    const hb_segment_properties_t *props HB_UNUSED)
-{
-}
-
-hb_ot_shape_normalization_mode_t
-_hb_ot_shape_complex_normalization_preference_thai (void)
-{
-  return HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_FULL;
-}
-
-void
-_hb_ot_shape_complex_setup_masks_thai (hb_ot_map_t *map HB_UNUSED,
-				       hb_buffer_t *buffer,
-				       hb_font_t *font HB_UNUSED)
+static void
+setup_masks_thai (const hb_ot_shape_plan_t *plan HB_UNUSED,
+		  hb_buffer_t              *buffer,
+		  hb_font_t                *font HB_UNUSED)
 {
   /* The following is NOT specified in the MS OT Thai spec, however, it seems
    * to be what Uniscribe and other engines implement.  According to Eric Muller:
    *
-   * When you have a sara am, decompose it in nikhahit + sara a, *and* mode the
-   * nihka hit backwards over any *tone* mark (0E48-0E4B).
+   * When you have a SARA AM, decompose it in NIKHAHIT + SARA AA, *and* move the
+   * NIKHAHIT backwards over any tone mark (0E48-0E4B).
    *
    * <0E14, 0E4B, 0E33> -> <0E14, 0E4D, 0E4B, 0E32>
    *
-   * This reordering is legit only when the nikhahit comes from a sara am, not
+   * This reordering is legit only when the NIKHAHIT comes from a SARA AM, not
    * when it's there to start with. The string <0E14, 0E4B, 0E4D> is probably
-   * not what a u↪ser wanted, but the rendering is nevertheless nikhahit above
+   * not what a user wanted, but the rendering is nevertheless nikhahit above
    * chattawa.
    *
    * Same for Lao.
+   *
+   * Note:
+   *
+   * Uniscribe also does so below-marks reordering.  Namely, it positions U+0E3A
+   * after U+0E38 and U+0E39.  We do that by modifying the ccc for U+0E3A.
+   * See unicode->modified_combining_class ().  Lao does NOT have a U+0E3A
+   * equivalent.
    */
 
+
   /*
    * Here are the characters of significance:
    *
    *			Thai	Lao
    * SARA AM:		U+0E33	U+0EB3
    * SARA AA:		U+0E32	U+0EB2
    * Nikhahit:		U+0E4D	U+0ECD
    *
-   * Tone marks:
-   * Thai:	<0E48..0E4B> CCC=107
-   * Lao:	<0EC8..0ECB> CCC=122
+   * Testing shows that Uniscribe reorder the following marks:
+   * Thai:	<0E31,0E34..0E37,0E47..0E4E>
+   * Lao:	<0EB1,0EB4..0EB7,0EC7..0ECE>
    *
    * Note how the Lao versions are the same as Thai + 0x80.
    */
 
   /* We only get one script at a time, so a script-agnostic implementation
    * is adequate here. */
 #define IS_SARA_AM(x) (((x) & ~0x0080) == 0x0E33)
 #define NIKHAHIT_FROM_SARA_AM(x) ((x) - 0xE33 + 0xE4D)
 #define SARA_AA_FROM_SARA_AM(x) ((x) - 1)
-#define IS_TONE_MARK(x) (((x) & ~0x0083) == 0x0E48)
+#define IS_TONE_MARK(x) (hb_in_ranges<hb_codepoint_t> ((x) & ~0x0080, 0x0E34, 0x0E37, 0x0E47, 0x0E4E, 0x0E31, 0x0E31))
 
   buffer->clear_output ();
   unsigned int count = buffer->len;
   for (buffer->idx = 0; buffer->idx < count;)
   {
     hb_codepoint_t u = buffer->cur().codepoint;
     if (likely (!IS_SARA_AM (u))) {
       buffer->next_glyph ();
@@ -164,30 +167,40 @@ void
       return;
 
     /* Ok, let's see... */
     unsigned int end = buffer->out_len;
     unsigned int start = end - 2;
     while (start > 0 && IS_TONE_MARK (buffer->out_info[start - 1].codepoint))
       start--;
 
-    /* Move Nikhahit (end-2) to the beginning */
-    hb_glyph_info_t t = buffer->out_info[end - 2];
-    memmove (buffer->out_info + start + 1,
-	     buffer->out_info + start,
-	     sizeof (buffer->out_info[0]) * (end - start - 2));
-    buffer->out_info[start] = t;
-
-    /* XXX Make this easier! */
-    /* Make cluster */
-    for (; start > 0 && buffer->out_info[start - 1].cluster == buffer->out_info[start].cluster; start--)
-      ;
-    for (; buffer->idx < count;)
-      if (buffer->cur().cluster == buffer->prev().cluster)
-        buffer->next_glyph ();
-      else
-        break;
-    end = buffer->out_len;
-
-    buffer->merge_out_clusters (start, end);
+    if (start + 2 < end)
+    {
+      /* Move Nikhahit (end-2) to the beginning */
+      buffer->merge_out_clusters (start, end);
+      hb_glyph_info_t t = buffer->out_info[end - 2];
+      memmove (buffer->out_info + start + 1,
+	       buffer->out_info + start,
+	       sizeof (buffer->out_info[0]) * (end - start - 2));
+      buffer->out_info[start] = t;
+    }
+    else
+    {
+      /* Since we decomposed, and NIKHAHIT is combining, merge clusters with the
+       * previous cluster. */
+      if (start)
+	buffer->merge_out_clusters (start - 1, end);
+    }
   }
   buffer->swap_buffers ();
 }
+
+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_thai =
+{
+  "thai",
+  NULL, /* collect_features */
+  NULL, /* override_features */
+  NULL, /* data_create */
+  NULL, /* data_destroy */
+  NULL, /* normalization_preference */
+  setup_masks_thai,
+  true, /* zero_width_attached_marks */
+};
diff --git a/gfx/harfbuzz/src/hb-ot-shape-complex-private.hh b/gfx/harfbuzz/src/hb-ot-shape-complex-private.hh
--- a/gfx/harfbuzz/src/hb-ot-shape-complex-private.hh
+++ b/gfx/harfbuzz/src/hb-ot-shape-complex-private.hh
@@ -24,86 +24,121 @@
  * Google Author(s): Behdad Esfahbod
  */
 
 #ifndef HB_OT_SHAPE_COMPLEX_PRIVATE_HH
 #define HB_OT_SHAPE_COMPLEX_PRIVATE_HH
 
 #include "hb-private.hh"
 
-#include "hb-ot-map-private.hh"
+#include "hb-ot-shape-private.hh"
 #include "hb-ot-shape-normalize-private.hh"
 
 
 
-/* buffer var allocations, used during the entire shaping process */
-#define unicode_props0()	var1.u8[0]
-#define unicode_props1()	var1.u8[1]
-
-/* buffer var allocations, used during the GSUB/GPOS processing */
-#define props_cache()		var1.u16[1] /* GSUB/GPOS glyph_props cache */
-#define syllable()		var2.u8[0] /* GSUB/GPOS shaping boundaries */
-#define lig_props()		var2.u8[1] /* GSUB/GPOS ligature tracking */
-
 /* buffer var allocations, used by complex shapers */
 #define complex_var_persistent_u8_0()	var2.u8[2]
 #define complex_var_persistent_u8_1()	var2.u8[3]
 #define complex_var_temporary_u8()	var2.u8[0]
 
 
+
+/* Master OT shaper list */
 #define HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS \
   HB_COMPLEX_SHAPER_IMPLEMENT (default) /* should be first */ \
   HB_COMPLEX_SHAPER_IMPLEMENT (arabic) \
-  HB_COMPLEX_SHAPER_IMPLEMENT (hangul) \
   HB_COMPLEX_SHAPER_IMPLEMENT (indic) \
   HB_COMPLEX_SHAPER_IMPLEMENT (thai) \
   /* ^--- Add new shapers here */
 
-enum hb_ot_complex_shaper_t {
-#define HB_COMPLEX_SHAPER_IMPLEMENT(name) hb_ot_complex_shaper_##name,
-  HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
-  /* Just here to avoid enum trailing comma: */
-  hb_ot_complex_shaper_generic = hb_ot_complex_shaper_default
-#undef HB_COMPLEX_SHAPER_IMPLEMENT
+
+struct hb_ot_complex_shaper_t
+{
+  char name[8];
+
+  /* collect_features()
+   * Called during shape_plan().
+   * Shapers should use plan->map to add their features and callbacks.
+   * May be NULL.
+   */
+  void (*collect_features) (hb_ot_shape_planner_t *plan);
+
+  /* override_features()
+   * Called during shape_plan().
+   * Shapers should use plan->map to override features and add callbacks after
+   * common features are added.
+   * May be NULL.
+   */
+  void (*override_features) (hb_ot_shape_planner_t *plan);
+
+
+  /* data_create()
+   * Called at the end of shape_plan().
+   * Whatever shapers return will be accessible through plan->data later.
+   * If NULL is returned, means a plan failure.
+   * May be NULL. */
+  void *(*data_create) (const hb_ot_shape_plan_t *plan);
+
+  /* data_destroy()
+   * Called when the shape_plan is being destroyed.
+   * plan->data is passed here for destruction.
+   * If NULL is returned, means a plan failure.
+   * May be NULL. */
+  void (*data_destroy) (void *data);
+
+  /* normalization_preference()
+   * Called during shape().
+   */
+  hb_ot_shape_normalization_mode_t
+  (*normalization_preference) (const hb_ot_shape_plan_t *plan);
+
+  /* setup_masks()
+   * Called during shape().
+   * Shapers should use map to get feature masks and set on buffer.
+   */
+  void (*setup_masks) (const hb_ot_shape_plan_t *plan,
+		       hb_buffer_t              *buffer,
+		       hb_font_t                *font);
+
+  bool zero_width_attached_marks;
 };
 
-static inline hb_ot_complex_shaper_t
+#define HB_COMPLEX_SHAPER_IMPLEMENT(name) extern HB_INTERNAL const hb_ot_complex_shaper_t _hb_ot_complex_shaper_##name;
+HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
+#undef HB_COMPLEX_SHAPER_IMPLEMENT
+
+
+static inline const hb_ot_complex_shaper_t *
 hb_ot_shape_complex_categorize (const hb_segment_properties_t *props)
 {
   switch ((hb_tag_t) props->script)
   {
     default:
-      return hb_ot_complex_shaper_default;
+      return &_hb_ot_complex_shaper_default;
 
 
     /* Unicode-1.1 additions */
     case HB_SCRIPT_ARABIC:
     case HB_SCRIPT_MONGOLIAN:
     case HB_SCRIPT_SYRIAC:
 
     /* Unicode-5.0 additions */
     case HB_SCRIPT_NKO:
 
     /* Unicode-6.0 additions */
     case HB_SCRIPT_MANDAIC:
 
-      return hb_ot_complex_shaper_arabic;
-
-
-    /* Unicode-1.1 additions */
-    case HB_SCRIPT_HANGUL:
-
-      return hb_ot_complex_shaper_hangul;
+      return &_hb_ot_complex_shaper_arabic;
 
 
     /* Unicode-1.1 additions */
     case HB_SCRIPT_THAI:
     case HB_SCRIPT_LAO:
 
-      return hb_ot_complex_shaper_thai;
+      return &_hb_ot_complex_shaper_thai;
 
 
 
     /* ^--- Add new shapers here */
 
 
 #if 0
     /* Note:
@@ -208,101 +243,14 @@ hb_ot_shape_complex_categorize (const hb
     case HB_SCRIPT_KAITHI:
     case HB_SCRIPT_TAI_THAM:
 
     /* Unicode-6.1 additions */
     case HB_SCRIPT_CHAKMA:
     case HB_SCRIPT_SHARADA:
     case HB_SCRIPT_TAKRI:
 
-      return hb_ot_complex_shaper_indic;
+      return &_hb_ot_complex_shaper_indic;
   }
 }
 
 
-
-/*
- * collect_features()
- *
- * Called during shape_plan().
- *
- * Shapers should use map to add their features and callbacks.
- */
-
-typedef void hb_ot_shape_complex_collect_features_func_t (hb_ot_map_builder_t *map, const hb_segment_properties_t  *props);
-#define HB_COMPLEX_SHAPER_IMPLEMENT(name) \
-  HB_INTERNAL hb_ot_shape_complex_collect_features_func_t _hb_ot_shape_complex_collect_features_##name;
-  HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
-#undef HB_COMPLEX_SHAPER_IMPLEMENT
-
-static inline void
-hb_ot_shape_complex_collect_features (hb_ot_complex_shaper_t shaper,
-				      hb_ot_map_builder_t *map,
-				      const hb_segment_properties_t  *props)
-{
-  switch (shaper) {
-    default:
-#define HB_COMPLEX_SHAPER_IMPLEMENT(name) \
-    case hb_ot_complex_shaper_##name:	_hb_ot_shape_complex_collect_features_##name (map, props); return;
-    HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
-#undef HB_COMPLEX_SHAPER_IMPLEMENT
-  }
-}
-
-
-/*
- * normalization_preference()
- *
- * Called during shape_execute().
- *
- * Shapers should return TRUE if it prefers decomposed (NFD) input rather than precomposed (NFC).
- */
-
-typedef hb_ot_shape_normalization_mode_t hb_ot_shape_complex_normalization_preference_func_t (void);
-#define HB_COMPLEX_SHAPER_IMPLEMENT(name) \
-  HB_INTERNAL hb_ot_shape_complex_normalization_preference_func_t _hb_ot_shape_complex_normalization_preference_##name;
-  HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
-#undef HB_COMPLEX_SHAPER_IMPLEMENT
-
-static inline hb_ot_shape_normalization_mode_t
-hb_ot_shape_complex_normalization_preference (hb_ot_complex_shaper_t shaper)
-{
-  switch (shaper) {
-    default:
-#define HB_COMPLEX_SHAPER_IMPLEMENT(name) \
-    case hb_ot_complex_shaper_##name:	return _hb_ot_shape_complex_normalization_preference_##name ();
-    HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
-#undef HB_COMPLEX_SHAPER_IMPLEMENT
-  }
-}
-
-
-/* setup_masks()
- *
- * Called during shape_execute().
- *
- * Shapers should use map to get feature masks and set on buffer.
- */
-
-typedef void hb_ot_shape_complex_setup_masks_func_t (hb_ot_map_t *map, hb_buffer_t *buffer, hb_font_t *font);
-#define HB_COMPLEX_SHAPER_IMPLEMENT(name) \
-  HB_INTERNAL hb_ot_shape_complex_setup_masks_func_t _hb_ot_shape_complex_setup_masks_##name;
-  HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
-#undef HB_COMPLEX_SHAPER_IMPLEMENT
-
-static inline void
-hb_ot_shape_complex_setup_masks (hb_ot_complex_shaper_t shaper,
-				 hb_ot_map_t *map,
-				 hb_buffer_t *buffer,
-				 hb_font_t *font)
-{
-  switch (shaper) {
-    default:
-#define HB_COMPLEX_SHAPER_IMPLEMENT(name) \
-    case hb_ot_complex_shaper_##name:	_hb_ot_shape_complex_setup_masks_##name (map, buffer, font); return;
-    HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
-#undef HB_COMPLEX_SHAPER_IMPLEMENT
-  }
-}
-
-
-
 #endif /* HB_OT_SHAPE_COMPLEX_PRIVATE_HH */
diff --git a/gfx/harfbuzz/src/hb-ot-shape-normalize-private.hh b/gfx/harfbuzz/src/hb-ot-shape-normalize-private.hh
--- a/gfx/harfbuzz/src/hb-ot-shape-normalize-private.hh
+++ b/gfx/harfbuzz/src/hb-ot-shape-normalize-private.hh
@@ -31,16 +31,18 @@
 
 #include "hb-font.h"
 #include "hb-buffer.h"
 
 
 enum hb_ot_shape_normalization_mode_t {
   HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED,
   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS, /* never composes base-to-base */
-  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_FULL /* including base-to-base composition */
+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_FULL, /* including base-to-base composition */
+
+  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT = HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS,
 };
 
 HB_INTERNAL void _hb_ot_shape_normalize (hb_font_t *font,
 					 hb_buffer_t *buffer,
 					 hb_ot_shape_normalization_mode_t mode);
 
 #endif /* HB_OT_SHAPE_NORMALIZE_PRIVATE_HH */
diff --git a/gfx/harfbuzz/src/hb-ot-shape-normalize.cc b/gfx/harfbuzz/src/hb-ot-shape-normalize.cc
--- a/gfx/harfbuzz/src/hb-ot-shape-normalize.cc
+++ b/gfx/harfbuzz/src/hb-ot-shape-normalize.cc
@@ -57,121 +57,150 @@
  *     feature in the font is not adequate, use the precomposed character
  *     which typically has better mark positioning.
  *
  *   - When a font does not support a combining mark, but supports it precomposed
  *     with previous base, use that.  This needs the itemizer to have this
  *     knowledge too.  We need to provide assistance to the itemizer.
  *
  *   - When a font does not support a character but supports its decomposition,
- *     well, use the decomposition.
+ *     well, use the decomposition (preferring the canonical decomposition, but
+ *     falling back to the compatibility decomposition if necessary).  The
+ *     compatibility decomposition is really nice to have, for characters like
+ *     ellipsis, or various-sized space characters.
  *
- *   - The Indic shaper requests decomposed output.  This will handle splitting
- *     matra for the Indic shaper.
+ *   - The complex shapers can customize the compose and decompose functions to
+ *     offload some of their requirements to the normalizer.  For example, the
+ *     Indic shaper may want to disallow recomposing of two matras.
+ *
+ *   - We try compatibility decomposition if decomposing through canonical
+ *     decomposition alone failed to find a sequence that the font supports.
+ *     We don't try compatibility decomposition recursively during the canonical
+ *     decomposition phase.  This has minimal impact.  There are only a handful
+ *     of Greek letter that have canonical decompositions that include characters
+ *     with compatibility decomposition.  Those can be found using this command:
+ *
+ *     egrep  "`echo -n ';('; grep ';<' UnicodeData.txt | cut -d';' -f1 | tr '\n' '|'; echo ') '`" UnicodeData.txt
  */
 
 static void
 output_glyph (hb_buffer_t *buffer, hb_codepoint_t glyph)
 {
   buffer->output_glyph (glyph);
   _hb_glyph_info_set_unicode_props (&buffer->prev(), buffer->unicode);
 }
 
 static bool
 decompose (hb_font_t *font, hb_buffer_t *buffer,
 	   bool shortest,
 	   hb_codepoint_t ab)
 {
   hb_codepoint_t a, b, glyph;
 
-  if (!hb_unicode_decompose (buffer->unicode, ab, &a, &b) ||
-      (b && !hb_font_get_glyph (font, b, 0, &glyph)))
-    return FALSE;
+  if (!buffer->unicode->decompose (ab, &a, &b) ||
+      (b && !font->get_glyph (b, 0, &glyph)))
+    return false;
 
-  bool has_a = hb_font_get_glyph (font, a, 0, &glyph);
+  bool has_a = font->get_glyph (a, 0, &glyph);
   if (shortest && has_a) {
     /* Output a and b */
     output_glyph (buffer, a);
     if (b)
       output_glyph (buffer, b);
-    return TRUE;
+    return true;
   }
 
   if (decompose (font, buffer, shortest, a)) {
     if (b)
       output_glyph (buffer, b);
-    return TRUE;
+    return true;
   }
 
   if (has_a) {
     output_glyph (buffer, a);
     if (b)
       output_glyph (buffer, b);
-    return TRUE;
+    return true;
   }
 
-  return FALSE;
+  return false;
+}
+
+static bool
+decompose_compatibility (hb_font_t *font, hb_buffer_t *buffer,
+			 hb_codepoint_t u)
+{
+  unsigned int len, i;
+  hb_codepoint_t decomposed[HB_UNICODE_MAX_DECOMPOSITION_LEN];
+
+  len = buffer->unicode->decompose_compatibility (u, decomposed);
+  if (!len)
+    return false;
+
+  hb_codepoint_t glyph;
+  for (i = 0; i < len; i++)
+    if (!font->get_glyph (decomposed[i], 0, &glyph))
+      return false;
+
+  for (i = 0; i < len; i++)
+    output_glyph (buffer, decomposed[i]);
+
+  return true;
 }
 
 static void
-decompose_current_glyph (hb_font_t *font, hb_buffer_t *buffer,
-			 bool shortest)
+decompose_current_character (hb_font_t *font, hb_buffer_t *buffer,
+			     bool shortest)
 {
-  if (decompose (font, buffer, shortest, buffer->cur().codepoint))
+  hb_codepoint_t glyph;
+
+  /* Kind of a cute waterfall here... */
+  if (shortest && font->get_glyph (buffer->cur().codepoint, 0, &glyph))
+    buffer->next_glyph ();
+  else if (decompose (font, buffer, shortest, buffer->cur().codepoint))
+    buffer->skip_glyph ();
+  else if (!shortest && font->get_glyph (buffer->cur().codepoint, 0, &glyph))
+    buffer->next_glyph ();
+  else if (decompose_compatibility (font, buffer, buffer->cur().codepoint))
     buffer->skip_glyph ();
   else
     buffer->next_glyph ();
 }
 
 static void
-decompose_single_char_cluster (hb_font_t *font, hb_buffer_t *buffer,
-			       bool will_recompose)
-{
-  hb_codepoint_t glyph;
-
-  /* If recomposing and font supports this, we're good to go */
-  if (will_recompose && hb_font_get_glyph (font, buffer->cur().codepoint, 0, &glyph)) {
-    buffer->next_glyph ();
-    return;
-  }
-
-  decompose_current_glyph (font, buffer, will_recompose);
-}
-
-static void
 decompose_multi_char_cluster (hb_font_t *font, hb_buffer_t *buffer,
 			      unsigned int end)
 {
   /* TODO Currently if there's a variation-selector we give-up, it's just too hard. */
   for (unsigned int i = buffer->idx; i < end; i++)
-    if (unlikely (_hb_unicode_is_variation_selector (buffer->info[i].codepoint))) {
+    if (unlikely (buffer->unicode->is_variation_selector (buffer->info[i].codepoint))) {
       while (buffer->idx < end)
 	buffer->next_glyph ();
       return;
     }
 
   while (buffer->idx < end)
-    decompose_current_glyph (font, buffer, FALSE);
+    decompose_current_character (font, buffer, false);
 }
 
 static int
 compare_combining_class (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)
 {
   unsigned int a = _hb_glyph_info_get_modified_combining_class (pa);
   unsigned int b = _hb_glyph_info_get_modified_combining_class (pb);
 
   return a < b ? -1 : a == b ? 0 : +1;
 }
 
 void
 _hb_ot_shape_normalize (hb_font_t *font, hb_buffer_t *buffer,
 			hb_ot_shape_normalization_mode_t mode)
 {
   bool recompose = mode != HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED;
-  bool has_multichar_clusters = FALSE;
+  bool has_multichar_clusters = false;
   unsigned int count;
 
   /* We do a fairly straightforward yet custom normalization process in three
    * separate rounds: decompose, reorder, recompose (if desired).  Currently
    * this makes two buffer swaps.  We can make it faster by moving the last
    * two rounds into the inner loop for the first round, but it's more readable
    * this way. */
 
@@ -183,20 +212,20 @@ void
   for (buffer->idx = 0; buffer->idx < count;)
   {
     unsigned int end;
     for (end = buffer->idx + 1; end < count; end++)
       if (buffer->cur().cluster != buffer->info[end].cluster)
         break;
 
     if (buffer->idx + 1 == end)
-      decompose_single_char_cluster (font, buffer, recompose);
+      decompose_current_character (font, buffer, recompose);
     else {
       decompose_multi_char_cluster (font, buffer, end);
-      has_multichar_clusters = TRUE;
+      has_multichar_clusters = true;
     }
   }
   buffer->swap_buffers ();
 
 
   if (mode != HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_FULL && !has_multichar_clusters)
     return; /* Done! */
 
@@ -247,29 +276,31 @@ void
 	 * compose a CCC=0 character with it's preceding starter. */
 	(mode == HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_FULL ||
 	 _hb_glyph_info_get_modified_combining_class (&buffer->cur()) != 0) &&
 	/* If there's anything between the starter and this char, they should have CCC
 	 * smaller than this character's. */
 	(starter == buffer->out_len - 1 ||
 	 _hb_glyph_info_get_modified_combining_class (&buffer->prev()) < _hb_glyph_info_get_modified_combining_class (&buffer->cur())) &&
 	/* And compose. */
-	hb_unicode_compose (buffer->unicode,
-			    buffer->out_info[starter].codepoint,
-			    buffer->cur().codepoint,
-			    &composed) &&
+	buffer->unicode->compose (buffer->out_info[starter].codepoint,
+				  buffer->cur().codepoint,
+				  &composed) &&
 	/* And the font has glyph for the composite. */
-	hb_font_get_glyph (font, composed, 0, &glyph))
+	font->get_glyph (composed, 0, &glyph))
     {
-      /* Composes. Modify starter and carry on. */
-      buffer->out_info[starter].codepoint = composed;
-      /* XXX update cluster */
+      /* Composes. */
+      buffer->next_glyph (); /* Copy to out-buffer. */
+      if (unlikely (buffer->in_error))
+        return;
+      buffer->merge_out_clusters (starter, buffer->out_len);
+      buffer->out_len--; /* Remove the second composble. */
+      buffer->out_info[starter].codepoint = composed; /* Modify starter and carry on. */
       _hb_glyph_info_set_unicode_props (&buffer->out_info[starter], buffer->unicode);
 
-      buffer->skip_glyph ();
       continue;
     }
 
     /* Blocked, or doesn't compose. */
     buffer->next_glyph ();
 
     if (_hb_glyph_info_get_modified_combining_class (&buffer->prev()) == 0)
       starter = buffer->out_len - 1;
diff --git a/gfx/harfbuzz/src/hb-ot-shape-private.hh b/gfx/harfbuzz/src/hb-ot-shape-private.hh
--- a/gfx/harfbuzz/src/hb-ot-shape-private.hh
+++ b/gfx/harfbuzz/src/hb-ot-shape-private.hh
@@ -25,46 +25,73 @@
  */
 
 #ifndef HB_OT_SHAPE_PRIVATE_HH
 #define HB_OT_SHAPE_PRIVATE_HH
 
 #include "hb-private.hh"
 
 #include "hb-ot-map-private.hh"
-#include "hb-ot-shape-complex-private.hh"
+
+
+
+/* buffer var allocations, used during the entire shaping process */
+#define unicode_props0()	var1.u8[0]
+#define unicode_props1()	var1.u8[1]
+
 
 
 struct hb_ot_shape_plan_t
 {
+  hb_segment_properties_t props;
+  const struct hb_ot_complex_shaper_t *shaper;
   hb_ot_map_t map;
-  hb_ot_complex_shaper_t shaper;
+  const void *data;
 
-  hb_ot_shape_plan_t (void) : map () {}
-  ~hb_ot_shape_plan_t (void) { map.finish (); }
+  inline void substitute_closure (hb_face_t *face, hb_set_t *glyphs) const { map.substitute_closure (this, face, glyphs); }
+  inline void substitute (hb_font_t *font, hb_buffer_t *buffer) const { map.substitute (this, font, buffer); }
+  inline void position (hb_font_t *font, hb_buffer_t *buffer) const { map.position (this, font, buffer); }
+
+  void finish (void) { map.finish (); }
+};
+
+struct hb_ot_shape_planner_t
+{
+  /* In the order that they are filled in. */
+  hb_face_t *face;
+  hb_segment_properties_t props;
+  const struct hb_ot_complex_shaper_t *shaper;
+  hb_ot_map_builder_t map;
+
+  hb_ot_shape_planner_t (const hb_shape_plan_t *master_plan) :
+			 face (master_plan->face),
+			 props (master_plan->props),
+			 shaper (NULL),
+			 map () {}
+  ~hb_ot_shape_planner_t (void) { map.finish (); }
+
+  inline void compile (hb_ot_shape_plan_t &plan)
+  {
+    plan.props = props;
+    plan.shaper = shaper;
+    map.compile (face, &props, plan.map);
+  }
 
   private:
-  NO_COPY (hb_ot_shape_plan_t);
+  NO_COPY (hb_ot_shape_planner_t);
 };
 
 
 
-HB_INTERNAL hb_bool_t
-_hb_ot_shape (hb_font_t          *font,
-	      hb_buffer_t        *buffer,
-	      const hb_feature_t *features,
-	      unsigned int        num_features);
-
-
 inline void
 _hb_glyph_info_set_unicode_props (hb_glyph_info_t *info, hb_unicode_funcs_t *unicode)
 {
-  info->unicode_props0() = ((unsigned int) hb_unicode_general_category (unicode, info->codepoint)) |
-			   (_hb_unicode_is_zero_width (info->codepoint) ? 0x80 : 0);
-  info->unicode_props1() = _hb_unicode_modified_combining_class (unicode, info->codepoint);
+  info->unicode_props0() = ((unsigned int) unicode->general_category (info->codepoint)) |
+			   (unicode->is_zero_width (info->codepoint) ? 0x80 : 0);
+  info->unicode_props1() = unicode->modified_combining_class (info->codepoint);
 }
 
 inline hb_unicode_general_category_t
 _hb_glyph_info_get_general_category (const hb_glyph_info_t *info)
 {
   return (hb_unicode_general_category_t) (info->unicode_props0() & 0x7F);
 }
 
diff --git a/gfx/harfbuzz/src/hb-ot-shape.cc b/gfx/harfbuzz/src/hb-ot-shape.cc
--- a/gfx/harfbuzz/src/hb-ot-shape.cc
+++ b/gfx/harfbuzz/src/hb-ot-shape.cc
@@ -21,24 +21,29 @@
  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  *
  * Red Hat Author(s): Behdad Esfahbod
  * Google Author(s): Behdad Esfahbod
  */
 
+#define HB_SHAPER ot
+#define hb_ot_shaper_face_data_t hb_ot_layout_t
+#define hb_ot_shaper_shape_plan_data_t hb_ot_shape_plan_t
+#include "hb-shaper-impl-private.hh"
+
 #include "hb-ot-shape-private.hh"
 #include "hb-ot-shape-normalize-private.hh"
+#include "hb-ot-shape-complex-private.hh"
 
-#include "hb-font-private.hh"
+#include "hb-ot-layout-private.hh"
 #include "hb-set-private.hh"
 
 
-
 hb_tag_t common_features[] = {
   HB_TAG('c','c','m','p'),
   HB_TAG('l','i','g','a'),
   HB_TAG('l','o','c','l'),
   HB_TAG('m','a','r','k'),
   HB_TAG('m','k','m','k'),
   HB_TAG('r','l','i','g'),
 };
@@ -61,111 +66,181 @@ hb_tag_t vertical_features[] = {
   HB_TAG('v','e','r','t'),
   HB_TAG('v','k','r','n'),
   HB_TAG('v','p','a','l'),
   HB_TAG('v','r','t','2'),
 };
 
 
 
-struct hb_ot_shape_planner_t
-{
-  hb_ot_map_builder_t map;
-  hb_ot_complex_shaper_t shaper;
-
-  hb_ot_shape_planner_t (void) : map () {}
-  ~hb_ot_shape_planner_t (void) { map.finish (); }
-
-  inline void compile (hb_face_t *face,
-		       const hb_segment_properties_t *props,
-		       struct hb_ot_shape_plan_t &plan)
-  {
-    plan.shaper = shaper;
-    map.compile (face, props, plan.map);
-  }
-
-  private:
-  NO_COPY (hb_ot_shape_planner_t);
-};
-
 static void
 hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,
 			      const hb_segment_properties_t  *props,
 			      const hb_feature_t             *user_features,
 			      unsigned int                    num_user_features)
 {
+  hb_ot_map_builder_t *map = &planner->map;
+
   switch (props->direction) {
     case HB_DIRECTION_LTR:
-      planner->map.add_bool_feature (HB_TAG ('l','t','r','a'));
-      planner->map.add_bool_feature (HB_TAG ('l','t','r','m'));
+      map->add_bool_feature (HB_TAG ('l','t','r','a'));
+      map->add_bool_feature (HB_TAG ('l','t','r','m'));
       break;
     case HB_DIRECTION_RTL:
-      planner->map.add_bool_feature (HB_TAG ('r','t','l','a'));
-      planner->map.add_bool_feature (HB_TAG ('r','t','l','m'), false);
+      map->add_bool_feature (HB_TAG ('r','t','l','a'));
+      map->add_bool_feature (HB_TAG ('r','t','l','m'), false);
       break;
     case HB_DIRECTION_TTB:
     case HB_DIRECTION_BTT:
     case HB_DIRECTION_INVALID:
     default:
       break;
   }
 
 #define ADD_FEATURES(array) \
   HB_STMT_START { \
     for (unsigned int i = 0; i < ARRAY_LENGTH (array); i++) \
-      planner->map.add_bool_feature (array[i]); \
+      map->add_bool_feature (array[i]); \
   } HB_STMT_END
 
-  hb_ot_shape_complex_collect_features (planner->shaper, &planner->map, props);
+  if (planner->shaper->collect_features)
+    planner->shaper->collect_features (planner);
 
   ADD_FEATURES (common_features);
 
   if (HB_DIRECTION_IS_HORIZONTAL (props->direction))
     ADD_FEATURES (horizontal_features);
   else
     ADD_FEATURES (vertical_features);
 
+  if (planner->shaper->override_features)
+    planner->shaper->override_features (planner);
+
 #undef ADD_FEATURES
 
   for (unsigned int i = 0; i < num_user_features; i++) {
     const hb_feature_t *feature = &user_features[i];
-    planner->map.add_feature (feature->tag, feature->value, (feature->start == 0 && feature->end == (unsigned int) -1));
+    map->add_feature (feature->tag, feature->value, (feature->start == 0 && feature->end == (unsigned int) -1));
   }
 }
 
 
+/*
+ * shaper face data
+ */
+
+hb_ot_shaper_face_data_t *
+_hb_ot_shaper_face_data_create (hb_face_t *face)
+{
+  return _hb_ot_layout_create (face);
+}
+
+void
+_hb_ot_shaper_face_data_destroy (hb_ot_shaper_face_data_t *data)
+{
+  _hb_ot_layout_destroy (data);
+}
+
+
+/*
+ * shaper font data
+ */
+
+struct hb_ot_shaper_font_data_t {};
+
+hb_ot_shaper_font_data_t *
+_hb_ot_shaper_font_data_create (hb_font_t *font)
+{
+  return (hb_ot_shaper_font_data_t *) HB_SHAPER_DATA_SUCCEEDED;
+}
+
+void
+_hb_ot_shaper_font_data_destroy (hb_ot_shaper_font_data_t *data)
+{
+}
+
+
+/*
+ * shaper shape_plan data
+ */
+
+hb_ot_shaper_shape_plan_data_t *
+_hb_ot_shaper_shape_plan_data_create (hb_shape_plan_t    *shape_plan,
+				      const hb_feature_t *user_features,
+				      unsigned int        num_user_features)
+{
+  hb_ot_shape_plan_t *plan = (hb_ot_shape_plan_t *) calloc (1, sizeof (hb_ot_shape_plan_t));
+  if (unlikely (!plan))
+    return NULL;
+
+  hb_ot_shape_planner_t planner (shape_plan);
+
+  planner.shaper = hb_ot_shape_complex_categorize (&shape_plan->props);
+
+  hb_ot_shape_collect_features (&planner, &shape_plan->props, user_features, num_user_features);
+
+  planner.compile (*plan);
+
+  if (plan->shaper->data_create) {
+    plan->data = plan->shaper->data_create (plan);
+    if (unlikely (!plan->data))
+      return NULL;
+  }
+
+  return plan;
+}
+
+void
+_hb_ot_shaper_shape_plan_data_destroy (hb_ot_shaper_shape_plan_data_t *plan)
+{
+  if (plan->shaper->data_destroy)
+    plan->shaper->data_destroy (const_cast<void *> (plan->data));
+
+  plan->finish ();
+
+  free (plan);
+}
+
+
+/*
+ * shaper
+ */
+
 struct hb_ot_shape_context_t
 {
-  /* Input to hb_ot_shape_execute() */
+  /* Input to hb_ot_shape_internal() */
   hb_ot_shape_plan_t *plan;
   hb_font_t *font;
   hb_face_t *face;
   hb_buffer_t  *buffer;
   const hb_feature_t *user_features;
   unsigned int        num_user_features;
 
   /* Transient stuff */
   hb_direction_t target_direction;
   hb_bool_t applied_position_complex;
 };
 
 static void
 hb_ot_shape_setup_masks (hb_ot_shape_context_t *c)
 {
-  hb_mask_t global_mask = c->plan->map.get_global_mask ();
+  hb_ot_map_t *map = &c->plan->map;
+
+  hb_mask_t global_mask = map->get_global_mask ();
   c->buffer->reset_masks (global_mask);
 
-  hb_ot_shape_complex_setup_masks (c->plan->shaper, &c->plan->map, c->buffer, c->font);
+  if (c->plan->shaper->setup_masks)
+    c->plan->shaper->setup_masks (c->plan, c->buffer, c->font);
 
   for (unsigned int i = 0; i < c->num_user_features; i++)
   {
     const hb_feature_t *feature = &c->user_features[i];
     if (!(feature->start == 0 && feature->end == (unsigned int)-1)) {
       unsigned int shift;
-      hb_mask_t mask = c->plan->map.get_mask (feature->tag, &shift);
+      hb_mask_t mask = map->get_mask (feature->tag, &shift);
       c->buffer->set_masks (feature->value << shift, mask, feature->start, feature->end);
     }
   }
 }
 
 
 /* Main shaper */
 
@@ -183,17 +258,17 @@ static void
 hb_form_clusters (hb_buffer_t *buffer)
 {
   unsigned int count = buffer->len;
   for (unsigned int i = 1; i < count; i++)
     if (FLAG (_hb_glyph_info_get_general_category (&buffer->info[i])) &
 	(FLAG (HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK) |
 	 FLAG (HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK) |
 	 FLAG (HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)))
-      buffer->info[i].cluster = buffer->info[i - 1].cluster; /* XXX do the min() here */
+      buffer->merge_clusters (i - 1, i + 1);
 }
 
 static void
 hb_ensure_native_direction (hb_buffer_t *buffer)
 {
   hb_direction_t direction = buffer->props.direction;
 
   /* TODO vertical:
@@ -218,17 +293,17 @@ hb_mirror_chars (hb_ot_shape_context_t *
 
   if (HB_DIRECTION_IS_FORWARD (c->target_direction))
     return;
 
   hb_mask_t rtlm_mask = c->plan->map.get_1_mask (HB_TAG ('r','t','l','m'));
 
   unsigned int count = c->buffer->len;
   for (unsigned int i = 0; i < count; i++) {
-    hb_codepoint_t codepoint = hb_unicode_mirroring (unicode, c->buffer->info[i].codepoint);
+    hb_codepoint_t codepoint = unicode->mirroring (c->buffer->info[i].codepoint);
     if (likely (codepoint == c->buffer->info[i].codepoint))
       c->buffer->info[i].mask |= rtlm_mask; /* XXX this should be moved to before setting user-feature masks */
     else
       c->buffer->info[i].codepoint = codepoint;
   }
 }
 
 static void
@@ -239,147 +314,149 @@ hb_map_glyphs (hb_font_t    *font,
 
   if (unlikely (!buffer->len))
     return;
 
   buffer->clear_output ();
 
   unsigned int count = buffer->len - 1;
   for (buffer->idx = 0; buffer->idx < count;) {
-    if (unlikely (_hb_unicode_is_variation_selector (buffer->cur(+1).codepoint))) {
-      hb_font_get_glyph (font, buffer->cur().codepoint, buffer->cur(+1).codepoint, &glyph);
+    if (unlikely (buffer->unicode->is_variation_selector (buffer->cur(+1).codepoint))) {
+      font->get_glyph (buffer->cur().codepoint, buffer->cur(+1).codepoint, &glyph);
       buffer->replace_glyphs (2, 1, &glyph);
     } else {
-      hb_font_get_glyph (font, buffer->cur().codepoint, 0, &glyph);
+      font->get_glyph (buffer->cur().codepoint, 0, &glyph);
       buffer->replace_glyph (glyph);
     }
   }
   if (likely (buffer->idx < buffer->len)) {
-    hb_font_get_glyph (font, buffer->cur().codepoint, 0, &glyph);
+    font->get_glyph (buffer->cur().codepoint, 0, &glyph);
     buffer->replace_glyph (glyph);
   }
   buffer->swap_buffers ();
 }
 
 static void
 hb_substitute_default (hb_ot_shape_context_t *c)
 {
-  hb_ot_layout_substitute_start (c->buffer);
-
   hb_mirror_chars (c);
 
   hb_map_glyphs (c->font, c->buffer);
 }
 
 static void
+hb_synthesize_glyph_classes (hb_ot_shape_context_t *c)
+{
+  unsigned int count = c->buffer->len;
+  for (unsigned int i = 0; i < count; i++)
+    c->buffer->info[i].glyph_props() = _hb_glyph_info_get_general_category (&c->buffer->info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ?
+				       HB_OT_LAYOUT_GLYPH_CLASS_MARK :
+				       HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH;
+}
+
+
+static void
 hb_ot_substitute_complex (hb_ot_shape_context_t *c)
 {
-  if (hb_ot_layout_has_substitution (c->face)) {
-    c->plan->map.substitute (c->face, c->buffer);
-  }
+  hb_ot_layout_substitute_start (c->font, c->buffer);
 
-  hb_ot_layout_substitute_finish (c->buffer);
+  if (!hb_ot_layout_has_glyph_classes (c->face))
+    hb_synthesize_glyph_classes (c);
+
+  if (hb_ot_layout_has_substitution (c->face))
+    c->plan->substitute (c->font, c->buffer);
+
+  hb_ot_layout_substitute_finish (c->font, c->buffer);
 
   return;
 }
 
 
 /* Position */
 
 static void
 hb_position_default (hb_ot_shape_context_t *c)
 {
-  hb_ot_layout_position_start (c->buffer);
+  hb_ot_layout_position_start (c->font, c->buffer);
 
   unsigned int count = c->buffer->len;
   for (unsigned int i = 0; i < count; i++) {
-    hb_font_get_glyph_advance_for_direction (c->font, c->buffer->info[i].codepoint,
-					     c->buffer->props.direction,
-					     &c->buffer->pos[i].x_advance,
-					     &c->buffer->pos[i].y_advance);
-    hb_font_subtract_glyph_origin_for_direction (c->font, c->buffer->info[i].codepoint,
-						 c->buffer->props.direction,
-						 &c->buffer->pos[i].x_offset,
-						 &c->buffer->pos[i].y_offset);
+    c->font->get_glyph_advance_for_direction (c->buffer->info[i].codepoint,
+					      c->buffer->props.direction,
+					      &c->buffer->pos[i].x_advance,
+					      &c->buffer->pos[i].y_advance);
+    c->font->subtract_glyph_origin_for_direction (c->buffer->info[i].codepoint,
+						  c->buffer->props.direction,
+						  &c->buffer->pos[i].x_offset,
+						  &c->buffer->pos[i].y_offset);
   }
 }
 
 static void
+hb_zero_mark_advances (hb_ot_shape_context_t *c)
+{
+  unsigned int count = c->buffer->len;
+  for (unsigned int i = 0; i < count; i++)
+    if (_hb_glyph_info_get_general_category (&c->buffer->info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)
+    {
+      c->buffer->pos[i].x_advance = 0;
+      c->buffer->pos[i].y_advance = 0;
+    }
+}
+
+static void
 hb_ot_position_complex (hb_ot_shape_context_t *c)
 {
 
   if (hb_ot_layout_has_positioning (c->face))
   {
     /* Change glyph origin to what GPOS expects, apply GPOS, change it back. */
 
     unsigned int count = c->buffer->len;
     for (unsigned int i = 0; i < count; i++) {
-      hb_font_add_glyph_origin_for_direction (c->font, c->buffer->info[i].codepoint,
-					      HB_DIRECTION_LTR,
-					      &c->buffer->pos[i].x_offset,
-					      &c->buffer->pos[i].y_offset);
+      c->font->add_glyph_origin_for_direction (c->buffer->info[i].codepoint,
+					       HB_DIRECTION_LTR,
+					       &c->buffer->pos[i].x_offset,
+					       &c->buffer->pos[i].y_offset);
     }
 
-    c->plan->map.position (c->font, c->buffer);
+    c->plan->position (c->font, c->buffer);
 
     for (unsigned int i = 0; i < count; i++) {
-      hb_font_subtract_glyph_origin_for_direction (c->font, c->buffer->info[i].codepoint,
-						   HB_DIRECTION_LTR,
-						   &c->buffer->pos[i].x_offset,
-						   &c->buffer->pos[i].y_offset);
+      c->font->subtract_glyph_origin_for_direction (c->buffer->info[i].codepoint,
+						    HB_DIRECTION_LTR,
+						    &c->buffer->pos[i].x_offset,
+						    &c->buffer->pos[i].y_offset);
     }
 
-    c->applied_position_complex = TRUE;
-  }
+    c->applied_position_complex = true;
+  } else
+    hb_zero_mark_advances (c);
 
-  hb_ot_layout_position_finish (c->face, c->buffer);
+  hb_ot_layout_position_finish (c->font, c->buffer, c->plan->shaper->zero_width_attached_marks);
 
   return;
 }
 
 static void
-hb_position_complex_fallback (hb_ot_shape_context_t *c)
+hb_position_complex_fallback (hb_ot_shape_context_t *c HB_UNUSED)
 {
   /* TODO Mark pos */
-  unsigned int count = c->buffer->len;
-  const hb_glyph_info_t *info = c->buffer->info;
-  hb_glyph_position_t *positions = c->buffer->pos;
-  if (c->buffer->props.direction == HB_DIRECTION_RTL) {
-    for (unsigned int i = 1; i < count; i++) {
-      if (FLAG (_hb_glyph_info_get_general_category (&info[i])) &
-	  (FLAG (HB_UNICODE_GENERAL_CATEGORY_FORMAT) |
-	   FLAG (HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK) |
-	   FLAG (HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)))
-        positions[i].x_advance = 0;
-    }
-  } else {
-    for (unsigned int i = 1; i < count; i++) {
-      if (FLAG (_hb_glyph_info_get_general_category (&info[i])) &
-	  (FLAG (HB_UNICODE_GENERAL_CATEGORY_FORMAT) |
-	   FLAG (HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK) |
-	   FLAG (HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK))) {
-        hb_glyph_position_t& pos = positions[i];
-        pos.x_offset = -pos.x_advance;
-        pos.x_advance = 0;
-      }
-    }
-  }
 }
 
 static void
 hb_truetype_kern (hb_ot_shape_context_t *c)
 {
   /* TODO Check for kern=0 */
   unsigned int count = c->buffer->len;
   for (unsigned int i = 1; i < count; i++) {
     hb_position_t x_kern, y_kern, kern1, kern2;
-    hb_font_get_glyph_kerning_for_direction (c->font,
-					     c->buffer->info[i - 1].codepoint, c->buffer->info[i].codepoint,
-					     c->buffer->props.direction,
-					     &x_kern, &y_kern);
+    c->font->get_glyph_kerning_for_direction (c->buffer->info[i - 1].codepoint, c->buffer->info[i].codepoint,
+					      c->buffer->props.direction,
+					      &x_kern, &y_kern);
 
     kern1 = x_kern >> 1;
     kern2 = x_kern - kern1;
     c->buffer->pos[i - 1].x_advance += kern1;
     c->buffer->pos[i].x_advance += kern2;
     c->buffer->pos[i].x_offset += kern2;
 
     kern1 = y_kern >> 1;
@@ -394,51 +471,56 @@ static void
 hb_position_complex_fallback_visual (hb_ot_shape_context_t *c)
 {
   hb_truetype_kern (c);
 }
 
 static void
 hb_hide_zerowidth (hb_ot_shape_context_t *c)
 {
-  /* TODO Save the space character in the font? */
   hb_codepoint_t space;
-  if (!hb_font_get_glyph (c->font, ' ', 0, &space))
+  if (!c->font->get_glyph (' ', 0, &space))
     return; /* No point! */
 
   unsigned int count = c->buffer->len;
   for (unsigned int i = 0; i < count; i++)
-    if (unlikely (_hb_glyph_info_is_zero_width (&c->buffer->info[i]))) {
+    if (unlikely (!is_a_ligature (c->buffer->info[i]) &&
+		  _hb_glyph_info_is_zero_width (&c->buffer->info[i]))) {
       c->buffer->info[i].codepoint = space;
       c->buffer->pos[i].x_advance = 0;
       c->buffer->pos[i].y_advance = 0;
     }
 }
 
 
 /* Do it! */
 
 static void
-hb_ot_shape_execute_internal (hb_ot_shape_context_t *c)
+hb_ot_shape_internal (hb_ot_shape_context_t *c)
 {
   c->buffer->deallocate_var_all ();
 
   /* Save the original direction, we use it later. */
   c->target_direction = c->buffer->props.direction;
 
   HB_BUFFER_ALLOCATE_VAR (c->buffer, unicode_props0);
   HB_BUFFER_ALLOCATE_VAR (c->buffer, unicode_props1);
 
+  c->buffer->clear_output ();
+
   hb_set_unicode_props (c->buffer);
 
   hb_form_clusters (c->buffer);
 
   hb_ensure_native_direction (c->buffer);
 
-  _hb_ot_shape_normalize (c->font, c->buffer, hb_ot_shape_complex_normalization_preference (c->plan->shaper));
+  _hb_ot_shape_normalize (c->font, c->buffer,
+			  c->plan->shaper->normalization_preference ?
+			  c->plan->shaper->normalization_preference (c->plan) :
+			  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT);
 
   hb_ot_shape_setup_masks (c);
 
   /* SUBSTITUTE */
   {
     hb_substitute_default (c);
 
     hb_ot_substitute_complex (c);
@@ -466,74 +548,44 @@ hb_ot_shape_execute_internal (hb_ot_shap
   HB_BUFFER_DEALLOCATE_VAR (c->buffer, unicode_props1);
   HB_BUFFER_DEALLOCATE_VAR (c->buffer, unicode_props0);
 
   c->buffer->props.direction = c->target_direction;
 
   c->buffer->deallocate_var_all ();
 }
 
-static void
-hb_ot_shape_plan_internal (hb_ot_shape_plan_t       *plan,
-			   hb_face_t                *face,
-			   const hb_segment_properties_t  *props,
-			   const hb_feature_t       *user_features,
-			   unsigned int              num_user_features)
-{
-  hb_ot_shape_planner_t planner;
-
-  assert (HB_DIRECTION_IS_VALID (props->direction));
-
-  planner.shaper = hb_ot_shape_complex_categorize (props);
-
-  hb_ot_shape_collect_features (&planner, props, user_features, num_user_features);
-
-  planner.compile (face, props, *plan);
-}
-
-static void
-hb_ot_shape_execute (hb_ot_shape_plan_t *plan,
-		     hb_font_t          *font,
-		     hb_buffer_t        *buffer,
-		     const hb_feature_t *user_features,
-		     unsigned int        num_user_features)
-{
-  hb_ot_shape_context_t c = {plan, font, font->face, buffer, user_features, num_user_features};
-  hb_ot_shape_execute_internal (&c);
-}
 
 hb_bool_t
-_hb_ot_shape (hb_font_t          *font,
+_hb_ot_shape (hb_shape_plan_t    *shape_plan,
+	      hb_font_t          *font,
 	      hb_buffer_t        *buffer,
 	      const hb_feature_t *features,
 	      unsigned int        num_features)
 {
-  hb_ot_shape_plan_t plan;
+  hb_ot_shape_context_t c = {HB_SHAPER_DATA_GET (shape_plan), font, font->face, buffer, features, num_features};
+  hb_ot_shape_internal (&c);
 
-  buffer->guess_properties ();
-
-  hb_ot_shape_plan_internal (&plan, font->face, &buffer->props, features, num_features);
-  hb_ot_shape_execute (&plan, font, buffer, features, num_features);
-
-  return TRUE;
+  return true;
 }
 
 
 void
 hb_ot_shape_glyphs_closure (hb_font_t          *font,
 			    hb_buffer_t        *buffer,
 			    const hb_feature_t *features,
 			    unsigned int        num_features,
 			    hb_set_t           *glyphs)
 {
   hb_ot_shape_plan_t plan;
 
   buffer->guess_properties ();
 
-  hb_ot_shape_plan_internal (&plan, font->face, &buffer->props, features, num_features);
+  /* TODO cache / ensure correct backend, etc. */
+  hb_shape_plan_t *shape_plan = hb_shape_plan_create (font->face, &buffer->props, features, num_features, NULL);
 
   /* TODO: normalization? have shapers do closure()? */
   /* TODO: Deal with mirrored chars? */
   hb_map_glyphs (font, buffer);
 
   /* Seed it.  It's user's responsibility to have cleard glyphs
    * if that's what they desire. */
   unsigned int count = buffer->len;
@@ -541,11 +593,13 @@ hb_ot_shape_glyphs_closure (hb_font_t   
     hb_set_add (glyphs, buffer->info[i].codepoint);
 
   /* And find transitive closure. */
   hb_set_t copy;
   copy.init ();
 
   do {
     copy.set (glyphs);
-    plan.map.substitute_closure (font->face, glyphs);
+    HB_SHAPER_DATA_GET (shape_plan)->substitute_closure (font->face, glyphs);
   } while (!copy.equal (glyphs));
+
+  hb_shape_plan_destroy (shape_plan);
 }
diff --git a/gfx/harfbuzz/src/hb-private.hh b/gfx/harfbuzz/src/hb-private.hh
--- a/gfx/harfbuzz/src/hb-private.hh
+++ b/gfx/harfbuzz/src/hb-private.hh
@@ -56,22 +56,16 @@
 
 
 /* Essentials */
 
 #ifndef NULL
 # define NULL ((void *) 0)
 #endif
 
-#undef FALSE
-#define FALSE 0
-
-#undef TRUE
-#define TRUE 1
-
 
 /* Basics */
 
 
 #undef MIN
 template <typename Type> static inline Type MIN (const Type &a, const Type &b) { return a < b ? a : b; }
 
 #undef MAX
@@ -79,21 +73,21 @@ template <typename Type> static inline T
 
 
 #undef  ARRAY_LENGTH
 #define ARRAY_LENGTH(__array) ((signed int) (sizeof (__array) / sizeof (__array[0])))
 
 #define HB_STMT_START do
 #define HB_STMT_END   while (0)
 
-#define _ASSERT_STATIC1(_line, _cond) typedef int _static_assert_on_line_##_line##_failed[(_cond)?1:-1]
-#define _ASSERT_STATIC0(_line, _cond) _ASSERT_STATIC1 (_line, (_cond))
-#define ASSERT_STATIC(_cond) _ASSERT_STATIC0 (__LINE__, (_cond))
+#define _ASSERT_STATIC1(_line, _cond)	typedef int _static_assert_on_line_##_line##_failed[(_cond)?1:-1]
+#define _ASSERT_STATIC0(_line, _cond)	_ASSERT_STATIC1 (_line, (_cond))
+#define ASSERT_STATIC(_cond)		_ASSERT_STATIC0 (__LINE__, (_cond))
 
-#define ASSERT_STATIC_EXPR(_cond) ((void) sizeof (char[(_cond) ? 1 : -1]))
+#define ASSERT_STATIC_EXPR(_cond)((void) sizeof (char[(_cond) ? 1 : -1]))
 #define ASSERT_STATIC_EXPR_ZERO(_cond) (0 * sizeof (char[(_cond) ? 1 : -1]))
 
 #define _PASTE1(a,b) a##b
 #define PASTE(a,b) _PASTE1(a,b)
 
 /* Lets assert int types.  Saves trouble down the road. */
 
 ASSERT_STATIC (sizeof (int8_t) == 1);
@@ -105,16 +99,44 @@ ASSERT_STATIC (sizeof (uint32_t) == 4);
 ASSERT_STATIC (sizeof (int64_t) == 8);
 ASSERT_STATIC (sizeof (uint64_t) == 8);
 
 ASSERT_STATIC (sizeof (hb_codepoint_t) == 4);
 ASSERT_STATIC (sizeof (hb_position_t) == 4);
 ASSERT_STATIC (sizeof (hb_mask_t) == 4);
 ASSERT_STATIC (sizeof (hb_var_int_t) == 4);
 
+
+/* We like our types POD */
+
+#define _ASSERT_TYPE_POD1(_line, _type)	union _type_##_type##_on_line_##_line##_is_not_POD { _type instance; }
+#define _ASSERT_TYPE_POD0(_line, _type)	_ASSERT_TYPE_POD1 (_line, _type)
+#define ASSERT_TYPE_POD(_type)		_ASSERT_TYPE_POD0 (__LINE__, _type)
+
+#ifdef __GNUC__
+# define _ASSERT_INSTANCE_POD1(_line, _instance) \
+	HB_STMT_START { \
+		typedef __typeof__(_instance) _type_##_line; \
+		_ASSERT_TYPE_POD1 (_line, _type_##_line); \
+	} HB_STMT_END
+#else
+# define _ASSERT_INSTANCE_POD1(_line, _instance)	typedef int _assertion_on_line_##_line##_not_tested
+#endif
+# define _ASSERT_INSTANCE_POD0(_line, _instance)	_ASSERT_INSTANCE_POD1 (_line, _instance)
+# define ASSERT_INSTANCE_POD(_instance)			_ASSERT_INSTANCE_POD0 (__LINE__, _instance)
+
+/* Check _assertion in a method environment */
+#define _ASSERT_POD1(_line) \
+	inline void _static_assertion_on_line_##_line (void) const \
+	{ _ASSERT_INSTANCE_POD1 (_line, *this); /* Make sure it's POD. */ }
+# define _ASSERT_POD0(_line)	_ASSERT_POD1 (_line)
+# define ASSERT_POD()		_ASSERT_POD0 (__LINE__)
+
+
+
 /* Misc */
 
 
 #if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
 #define _HB_BOOLEAN_EXPR(expr) ((expr) ? 1 : 0)
 #define likely(expr) (__builtin_expect (_HB_BOOLEAN_EXPR(expr), 1))
 #define unlikely(expr) (__builtin_expect (_HB_BOOLEAN_EXPR(expr), 0))
 #else
@@ -234,25 +256,26 @@ static inline bool
 typedef int (*hb_compare_func_t) (const void *, const void *);
 
 
 
 
 /* arrays and maps */
 
 
+#define HB_PREALLOCED_ARRAY_INIT {0}
 template <typename Type, unsigned int StaticSize>
-struct hb_prealloced_array_t {
-
+struct hb_prealloced_array_t
+{
   unsigned int len;
   unsigned int allocated;
   Type *array;
   Type static_array[StaticSize];
 
-  hb_prealloced_array_t (void) { memset (this, 0, sizeof (*this)); }
+  void init (void) { memset (this, 0, sizeof (*this)); }
 
   inline Type& operator [] (unsigned int i) { return array[i]; }
   inline const Type& operator [] (unsigned int i) const { return array[i]; }
 
   inline Type *push (void)
   {
     if (!array) {
       array = static_array;
@@ -337,24 +360,24 @@ struct hb_prealloced_array_t {
   {
     if (array != static_array)
       free (array);
     array = NULL;
     allocated = len = 0;
   }
 };
 
-template <typename Type>
-struct hb_array_t : hb_prealloced_array_t<Type, 2> {};
 
-
+#define HB_LOCKABLE_SET_INIT {HB_PREALLOCED_ARRAY_INIT}
 template <typename item_t, typename lock_t>
 struct hb_lockable_set_t
 {
-  hb_array_t <item_t> items;
+  hb_prealloced_array_t <item_t, 2> items;
+
+  inline void init (void) { items.init (); }
 
   template <typename T>
   inline item_t *replace_or_insert (T v, lock_t &l, bool replace)
   {
     l.lock ();
     item_t *item = items.find (v);
     if (item) {
       if (replace) {
@@ -414,16 +437,21 @@ struct hb_lockable_set_t
         *item = v;
     }
     l.unlock ();
     return item;
   }
 
   inline void finish (lock_t &l)
   {
+    if (!items.len) {
+      /* No need for locking. */
+      items.finish ();
+      return;
+    }
     l.lock ();
     while (items.len) {
       item_t old = items[items.len - 1];
 	items.pop ();
 	l.unlock ();
 	old.finish ();
 	l.lock ();
     }
@@ -436,17 +464,27 @@ struct hb_lockable_set_t
 
 
 
 /* Big-endian handling */
 
 static inline uint16_t hb_be_uint16 (const uint16_t v)
 {
   const uint8_t *V = (const uint8_t *) &v;
-  return (uint16_t) (V[0] << 8) + V[1];
+  return (V[0] << 8) | V[1];
+}
+
+static inline uint16_t hb_uint16_swap (const uint16_t v)
+{
+  return (v >> 8) | (v << 8);
+}
+
+static inline uint32_t hb_uint32_swap (const uint32_t v)
+{
+  return (hb_uint16_swap (v) << 16) | hb_uint16_swap (v >> 16);
 }
 
 /* Note, of the following macros, uint16_get is the one called many many times.
  * If there is any optimizations to be done, it's in that macro.  However, I
  * already confirmed that on my T400 ThinkPad at least, using bswap_16(), which
  * results in a single ror instruction, does NOT speed this up.  In fact, it
  * resulted in a minor slowdown.  At any rate, note that v may not be correctly
  * aligned, so I think the current implementation is optimal.
@@ -519,23 +557,30 @@ template <int max_level> inline void
   fprintf (stderr, "%-10s", what ? what : "");
 
   if (obj)
     fprintf (stderr, "(%0*lx) ", (unsigned int) (2 * sizeof (void *)), (unsigned long) obj);
   else
     fprintf (stderr, " %*s  ", (unsigned int) (2 * sizeof (void *)), "");
 
   if (indented) {
-    static const char bars[] = "││││││││││││││││││││││││││││││││││││││││";
-    fprintf (stderr, "%2d %s├%s",
+/* One may want to add ASCII version of these.  See:
+ * https://bugs.freedesktop.org/show_bug.cgi?id=50970 */
+#define VBAR	"\342\224\202"	/* U+2502 BOX DRAWINGS LIGHT VERTICAL */
+#define VRBAR	"\342\224\234"	/* U+251C BOX DRAWINGS LIGHT VERTICAL AND RIGHT */
+#define DLBAR	"\342\225\256"	/* U+256E BOX DRAWINGS LIGHT ARC DOWN AND LEFT */
+#define ULBAR	"\342\225\257"	/* U+256F BOX DRAWINGS LIGHT ARC UP AND LEFT */
+#define LBAR	"\342\225\264"	/* U+2574 BOX DRAWINGS LIGHT LEFT */
+    static const char bars[] = VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR;
+    fprintf (stderr, "%2d %s" VRBAR "%s",
 	     level,
-	     bars + sizeof (bars) - 1 - MIN ((unsigned int) sizeof (bars), 3 * level),
-	     level_dir ? (level_dir > 0 ? "╮" : "╯") : "╴");
+	     bars + sizeof (bars) - 1 - MIN ((unsigned int) sizeof (bars), (unsigned int) (sizeof (VBAR) - 1) * level),
+	     level_dir ? (level_dir > 0 ? DLBAR : ULBAR) : LBAR);
   } else
-    fprintf (stderr, "   ├╴");
+    fprintf (stderr, "   " VRBAR LBAR);
 
   if (func) {
     /* If there's a class name, just write that. */
     const char *dotdot = strstr (func, "::");
     const char *space = strchr (func, ' ');
     if (space && dotdot && space < dotdot)
       func = space + 1;
     unsigned int func_len = dotdot ? dotdot - func : strlen (func);
@@ -595,19 +640,19 @@ template <> inline void
 		  const void *obj HB_UNUSED,
 		  const char *func HB_UNUSED,
 		  bool indented HB_UNUSED,
 		  unsigned int level HB_UNUSED,
 		  int level_dir HB_UNUSED,
 		  const char *message HB_UNUSED,
 		  ...) {}
 
-#define DEBUG_MSG_LEVEL(WHAT, OBJ, LEVEL, LEVEL_DIR, ...)	_hb_debug_msg<HB_DEBUG_##WHAT> (#WHAT, (OBJ), NULL,    TRUE, (LEVEL), (LEVEL_DIR), __VA_ARGS__)
-#define DEBUG_MSG(WHAT, OBJ, ...) 				_hb_debug_msg<HB_DEBUG_##WHAT> (#WHAT, (OBJ), NULL,    FALSE, 0, 0, __VA_ARGS__)
-#define DEBUG_MSG_FUNC(WHAT, OBJ, ...)				_hb_debug_msg<HB_DEBUG_##WHAT> (#WHAT, (OBJ), HB_FUNC, FALSE, 0, 0, __VA_ARGS__)
+#define DEBUG_MSG_LEVEL(WHAT, OBJ, LEVEL, LEVEL_DIR, ...)	_hb_debug_msg<HB_DEBUG_##WHAT> (#WHAT, (OBJ), NULL,    true, (LEVEL), (LEVEL_DIR), __VA_ARGS__)
+#define DEBUG_MSG(WHAT, OBJ, ...) 				_hb_debug_msg<HB_DEBUG_##WHAT> (#WHAT, (OBJ), NULL,    false, 0, 0, __VA_ARGS__)
+#define DEBUG_MSG_FUNC(WHAT, OBJ, ...)				_hb_debug_msg<HB_DEBUG_##WHAT> (#WHAT, (OBJ), HB_FUNC, false, 0, 0, __VA_ARGS__)
 
 
 /*
  * Trace
  */
 
 template <int max_level>
 struct hb_auto_trace_t {
@@ -617,38 +662,38 @@ struct hb_auto_trace_t {
 				   const char *func,
 				   const char *message,
 				   ...) : plevel (plevel_), what (what_), obj (obj_), returned (false)
   {
     if (plevel) ++*plevel;
 
     va_list ap;
     va_start (ap, message);
-    _hb_debug_msg_va<max_level> (what, obj, func, TRUE, plevel ? *plevel : 0, +1, message, ap);
+    _hb_debug_msg_va<max_level> (what, obj, func, true, plevel ? *plevel : 0, +1, message, ap);
     va_end (ap);
   }
   inline ~hb_auto_trace_t (void)
   {
     if (unlikely (!returned)) {
       fprintf (stderr, "OUCH, returned with no call to TRACE_RETURN.  This is a bug, please report.  Level was %d.\n", plevel ? *plevel : -1);
-      _hb_debug_msg<max_level> (what, obj, NULL, TRUE, plevel ? *plevel : 1, -1, " ");
+      _hb_debug_msg<max_level> (what, obj, NULL, true, plevel ? *plevel : 1, -1, " ");
       return;
     }
 
     if (plevel) --*plevel;
   }
 
-  inline bool ret (bool v)
+  inline bool ret (bool v, unsigned int line = 0)
   {
     if (unlikely (returned)) {
       fprintf (stderr, "OUCH, double calls to TRACE_RETURN.  This is a bug, please report.\n");
       return v;
     }
 
-    _hb_debug_msg<max_level> (what, obj, NULL, TRUE, plevel ? *plevel : 1, -1, "return %s", v ? "true" : "false");
+    _hb_debug_msg<max_level> (what, obj, NULL, true, plevel ? *plevel : 1, -1, "return %s (line %d)", v ? "true" : "false", line);
     if (plevel) --*plevel;
     plevel = NULL;
     returned = true;
     return v;
   }
 
   private:
   unsigned int *plevel;
@@ -661,66 +706,88 @@ struct hb_auto_trace_t<0> {
   explicit inline hb_auto_trace_t (unsigned int *plevel_ HB_UNUSED,
 				   const char *what HB_UNUSED,
 				   const void *obj HB_UNUSED,
 				   const char *func HB_UNUSED,
 				   const char *message HB_UNUSED,
 				   ...) {}
 
   template <typename T>
-  inline T ret (T v) { return v; }
+  inline T ret (T v, unsigned int line = 0) { return v; }
 };
 
-#define TRACE_RETURN(RET) trace.ret (RET)
+#define TRACE_RETURN(RET) trace.ret (RET, __LINE__)
 
 /* Misc */
 
 
 /* Pre-mature optimization:
  * Checks for lo <= u <= hi but with an optimization if lo and hi
  * are only different in a contiguous set of lower-most bits.
  */
-template <typename T> inline bool
+template <typename T> static inline bool
 hb_in_range (T u, T lo, T hi)
 {
   if ( ((lo^hi) & lo) == 0 &&
        ((lo^hi) & hi) == (lo^hi) &&
        ((lo^hi) & ((lo^hi) + 1)) == 0 )
     return (u & ~(lo^hi)) == lo;
   else
     return lo <= u && u <= hi;
 }
 
+template <typename T> static inline bool
+hb_in_ranges (T u, T lo1, T hi1, T lo2, T hi2, T lo3, T hi3)
+{
+  return hb_in_range (u, lo1, hi1) || hb_in_range (u, lo2, hi2) || hb_in_range (u, lo3, hi3);
+}
+
 
 /* Useful for set-operations on small enums.
  * For example, for testing "x ∈ {x1, x2, x3}" use:
  * (FLAG(x) & (FLAG(x1) | FLAG(x2) | FLAG(x3)))
  */
 #define FLAG(x) (1<<(x))
+#define FLAG_RANGE(x,y) (ASSERT_STATIC_EXPR_ZERO ((x) < (y)) + FLAG(y+1) - FLAG(x))
 
 
-template <typename T> inline void
-hb_bubble_sort (T *array, unsigned int len, int(*compar)(const T *, const T *))
+template <typename T, typename T2> inline void
+hb_bubble_sort (T *array, unsigned int len, int(*compar)(const T *, const T *), T2 *array2)
 {
   if (unlikely (!len))
     return;
 
   unsigned int k = len - 1;
   do {
     unsigned int new_k = 0;
 
     for (unsigned int j = 0; j < k; j++)
-      if (compar (&array[j], &array[j+1]) > 0) {
-        T t;
-	t = array[j];
-	array[j] = array[j + 1];
-	array[j + 1] = t;
+      if (compar (&array[j], &array[j+1]) > 0)
+      {
+        {
+	  T t;
+	  t = array[j];
+	  array[j] = array[j + 1];
+	  array[j + 1] = t;
+	}
+        if (array2)
+        {
+	  T2 t;
+	  t = array2[j];
+	  array2[j] = array2[j + 1];
+	  array2[j + 1] = t;
+	}
 
 	new_k = j;
       }
     k = new_k;
   } while (k);
 }
 
+template <typename T> inline void
+hb_bubble_sort (T *array, unsigned int len, int(*compar)(const T *, const T *))
+{
+  hb_bubble_sort (array, len, compar, (int *) NULL);
+}
 
 
 
 #endif /* HB_PRIVATE_HH */
diff --git a/gfx/harfbuzz/src/hb-set-private.hh b/gfx/harfbuzz/src/hb-set-private.hh
--- a/gfx/harfbuzz/src/hb-set-private.hh
+++ b/gfx/harfbuzz/src/hb-set-private.hh
@@ -27,21 +27,120 @@
 #ifndef HB_SET_PRIVATE_HH
 #define HB_SET_PRIVATE_HH
 
 #include "hb-private.hh"
 #include "hb-set.h"
 #include "hb-object-private.hh"
 
 
+struct hb_set_digest_common_bits_t
+{
+  ASSERT_POD ();
+
+  typedef unsigned int mask_t;
+
+  inline void init (void) {
+    mask = ~0;
+    value = (mask_t) -1;
+  }
+
+  inline void add (hb_codepoint_t g) {
+    if (unlikely (value == (mask_t) -1)) {
+      value = g;
+      return;
+    }
+
+    mask ^= (g & mask) ^ value;
+    value &= mask;
+  }
+
+  inline void add_range (hb_codepoint_t a, hb_codepoint_t b) {
+    /* TODO Speedup. */
+    for (unsigned int i = a; i < b + 1; i++)
+      add (i);
+  }
+
+  inline bool may_have (hb_codepoint_t g) const {
+    return (g & mask) == value;
+  }
+
+  private:
+  mask_t mask;
+  mask_t value;
+};
+
+struct hb_set_digest_lowest_bits_t
+{
+  ASSERT_POD ();
+
+  typedef unsigned long mask_t;
+
+  inline void init (void) {
+    mask = 0;
+  }
+
+  inline void add (hb_codepoint_t g) {
+    mask |= mask_for (g);
+  }
+
+  inline void add_range (hb_codepoint_t a, hb_codepoint_t b) {
+    /* TODO Speedup. */
+    for (unsigned int i = a; i < b + 1; i++)
+      add (i);
+  }
+
+  inline bool may_have (hb_codepoint_t g) const {
+    return !!(mask & mask_for (g));
+  }
+
+  private:
+
+  mask_t mask_for (hb_codepoint_t g) const { return ((mask_t) 1) << (g & (sizeof (mask_t) * 8 - 1)); }
+  mask_t mask;
+};
+
+struct hb_set_digest_t
+{
+  ASSERT_POD ();
+
+  inline void init (void) {
+    digest1.init ();
+    digest2.init ();
+  }
+
+  inline void add (hb_codepoint_t g) {
+    digest1.add (g);
+    digest2.add (g);
+  }
+
+  inline void add_range (hb_codepoint_t a, hb_codepoint_t b) {
+    digest1.add_range (a, b);
+    digest2.add_range (a, b);
+  }
+
+  inline bool may_have (hb_codepoint_t g) const {
+    return digest1.may_have (g) && digest2.may_have (g);
+  }
+
+  private:
+  hb_set_digest_common_bits_t digest1;
+  hb_set_digest_lowest_bits_t digest2;
+};
+
+
 /* TODO Make this faster and memmory efficient. */
 
-struct _hb_set_t
+struct hb_set_t
 {
+  hb_object_header_t header;
+  ASSERT_POD ();
+
   inline void init (void) {
+    header.init ();
     clear ();
   }
   inline void fini (void) {
   }
   inline void clear (void) {
     memset (elts, 0, sizeof elts);
   }
   inline bool empty (void) const {
@@ -51,16 +150,21 @@ struct _hb_set_t
     return true;
   }
   inline void add (hb_codepoint_t g)
   {
     if (unlikely (g == SENTINEL)) return;
     if (unlikely (g > MAX_G)) return;
     elt (g) |= mask (g);
   }
+  inline void add_range (hb_codepoint_t a, hb_codepoint_t b)
+  {
+    for (unsigned int i = a; i < b + 1; i++)
+      add (i);
+  }
   inline void del (hb_codepoint_t g)
   {
     if (unlikely (g > MAX_G)) return;
     elt (g) &= ~mask (g);
   }
   inline bool has (hb_codepoint_t g) const
   {
     if (unlikely (g > MAX_G)) return false;
@@ -152,17 +256,16 @@ struct _hb_set_t
   static const unsigned int MASK = BITS - 1;
   static const unsigned int ELTS = (MAX_G + 1 + (BITS - 1)) / BITS;
   static  const hb_codepoint_t SENTINEL = (hb_codepoint_t) -1;
 
   elt_t &elt (hb_codepoint_t g) { return elts[g >> SHIFT]; }
   elt_t elt (hb_codepoint_t g) const { return elts[g >> SHIFT]; }
   elt_t mask (hb_codepoint_t g) const { return elt_t (1) << (g & MASK); }
 
-  hb_object_header_t header;
   elt_t elts[ELTS]; /* XXX 8kb */
 
   ASSERT_STATIC (sizeof (elt_t) * 8 == BITS);
   ASSERT_STATIC (sizeof (elt_t) * 8 * ELTS > MAX_G);
 };
 
 
 
diff --git a/gfx/harfbuzz/src/hb-set.cc b/gfx/harfbuzz/src/hb-set.cc
--- a/gfx/harfbuzz/src/hb-set.cc
+++ b/gfx/harfbuzz/src/hb-set.cc
@@ -25,40 +25,40 @@
  */
 
 #include "hb-set-private.hh"
 
 
 
 /* Public API */
 
-static hb_set_t _hb_set_nil = {
-  HB_OBJECT_HEADER_STATIC,
-
-  {0} /* elts */
-};
-
 
 hb_set_t *
 hb_set_create ()
 {
   hb_set_t *set;
 
   if (!(set = hb_object_create<hb_set_t> ()))
-    return &_hb_set_nil;
+    return hb_set_get_empty ();
 
   set->clear ();
 
   return set;
 }
 
 hb_set_t *
 hb_set_get_empty (void)
 {
-  return &_hb_set_nil;
+  static const hb_set_t _hb_set_nil = {
+    HB_OBJECT_HEADER_STATIC,
+
+    {0} /* elts */
+  };
+
+  return const_cast<hb_set_t *> (&_hb_set_nil);
 }
 
 hb_set_t *
 hb_set_reference (hb_set_t *set)
 {
   return hb_object_reference (set);
 }
 
@@ -88,17 +88,17 @@ hb_set_get_user_data (hb_set_t        *s
 {
   return hb_object_get_user_data (set, key);
 }
 
 
 hb_bool_t
 hb_set_allocation_successful (hb_set_t  *set HB_UNUSED)
 {
-  return TRUE;
+  return true;
 }
 
 void
 hb_set_clear (hb_set_t *set)
 {
   set->clear ();
 }
 
diff --git a/gfx/harfbuzz/src/hb-set.h b/gfx/harfbuzz/src/hb-set.h
--- a/gfx/harfbuzz/src/hb-set.h
+++ b/gfx/harfbuzz/src/hb-set.h
@@ -31,17 +31,17 @@
 #ifndef HB_SET_H
 #define HB_SET_H
 
 #include "hb-common.h"
 
 HB_BEGIN_DECLS
 
 
-typedef struct _hb_set_t hb_set_t;
+typedef struct hb_set_t hb_set_t;
 
 
 hb_set_t *
 hb_set_create (void);
 
 hb_set_t *
 hb_set_get_empty (void);
 
@@ -58,17 +58,17 @@ hb_set_set_user_data (hb_set_t          
 		      hb_destroy_func_t   destroy,
 		      hb_bool_t           replace);
 
 void *
 hb_set_get_user_data (hb_set_t           *set,
 		      hb_user_data_key_t *key);
 
 
-/* Returns FALSE if allocation has failed before */
+/* Returns false if allocation has failed before */
 hb_bool_t
 hb_set_allocation_successful (hb_set_t  *set);
 
 void
 hb_set_clear (hb_set_t *set);
 
 hb_bool_t
 hb_set_empty (hb_set_t *set);
diff --git a/gfx/harfbuzz/src/hb-shape-plan-private.hh b/gfx/harfbuzz/src/hb-shape-plan-private.hh
new file mode 100644
--- /dev/null
+++ b/gfx/harfbuzz/src/hb-shape-plan-private.hh
@@ -0,0 +1,60 @@
+/*
+ * Copyright © 2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_SHAPE_PLAN_PRIVATE_HH
+#define HB_SHAPE_PLAN_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-shape-plan.h"
+
+#include "hb-shaper-private.hh"
+
+
+struct hb_shape_plan_t
+{
+  hb_object_header_t header;
+  ASSERT_POD ();
+
+  hb_bool_t default_shaper_list;
+  hb_face_t *face;
+  hb_segment_properties_t props;
+
+  hb_shape_func_t *shaper_func;
+
+  struct hb_shaper_data_t shaper_data;
+};
+
+#define HB_SHAPER_DATA_CREATE_FUNC_EXTRA_ARGS \
+	, const hb_feature_t            *user_features \
+	, unsigned int                   num_user_features
+#define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_PROTOTYPE(shaper, shape_plan);
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+#undef HB_SHAPER_DATA_CREATE_FUNC_EXTRA_ARGS
+
+
+#endif /* HB_SHAPE_PLAN_PRIVATE_HH */
diff --git a/gfx/harfbuzz/src/hb-shape-plan.cc b/gfx/harfbuzz/src/hb-shape-plan.cc
new file mode 100644
--- /dev/null
+++ b/gfx/harfbuzz/src/hb-shape-plan.cc
@@ -0,0 +1,285 @@
+/*
+ * Copyright © 2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+
+#include "hb-shape-plan-private.hh"
+#include "hb-shaper-private.hh"
+#include "hb-font-private.hh"
+
+#define HB_SHAPER_IMPLEMENT(shaper) \
+	HB_SHAPER_DATA_ENSURE_DECLARE(shaper, face) \
+	HB_SHAPER_DATA_ENSURE_DECLARE(shaper, font)
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+
+
+void
+hb_shape_plan_plan (hb_shape_plan_t    *shape_plan,
+		    const hb_feature_t *user_features,
+		    unsigned int        num_user_features,
+		    const char * const *shaper_list)
+{
+  const hb_shaper_pair_t *shapers = _hb_shapers_get ();
+
+#define HB_SHAPER_PLAN(shaper) \
+	HB_STMT_START { \
+	  if (hb_##shaper##_shaper_face_data_ensure (shape_plan->face)) { \
+	    HB_SHAPER_DATA (shaper, shape_plan) = \
+	      HB_SHAPER_DATA_CREATE_FUNC (shaper, shape_plan) (shape_plan, user_features, num_user_features); \
+	    shape_plan->shaper_func = _hb_##shaper##_shape; \
+	    return; \
+	  } \
+	} HB_STMT_END
+
+  if (likely (!shaper_list)) {
+    for (unsigned int i = 0; i < HB_SHAPERS_COUNT; i++)
+      if (0)
+	;
+#define HB_SHAPER_IMPLEMENT(shaper) \
+      else if (shapers[i].func == _hb_##shaper##_shape) \
+	HB_SHAPER_PLAN (shaper);
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+  } else {
+    for (; *shaper_list; shaper_list++)
+      if (0)
+	;
+#define HB_SHAPER_IMPLEMENT(shaper) \
+      else if (0 == strcmp (*shaper_list, #shaper)) \
+	HB_SHAPER_PLAN (shaper);
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+  }
+
+#undef HB_SHAPER_PLAN
+}
+
+
+/*
+ * hb_shape_plan_t
+ */
+
+hb_shape_plan_t *
+hb_shape_plan_create (hb_face_t                     *face,
+		      const hb_segment_properties_t *props,
+		      const hb_feature_t            *user_features,
+		      unsigned int                   num_user_features,
+		      const char * const            *shaper_list)
+{
+  assert (props->direction != HB_DIRECTION_INVALID);
+
+  hb_shape_plan_t *shape_plan;
+
+  if (unlikely (!face))
+    face = hb_face_get_empty ();
+  if (unlikely (!props || hb_object_is_inert (face)))
+    return hb_shape_plan_get_empty ();
+  if (!(shape_plan = hb_object_create<hb_shape_plan_t> ()))
+    return hb_shape_plan_get_empty ();
+
+  hb_face_make_immutable (face);
+  shape_plan->default_shaper_list = shaper_list == NULL;
+  shape_plan->face = hb_face_reference (face);
+  shape_plan->props = *props;
+
+  hb_shape_plan_plan (shape_plan, user_features, num_user_features, shaper_list);
+
+  return shape_plan;
+}
+
+hb_shape_plan_t *
+hb_shape_plan_get_empty (void)
+{
+  static const hb_shape_plan_t _hb_shape_plan_nil = {
+    HB_OBJECT_HEADER_STATIC,
+
+    true, /* default_shaper_list */
+    NULL, /* face */
+    _HB_BUFFER_PROPS_DEFAULT, /* props */
+
+    NULL, /* shaper_func */
+
+    {
+#define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_INVALID,
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+    }
+  };
+
+  return const_cast<hb_shape_plan_t *> (&_hb_shape_plan_nil);
+}
+
+hb_shape_plan_t *
+hb_shape_plan_reference (hb_shape_plan_t *shape_plan)
+{
+  return hb_object_reference (shape_plan);
+}
+
+void
+hb_shape_plan_destroy (hb_shape_plan_t *shape_plan)
+{
+  if (!hb_object_destroy (shape_plan)) return;
+
+#define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_DESTROY(shaper, shape_plan);
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+
+  hb_face_destroy (shape_plan->face);
+
+  free (shape_plan);
+}
+
+
+hb_bool_t
+hb_shape_plan_execute (hb_shape_plan      *shape_plan,
+		       hb_font_t          *font,
+		       hb_buffer_t        *buffer,
+		       const hb_feature_t *features,
+		       unsigned int        num_features)
+{
+  if (unlikely (shape_plan->face != font->face))
+    return false;
+
+#define HB_SHAPER_EXECUTE(shaper) \
+	HB_STMT_START { \
+	  return HB_SHAPER_DATA (shaper, shape_plan) && \
+		 hb_##shaper##_shaper_font_data_ensure (font) && \
+		 _hb_##shaper##_shape (shape_plan, font, buffer, features, num_features); \
+	} HB_STMT_END
+
+  if (0)
+    ;
+#define HB_SHAPER_IMPLEMENT(shaper) \
+  else if (shape_plan->shaper_func == _hb_##shaper##_shape) \
+    HB_SHAPER_EXECUTE (shaper);
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+
+#undef HB_SHAPER_EXECUTE
+
+  return false;
+}
+
+
+/*
+ * caching
+ */
+
+#if 0
+static long
+hb_shape_plan_hash (const hb_shape_plan_t *shape_plan)
+{
+  return hb_segment_properties_hash (&shape_plan->props) +
+	 shape_plan->default_shaper_list ? 0 : (long) shape_plan->shaper_func;
+}
+#endif
+
+/* TODO no user-feature caching for now. */
+struct hb_shape_plan_proposal_t
+{
+  const hb_segment_properties_t  props;
+  const char * const            *shaper_list;
+  hb_shape_func_t               *shaper_func;
+};
+
+static hb_bool_t
+hb_shape_plan_matches (const hb_shape_plan_t          *shape_plan,
+		       const hb_shape_plan_proposal_t *proposal)
+{
+  return hb_segment_properties_equal (&shape_plan->props, &proposal->props) &&
+	 ((shape_plan->default_shaper_list && proposal->shaper_list == NULL) ||
+	  (shape_plan->shaper_func == proposal->shaper_func));
+}
+
+hb_shape_plan_t *
+hb_shape_plan_create_cached (hb_face_t                     *face,
+			     const hb_segment_properties_t *props,
+			     const hb_feature_t            *user_features,
+			     unsigned int                   num_user_features,
+			     const char * const            *shaper_list)
+{
+  if (num_user_features)
+    return hb_shape_plan_create (face, props, user_features, num_user_features, shaper_list);
+
+  hb_shape_plan_proposal_t proposal = {
+    *props,
+    shaper_list,
+    NULL
+  };
+
+  if (shaper_list) {
+    /* Choose shaper.  Adapted from hb_shape_plan_plan(). */
+#define HB_SHAPER_PLAN(shaper) \
+	  HB_STMT_START { \
+	    if (hb_##shaper##_shaper_face_data_ensure (face)) \
+	      proposal.shaper_func = _hb_##shaper##_shape; \
+	  } HB_STMT_END
+
+    for (const char * const *shaper_item = shaper_list; *shaper_item; shaper_item++)
+      if (0)
+	;
+#define HB_SHAPER_IMPLEMENT(shaper) \
+      else if (0 == strcmp (*shaper_item, #shaper)) \
+	HB_SHAPER_PLAN (shaper);
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+
+#undef HB_SHAPER_PLAN
+
+    if (unlikely (!proposal.shaper_list))
+      return hb_shape_plan_get_empty ();
+  }
+
+
+retry:
+  hb_face_t::plan_node_t *cached_plan_nodes = (hb_face_t::plan_node_t *) hb_atomic_ptr_get (&face->shape_plans);
+  for (hb_face_t::plan_node_t *node = cached_plan_nodes; node; node = node->next)
+    if (hb_shape_plan_matches (node->shape_plan, &proposal))
+      return hb_shape_plan_reference (node->shape_plan);
+
+  /* Not found. */
+
+  hb_shape_plan_t *shape_plan = hb_shape_plan_create (face, props, user_features, num_user_features, shaper_list);
+
+  hb_face_t::plan_node_t *node = (hb_face_t::plan_node_t *) calloc (1, sizeof (hb_face_t::plan_node_t));
+  if (unlikely (!node))
+    return shape_plan;
+
+  node->shape_plan = shape_plan;
+  node->next = cached_plan_nodes;
+
+  if (!hb_atomic_ptr_cmpexch (&face->shape_plans, cached_plan_nodes, node)) {
+    hb_shape_plan_destroy (shape_plan);
+    free (node);
+    goto retry;
+  }
+
+  /* Release our reference on face. */
+  hb_face_destroy (face);
+
+  return hb_shape_plan_reference (shape_plan);
+}
diff --git a/gfx/harfbuzz/src/hb-shape-plan.h b/gfx/harfbuzz/src/hb-shape-plan.h
new file mode 100644
--- /dev/null
+++ b/gfx/harfbuzz/src/hb-shape-plan.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright © 2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_SHAPE_PLAN_H
+#define HB_SHAPE_PLAN_H
+
+/* TODO To become public one day */
+
+#include "hb-private.hh"
+
+#include "hb-buffer-private.hh"
+
+
+typedef struct hb_shape_plan_t hb_shape_plan;
+
+/*
+ * hb_shape_plan_t
+ */
+
+HB_INTERNAL hb_shape_plan_t *
+hb_shape_plan_create (hb_face_t                     *face,
+		      const hb_segment_properties_t *props,
+		      const hb_feature_t            *user_features,
+		      unsigned int                   num_user_features,
+		      const char * const            *shaper_list);
+
+hb_shape_plan_t *
+hb_shape_plan_create_cached (hb_face_t                     *face,
+			     const hb_segment_properties_t *props,
+			     const hb_feature_t            *user_features,
+			     unsigned int                   num_user_features,
+			     const char * const            *shaper_list);
+
+HB_INTERNAL hb_shape_plan_t *
+hb_shape_plan_get_empty (void);
+
+HB_INTERNAL hb_shape_plan_t *
+hb_shape_plan_reference (hb_shape_plan_t *shape_plan);
+
+HB_INTERNAL void
+hb_shape_plan_destroy (hb_shape_plan_t *shape_plan);
+
+
+HB_INTERNAL hb_bool_t
+hb_shape_plan_execute (hb_shape_plan      *shape_plan,
+		       hb_font_t          *font,
+		       hb_buffer_t        *buffer,
+		       const hb_feature_t *features,
+		       unsigned int        num_features);
+
+
+#endif /* HB_SHAPE_PLAN_H */
diff --git a/gfx/harfbuzz/src/hb-shape.cc b/gfx/harfbuzz/src/hb-shape.cc
--- a/gfx/harfbuzz/src/hb-shape.cc
+++ b/gfx/harfbuzz/src/hb-shape.cc
@@ -21,129 +21,81 @@
  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  *
  * Red Hat Author(s): Behdad Esfahbod
  */
 
 #include "hb-private.hh"
 
-#include "hb-shape.h"
+#include "hb-shaper-private.hh"
+#include "hb-shape-plan-private.hh"
+#include "hb-buffer-private.hh"
+#include "hb-font-private.hh"
 
-#include "hb-buffer-private.hh"
 
-#ifdef HAVE_GRAPHITE
-#include "hb-graphite2-private.hh"
-#endif
-#ifdef HAVE_UNISCRIBE
-# include "hb-uniscribe-private.hh"
-#endif
-#ifdef HAVE_OT
-# include "hb-ot-shape-private.hh"
-#endif
-#include "hb-fallback-shape-private.hh"
+static const char **static_shaper_list;
 
-typedef hb_bool_t (*hb_shape_func_t) (hb_font_t          *font,
-				      hb_buffer_t        *buffer,
-				      const hb_feature_t *features,
-				      unsigned int        num_features);
-
-#define HB_SHAPER_IMPLEMENT(name) {#name, _hb_##name##_shape}
-static struct hb_shaper_pair_t {
-  char name[16];
-  hb_shape_func_t func;
-} shapers[] = {
-  /* v--- Add new shapers in the right place here */
-#ifdef HAVE_GRAPHITE
-  HB_SHAPER_IMPLEMENT (graphite2),
-#endif
-#ifdef HAVE_UNISCRIBE
-  HB_SHAPER_IMPLEMENT (uniscribe),
-#endif
-#ifdef HAVE_OT
-  HB_SHAPER_IMPLEMENT (ot),
-#endif
-  HB_SHAPER_IMPLEMENT (fallback) /* should be last */
-};
-#undef HB_SHAPER_IMPLEMENT
-
-static struct static_shaper_list_t
+static
+void free_static_shaper_list (void)
 {
-  static_shaper_list_t (void)
-  {
-    char *env = getenv ("HB_SHAPER_LIST");
-    if (env && *env)
-    {
-       /* Reorder shaper list to prefer requested shaper list. */
-      unsigned int i = 0;
-      char *end, *p = env;
-      for (;;) {
-        end = strchr (p, ',');
-        if (!end)
-          end = p + strlen (p);
-
-	for (unsigned int j = i; j < ARRAY_LENGTH (shapers); j++)
-	  if (end - p == (int) strlen (shapers[j].name) &&
-	      0 == strncmp (shapers[j].name, p, end - p))
-	  {
-	    /* Reorder this shaper to position i */
-	   struct hb_shaper_pair_t t = shapers[j];
-	   memmove (&shapers[i + 1], &shapers[i], sizeof (shapers[i]) * (j - i));
-	   shapers[i] = t;
-	   i++;
-	  }
-
-        if (!*end)
-          break;
-        else
-          p = end + 1;
-      }
-    }
-
-    ASSERT_STATIC ((ARRAY_LENGTH (shapers) + 1) * sizeof (*shaper_list) <= sizeof (shaper_list));
-    unsigned int i;
-    for (i = 0; i < ARRAY_LENGTH (shapers); i++)
-      shaper_list[i] = shapers[i].name;
-    shaper_list[i] = NULL;
-  }
-
-  const char *shaper_list[ARRAY_LENGTH (shapers) + 1];
-} static_shaper_list;
+  free (static_shaper_list);
+}
 
 const char **
 hb_shape_list_shapers (void)
 {
-  return static_shaper_list.shaper_list;
+retry:
+  const char **shaper_list = (const char **) hb_atomic_ptr_get (&static_shaper_list);
+
+  if (unlikely (!shaper_list))
+  {
+    /* Not found; allocate one. */
+    shaper_list = (const char **) calloc (1 + HB_SHAPERS_COUNT, sizeof (const char *));
+    if (unlikely (!shaper_list)) {
+      static const char *nil_shaper_list[] = {NULL};
+      return nil_shaper_list;
+    }
+
+    const hb_shaper_pair_t *shapers = _hb_shapers_get ();
+    unsigned int i;
+    for (i = 0; i < HB_SHAPERS_COUNT; i++)
+      shaper_list[i] = shapers[i].name;
+    shaper_list[i] = NULL;
+
+    if (!hb_atomic_ptr_cmpexch (&static_shaper_list, NULL, shaper_list)) {
+      free (shaper_list);
+      goto retry;
+    }
+
+#ifdef HAVE_ATEXIT
+    atexit (free_static_shaper_list); /* First person registers atexit() callback. */
+#endif
+  }
+
+  return shaper_list;
 }
 
+
 hb_bool_t
 hb_shape_full (hb_font_t          *font,
 	       hb_buffer_t        *buffer,
 	       const hb_feature_t *features,
 	       unsigned int        num_features,
 	       const char * const *shaper_list)
 {
-  hb_font_make_immutable (font); /* So we can safely cache stuff on it */
+  if (unlikely (!buffer->len))
+    return true;
 
-  if (likely (!shaper_list)) {
-    for (unsigned int i = 0; i < ARRAY_LENGTH (shapers); i++)
-      if (likely (shapers[i].func (font, buffer, features, num_features)))
-        return TRUE;
-  } else {
-    while (*shaper_list) {
-      for (unsigned int i = 0; i < ARRAY_LENGTH (shapers); i++)
-	if (0 == strcmp (*shaper_list, shapers[i].name)) {
-	  if (likely (shapers[i].func (font, buffer, features, num_features)))
-	    return TRUE;
-	  break;
-	}
-      shaper_list++;
-    }
-  }
-  return FALSE;
+  buffer->guess_properties ();
+
+  hb_shape_plan_t *shape_plan = hb_shape_plan_create_cached (font->face, &buffer->props, features, num_features, shaper_list);
+  hb_bool_t res = hb_shape_plan_execute (shape_plan, font, buffer, features, num_features);
+  hb_shape_plan_destroy (shape_plan);
+  return res;
 }
 
 void
 hb_shape (hb_font_t           *font,
 	  hb_buffer_t         *buffer,
 	  const hb_feature_t  *features,
 	  unsigned int         num_features)
 {
diff --git a/gfx/harfbuzz/src/hb-shape.h b/gfx/harfbuzz/src/hb-shape.h
--- a/gfx/harfbuzz/src/hb-shape.h
+++ b/gfx/harfbuzz/src/hb-shape.h
@@ -33,17 +33,17 @@
 
 #include "hb-common.h"
 #include "hb-buffer.h"
 #include "hb-font.h"
 
 HB_BEGIN_DECLS
 
 
-typedef struct _hb_feature_t {
+typedef struct hb_feature_t {
   hb_tag_t      tag;
   uint32_t      value;
   unsigned int  start;
   unsigned int  end;
 } hb_feature_t;
 
 
 void
diff --git a/gfx/harfbuzz/src/hb-shaper-impl-private.hh b/gfx/harfbuzz/src/hb-shaper-impl-private.hh
new file mode 100644
--- /dev/null
+++ b/gfx/harfbuzz/src/hb-shaper-impl-private.hh
@@ -0,0 +1,43 @@
+/*
+ * Copyright © 2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_SHAPER_IMPL_PRIVATE_HH
+#define HB_SHAPER_IMPL_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-shaper-private.hh"
+#include "hb-shape-plan-private.hh"
+#include "hb-font-private.hh"
+#include "hb-buffer-private.hh"
+
+
+#ifdef HB_SHAPER
+#define HB_SHAPER_DATA_GET(object) HB_SHAPER_DATA (HB_SHAPER, object)
+#endif
+
+
+#endif /* HB_SHAPER_IMPL_PRIVATE_HH */
diff --git a/gfx/harfbuzz/src/hb-shaper-list.hh b/gfx/harfbuzz/src/hb-shaper-list.hh
new file mode 100644
--- /dev/null
+++ b/gfx/harfbuzz/src/hb-shaper-list.hh
@@ -0,0 +1,50 @@
+/*
+ * Copyright © 2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_SHAPER_LIST_HH
+#define HB_SHAPER_LIST_HH
+#endif /* HB_SHAPER_LIST_HH */ /* Dummy header guards */
+
+/* v--- Add new shapers in the right place here. */
+#ifdef HAVE_GRAPHITE
+HB_SHAPER_IMPLEMENT (graphite2)
+#endif
+#ifdef HAVE_UNISCRIBE
+HB_SHAPER_IMPLEMENT (uniscribe)
+#endif
+#ifdef HAVE_CORETEXT
+HB_SHAPER_IMPLEMENT (coretext)
+#endif
+
+#ifdef HAVE_OT
+HB_SHAPER_IMPLEMENT (ot) /* <--- This is our main OpenType shaper. */
+#endif
+
+#ifdef HAVE_HB_OLD
+HB_SHAPER_IMPLEMENT (old)
+#endif
+
+HB_SHAPER_IMPLEMENT (fallback) /* <--- This should be last. */
diff --git a/gfx/harfbuzz/src/hb-shaper-private.hh b/gfx/harfbuzz/src/hb-shaper-private.hh
new file mode 100644
--- /dev/null
+++ b/gfx/harfbuzz/src/hb-shaper-private.hh
@@ -0,0 +1,108 @@
+/*
+ * Copyright © 2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_SHAPER_PRIVATE_HH
+#define HB_SHAPER_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-shape-plan.h" /* TODO remove */
+
+typedef hb_bool_t hb_shape_func_t (hb_shape_plan_t    *shape_plan,
+				   hb_font_t          *font,
+				   hb_buffer_t        *buffer,
+				   const hb_feature_t *features,
+				   unsigned int        num_features);
+
+#define HB_SHAPER_IMPLEMENT(name) \
+	extern "C" HB_INTERNAL hb_shape_func_t _hb_##name##_shape;
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+
+struct hb_shaper_pair_t {
+  char name[16];
+  hb_shape_func_t *func;
+};
+
+HB_INTERNAL const hb_shaper_pair_t *
+_hb_shapers_get (void);
+
+
+/* For embedding in face / font / ... */
+struct hb_shaper_data_t {
+#define HB_SHAPER_IMPLEMENT(shaper) void *shaper;
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+};
+
+#define HB_SHAPERS_COUNT (sizeof (hb_shaper_data_t) / sizeof (void *))
+
+/* Means: succeeded, but don't need to keep any data. */
+#define HB_SHAPER_DATA_SUCCEEDED ((void *) +1)
+
+/* Means: tried but failed to create. */
+#define HB_SHAPER_DATA_INVALID ((void *) -1)
+#define HB_SHAPER_DATA_IS_INVALID(data) ((void *) (data) == HB_SHAPER_DATA_INVALID)
+
+#define HB_SHAPER_DATA_TYPE(shaper, object)		struct hb_##shaper##_shaper_##object##_data_t
+#define HB_SHAPER_DATA_INSTANCE(shaper, object, instance)	(* (HB_SHAPER_DATA_TYPE(shaper, object) **) &(instance)->shaper_data.shaper)
+#define HB_SHAPER_DATA(shaper, object)			HB_SHAPER_DATA_INSTANCE (shaper, object, object)
+#define HB_SHAPER_DATA_CREATE_FUNC(shaper, object)	_hb_##shaper##_shaper_##object##_data_create
+#define HB_SHAPER_DATA_DESTROY_FUNC(shaper, object)	_hb_##shaper##_shaper_##object##_data_destroy
+
+#define HB_SHAPER_DATA_PROTOTYPE(shaper, object) \
+	HB_SHAPER_DATA_TYPE (shaper, object); /* Type forward declaration. */ \
+	extern "C" HB_INTERNAL HB_SHAPER_DATA_TYPE (shaper, object) * \
+	HB_SHAPER_DATA_CREATE_FUNC (shaper, object) (hb_##object##_t *object HB_SHAPER_DATA_CREATE_FUNC_EXTRA_ARGS); \
+	extern "C" HB_INTERNAL void \
+	HB_SHAPER_DATA_DESTROY_FUNC (shaper, object) (HB_SHAPER_DATA_TYPE (shaper, object) *data)
+
+#define HB_SHAPER_DATA_DESTROY(shaper, object) \
+	if (object->shaper_data.shaper && \
+	    object->shaper_data.shaper != HB_SHAPER_DATA_INVALID && \
+	    object->shaper_data.shaper != HB_SHAPER_DATA_SUCCEEDED) \
+	  HB_SHAPER_DATA_DESTROY_FUNC (shaper, object) (HB_SHAPER_DATA (shaper, object));
+
+#define HB_SHAPER_DATA_ENSURE_DECLARE(shaper, object) \
+static inline bool \
+hb_##shaper##_shaper_##object##_data_ensure (hb_##object##_t *object) \
+{\
+  retry: \
+  HB_SHAPER_DATA_TYPE (shaper, object) *data = (HB_SHAPER_DATA_TYPE (shaper, object) *) hb_atomic_ptr_get (&HB_SHAPER_DATA (shaper, object)); \
+  if (unlikely (!data)) { \
+    data = HB_SHAPER_DATA_CREATE_FUNC (shaper, object) (object); \
+    if (unlikely (!data)) \
+      data = (HB_SHAPER_DATA_TYPE (shaper, object) *) HB_SHAPER_DATA_INVALID; \
+    if (!hb_atomic_ptr_cmpexch (&HB_SHAPER_DATA (shaper, object), NULL, data)) { \
+      HB_SHAPER_DATA_DESTROY_FUNC (shaper, object) (data); \
+      goto retry; \
+    } \
+  } \
+  return data != NULL && !HB_SHAPER_DATA_IS_INVALID (data); \
+}
+
+
+#endif /* HB_SHAPER_PRIVATE_HH */
diff --git a/gfx/harfbuzz/src/hb-shaper.cc b/gfx/harfbuzz/src/hb-shaper.cc
new file mode 100644
--- /dev/null
+++ b/gfx/harfbuzz/src/hb-shaper.cc
@@ -0,0 +1,109 @@
+/*
+ * Copyright © 2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+
+#include "hb-shaper-private.hh"
+
+
+static const hb_shaper_pair_t all_shapers[] = {
+#define HB_SHAPER_IMPLEMENT(name) {#name, _hb_##name##_shape},
+#include "hb-shaper-list.hh"
+#undef HB_SHAPER_IMPLEMENT
+};
+
+
+/* Thread-safe, lock-free, shapers */
+
+static const hb_shaper_pair_t *static_shapers;
+
+static
+void free_static_shapers (void)
+{
+  if (unlikely (static_shapers != all_shapers))
+    free ((void *) static_shapers);
+}
+
+const hb_shaper_pair_t *
+_hb_shapers_get (void)
+{
+retry:
+  hb_shaper_pair_t *shapers = (hb_shaper_pair_t *) hb_atomic_ptr_get (&static_shapers);
+
+  if (unlikely (!shapers))
+  {
+    char *env = getenv ("HB_SHAPER_LIST");
+    if (!env || !*env) {
+      (void) hb_atomic_ptr_cmpexch (&static_shapers, NULL, &all_shapers[0]);
+      return (const hb_shaper_pair_t *) all_shapers;
+    }
+
+    /* Not found; allocate one. */
+    shapers = (hb_shaper_pair_t *) malloc (sizeof (all_shapers));
+    if (unlikely (!shapers)) {
+      (void) hb_atomic_ptr_cmpexch (&static_shapers, NULL, &all_shapers[0]);
+      return (const hb_shaper_pair_t *) all_shapers;
+    }
+
+    memcpy (shapers, all_shapers, sizeof (all_shapers));
+
+     /* Reorder shaper list to prefer requested shapers. */
+    unsigned int i = 0;
+    char *end, *p = env;
+    for (;;) {
+      end = strchr (p, ',');
+      if (!end)
+	end = p + strlen (p);
+
+      for (unsigned int j = i; j < ARRAY_LENGTH (all_shapers); j++)
+	if (end - p == (int) strlen (shapers[j].name) &&
+	    0 == strncmp (shapers[j].name, p, end - p))
+	{
+	  /* Reorder this shaper to position i */
+	 struct hb_shaper_pair_t t = shapers[j];
+	 memmove (&shapers[i + 1], &shapers[i], sizeof (shapers[i]) * (j - i));
+	 shapers[i] = t;
+	 i++;
+	}
+
+      if (!*end)
+	break;
+      else
+	p = end + 1;
+    }
+
+    if (!hb_atomic_ptr_cmpexch (&static_shapers, NULL, shapers)) {
+      free (shapers);
+      goto retry;
+    }
+
+#ifdef HAVE_ATEXIT
+    atexit (free_static_shapers); /* First person registers atexit() callback. */
+#endif
+  }
+
+  return shapers;
+}
diff --git a/gfx/harfbuzz/src/hb-tt-font.cc b/gfx/harfbuzz/src/hb-tt-font.cc
--- a/gfx/harfbuzz/src/hb-tt-font.cc
+++ b/gfx/harfbuzz/src/hb-tt-font.cc
@@ -83,17 +83,17 @@ hb_font_get_glyph_nil (hb_font_t *font H
 		       hb_codepoint_t variation_selector,
 		       hb_codepoint_t *glyph,
 		       void *user_data HB_UNUSED)
 {
   if (font->parent)
     return hb_font_get_glyph (font->parent, unicode, variation_selector, glyph);
 
   *glyph = 0;
-  return FALSE;
+  return false;
 }
 
 static hb_position_t
 hb_font_get_glyph_h_advance_nil (hb_font_t *font HB_UNUSED,
 				 void *font_data HB_UNUSED,
 				 hb_codepoint_t glyph,
 				 void *user_data HB_UNUSED)
 {
@@ -128,17 +128,17 @@ hb_font_get_glyph_h_origin_nil (hb_font_
 						glyph,
 						x, y);
     if (ret)
       font->parent_scale_position (x, y);
     return ret;
   }
 
   *x = *y = 0;
-  return FALSE;
+  return false;
 }
 
 static hb_bool_t
 hb_font_get_glyph_v_origin_nil (hb_font_t *font HB_UNUSED,
 				void *font_data HB_UNUSED,
 				hb_codepoint_t glyph,
 				hb_position_t *x,
 				hb_position_t *y,
@@ -149,17 +149,17 @@ hb_font_get_glyph_v_origin_nil (hb_font_
 						glyph,
 						x, y);
     if (ret)
       font->parent_scale_position (x, y);
     return ret;
   }
 
   *x = *y = 0;
-  return FALSE;
+  return false;
 }
 
 static hb_position_t
 hb_font_get_glyph_h_kerning_nil (hb_font_t *font HB_UNUSED,
 				 void *font_data HB_UNUSED,
 				 hb_codepoint_t left_glyph,
 				 hb_codepoint_t right_glyph,
 				 void *user_data HB_UNUSED)
@@ -197,17 +197,17 @@ hb_font_get_glyph_extents_nil (hb_font_t
     if (ret) {
       font->parent_scale_position (&extents->x_bearing, &extents->y_bearing);
       font->parent_scale_distance (&extents->width, &extents->height);
     }
     return ret;
   }
 
   memset (extents, 0, sizeof (*extents));
-  return FALSE;
+  return false;
 }
 
 static hb_bool_t
 hb_font_get_glyph_contour_point_nil (hb_font_t *font HB_UNUSED,
 				     void *font_data HB_UNUSED,
 				     hb_codepoint_t glyph,
 				     unsigned int point_index,
 				     hb_position_t *x,
@@ -219,24 +219,24 @@ hb_font_get_glyph_contour_point_nil (hb_
 						     glyph, point_index,
 						     x, y);
     if (ret)
       font->parent_scale_position (x, y);
     return ret;
   }
 
   *x = *y = 0;
-  return FALSE;
+  return false;
 }
 
 
 static hb_font_funcs_t _hb_font_funcs_nil = {
   HB_OBJECT_HEADER_STATIC,
 
-  TRUE, /* immutable */
+  true, /* immutable */
 
   {
 #define HB_FONT_FUNC_IMPLEMENT(name) hb_font_get_##name##_nil,
     HB_FONT_FUNCS_IMPLEMENT_CALLBACKS
 #undef HB_FONT_FUNC_IMPLEMENT
   }
 };
 #endif
diff --git a/gfx/harfbuzz/src/hb-unicode-private.hh b/gfx/harfbuzz/src/hb-unicode-private.hh
--- a/gfx/harfbuzz/src/hb-unicode-private.hh
+++ b/gfx/harfbuzz/src/hb-unicode-private.hh
@@ -1,12 +1,12 @@
 /*
  * Copyright © 2009  Red Hat, Inc.
  * Copyright © 2011  Codethink Limited
- * Copyright © 2010,2011  Google, Inc.
+ * Copyright © 2010,2011,2012  Google, Inc.
  *
  *  This is part of HarfBuzz, a text shaping library.
  *
  * Permission is hereby granted, without written agreement and without
  * license or royalty fees, to use, copy, modify, and distribute this
  * software and its documentation for any purpose, provided that the
  * above copyright notice and the following two paragraphs appear in
  * all copies of this software.
@@ -32,48 +32,181 @@
 #define HB_UNICODE_PRIVATE_HH
 
 #include "hb-private.hh"
 
 #include "hb-unicode.h"
 #include "hb-object-private.hh"
 
 
+extern HB_INTERNAL const uint8_t _hb_modified_combining_class[256];
 
 /*
  * hb_unicode_funcs_t
  */
 
 #define HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS \
   HB_UNICODE_FUNC_IMPLEMENT (combining_class) \
   HB_UNICODE_FUNC_IMPLEMENT (eastasian_width) \
   HB_UNICODE_FUNC_IMPLEMENT (general_category) \
   HB_UNICODE_FUNC_IMPLEMENT (mirroring) \
   HB_UNICODE_FUNC_IMPLEMENT (script) \
   HB_UNICODE_FUNC_IMPLEMENT (compose) \
   HB_UNICODE_FUNC_IMPLEMENT (decompose) \
+  HB_UNICODE_FUNC_IMPLEMENT (decompose_compatibility) \
   /* ^--- Add new callbacks here */
 
 /* Simple callbacks are those taking a hb_codepoint_t and returning a hb_codepoint_t */
 #define HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS_SIMPLE \
-  HB_UNICODE_FUNC_IMPLEMENT (unsigned int, combining_class) \
+  HB_UNICODE_FUNC_IMPLEMENT (hb_unicode_combining_class_t, combining_class) \
   HB_UNICODE_FUNC_IMPLEMENT (unsigned int, eastasian_width) \
   HB_UNICODE_FUNC_IMPLEMENT (hb_unicode_general_category_t, general_category) \
   HB_UNICODE_FUNC_IMPLEMENT (hb_codepoint_t, mirroring) \
   HB_UNICODE_FUNC_IMPLEMENT (hb_script_t, script) \
   /* ^--- Add new simple callbacks here */
 
-struct _hb_unicode_funcs_t {
+struct hb_unicode_funcs_t {
   hb_object_header_t header;
+  ASSERT_POD ();
 
   hb_unicode_funcs_t *parent;
 
   bool immutable;
 
-  /* Don't access these directly.  Call hb_unicode_*() instead. */
+#define HB_UNICODE_FUNC_IMPLEMENT(return_type, name) \
+  inline return_type name (hb_codepoint_t unicode) { return func.name (this, unicode, user_data.name); }
+HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS_SIMPLE
+#undef HB_UNICODE_FUNC_IMPLEMENT
+
+  inline hb_bool_t compose (hb_codepoint_t a, hb_codepoint_t b,
+			    hb_codepoint_t *ab)
+  {
+    *ab = 0;
+    /* XXX, this belongs to indic normalizer. */
+    if ((FLAG (general_category (a)) &
+	 (FLAG (HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK) |
+	  FLAG (HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK) |
+	  FLAG (HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK))))
+      return false;
+    /* XXX, add composition-exclusion exceptions to Indic shaper. */
+    if (a == 0x09AF && b == 0x09BC) { *ab = 0x09DF; return true; }
+    return func.compose (this, a, b, ab, user_data.compose);
+  }
+
+  inline hb_bool_t decompose (hb_codepoint_t ab,
+			      hb_codepoint_t *a, hb_codepoint_t *b)
+  {
+    /* XXX FIXME, move these to complex shapers and propagage to normalizer.*/
+    switch (ab) {
+      case 0x0AC9  : return false;
+
+      case 0x0931  : return false;
+      case 0x0B94  : return false;
+
+      /* These ones have Unicode decompositions, but we do it
+       * this way to be close to what Uniscribe does. */
+      case 0x0DDA  : *a = 0x0DD9; *b= 0x0DDA; return true;
+      case 0x0DDC  : *a = 0x0DD9; *b= 0x0DDC; return true;
+      case 0x0DDD  : *a = 0x0DD9; *b= 0x0DDD; return true;
+      case 0x0DDE  : *a = 0x0DD9; *b= 0x0DDE; return true;
+
+      case 0x0F77  : *a = 0x0FB2; *b= 0x0F81; return true;
+      case 0x0F79  : *a = 0x0FB3; *b= 0x0F81; return true;
+      case 0x17BE  : *a = 0x17C1; *b= 0x17BE; return true;
+      case 0x17BF  : *a = 0x17C1; *b= 0x17BF; return true;
+      case 0x17C0  : *a = 0x17C1; *b= 0x17C0; return true;
+      case 0x17C4  : *a = 0x17C1; *b= 0x17C4; return true;
+      case 0x17C5  : *a = 0x17C1; *b= 0x17C5; return true;
+      case 0x1925  : *a = 0x1920; *b= 0x1923; return true;
+      case 0x1926  : *a = 0x1920; *b= 0x1924; return true;
+      case 0x1B3C  : *a = 0x1B42; *b= 0x1B3C; return true;
+      case 0x1112E  : *a = 0x11127; *b= 0x11131; return true;
+      case 0x1112F  : *a = 0x11127; *b= 0x11132; return true;
+#if 0
+      case 0x0B57  : *a = 0xno decomp, -> RIGHT; return true;
+      case 0x1C29  : *a = 0xno decomp, -> LEFT; return true;
+      case 0xA9C0  : *a = 0xno decomp, -> RIGHT; return true;
+      case 0x111BF  : *a = 0xno decomp, -> ABOVE; return true;
+#endif
+    }
+    *a = ab; *b = 0;
+    return func.decompose (this, ab, a, b, user_data.decompose);
+  }
+
+  inline unsigned int decompose_compatibility (hb_codepoint_t  u,
+					       hb_codepoint_t *decomposed)
+  {
+    unsigned int ret = func.decompose_compatibility (this, u, decomposed, user_data.decompose_compatibility);
+    if (ret == 1 && u == decomposed[0]) {
+      decomposed[0] = 0;
+      return 0;
+    }
+    decomposed[ret] = 0;
+    return ret;
+  }
+
+
+  unsigned int
+  modified_combining_class (hb_codepoint_t unicode)
+  {
+    return _hb_modified_combining_class[combining_class (unicode)];
+  }
+
+  inline hb_bool_t
+  is_variation_selector (hb_codepoint_t unicode)
+  {
+    return unlikely (hb_in_ranges<hb_codepoint_t> (unicode,
+						   0x180B, 0x180D, /* MONGOLIAN FREE VARIATION SELECTOR ONE..THREE */
+						   0xFE00, 0xFE0F, /* VARIATION SELECTOR-1..16 */
+						   0xE0100, 0xE01EF));  /* VARIATION SELECTOR-17..256 */
+  }
+
+  /* Zero-Width invisible characters:
+   *
+   *  00AD  SOFT HYPHEN
+   *  034F  COMBINING GRAPHEME JOINER
+   *
+   *  180E  MONGOLIAN VOWEL SEPARATOR
+   *
+   *  200B  ZERO WIDTH SPACE
+   *  200C  ZERO WIDTH NON-JOINER
+   *  200D  ZERO WIDTH JOINER
+   *  200E  LEFT-TO-RIGHT MARK
+   *  200F  RIGHT-TO-LEFT MARK
+   *
+   *  2028  LINE SEPARATOR
+   *
+   *  202A  LEFT-TO-RIGHT EMBEDDING
+   *  202B  RIGHT-TO-LEFT EMBEDDING
+   *  202C  POP DIRECTIONAL FORMATTING
+   *  202D  LEFT-TO-RIGHT OVERRIDE
+   *  202E  RIGHT-TO-LEFT OVERRIDE
+   *
+   *  2060  WORD JOINER
+   *  2061  FUNCTION APPLICATION
+   *  2062  INVISIBLE TIMES
+   *  2063  INVISIBLE SEPARATOR
+   *
+   *  FEFF  ZERO WIDTH NO-BREAK SPACE
+   */
+  inline hb_bool_t
+  is_zero_width (hb_codepoint_t ch)
+  {
+    return ((ch & ~0x007F) == 0x2000 && (hb_in_ranges<hb_codepoint_t> (ch,
+								       0x200B, 0x200F,
+								       0x202A, 0x202E,
+								       0x2060, 0x2064) ||
+					 (ch == 0x2028))) ||
+	    unlikely (ch == 0x0009 ||
+		      ch == 0x00AD ||
+		      ch == 0x034F ||
+		      ch == 0x180E ||
+		      ch == 0xFEFF);
+  }
+
 
   struct {
 #define HB_UNICODE_FUNC_IMPLEMENT(name) hb_unicode_##name##_func_t name;
     HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
 #undef HB_UNICODE_FUNC_IMPLEMENT
   } func;
 
   struct {
@@ -86,71 +219,21 @@ struct _hb_unicode_funcs_t {
 #define HB_UNICODE_FUNC_IMPLEMENT(name) hb_destroy_func_t name;
     HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
 #undef HB_UNICODE_FUNC_IMPLEMENT
   } destroy;
 };
 
 
 #ifdef HAVE_GLIB
-extern HB_INTERNAL hb_unicode_funcs_t _hb_glib_unicode_funcs;
+extern HB_INTERNAL const hb_unicode_funcs_t _hb_glib_unicode_funcs;
 #define _hb_unicode_funcs_default _hb_glib_unicode_funcs
 #elif defined(HAVE_ICU)
-extern HB_INTERNAL hb_unicode_funcs_t _hb_icu_unicode_funcs;
+extern HB_INTERNAL const hb_unicode_funcs_t _hb_icu_unicode_funcs;
 #define _hb_unicode_funcs_default _hb_icu_unicode_funcs
 #else
-extern HB_INTERNAL hb_unicode_funcs_t _hb_unicode_funcs_nil;
+#define HB_UNICODE_FUNCS_NIL 1
+extern HB_INTERNAL const hb_unicode_funcs_t _hb_unicode_funcs_nil;
 #define _hb_unicode_funcs_default _hb_unicode_funcs_nil
 #endif
 
 
-HB_INTERNAL unsigned int
-_hb_unicode_modified_combining_class (hb_unicode_funcs_t *ufuncs,
-				      hb_codepoint_t      unicode);
-
-static inline hb_bool_t
-_hb_unicode_is_variation_selector (hb_codepoint_t unicode)
-{
-  return unlikely ((unicode >=  0x180B && unicode <=  0x180D) || /* MONGOLIAN FREE VARIATION SELECTOR ONE..THREE */
-		   (unicode >=  0xFE00 && unicode <=  0xFE0F) || /* VARIATION SELECTOR-1..16 */
-		   (unicode >= 0xE0100 && unicode <= 0xE01EF));  /* VARIATION SELECTOR-17..256 */
-}
-
-/* Zero-Width invisible characters:
- *
- *  00AD  SOFT HYPHEN
- *  034F  COMBINING GRAPHEME JOINER
- *
- *  200B  ZERO WIDTH SPACE
- *  200C  ZERO WIDTH NON-JOINER
- *  200D  ZERO WIDTH JOINER
- *  200E  LEFT-TO-RIGHT MARK
- *  200F  RIGHT-TO-LEFT MARK
- *
- *  2028  LINE SEPARATOR
- *
- *  202A  LEFT-TO-RIGHT EMBEDDING
- *  202B  RIGHT-TO-LEFT EMBEDDING
- *  202C  POP DIRECTIONAL FORMATTING
- *  202D  LEFT-TO-RIGHT OVERRIDE
- *  202E  RIGHT-TO-LEFT OVERRIDE
- *
- *  2060  WORD JOINER
- *  2061  FUNCTION APPLICATION
- *  2062  INVISIBLE TIMES
- *  2063  INVISIBLE SEPARATOR
- *
- *  FEFF  ZERO WIDTH NO-BREAK SPACE
- */
-static inline hb_bool_t
-_hb_unicode_is_zero_width (hb_codepoint_t ch)
-{
-  return ((ch & ~0x007F) == 0x2000 && (
-	  (ch >= 0x200B && ch <= 0x200F) ||
-	  (ch >= 0x202A && ch <= 0x202E) ||
-	  (ch >= 0x2060 && ch <= 0x2063) ||
-	  (ch == 0x2028)
-	 )) || unlikely (ch == 0x00AD
-		      || ch == 0x034F
-		      || ch == 0xFEFF);
-}
-
 #endif /* HB_UNICODE_PRIVATE_HH */
diff --git a/gfx/harfbuzz/src/hb-unicode.cc b/gfx/harfbuzz/src/hb-unicode.cc
--- a/gfx/harfbuzz/src/hb-unicode.cc
+++ b/gfx/harfbuzz/src/hb-unicode.cc
@@ -1,12 +1,12 @@
 /*
  * Copyright © 2009  Red Hat, Inc.
- * Copyright © 2011 Codethink Limited
- * Copyright © 2010,2011  Google, Inc.
+ * Copyright © 2011  Codethink Limited
+ * Copyright © 2010,2011,2012  Google, Inc.
  *
  *  This is part of HarfBuzz, a text shaping library.
  *
  * Permission is hereby granted, without written agreement and without
  * license or royalty fees, to use, copy, modify, and distribute this
  * software and its documentation for any purpose, provided that the
  * above copyright notice and the following two paragraphs appear in
  * all copies of this software.
@@ -33,22 +33,22 @@
 #include "hb-unicode-private.hh"
 
 
 
 /*
  * hb_unicode_funcs_t
  */
 
-static unsigned int
+static hb_unicode_combining_class_t
 hb_unicode_combining_class_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
 				hb_codepoint_t      unicode   HB_UNUSED,
 				void               *user_data HB_UNUSED)
 {
-  return 0;
+  return HB_UNICODE_COMBINING_CLASS_NOT_REORDERED;
 }
 
 static unsigned int
 hb_unicode_eastasian_width_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
 				hb_codepoint_t      unicode   HB_UNUSED,
 				void               *user_data HB_UNUSED)
 {
   return 1;
@@ -80,77 +80,88 @@ hb_unicode_script_nil (hb_unicode_funcs_
 
 static hb_bool_t
 hb_unicode_compose_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
 			hb_codepoint_t      a         HB_UNUSED,
 			hb_codepoint_t      b         HB_UNUSED,
 			hb_codepoint_t     *ab        HB_UNUSED,
 			void               *user_data HB_UNUSED)
 {
-  return FALSE;
+  return false;
 }
 
 static hb_bool_t
 hb_unicode_decompose_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
 			  hb_codepoint_t      ab        HB_UNUSED,
 			  hb_codepoint_t     *a         HB_UNUSED,
 			  hb_codepoint_t     *b         HB_UNUSED,
 			  void               *user_data HB_UNUSED)
 {
-  return FALSE;
+  return false;
 }
 
 
-hb_unicode_funcs_t _hb_unicode_funcs_nil = {
-  HB_OBJECT_HEADER_STATIC,
-
-  NULL, /* parent */
-  TRUE, /* immutable */
-  {
-#define HB_UNICODE_FUNC_IMPLEMENT(name) hb_unicode_##name##_nil,
-    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
-#undef HB_UNICODE_FUNC_IMPLEMENT
-  }
-};
+static unsigned int
+hb_unicode_decompose_compatibility_nil (hb_unicode_funcs_t *ufuncs     HB_UNUSED,
+					hb_codepoint_t      u          HB_UNUSED,
+					hb_codepoint_t     *decomposed HB_UNUSED,
+					void               *user_data  HB_UNUSED)
+{
+  return 0;
+}
 
 
 hb_unicode_funcs_t *
 hb_unicode_funcs_get_default (void)
 {
-  return &_hb_unicode_funcs_default;
+  return const_cast<hb_unicode_funcs_t *> (&_hb_unicode_funcs_default);
 }
 
 hb_unicode_funcs_t *
 hb_unicode_funcs_create (hb_unicode_funcs_t *parent)
 {
   hb_unicode_funcs_t *ufuncs;
 
   if (!(ufuncs = hb_object_create<hb_unicode_funcs_t> ()))
-    return &_hb_unicode_funcs_nil;
+    return hb_unicode_funcs_get_empty ();
 
   if (!parent)
-    parent = &_hb_unicode_funcs_nil;
+    parent = hb_unicode_funcs_get_empty ();
 
   hb_unicode_funcs_make_immutable (parent);
   ufuncs->parent = hb_unicode_funcs_reference (parent);
 
   ufuncs->func = parent->func;
 
   /* We can safely copy user_data from parent since we hold a reference
    * onto it and it's immutable.  We should not copy the destroy notifiers
    * though. */
   ufuncs->user_data = parent->user_data;
 
   return ufuncs;
 }
 
+
+extern HB_INTERNAL const hb_unicode_funcs_t _hb_unicode_funcs_nil;
+const hb_unicode_funcs_t _hb_unicode_funcs_nil = {
+  HB_OBJECT_HEADER_STATIC,
+
+  NULL, /* parent */
+  true, /* immutable */
+  {
+#define HB_UNICODE_FUNC_IMPLEMENT(name) hb_unicode_##name##_nil,
+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_UNICODE_FUNC_IMPLEMENT
+  }
+};
+
 hb_unicode_funcs_t *
 hb_unicode_funcs_get_empty (void)
 {
-  return &_hb_unicode_funcs_nil;
+  return const_cast<hb_unicode_funcs_t *> (&_hb_unicode_funcs_nil);
 }
 
 hb_unicode_funcs_t *
 hb_unicode_funcs_reference (hb_unicode_funcs_t *ufuncs)
 {
   return hb_object_reference (ufuncs);
 }
 
@@ -188,29 +199,29 @@ hb_unicode_funcs_get_user_data (hb_unico
 
 
 void
 hb_unicode_funcs_make_immutable (hb_unicode_funcs_t *ufuncs)
 {
   if (hb_object_is_inert (ufuncs))
     return;
 
-  ufuncs->immutable = TRUE;
+  ufuncs->immutable = true;
 }
 
 hb_bool_t
 hb_unicode_funcs_is_immutable (hb_unicode_funcs_t *ufuncs)
 {
   return ufuncs->immutable;
 }
 
 hb_unicode_funcs_t *
 hb_unicode_funcs_get_parent (hb_unicode_funcs_t *ufuncs)
 {
-  return ufuncs->parent ? ufuncs->parent : &_hb_unicode_funcs_nil;
+  return ufuncs->parent ? ufuncs->parent : hb_unicode_funcs_get_empty ();
 }
 
 
 #define HB_UNICODE_FUNC_IMPLEMENT(name)						\
 										\
 void										\
 hb_unicode_funcs_set_##name##_func (hb_unicode_funcs_t		   *ufuncs,	\
 				    hb_unicode_##name##_func_t	    func,	\
@@ -229,98 +240,195 @@ hb_unicode_funcs_set_##name##_func (hb_u
     ufuncs->destroy.name = destroy;						\
   } else {									\
     ufuncs->func.name = ufuncs->parent->func.name;				\
     ufuncs->user_data.name = ufuncs->parent->user_data.name;			\
     ufuncs->destroy.name = NULL;						\
   }										\
 }
 
-    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
+HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
 #undef HB_UNICODE_FUNC_IMPLEMENT
 
 
 #define HB_UNICODE_FUNC_IMPLEMENT(return_type, name)				\
 										\
 return_type									\
 hb_unicode_##name (hb_unicode_funcs_t *ufuncs,					\
 		   hb_codepoint_t      unicode)					\
 {										\
-  return ufuncs->func.name (ufuncs, unicode, ufuncs->user_data.name);		\
+  return ufuncs->name (unicode);						\
 }
-    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS_SIMPLE
+HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS_SIMPLE
 #undef HB_UNICODE_FUNC_IMPLEMENT
 
 hb_bool_t
 hb_unicode_compose (hb_unicode_funcs_t *ufuncs,
 		    hb_codepoint_t      a,
 		    hb_codepoint_t      b,
 		    hb_codepoint_t     *ab)
 {
-  *ab = 0;
-  return ufuncs->func.compose (ufuncs, a, b, ab, ufuncs->user_data.compose);
+  return ufuncs->compose (a, b, ab);
 }
 
 hb_bool_t
 hb_unicode_decompose (hb_unicode_funcs_t *ufuncs,
 		      hb_codepoint_t      ab,
 		      hb_codepoint_t     *a,
 		      hb_codepoint_t     *b)
 {
-  *a = ab; *b = 0;
-  return ufuncs->func.decompose (ufuncs, ab, a, b, ufuncs->user_data.decompose);
+  return ufuncs->decompose (ab, a, b);
 }
 
-
-
 unsigned int
-_hb_unicode_modified_combining_class (hb_unicode_funcs_t *ufuncs,
-				      hb_codepoint_t      unicode)
+hb_unicode_decompose_compatibility (hb_unicode_funcs_t *ufuncs,
+				    hb_codepoint_t      u,
+				    hb_codepoint_t     *decomposed)
 {
-  int c = hb_unicode_combining_class (ufuncs, unicode);
-
-  if (unlikely (hb_in_range<int> (c, 27, 33)))
-  {
-    /* Modify the combining-class to suit Arabic better.  See:
-     * http://unicode.org/faq/normalization.html#8
-     * http://unicode.org/faq/normalization.html#9
-     */
-    c = c == 33 ? 27 : c + 1;
-  }
-  else if (unlikely (hb_in_range<int> (c, 10, 25)))
-  {
-    /* The equivalent fix for Hebrew is more complex.
-     *
-     * We permute the "fixed-position" classes 10-25 into the order
-     * described in the SBL Hebrew manual:
-     *
-     * http://www.sbl-site.org/Fonts/SBLHebrewUserManual1.5x.pdf
-     *
-     * (as recommended by:
-     *  http://forum.fontlab.com/archive-old-microsoft-volt-group/vista-and-diacritic-ordering-t6751.0.html)
-     *
-     * More details here:
-     * https://bugzilla.mozilla.org/show_bug.cgi?id=662055
-     */
-    static const int permuted_hebrew_classes[25 - 10 + 1] = {
-      /* 10 sheva */        22,
-      /* 11 hataf segol */  15,
-      /* 12 hataf patah */  16,
-      /* 13 hataf qamats */ 17,
-      /* 14 hiriq */        23,
-      /* 15 tsere */        18,
-      /* 16 segol */        19,
-      /* 17 patah */        20,
-      /* 18 qamats */       21,
-      /* 19 holam */        14,
-      /* 20 qubuts */       24,
-      /* 21 dagesh */       12,
-      /* 22 meteg */        25,
-      /* 23 rafe */         13,
-      /* 24 shin dot */     10,
-      /* 25 sin dot */      11,
-    };
-    c = permuted_hebrew_classes[c - 10];
-  }
-
-  return c;
+  return ufuncs->decompose_compatibility (u, decomposed);
 }
 
+
+const uint8_t
+_hb_modified_combining_class[256] =
+{
+  0, /* HB_UNICODE_COMBINING_CLASS_NOT_REORDERED */
+  1, /* HB_UNICODE_COMBINING_CLASS_OVERLAY */
+  2, 3, 4, 5, 6,
+  7, /* HB_UNICODE_COMBINING_CLASS_NUKTA */
+  8, /* HB_UNICODE_COMBINING_CLASS_KANA_VOICING */
+  9, /* HB_UNICODE_COMBINING_CLASS_VIRAMA */
+
+  /* Hebrew */
+
+  /*
+   * We permute the "fixed-position" classes 10-26 into the order
+   * described in the SBL Hebrew manual:
+   *
+   * http://www.sbl-site.org/Fonts/SBLHebrewUserManual1.5x.pdf
+   *
+   * (as recommended by:
+   *  http://forum.fontlab.com/archive-old-microsoft-volt-group/vista-and-diacritic-ordering-t6751.0.html)
+   *
+   * More details here:
+   * https://bugzilla.mozilla.org/show_bug.cgi?id=662055
+   */
+  22, /* HB_UNICODE_COMBINING_CLASS_CCC10 sheva */
+  15, /* HB_UNICODE_COMBINING_CLASS_CCC11 hataf segol */
+  16, /* HB_UNICODE_COMBINING_CLASS_CCC12 hataf patah*/
+  17, /* HB_UNICODE_COMBINING_CLASS_CCC13 hataf qamats */
+  23, /* HB_UNICODE_COMBINING_CLASS_CCC14 hiriq */
+  18, /* HB_UNICODE_COMBINING_CLASS_CCC15 tsere */
+  19, /* HB_UNICODE_COMBINING_CLASS_CCC16 segol */
+  20, /* HB_UNICODE_COMBINING_CLASS_CCC17 patah */
+  21, /* HB_UNICODE_COMBINING_CLASS_CCC18 qamats */
+  14, /* HB_UNICODE_COMBINING_CLASS_CCC19 holam */
+  24, /* HB_UNICODE_COMBINING_CLASS_CCC20 qubuts */
+  12, /* HB_UNICODE_COMBINING_CLASS_CCC21 dagesh */
+  25, /* HB_UNICODE_COMBINING_CLASS_CCC22 meteg */
+  13, /* HB_UNICODE_COMBINING_CLASS_CCC23 rafe */
+  10, /* HB_UNICODE_COMBINING_CLASS_CCC24 shin dot */
+  11, /* HB_UNICODE_COMBINING_CLASS_CCC25 sin dot */
+
+  26, /* HB_UNICODE_COMBINING_CLASS_CCC26 */
+
+  /* Arabic */
+
+  /*
+   * Modify to move Shadda (ccc=33) before other marks.  See:
+   * http://unicode.org/faq/normalization.html#8
+   * http://unicode.org/faq/normalization.html#9
+   */
+  28, /* HB_UNICODE_COMBINING_CLASS_CCC27 */
+  29, /* HB_UNICODE_COMBINING_CLASS_CCC28 */
+  30, /* HB_UNICODE_COMBINING_CLASS_CCC29 */
+  31, /* HB_UNICODE_COMBINING_CLASS_CCC30 */
+  32, /* HB_UNICODE_COMBINING_CLASS_CCC31 */
+  33, /* HB_UNICODE_COMBINING_CLASS_CCC32 */
+  27, /* HB_UNICODE_COMBINING_CLASS_CCC33 shadda */
+
+  34, /* HB_UNICODE_COMBINING_CLASS_CCC34 */
+  35, /* HB_UNICODE_COMBINING_CLASS_CCC35 */
+
+  /* Syriac */
+  36, /* HB_UNICODE_COMBINING_CLASS_CCC36 */
+
+  37, 38, 39,
+  40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
+  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
+  80, 81, 82, 83,
+
+  /* Telugu */
+
+  /*
+   * Modify Telugu length marks (ccc=84, ccc=91).
+   * These are the only matras in the main Indic scripts range that have
+   * a non-zero ccc.  That makes them reorder with the Halant that is
+   * ccc=9.  Just zero them, we don't need them in our Indic shaper.
+   */
+  0, /* HB_UNICODE_COMBINING_CLASS_CCC84 */
+  85, 86, 87, 88, 89, 90,
+  0, /* HB_UNICODE_COMBINING_CLASS_CCC91 */
+  92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102,
+
+  /* Thai */
+
+  /*
+   * Modify U+0E38 and U+0E39 (ccc=104) to be reordered before U+0E3A (ccc=9).
+   * Uniscribe does this too.
+   */
+  3, /* HB_UNICODE_COMBINING_CLASS_CCC103 */
+
+  104, 105, 106,
+  107, /* HB_UNICODE_COMBINING_CLASS_CCC107 */
+  108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
+
+  /* Lao */
+  118, /* HB_UNICODE_COMBINING_CLASS_CCC118 */
+  119, 120, 121,
+  122, /* HB_UNICODE_COMBINING_CLASS_CCC122 */
+  123, 124, 125, 126, 127, 128,
+
+  /* Tibetan */
+  129, /* HB_UNICODE_COMBINING_CLASS_CCC129 */
+  130, /* HB_UNICODE_COMBINING_CLASS_CCC130 */
+  131,
+  132, /* HB_UNICODE_COMBINING_CLASS_CCC133 */
+  133, 134, 135, 136, 137, 138, 139,
+
+
+  140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
+  150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
+  160, 161, 162, 163, 164, 165, 166, 167, 168, 169,
+  170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
+  180, 181, 182, 183, 184, 185, 186, 187, 188, 189,
+  190, 191, 192, 193, 194, 195, 196, 197, 198, 199,
+
+  200, /* HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT */
+  201,
+  202, /* HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW */
+  203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213,
+  214, /* HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE */
+  215,
+  216, /* HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT */
+  217,
+  218, /* HB_UNICODE_COMBINING_CLASS_BELOW_LEFT */
+  219,
+  220, /* HB_UNICODE_COMBINING_CLASS_BELOW */
+  221,
+  222, /* HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT */
+  223,
+  224, /* HB_UNICODE_COMBINING_CLASS_LEFT */
+  225,
+  226, /* HB_UNICODE_COMBINING_CLASS_RIGHT */
+  227,
+  228, /* HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT */
+  229,
+  230, /* HB_UNICODE_COMBINING_CLASS_ABOVE */
+  231,
+  232, /* HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT */
+  233, /* HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW */
+  234, /* HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE */
+  235, 236, 237, 238, 239,
+  240, /* HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT */
+  241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,
+  255, /* HB_UNICODE_COMBINING_CLASS_INVALID */
+};
diff --git a/gfx/harfbuzz/src/hb-unicode.h b/gfx/harfbuzz/src/hb-unicode.h
--- a/gfx/harfbuzz/src/hb-unicode.h
+++ b/gfx/harfbuzz/src/hb-unicode.h
@@ -1,12 +1,12 @@
 /*
  * Copyright © 2009  Red Hat, Inc.
  * Copyright © 2011  Codethink Limited
- * Copyright © 2011  Google, Inc.
+ * Copyright © 2011,2012  Google, Inc.
  *
  *  This is part of HarfBuzz, a text shaping library.
  *
  * Permission is hereby granted, without written agreement and without
  * license or royalty fees, to use, copy, modify, and distribute this
  * software and its documentation for any purpose, provided that the
  * above copyright notice and the following two paragraphs appear in
  * all copies of this software.
@@ -35,21 +35,145 @@
 #ifndef HB_UNICODE_H
 #define HB_UNICODE_H
 
 #include "hb-common.h"
 
 HB_BEGIN_DECLS
 
 
+/* hb_unicode_general_category_t */
+
+/* Unicode Character Database property: General_Category (gc) */
+typedef enum
+{
+  HB_UNICODE_GENERAL_CATEGORY_CONTROL,			/* Cc */
+  HB_UNICODE_GENERAL_CATEGORY_FORMAT,			/* Cf */
+  HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED,		/* Cn */
+  HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE,		/* Co */
+  HB_UNICODE_GENERAL_CATEGORY_SURROGATE,		/* Cs */
+  HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER,		/* Ll */
+  HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER,		/* Lm */
+  HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER,		/* Lo */
+  HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER,		/* Lt */
+  HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER,		/* Lu */
+  HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK,		/* Mc */
+  HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK,		/* Me */
+  HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK,		/* Mn */
+  HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER,		/* Nd */
+  HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER,		/* Nl */
+  HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER,		/* No */
+  HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION,	/* Pc */
+  HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION,		/* Pd */
+  HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION,	/* Pe */
+  HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION,	/* Pf */
+  HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION,	/* Pi */
+  HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION,	/* Po */
+  HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION,		/* Ps */
+  HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL,		/* Sc */
+  HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL,		/* Sk */
+  HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL,		/* Sm */
+  HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL,		/* So */
+  HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR,		/* Zl */
+  HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR,	/* Zp */
+  HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR		/* Zs */
+} hb_unicode_general_category_t;
+
+/* hb_unicode_combining_class_t */
+
+/* Note: newer versions of Unicode may add new values.  Clients should be ready to handle
+ * any value in the 0..254 range being returned from hb_unicode_combining_class().
+ */
+
+/* Unicode Character Database property: Canonical_Combining_Class (ccc) */
+typedef enum
+{
+  HB_UNICODE_COMBINING_CLASS_NOT_REORDERED	= 0,
+  HB_UNICODE_COMBINING_CLASS_OVERLAY		= 1,
+  HB_UNICODE_COMBINING_CLASS_NUKTA		= 7,
+  HB_UNICODE_COMBINING_CLASS_KANA_VOICING	= 8,
+  HB_UNICODE_COMBINING_CLASS_VIRAMA		= 9,
+
+  /* Hebrew */
+  HB_UNICODE_COMBINING_CLASS_CCC10	=  10,
+  HB_UNICODE_COMBINING_CLASS_CCC11	=  11,
+  HB_UNICODE_COMBINING_CLASS_CCC12	=  12,
+  HB_UNICODE_COMBINING_CLASS_CCC13	=  13,
+  HB_UNICODE_COMBINING_CLASS_CCC14	=  14,
+  HB_UNICODE_COMBINING_CLASS_CCC15	=  15,
+  HB_UNICODE_COMBINING_CLASS_CCC16	=  16,
+  HB_UNICODE_COMBINING_CLASS_CCC17	=  17,
+  HB_UNICODE_COMBINING_CLASS_CCC18	=  18,
+  HB_UNICODE_COMBINING_CLASS_CCC19	=  19,
+  HB_UNICODE_COMBINING_CLASS_CCC20	=  20,
+  HB_UNICODE_COMBINING_CLASS_CCC21	=  21,
+  HB_UNICODE_COMBINING_CLASS_CCC22	=  22,
+  HB_UNICODE_COMBINING_CLASS_CCC23	=  23,
+  HB_UNICODE_COMBINING_CLASS_CCC24	=  24,
+  HB_UNICODE_COMBINING_CLASS_CCC25	=  25,
+  HB_UNICODE_COMBINING_CLASS_CCC26	=  26,
+
+  /* Arabic */
+  HB_UNICODE_COMBINING_CLASS_CCC27	=  27,
+  HB_UNICODE_COMBINING_CLASS_CCC28	=  28,
+  HB_UNICODE_COMBINING_CLASS_CCC29	=  29,
+  HB_UNICODE_COMBINING_CLASS_CCC30	=  30,
+  HB_UNICODE_COMBINING_CLASS_CCC31	=  31,
+  HB_UNICODE_COMBINING_CLASS_CCC32	=  32,
+  HB_UNICODE_COMBINING_CLASS_CCC33	=  33,
+  HB_UNICODE_COMBINING_CLASS_CCC34	=  34,
+  HB_UNICODE_COMBINING_CLASS_CCC35	=  35,
+
+  /* Syriac */
+  HB_UNICODE_COMBINING_CLASS_CCC36	=  36,
+
+  /* Telugu */
+  HB_UNICODE_COMBINING_CLASS_CCC84	=  84,
+  HB_UNICODE_COMBINING_CLASS_CCC91	=  91,
+
+  /* Thai */
+  HB_UNICODE_COMBINING_CLASS_CCC103	= 103,
+  HB_UNICODE_COMBINING_CLASS_CCC107	= 107,
+
+  /* Lao */
+  HB_UNICODE_COMBINING_CLASS_CCC118	= 118,
+  HB_UNICODE_COMBINING_CLASS_CCC122	= 122,
+
+  /* Tibetan */
+  HB_UNICODE_COMBINING_CLASS_CCC129	= 129,
+  HB_UNICODE_COMBINING_CLASS_CCC130	= 130,
+  HB_UNICODE_COMBINING_CLASS_CCC133	= 132,
+
+
+  HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT	= 200,
+  HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW		= 202,
+  HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE		= 214,
+  HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT	= 216,
+  HB_UNICODE_COMBINING_CLASS_BELOW_LEFT			= 218,
+  HB_UNICODE_COMBINING_CLASS_BELOW			= 220,
+  HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT		= 222,
+  HB_UNICODE_COMBINING_CLASS_LEFT			= 224,
+  HB_UNICODE_COMBINING_CLASS_RIGHT			= 226,
+  HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT			= 228,
+  HB_UNICODE_COMBINING_CLASS_ABOVE			= 230,
+  HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT		= 232,
+  HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW		= 233,
+  HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE		= 234,
+
+  HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT		= 240,
+
+  HB_UNICODE_COMBINING_CLASS_INVALID	= 255
+} hb_unicode_combining_class_t;
+
+
 /*
  * hb_unicode_funcs_t
  */
 
-typedef struct _hb_unicode_funcs_t hb_unicode_funcs_t;
+typedef struct hb_unicode_funcs_t hb_unicode_funcs_t;
 
 
 /*
  * just give me the best implementation you've got there.
  */
 hb_unicode_funcs_t *
 hb_unicode_funcs_get_default (void);
 
@@ -90,17 +214,17 @@ hb_unicode_funcs_get_parent (hb_unicode_
 
 
 /*
  * funcs
  */
 
 /* typedefs */
 
-typedef unsigned int			(*hb_unicode_combining_class_func_t)	(hb_unicode_funcs_t *ufuncs,
+typedef hb_unicode_combining_class_t	(*hb_unicode_combining_class_func_t)	(hb_unicode_funcs_t *ufuncs,
 										 hb_codepoint_t      unicode,
 										 void               *user_data);
 typedef unsigned int			(*hb_unicode_eastasian_width_func_t)	(hb_unicode_funcs_t *ufuncs,
 										 hb_codepoint_t      unicode,
 										 void               *user_data);
 typedef hb_unicode_general_category_t	(*hb_unicode_general_category_func_t)	(hb_unicode_funcs_t *ufuncs,
 										 hb_codepoint_t      unicode,
 										 void               *user_data);
@@ -117,16 +241,42 @@ typedef hb_bool_t			(*hb_unicode_compose
 										 hb_codepoint_t     *ab,
 										 void               *user_data);
 typedef hb_bool_t			(*hb_unicode_decompose_func_t)		(hb_unicode_funcs_t *ufuncs,
 										 hb_codepoint_t      ab,
 										 hb_codepoint_t     *a,
 										 hb_codepoint_t     *b,
 										 void               *user_data);
 
+/**
+ * hb_unicode_decompose_compatibility_func_t:
+ * @ufuncs: Unicode function structure
+ * @u: codepoint to decompose
+ * @decomposed: address of codepoint array (of length %HB_UNICODE_MAX_DECOMPOSITION_LEN) to write decomposition into
+ * @user_data: user data pointer as passed to hb_unicode_funcs_set_decompose_compatibility_func()
+ *
+ * Fully decompose @u to its Unicode compatibility decomposition. The codepoints of the decomposition will be written to @decomposed.
+ * The complete length of the decomposition will be returned.
+ *
+ * If @u has no compatibility decomposition, zero should be returned.
+ *
+ * The Unicode standard guarantees that a buffer of length %HB_UNICODE_MAX_DECOMPOSITION_LEN codepoints will always be sufficient for any
+ * compatibility decomposition plus an terminating value of 0.  Consequently, @decompose must be allocated by the caller to be at least this length.  Implementations
+ * of this function type must ensure that they do not write past the provided array.
+ *
+ * Return value: number of codepoints in the full compatibility decomposition of @u, or 0 if no decomposition available.
+ */
+typedef unsigned int			(*hb_unicode_decompose_compatibility_func_t)	(hb_unicode_funcs_t *ufuncs,
+											 hb_codepoint_t      u,
+											 hb_codepoint_t     *decomposed,
+											 void               *user_data);
+
+/* See Unicode 6.1 for details on the maximum decomposition length. */
+#define HB_UNICODE_MAX_DECOMPOSITION_LEN (18+1) /* codepoints */
+
 /* setters */
 
 void
 hb_unicode_funcs_set_combining_class_func (hb_unicode_funcs_t *ufuncs,
 					   hb_unicode_combining_class_func_t combining_class_func,
 					   void *user_data, hb_destroy_func_t destroy);
 
 void
@@ -154,20 +304,24 @@ hb_unicode_funcs_set_compose_func (hb_un
 				   hb_unicode_compose_func_t compose_func,
 				   void *user_data, hb_destroy_func_t destroy);
 
 void
 hb_unicode_funcs_set_decompose_func (hb_unicode_funcs_t *ufuncs,
 				     hb_unicode_decompose_func_t decompose_func,
 				     void *user_data, hb_destroy_func_t destroy);
 
+void
+hb_unicode_funcs_set_decompose_compatibility_func (hb_unicode_funcs_t *ufuncs,
+						   hb_unicode_decompose_compatibility_func_t decompose_compatibility_func,
+						   void *user_data, hb_destroy_func_t destroy);
 
 /* accessors */
 
-unsigned int
+hb_unicode_combining_class_t
 hb_unicode_combining_class (hb_unicode_funcs_t *ufuncs,
 			    hb_codepoint_t unicode);
 
 unsigned int
 hb_unicode_eastasian_width (hb_unicode_funcs_t *ufuncs,
 			    hb_codepoint_t unicode);
 
 hb_unicode_general_category_t
@@ -188,11 +342,16 @@ hb_unicode_compose (hb_unicode_funcs_t *
 		    hb_codepoint_t      b,
 		    hb_codepoint_t     *ab);
 hb_bool_t
 hb_unicode_decompose (hb_unicode_funcs_t *ufuncs,
 		      hb_codepoint_t      ab,
 		      hb_codepoint_t     *a,
 		      hb_codepoint_t     *b);
 
+unsigned int
+hb_unicode_decompose_compatibility (hb_unicode_funcs_t *ufuncs,
+				    hb_codepoint_t      u,
+				    hb_codepoint_t     *decomposed);
+
 HB_END_DECLS
 
 #endif /* HB_UNICODE_H */
diff --git a/gfx/harfbuzz/src/hb-uniscribe.cc b/gfx/harfbuzz/src/hb-uniscribe.cc
--- a/gfx/harfbuzz/src/hb-uniscribe.cc
+++ b/gfx/harfbuzz/src/hb-uniscribe.cc
@@ -1,10 +1,10 @@
 /*
- * Copyright © 2011  Google, Inc.
+ * Copyright © 2011,2012  Google, Inc.
  *
  *  This is part of HarfBuzz, a text shaping library.
  *
  * Permission is hereby granted, without written agreement and without
  * license or royalty fees, to use, copy, modify, and distribute this
  * software and its documentation for any purpose, provided that the
  * above copyright notice and the following two paragraphs appear in
  * all copies of this software.
@@ -19,252 +19,254 @@
  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  *
  * Google Author(s): Behdad Esfahbod
  */
 
-#define _WIN32_WINNT 0x0500
+#define _WIN32_WINNT 0x0600
 
-#include "hb-private.hh"
+#define HB_SHAPER uniscribe
+#include "hb-shaper-impl-private.hh"
 
 #include <windows.h>
 #include <usp10.h>
 
 typedef ULONG WIN_ULONG;
 
 #include "hb-uniscribe.h"
 
 #include "hb-ot-name-table.hh"
 #include "hb-ot-tag.h"
 
-#include "hb-font-private.hh"
-#include "hb-buffer-private.hh"
-
-
 
 #ifndef HB_DEBUG_UNISCRIBE
 #define HB_DEBUG_UNISCRIBE (HB_DEBUG+0)
 #endif
 
 
 /*
 DWORD GetFontData(
   __in   HDC hdc,
   __in   DWORD dwTable,
   __in   DWORD dwOffset,
   __out  LPVOID lpvBuffer,
   __in   DWORD cbData
 );
 */
 
+
+HB_SHAPER_DATA_ENSURE_DECLARE(uniscribe, face)
+HB_SHAPER_DATA_ENSURE_DECLARE(uniscribe, font)
+
+
+/*
+ * shaper face data
+ */
+
+struct hb_uniscribe_shaper_face_data_t {
+  HANDLE fh;
+};
+
+hb_uniscribe_shaper_face_data_t *
+_hb_uniscribe_shaper_face_data_create (hb_face_t *face)
+{
+  hb_uniscribe_shaper_face_data_t *data = (hb_uniscribe_shaper_face_data_t *) calloc (1, sizeof (hb_uniscribe_shaper_face_data_t));
+  if (unlikely (!data))
+    return NULL;
+
+  hb_blob_t *blob = hb_face_reference_blob (face);
+  unsigned int blob_length;
+  const char *blob_data = hb_blob_get_data (blob, &blob_length);
+  if (unlikely (!blob_length))
+    DEBUG_MSG (UNISCRIBE, face, "Face has empty blob");
+
+  DWORD num_fonts_installed;
+  data->fh = AddFontMemResourceEx ((void *) blob_data, blob_length, 0, &num_fonts_installed);
+  hb_blob_destroy (blob);
+  if (unlikely (!data->fh)) {
+    DEBUG_MSG (UNISCRIBE, face, "Face AddFontMemResourceEx() failed");
+    free (data);
+    return NULL;
+  }
+
+  return data;
+}
+
+void
+_hb_uniscribe_shaper_face_data_destroy (hb_uniscribe_shaper_face_data_t *data)
+{
+  RemoveFontMemResourceEx (data->fh);
+  free (data);
+}
+
+
+/*
+ * shaper font data
+ */
+
+struct hb_uniscribe_shaper_font_data_t {
+  HDC hdc;
+  LOGFONTW log_font;
+  HFONT hfont;
+  SCRIPT_CACHE script_cache;
+};
+
 static bool
 populate_log_font (LOGFONTW  *lf,
-		   HDC        hdc,
 		   hb_font_t *font)
 {
   memset (lf, 0, sizeof (*lf));
-  int dpi = GetDeviceCaps (hdc, LOGPIXELSY);
   lf->lfHeight = -font->y_scale;
+  lf->lfCharSet = DEFAULT_CHARSET;
 
   hb_blob_t *blob = Sanitizer<name>::sanitize (hb_face_reference_table (font->face, HB_TAG ('n','a','m','e')));
   const name *name_table = Sanitizer<name>::lock_instance (blob);
   unsigned int len = name_table->get_name (3, 1, 0x409, 4,
 					   lf->lfFaceName,
 					   sizeof (lf->lfFaceName[0]) * LF_FACESIZE)
 					  / sizeof (lf->lfFaceName[0]);
   hb_blob_destroy (blob);
 
   if (unlikely (!len)) {
     DEBUG_MSG (UNISCRIBE, NULL, "Didn't find English name table entry");
-    return FALSE;
+    return false;
   }
   if (unlikely (len >= LF_FACESIZE)) {
     DEBUG_MSG (UNISCRIBE, NULL, "Font name too long");
-    return FALSE;
+    return false;
   }
 
   for (unsigned int i = 0; i < len; i++)
     lf->lfFaceName[i] = hb_be_uint16 (lf->lfFaceName[i]);
   lf->lfFaceName[len] = 0;
 
-  return TRUE;
+  return true;
 }
 
+hb_uniscribe_shaper_font_data_t *
+_hb_uniscribe_shaper_font_data_create (hb_font_t *font)
+{
+  if (unlikely (!hb_uniscribe_shaper_face_data_ensure (font->face))) return NULL;
 
-static hb_user_data_key_t hb_uniscribe_data_key;
+  hb_uniscribe_shaper_font_data_t *data = (hb_uniscribe_shaper_font_data_t *) calloc (1, sizeof (hb_uniscribe_shaper_font_data_t));
+  if (unlikely (!data))
+    return NULL;
 
+  data->hdc = GetDC (NULL);
 
-static struct hb_uniscribe_face_data_t {
-  HANDLE fh;
-} _hb_uniscribe_face_data_nil = {0};
+  if (unlikely (!populate_log_font (&data->log_font, font))) {
+    DEBUG_MSG (UNISCRIBE, font, "Font populate_log_font() failed");
+    _hb_uniscribe_shaper_font_data_destroy (data);
+    return NULL;
+  }
 
-static void
-_hb_uniscribe_face_data_destroy (hb_uniscribe_face_data_t *data)
-{
-  if (data->fh)
-    RemoveFontMemResourceEx (data->fh);
-  free (data);
-}
+  data->hfont = CreateFontIndirectW (&data->log_font);
+  if (unlikely (!data->hfont)) {
+    DEBUG_MSG (UNISCRIBE, font, "Font CreateFontIndirectW() failed");
+    _hb_uniscribe_shaper_font_data_destroy (data);
+     return NULL;
+  }
 
-static hb_uniscribe_face_data_t *
-_hb_uniscribe_face_get_data (hb_face_t *face)
-{
-  hb_uniscribe_face_data_t *data = (hb_uniscribe_face_data_t *) hb_face_get_user_data (face, &hb_uniscribe_data_key);
-  if (likely (data)) return data;
-
-  data = (hb_uniscribe_face_data_t *) calloc (1, sizeof (hb_uniscribe_face_data_t));
-  if (unlikely (!data))
-    return &_hb_uniscribe_face_data_nil;
-
-
-  hb_blob_t *blob = hb_face_reference_blob (face);
-  unsigned int blob_length;
-  const char *blob_data = hb_blob_get_data (blob, &blob_length);
-  if (unlikely (!blob_length))
-    DEBUG_MSG (UNISCRIBE, face, "Face has empty blob");
-
-  DWORD num_fonts_installed;
-  data->fh = AddFontMemResourceEx ((void *) blob_data, blob_length, 0, &num_fonts_installed);
-  hb_blob_destroy (blob);
-  if (unlikely (!data->fh))
-    DEBUG_MSG (UNISCRIBE, face, "Face AddFontMemResourceEx() failed");
-
-
-  if (unlikely (!hb_face_set_user_data (face, &hb_uniscribe_data_key, data,
-					(hb_destroy_func_t) _hb_uniscribe_face_data_destroy,
-					FALSE)))
-  {
-    _hb_uniscribe_face_data_destroy (data);
-    data = (hb_uniscribe_face_data_t *) hb_face_get_user_data (face, &hb_uniscribe_data_key);
-    if (data)
-      return data;
-    else
-      return &_hb_uniscribe_face_data_nil;
+  if (!SelectObject (data->hdc, data->hfont)) {
+    DEBUG_MSG (UNISCRIBE, font, "Font SelectObject() failed");
+    _hb_uniscribe_shaper_font_data_destroy (data);
+     return NULL;
   }
 
   return data;
 }
 
-
-static struct hb_uniscribe_font_data_t {
-  HDC hdc;
-  LOGFONTW log_font;
-  HFONT hfont;
-  SCRIPT_CACHE script_cache;
-} _hb_uniscribe_font_data_nil = {NULL, NULL, NULL};
-
-static void
-_hb_uniscribe_font_data_destroy (hb_uniscribe_font_data_t *data)
+void
+_hb_uniscribe_shaper_font_data_destroy (hb_uniscribe_shaper_font_data_t *data)
 {
   if (data->hdc)
     ReleaseDC (NULL, data->hdc);
   if (data->hfont)
     DeleteObject (data->hfont);
   if (data->script_cache)
     ScriptFreeCache (&data->script_cache);
   free (data);
 }
 
-static hb_uniscribe_font_data_t *
-_hb_uniscribe_font_get_data (hb_font_t *font)
+
+/*
+ * shaper shape_plan data
+ */
+
+struct hb_uniscribe_shaper_shape_plan_data_t {};
+
+hb_uniscribe_shaper_shape_plan_data_t *
+_hb_uniscribe_shaper_shape_plan_data_create (hb_shape_plan_t    *shape_plan,
+					     const hb_feature_t *user_features,
+					     unsigned int        num_user_features)
 {
-  hb_uniscribe_font_data_t *data = (hb_uniscribe_font_data_t *) hb_font_get_user_data (font, &hb_uniscribe_data_key);
-  if (likely (data)) return data;
+  return (hb_uniscribe_shaper_shape_plan_data_t *) HB_SHAPER_DATA_SUCCEEDED;
+}
 
-  data = (hb_uniscribe_font_data_t *) calloc (1, sizeof (hb_uniscribe_font_data_t));
-  if (unlikely (!data))
-    return &_hb_uniscribe_font_data_nil;
+void
+_hb_uniscribe_shaper_shape_plan_data_destroy (hb_uniscribe_shaper_shape_plan_data_t *data)
+{
+}
 
-  data->hdc = GetDC (NULL);
 
-  if (unlikely (!populate_log_font (&data->log_font, data->hdc, font)))
-    DEBUG_MSG (UNISCRIBE, font, "Font populate_log_font() failed");
-  else {
-    data->hfont = CreateFontIndirectW (&data->log_font);
-    if (unlikely (!data->hfont))
-      DEBUG_MSG (UNISCRIBE, font, "Font CreateFontIndirectW() failed");
-    if (!SelectObject (data->hdc, data->hfont))
-      DEBUG_MSG (UNISCRIBE, font, "Font SelectObject() failed");
-  }
-
-  if (unlikely (!hb_font_set_user_data (font, &hb_uniscribe_data_key, data,
-					(hb_destroy_func_t) _hb_uniscribe_font_data_destroy,
-					FALSE)))
-  {
-    _hb_uniscribe_font_data_destroy (data);
-    data = (hb_uniscribe_font_data_t *) hb_font_get_user_data (font, &hb_uniscribe_data_key);
-    if (data)
-      return data;
-    else
-      return &_hb_uniscribe_font_data_nil;
-  }
-
-  return data;
-}
+/*
+ * shaper
+ */
 
 LOGFONTW *
 hb_uniscribe_font_get_logfontw (hb_font_t *font)
 {
-  hb_uniscribe_font_data_t *font_data = _hb_uniscribe_font_get_data (font);
-  if (unlikely (!font_data))
+  if (unlikely (!hb_uniscribe_shaper_font_data_ensure (font))) return NULL;
     return NULL;
+  hb_uniscribe_shaper_font_data_t *font_data =  HB_SHAPER_DATA_GET (font);
   return &font_data->log_font;
 }
 
 HFONT
 hb_uniscribe_font_get_hfont (hb_font_t *font)
 {
-  hb_uniscribe_font_data_t *font_data = _hb_uniscribe_font_get_data (font);
-  if (unlikely (!font_data))
-    return 0;
+  if (unlikely (!hb_uniscribe_shaper_font_data_ensure (font))) return NULL;
+  hb_uniscribe_shaper_font_data_t *font_data =  HB_SHAPER_DATA_GET (font);
   return font_data->hfont;
 }
 
 
 hb_bool_t
-_hb_uniscribe_shape (hb_font_t          *font,
+_hb_uniscribe_shape (hb_shape_plan_t    *shape_plan,
+		     hb_font_t          *font,
 		     hb_buffer_t        *buffer,
 		     const hb_feature_t *features,
 		     unsigned int        num_features)
 {
-  buffer->guess_properties ();
+  hb_face_t *face = font->face;
+  hb_uniscribe_shaper_face_data_t *face_data = HB_SHAPER_DATA_GET (face);
+  hb_uniscribe_shaper_font_data_t *font_data = HB_SHAPER_DATA_GET (font);
 
 #define FAIL(...) \
   HB_STMT_START { \
     DEBUG_MSG (UNISCRIBE, NULL, __VA_ARGS__); \
-    return FALSE; \
+    return false; \
   } HB_STMT_END;
 
-  hb_uniscribe_face_data_t *face_data = _hb_uniscribe_face_get_data (font->face);
-  if (unlikely (!face_data->fh))
-    FAIL ("Couldn't get face data");
-
-  hb_uniscribe_font_data_t *font_data = _hb_uniscribe_font_get_data (font);
-  if (unlikely (!font_data->hfont))
-    FAIL ("Couldn't get font font");
-
-  if (unlikely (!buffer->len))
-    return TRUE;
-
   HRESULT hr;
 
 retry:
 
   unsigned int scratch_size;
   char *scratch = (char *) buffer->get_scratch_buffer (&scratch_size);
 
   /* Allocate char buffers; they all fit */
 
 #define ALLOCATE_ARRAY(Type, name, len) \
   Type *name = (Type *) scratch; \
-  scratch += len * sizeof (name[0]); \
-  scratch_size -= len * sizeof (name[0]);
+  scratch += (len) * sizeof ((name)[0]); \
+  scratch_size -= (len) * sizeof ((name)[0]);
 
 #define utf16_index() var1.u32
 
   WCHAR *pchars = (WCHAR *) scratch;
   unsigned int chars_len = 0;
   for (unsigned int i = 0; i < buffer->len; i++) {
     hb_codepoint_t c = buffer->info[i].codepoint;
     buffer->info[i].utf16_index() = chars_len;
@@ -290,31 +292,32 @@ retry:
 					     sizeof (uint32_t));
 
   ALLOCATE_ARRAY (WORD, glyphs, glyphs_size);
   ALLOCATE_ARRAY (SCRIPT_GLYPHPROP, glyph_props, glyphs_size);
   ALLOCATE_ARRAY (int, advances, glyphs_size);
   ALLOCATE_ARRAY (GOFFSET, offsets, glyphs_size);
   ALLOCATE_ARRAY (uint32_t, vis_clusters, glyphs_size);
 
+#undef ALLOCATE_ARRAY
 
-#define MAX_ITEMS 10
+#define MAX_ITEMS 256
 
   SCRIPT_ITEM items[MAX_ITEMS + 1];
   SCRIPT_CONTROL bidi_control = {0};
   SCRIPT_STATE bidi_state = {0};
   WIN_ULONG script_tags[MAX_ITEMS];
   int item_count;
 
   /* MinGW32 doesn't define fMergeNeutralItems, so we bruteforce */
-  //bidi_control.fMergeNeutralItems = TRUE;
+  //bidi_control.fMergeNeutralItems = true;
   *(uint32_t*)&bidi_control |= 1<<24;
 
   bidi_state.uBidiLevel = HB_DIRECTION_IS_FORWARD (buffer->props.direction) ? 0 : 1;
-//  bidi_state.fOverrideDirection = 1;
+  bidi_state.fOverrideDirection = 1;
 
   hr = ScriptItemizeOpenType (wchars,
 			      chars_len,
 			      MAX_ITEMS,
 			      &bidi_control,
 			      &bidi_state,
 			      items,
 			      script_tags,
@@ -326,104 +329,113 @@ retry:
 
   int *range_char_counts = NULL;
   TEXTRANGE_PROPERTIES **range_properties = NULL;
   int range_count = 0;
   if (num_features) {
     /* TODO setup ranges */
   }
 
-  OPENTYPE_TAG language_tag = hb_ot_tag_from_language (buffer->props.language);
+  OPENTYPE_TAG language_tag = hb_uint32_swap (hb_ot_tag_from_language (buffer->props.language));
 
   unsigned int glyphs_offset = 0;
   unsigned int glyphs_len;
-  for (unsigned int i = 0; i < item_count; i++)
+  bool backward = HB_DIRECTION_IS_BACKWARD (buffer->props.direction);
+  for (unsigned int j = 0; j < item_count; j++)
   {
-      unsigned int chars_offset = items[i].iCharPos;
-      unsigned int item_chars_len = items[i + 1].iCharPos - chars_offset;
-      OPENTYPE_TAG script_tag = script_tags[i]; /* XXX buffer->props.script */
+    unsigned int i = backward ? item_count - 1 - j : j;
+    unsigned int chars_offset = items[i].iCharPos;
+    unsigned int item_chars_len = items[i + 1].iCharPos - chars_offset;
 
-      hr = ScriptShapeOpenType (font_data->hdc,
-				&font_data->script_cache,
-				&items[i].a,
-				script_tag,
-				language_tag,
-				range_char_counts,
-				range_properties,
-				range_count,
-				wchars + chars_offset,
-				item_chars_len,
-				glyphs_size - glyphs_offset,
-				/* out */
-				log_clusters + chars_offset,
-				char_props + chars_offset,
-				glyphs + glyphs_offset,
-				glyph_props + glyphs_offset,
-				(int *) &glyphs_len);
+  retry_shape:
+    hr = ScriptShapeOpenType (font_data->hdc,
+			      &font_data->script_cache,
+			      &items[i].a,
+			      script_tags[i],
+			      language_tag,
+			      range_char_counts,
+			      range_properties,
+			      range_count,
+			      wchars + chars_offset,
+			      item_chars_len,
+			      glyphs_size - glyphs_offset,
+			      /* out */
+			      log_clusters + chars_offset,
+			      char_props + chars_offset,
+			      glyphs + glyphs_offset,
+			      glyph_props + glyphs_offset,
+			      (int *) &glyphs_len);
 
-      for (unsigned int j = chars_offset; j < chars_offset + item_chars_len; j++)
-        log_clusters[j] += glyphs_offset;
+    if (unlikely (items[i].a.fNoGlyphIndex))
+      FAIL ("ScriptShapeOpenType() set fNoGlyphIndex");
+    if (unlikely (hr == E_OUTOFMEMORY))
+    {
+      buffer->ensure (buffer->allocated * 2);
+      if (buffer->in_error)
+	FAIL ("Buffer resize failed");
+      goto retry;
+    }
+    if (unlikely (hr == USP_E_SCRIPT_NOT_IN_FONT))
+    {
+      if (items[i].a.eScript == SCRIPT_UNDEFINED)
+	FAIL ("ScriptShapeOpenType() failed: Font doesn't support script");
+      items[i].a.eScript = SCRIPT_UNDEFINED;
+      goto retry_shape;
+    }
+    if (unlikely (FAILED (hr)))
+    {
+      FAIL ("ScriptShapeOpenType() failed: 0x%08xL", hr);
+    }
 
-      if (unlikely (items[i].a.fNoGlyphIndex))
-	FAIL ("ScriptShapeOpenType() set fNoGlyphIndex");
-      if (unlikely (hr == E_OUTOFMEMORY))
-      {
-        buffer->ensure (buffer->allocated * 2);
-	if (buffer->in_error)
-	  FAIL ("Buffer resize failed");
-	goto retry;
-      }
-      if (unlikely (hr == USP_E_SCRIPT_NOT_IN_FONT))
-	FAIL ("ScriptShapeOpenType() failed: Font doesn't support script");
-      if (unlikely (FAILED (hr)))
-	FAIL ("ScriptShapeOpenType() failed: 0x%08xL", hr);
+    for (unsigned int j = chars_offset; j < chars_offset + item_chars_len; j++)
+      log_clusters[j] += glyphs_offset;
 
-      hr = ScriptPlaceOpenType (font_data->hdc,
-				&font_data->script_cache,
-				&items[i].a,
-				script_tag,
-				language_tag,
-				range_char_counts,
-				range_properties,
-				range_count,
-				wchars + chars_offset,
-				log_clusters + chars_offset,
-				char_props + chars_offset,
-				item_chars_len,
-				glyphs + glyphs_offset,
-				glyph_props + glyphs_offset,
-				glyphs_len,
-				/* out */
-				advances + glyphs_offset,
-				offsets + glyphs_offset,
-				NULL);
-      if (unlikely (FAILED (hr)))
-	FAIL ("ScriptPlaceOpenType() failed: 0x%08xL", hr);
+    hr = ScriptPlaceOpenType (font_data->hdc,
+			      &font_data->script_cache,
+			      &items[i].a,
+			      script_tags[i],
+			      language_tag,
+			      range_char_counts,
+			      range_properties,
+			      range_count,
+			      wchars + chars_offset,
+			      log_clusters + chars_offset,
+			      char_props + chars_offset,
+			      item_chars_len,
+			      glyphs + glyphs_offset,
+			      glyph_props + glyphs_offset,
+			      glyphs_len,
+			      /* out */
+			      advances + glyphs_offset,
+			      offsets + glyphs_offset,
+			      NULL);
+    if (unlikely (FAILED (hr)))
+      FAIL ("ScriptPlaceOpenType() failed: 0x%08xL", hr);
 
-      glyphs_offset += glyphs_len;
+    glyphs_offset += glyphs_len;
   }
   glyphs_len = glyphs_offset;
 
   /* Ok, we've got everything we need, now compose output buffer,
    * very, *very*, carefully! */
 
   /* Calculate visual-clusters.  That's what we ship. */
   for (unsigned int i = 0; i < glyphs_len; i++)
     vis_clusters[i] = -1;
   for (unsigned int i = 0; i < buffer->len; i++) {
     uint32_t *p = &vis_clusters[log_clusters[buffer->info[i].utf16_index()]];
     *p = MIN (*p, buffer->info[i].cluster);
   }
-  if (HB_DIRECTION_IS_FORWARD (buffer->props.direction)) {
+  if (!backward) {
     for (unsigned int i = 1; i < glyphs_len; i++)
-      if (!glyph_props[i].sva.fClusterStart)
+      if (vis_clusters[i] == -1)
 	vis_clusters[i] = vis_clusters[i - 1];
   } else {
     for (int i = glyphs_len - 2; i >= 0; i--)
-      if (!glyph_props[i].sva.fClusterStart)
+      if (vis_clusters[i] == -1)
 	vis_clusters[i] = vis_clusters[i + 1];
   }
 
 #undef utf16_index
 
   buffer->ensure (glyphs_len);
   if (buffer->in_error)
     FAIL ("Buffer in error");
@@ -454,12 +466,12 @@ retry:
 
     /* TODO vertical */
     pos->x_advance = info->mask;
     pos->x_offset = info->var1.u32;
     pos->y_offset = info->var2.u32;
   }
 
   /* Wow, done! */
-  return TRUE;
+  return true;
 }
 
 
diff --git a/gfx/harfbuzz/src/hb-uniscribe.h b/gfx/harfbuzz/src/hb-uniscribe.h
--- a/gfx/harfbuzz/src/hb-uniscribe.h
+++ b/gfx/harfbuzz/src/hb-uniscribe.h
@@ -24,17 +24,17 @@
  * Google Author(s): Behdad Esfahbod
  */
 
 #ifndef HB_UNISCRIBE_H
 #define HB_UNISCRIBE_H
 
 #include "hb.h"
 
-#define _WIN32_WINNT 0x0500
+#define _WIN32_WINNT 0x0600
 #include <windows.h>
 
 HB_BEGIN_DECLS
 
 
 LOGFONTW *
 hb_uniscribe_font_get_logfontw (hb_font_t *font);
 
diff --git a/gfx/harfbuzz/src/hb-warning.cc b/gfx/harfbuzz/src/hb-warning.cc
--- a/gfx/harfbuzz/src/hb-warning.cc
+++ b/gfx/harfbuzz/src/hb-warning.cc
@@ -23,31 +23,25 @@
  *
  * Google Author(s): Behdad Esfahbod
  */
 
 #include "hb-atomic-private.hh"
 #include "hb-mutex-private.hh"
 
 
-#if !defined(HB_NO_MT) && defined(HB_ATOMIC_INT_NIL)
-#ifdef _MSC_VER
-#pragma message("Could not find any system to define atomic_int macros, library will NOT be thread-safe")
-#else
-#warning "Could not find any system to define atomic_int macros, library will NOT be thread-safe"
+#if defined(HB_ATOMIC_INT_NIL)
+#pragma message("Could not find any system to define atomic_int macros, library may NOT be thread-safe.")
 #endif
+#if defined(HB_MUTEX_IMPL_NIL)
+#pragma message("Could not find any system to define mutex macros, library may NOT be thread-safe.")
+#endif
+#if defined(HB_ATOMIC_INT_NIL) || defined(HB_MUTEX_IMPL_NIL)
+#pragma message("To suppress these warnings, define HB_NO_MT.")
 #endif
 
-#if !defined(HB_NO_MT) && defined(HB_MUTEX_IMPL_NIL)
-#ifdef _MSC_VER
-#pragma message("Could not find any system to define mutex macros, library will NOT be thread-safe")
-#else
-#warning "Could not find any system to define mutex macros, library will NOT be thread-safe"
+
+#include "hb-unicode-private.hh"
+
+#if !defined(HB_NO_UNICODE_FUNCS) && defined(HB_UNICODE_FUNCS_NIL)
+#pragma message("Could not find any Unicode functions implementation, you have to provide your own.")
+#pragma message("To suppress this warnings, define HB_NO_UNICODE_FUNCS.")
 #endif
-#endif
-
-#if !defined(HB_NO_MT) && (defined(HB_ATOMIC_INT_NIL) || defined(HB_MUTEX_IMPL_NIL))
-#ifdef _MSC_VER
-#pragma message("To suppress these warnings, define HB_NO_MT")
-#else
-#warning "To suppress these warnings, define HB_NO_MT"
-#endif
-#endif
diff --git a/gfx/harfbuzz/src/indic.cc b/gfx/harfbuzz/src/indic.cc
--- a/gfx/harfbuzz/src/indic.cc
+++ b/gfx/harfbuzz/src/indic.cc
@@ -34,13 +34,18 @@ main (void)
   printf ("There are split matras without a Unicode decomposition:\n");
   for (hb_codepoint_t u = 0; u < 0x110000; u++)
   {
     unsigned int type = get_indic_categories (u);
 
     unsigned int category = type & 0x0F;
     unsigned int position = type >> 4;
 
-    hb_codepoint_t a, b;
-    if (!hb_unicode_decompose (funcs, u, &a, &b))
-      printf ("U+%04X\n", u);
+    hb_unicode_general_category_t cat = hb_unicode_general_category (funcs, u);
+    unsigned int ccc = hb_unicode_combining_class (funcs, u);
+    if (category == OT_M && ccc)
+      printf ("U+%04X %d\n", u, ccc);
+
+//    hb_codepoint_t a, b;
+//    if (!hb_unicode_decompose (funcs, u, &a, &b))
+//      printf ("U+%04X %x %x\n", u, category, position);
   }
 }
diff --git a/gfx/harfbuzz/src/main.cc b/gfx/harfbuzz/src/main.cc
--- a/gfx/harfbuzz/src/main.cc
+++ b/gfx/harfbuzz/src/main.cc
@@ -44,17 +44,17 @@ main (int argc, char **argv)
     fprintf (stderr, "usage: %s font-file.ttf\n", argv[0]);
     exit (1);
   }
 
   const char *font_data = NULL;
   int len = 0;
 
 #ifdef HAVE_GLIB
-  GMappedFile *mf = g_mapped_file_new (argv[1], FALSE, NULL);
+  GMappedFile *mf = g_mapped_file_new (argv[1], false, NULL);
   font_data = g_mapped_file_get_contents (mf);
   len = g_mapped_file_get_length (mf);
 #else
   FILE *f = fopen (argv[1], "rb");
   fseek (f, 0, SEEK_END);
   len = ftell (f);
   fseek (f, 0, SEEK_SET);
   font_data = (const char *) malloc (len);
diff --git a/gfx/harfbuzz/src/test-would-substitute.cc b/gfx/harfbuzz/src/test-would-substitute.cc
new file mode 100644
--- /dev/null
+++ b/gfx/harfbuzz/src/test-would-substitute.cc
@@ -0,0 +1,94 @@
+/*
+ * Copyright © 2010,2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "hb.h"
+#include "hb-ot.h"
+
+#ifdef HAVE_GLIB
+#include <glib.h>
+#endif
+#include <stdlib.h>
+#include <stdio.h>
+
+#ifdef HAVE_FREETYPE
+#include "hb-ft.h"
+#endif
+
+int
+main (int argc, char **argv)
+{
+  hb_blob_t *blob = NULL;
+
+  if (argc != 4 && argc != 5) {
+    fprintf (stderr, "usage: %s font-file lookup-index first-glyph [second-glyph]\n", argv[0]);
+    exit (1);
+  }
+
+  /* Create the blob */
+  {
+    const char *font_data;
+    unsigned int len;
+    hb_destroy_func_t destroy;
+    void *user_data;
+    hb_memory_mode_t mm;
+
+#ifdef HAVE_GLIB
+    GMappedFile *mf = g_mapped_file_new (argv[1], false, NULL);
+    font_data = g_mapped_file_get_contents (mf);
+    len = g_mapped_file_get_length (mf);
+    destroy = (hb_destroy_func_t) g_mapped_file_unref;
+    user_data = (void *) mf;
+    mm = HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE;
+#else
+    FILE *f = fopen (argv[1], "rb");
+    fseek (f, 0, SEEK_END);
+    len = ftell (f);
+    fseek (f, 0, SEEK_SET);
+    font_data = (const char *) malloc (len);
+    if (!font_data) len = 0;
+    len = fread ((char *) font_data, 1, len, f);
+    destroy = free;
+    user_data = (void *) font_data;
+    fclose (f);
+    mm = HB_MEMORY_MODE_WRITABLE;
+#endif
+
+    blob = hb_blob_create (font_data, len, mm, user_data, destroy);
+  }
+
+  /* Create the face */
+  hb_face_t *face = hb_face_create (blob, 0 /* first face */);
+  hb_blob_destroy (blob);
+  blob = NULL;
+
+  unsigned int len = argc - 3;
+  hb_codepoint_t glyphs[2] = {strtol (argv[3], NULL, 0), argc > 4 ? strtol (argv[4], NULL, 0) : (hb_codepoint_t) -1};
+  return !hb_ot_layout_would_substitute_lookup (face, glyphs, len, strtol (argv[2], NULL, 0));
+}
diff --git a/gfx/harfbuzz/src/test.cc b/gfx/harfbuzz/src/test.cc
--- a/gfx/harfbuzz/src/test.cc
+++ b/gfx/harfbuzz/src/test.cc
@@ -54,17 +54,17 @@ main (int argc, char **argv)
   {
     const char *font_data;
     unsigned int len;
     hb_destroy_func_t destroy;
     void *user_data;
     hb_memory_mode_t mm;
 
 #ifdef HAVE_GLIB
-    GMappedFile *mf = g_mapped_file_new (argv[1], FALSE, NULL);
+    GMappedFile *mf = g_mapped_file_new (argv[1], false, NULL);
     font_data = g_mapped_file_get_contents (mf);
     len = g_mapped_file_get_length (mf);
     destroy = (hb_destroy_func_t) g_mapped_file_unref;
     user_data = (void *) mf;
     mm = HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE;
 #else
     FILE *f = fopen (argv[1], "rb");
     fseek (f, 0, SEEK_END);

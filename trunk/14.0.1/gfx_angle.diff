diff -r 91d3e124dee2 gfx/angle/CONTRIBUTORS
--- a/gfx/angle/CONTRIBUTORS	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/CONTRIBUTORS	Sat Jun 09 12:08:28 2012 +0900
@@ -39,6 +39,10 @@
 Apple Inc.
  David Kilzer
 
+Adobe Systems Inc.
+ Alexandru Chiculita
+ Max Vujovic
+
 Aitor Moreno <aitormoreno at gmail.com>
 Jim Hauxwell <james at dattrax.co.uk>
 ddefrostt
@@ -48,4 +52,5 @@
 Yuriy O'Donnell
 Sam Hocevar
 Pierre Leveille
+Jin Yang
 
diff -r 91d3e124dee2 gfx/angle/DEPS
--- a/gfx/angle/DEPS	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/DEPS	Sat Jun 09 12:08:28 2012 +0900
@@ -4,6 +4,9 @@
 
   "trunk/third_party/googletest":
       "http://googletest.googlecode.com/svn/trunk@573", #release 1.6.0
+
+  "trunk/third_party/googlemock":
+      "http://googlemock.googlecode.com/svn/trunk@387", #release 1.6.0
 }
 
 hooks = [
diff -r 91d3e124dee2 gfx/angle/Makefile.in
--- a/gfx/angle/Makefile.in	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/Makefile.in	Sat Jun 09 12:08:28 2012 +0900
@@ -61,9 +61,12 @@
 VPATH += $(srcdir)/src/compiler
 VPATH += $(srcdir)/src/compiler/preprocessor
 VPATH += $(srcdir)/src/compiler/preprocessor/new
+VPATH += $(srcdir)/src/compiler/timing
+VPATH += $(srcdir)/src/compiler/depgraph
 
 CPPSRCS = \
 	Compiler.cpp \
+	DetectDiscontinuity.cpp \
         DetectRecursion.cpp \
         InfoSink.cpp \
         Initialize.cpp \
@@ -112,6 +115,20 @@
         TranslatorESSL.cpp \
 	$(NULL)
 
+# depgraph
+CPPSRCS += \
+	DependencyGraph.cpp \
+	DependencyGraphBuilder.cpp \
+	DependencyGraphOutput.cpp \
+	DependencyGraphTraverse.cpp \
+	$(NULL)
+
+# Timing
+CPPSRCS += \
+	RestrictFragmentShaderTiming.cpp \
+	RestrictVertexShaderTiming.cpp \
+	$(NULL)
+
 # Currently, only one or the other
 # can be selected.
 
diff -r 91d3e124dee2 gfx/angle/extensions/ANGLE_depth_texture.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/extensions/ANGLE_depth_texture.txt	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,375 @@
+Name
+
+    ANGLE_depth_texture
+
+Name Strings
+
+    GL_ANGLE_depth_texture
+
+Contributors
+
+    Nicolas Capens, TransGaming
+    Kenneth Russell, Google
+    Vangelis Kokkevis, Google
+    Contributors to OES_depth_texture
+    Contributors to OES_packed_depth_stencil
+
+Contact
+
+    Daniel Koch, TransGaming (daniel 'at' transgaming.com)
+
+Status
+
+    Implemented in ANGLE.
+
+Version
+
+    Last Modifed Date: May 30, 2012
+    Revision: #2
+
+Number
+
+    TBD
+
+Dependencies
+
+    OpenGL ES 2.0 is required.
+    This extension is written against the OpenGL ES 2.0.25 specification
+
+    OES_packed_depth_stencil affects the definition of this extension.
+
+    EXT_texture_storage affects the definition of this extension.
+
+Overview
+
+    This extension defines support for 2D depth and depth-stencil
+    textures in an OpenGL ES implementation.
+
+    This extension incorporates the depth texturing functionality of 
+    OES_depth_texture and OES_packed_depth_stencil, but does not 
+    provide the ability to load existing data via TexImage2D or
+    TexSubImage2D. This extension also allows implementation 
+    variability in which components from a sampled depth texture
+    contain the depth data.
+
+New Procedures and Functions
+
+    None
+
+New Tokens
+
+    Accepted by the <format> parameter of TexImage2D and TexSubImage2D and
+    <internalformat> parameter of TexImage2D:
+    
+        DEPTH_COMPONENT             0x1902
+        DEPTH_STENCIL_OES           0x84F9
+        
+    Accepted by the <type> parameter of TexImage2D, TexSubImage2D: 
+
+        UNSIGNED_SHORT              0x1403
+        UNSIGNED_INT                0x1405
+        UNSIGNED_INT_24_8_OES       0x84FA
+
+    Accepted by the <internalformat> parameter of TexStorage2DEXT:
+
+        DEPTH_COMPONENT16           0x81A5
+        DEPTH_COMPONENT32_OES       0x81A7
+        DEPTH24_STENCIL8_OES        0x88F0
+
+Additions to Chapter 2 of the OpenGL ES 2.0 Specification (OpenGL Operation)
+
+    Update Section 2.10.5 "Shader Execution" in the subsection titled 
+    "Texture Access" add a new paragraph before the last paragraph add
+    this line:
+
+    "The stencil index texture internal component is ignored if the base
+    internal format is DEPTH_STENCIL_OES.
+
+    If a vertex shader uses..."
+
+Additions to Chapter 3 of the OpenGL ES 2.0 specification (Rasterizatoin)
+
+    Add the following rows to Table 3.2 (page 62):
+
+      type Parameter           GL Data Type    Special
+      ------------------------------------------------
+      ...                      ...              ...
+      UNSIGNED_SHORT           ushort           No
+      UNSIGNED_INT             uint             No
+      UNSIGNED_INT_24_8_OES    uint             Yes
+
+    Add the following rows to Table 3.3 (page 62):
+
+      Format Name       Element Meaning and Order      Target Buffer
+      ------------------------------------------------------------------
+      ...               ...                            ...
+      DEPTH_COMPONENT   Depth                          Depth
+      DEPTH_STENCIL_OES Depth and Stencil Index        Depth and Stencil
+      ...               ...                            ...
+
+    Add a row to Table 3.5 "Packed pixel formats" (page 64):
+
+      type Parameter               GL Type  Components  Pixel Formats
+      ------------------------------------------------------------------
+      ...                          ...      ...         ...
+      UNSIGNED_INT_24_8_OES        uint     2           DEPTH_STENCIL_OES
+
+    Add a new table after Table 3.6 (page 64):
+
+    UNSIGNED_INT_24_8_OES
+
+       31 30 29 28 27 26 ... 12 11 10 9 8 7 6 5 4 3 2 1 0
+      +----------------------------------+---------------+
+      |           1st Component          | 2nd Component |
+      +----------------------------------+---------------+
+
+      Table 3.6.B: UNSIGNED_INT formats
+
+    Add a row to Table 3.7 "Packed pixel field assignments" (page 65):
+
+      Format            |  1st     2nd     3rd     4th
+      ------------------+-------------------------------
+      ...               |  ...     ...     ...     ...
+      DEPTH_STENCIL_OES |  depth   stencil N/A     N/A
+
+    Add the following paragraph to the end of the section "Conversion to
+    floating-point" (page 65):
+
+    "For groups of components that contain both standard components and index
+    elements, such as DEPTH_STENCIL_OES, the index elements are not converted."
+
+    In section 3.7.1 "Texture Image Specification", update page 67 to
+    say:
+
+    "The selected groups are processed as described in section 3.6.2, stopping
+    just before final conversion.  Each R, G, B, A, or depth value so generated
+    is clamped to [0, 1], while the stencil index values are masked by 2^n-1,
+    where n is the number of stencil bits in the internal format resolution
+    (see below).
+
+    Components are then selected from the resulting R, G, B, A, depth, or
+    stencil index values to obtain a texture with the base internal format
+    specified by <internalformat>.  Table 3.8 summarizes the mapping of R, G,
+    B, A, depth, or stencil values to texture components, as a function of the
+    base internal format of the texture image.  <internalformat> may be
+    specified as one of the internal format symbolic constants listed in
+    table 3.8. Specifying a value for <internalformat> that is not one of the
+    above values generates the error INVALID_VALUE. If <internalformat> does
+    not match <format>, the error INVALID_OPERATION is generated.
+
+    Textures with a base internal format of DEPTH_COMPONENT or 
+    DEPTH_STENCIL_OES are supported by texture image specification commands
+    only if <target> is TEXTURE_2D.  Using these formats in conjunction with
+    any other <target> will result in an INVALID_OPERATION error.
+
+    Textures with a base internal format of DEPTH_COMPONENT or DEPTH_STENCIL_OES
+    require either depth component data or depth/stencil component data.
+    Textures with other base internal formats require RGBA component data.  The
+    error INVALID_OPERATION is generated if the base internal format is
+    DEPTH_COMPONENT or DEPTH_STENCIL_OES and <format> is not DEPTH_COMPONENT or
+    DEPTH_STENCIL_OES, or if the base internal format is not DEPTH_COMPONENT or
+    DEPTH_STENCIL_OES and <format> is DEPTH_COMPONENT or DEPTH_STENCIL_OES.
+
+    Textures with a base internal format of DEPTH_COMPONENT or
+    DEPTH_STENCIL_OES do not support loading image data via the TexImage
+    commands. They can only have their contents specified by rendering
+    to them. The INVALID_OPERATION error is generated by the TexImage2D
+    command if <data> is not NULL for such textures."
+
+    Add a row to table 3.8 (page 68), and update the title of the
+    second column:
+
+      Base Internal Format  RGBA, Depth and Stencil Values  Internal Components
+      -------------------------------------------------------------------------
+      ...                   ...                             ...
+      DEPTH_COMPONENT       Depth                           D
+      DEPTH_STENCIL_OES     Depth,Stencil                   D,S
+      ...                   ...                             ...
+
+    Update the caption for table 3.8 (page 68)
+
+    "Table 3.8: Conversion from RGBA, depth, and stencil pixel components to
+    internal texture components.  Texture components R, G, B, A, and L are 
+    converted back to RGBA colors during filtering as shown in table 3.12.
+    Texture components D are converted to RGBA colors as described in 
+    section 3.7.8-1/2."
+
+    Add the following to section 3.7.2 "Alternate Texture Image Specification
+    Commands":
+
+    "CopyTexImage2D and CopyTexSubImage2D generate the INVALID_OPERATION 
+    error if the base internal format of the destination texture is 
+    DEPTH_COMPONENT or DEPTH_STENCIL_OES.
+
+    TexSubImage2D generates the INVALID_OPERATION error if the base internal
+    format of the texture is DEPTH_COMPONENT or DEPTH_STENCIL_OES."
+
+    Add a new section between sections 3.7.8 and 3.7.9:
+
+    "3.7.8-1/2 Depth/Stencil Textures
+
+    If the currently bound texture's base internal format is DEPTH_COMPONENT or
+    DEPTH_STENCIL_OES, then the output of the texture unit is as described
+    below. Otherwise, the texture unit operates in the normal manner.
+
+    Let <D_t> be the depth texture value, provided by the shader's texture lookup
+    function. Then the effective texture value, <L_t> or <A_t> is computed
+    as follows:
+            <Tau> = <D_t>
+
+    If the texture image has a base internal format of DEPTH_STENCIL_OES, then
+    the stencil index texture component is ignored.  The texture value <Tau> does
+    not include a stencil index component, but includes only the depth
+    component.
+
+    The resulting <Tau> is assigned to <L_t>. In some implementations, 
+    <Tau> is also assigned to <A_t>. Thus in table 3.12, textures with
+    depth component data behave as if their base internal format is
+    either LUMINANCE or LUMINANCE_ALPHA."
+
+    Add the following to section 3.7.11 "Mipmap Generation":
+
+    "If the level zero array contains depth or depth-stencil data, the
+     error INVALID_OPERATION is generated."
+
+    Insert a new paragraph after the first paragraph of the "Texture Access"
+    subsection of section 3.8.2 on page 87, which says:
+
+    "Texture lookups involving textures with depth component data generate
+    a texture source color by using depth data directly, as described in
+    section 3.7.8-1/2.  The stencil texture internal component is ignored
+    if the base internal format is DEPTH_STENCIL_OES."
+
+Additions to Chapter 4 of the OpenGL ES 2.0 specification (Per-Fragment
+Operations and the Framebuffer)
+
+    In section 4.4.5 "Framebuffer Completeness", replace the the 3rd
+    paragraph with the following text:
+
+     "* An internal format is color-renderable if it is one of the formats
+        from table 4.5 noted as color-renderable or if it is unsized format
+        RGBA or RGB. No other formats, including compressed internal formats,
+        are color-renderable.
+
+      * An internal format is depth-renderable if it is one of the sized
+        internal formats from table 4.5 noted as depth-renderable, if it
+        is the unsized format DEPTH_COMPONENT or if it is the internal 
+        format value of DEPTH24_STENCIL8_OES. No other formats are 
+        depth-renderable.
+
+      * An internal format is stencil-renderable if it is one of the sized 
+        internal formats from table 4.5 noted as stencil-renderable or if it
+        is DEPTH24_STENCIL8_OES. No other formats are stencil-renderable."
+
+Additions to Chapter 5 of the OpenGL ES 2.0 Specification (Special
+Functions)
+
+    None.
+
+Additions to Chapter 6 of the OpenGL ES 2.0 Specification (State and State
+Requests)
+
+    None.
+
+Interactions with OES_packed_depth_stencil
+
+    If OES_packed_depth_stencil is not supported, mentions of
+    DEPTH_STENCIL_OES and UNSIGNED_INT_24_8_OES as a format/type combinations
+    for TexImage2D and TexSubImage2D are omitted. Mentions of
+    the internal format DEPTH24_STENCIL8_OES are also omitted.
+
+Interactions with EXT_texture_storage
+
+    If EXT_texture_storage is supported the following internalformat
+    to format/type mappings are used:
+
+        <internalformat>       <format>           <type>
+        ----------------       --------           ------
+        DEPTH_COMPONENT16      DEPTH_COMPONENT    UNSIGNED_SHORT
+        DEPTH_COMPONENT32_OES  DEPTH_COMPONENT    UNSIGNED_INT
+        DEPTH24_STENCIL8_OES   DEPTH_STENCIL_OES  UNSIGNED_INT
+
+    If EXT_texture_storage is not supported, ignore any references
+    to TexStorage2DEXT. 
+
+Errors
+
+    The error INVALID_ENUM is generated by TexImage2D if <format> and 
+    <internalformat> are DEPTH_COMPONENT and <type> is not UNSIGNED_SHORT,
+    or UNSIGNED_INT.
+
+    The error INVALID_ENUM is generated by TexSubImage2D if <format> is 
+    DEPTH_COMPONENT and <type> is not UNSIGNED_SHORT, or UNSIGNED_INT.
+
+    The error INVALID_ENUM is generated by TexImage2D if <format> and
+    <internalformat> are not DEPTH_COMPONENT and <type> is UNSIGNED_SHORT,
+    or UNSIGNED_INT.
+
+    The error INVALID_ENUM is generated by TexSubImage2D if <format> is
+    not DEPTH_COMPONENT and <type> is UNSIGNED_SHORT, or UNSIGNED_INT.
+
+    The error INVALID_ENUM is generated by TexImage2D if <format> and
+    <internalformat> are DEPTH_STENCIL_OES and <type> is not
+    UNSIGNED_INT_24_8_OES. 
+
+    The error INVALID_ENUM is generated by TexSubImage2D if <format>
+    is DEPTH_STENCIL_OES and <type> is not UNSIGNED_INT_24_8_OES. 
+
+    The error INVALID_ENUM is generated by TexImage2D if <format> and
+    <internalformat> is not DEPTH_STENCIL_OES and <type> is 
+    UNSIGNED_INT_24_8_OES.
+
+    The error INVALID_ENUM is generated by TexSubImage2D if <format>
+    is not DEPTH_STENCIL_OES and <type> is UNSIGNED_INT_24_8_OES.
+
+    The error INVALID_OPERATION is generated in the following situations:
+    - TexImage2D is called with <format> and <internalformat> of
+      DEPTH_COMPONENT or DEPTH_STENCIL_OES and
+       - <target> is not TEXTURE_2D, or
+       - <data> is not NULL
+    - TexSubImage2D is called with <format> of DEPTH_COMPONENT or 
+      DEPTH_STENCIL_OES.
+    - TexStorage2DEXT is called with <internalformat> of DEPTH_COMPONENT16,
+      DEPTH_COMPONENT32_OES, DEPTH24_STENCIL8_OES, and 
+       - <target> is not TEXTURE_2D
+    - CopyTexImage2D is called with an <internalformat> that has a base
+      internal format of DEPTH_COMPONENT or DEPTH_STENCIL_OES.
+    - CopyTexSubImage2D is called with a target texture that has a base
+      internal format of DEPTH_COMPONENT or DEPTH_STENCIL_OES.
+    - GenerateMipmap is called on a texture that has a base internal format
+      of DEPTH_COMPONENT or DEPTH_STENCIL_OES.
+    
+New State
+
+    None.
+
+Issues
+
+    1) What are the differences between this extension and OES_depth_texture
+       and OES_packed_depth_stencil?
+    
+       RESOLVED: This extension does not support loading pre-baked depth
+       or stencil data via TexImage2D or TexSubImage2D. This extension
+       also allows variability in w-component of the sample results from
+       depth textures.  This version also explicitly lists the errors for
+       unsupported functionality. Since this was not clearly specified in
+       the OES_depth_texture extension there may be differences in error
+       values between implementations of OES_depth_texture and 
+       ANGLE_depth_texture. This specification was also rebased to apply
+       against the OpenGL ES 2.0 specification instead of the OpenGL
+       specification, making it more obvious what all the functionality
+       changes are.
+
+    2) Why does TexSubImage2D accept the new format/type combinations even
+       though it does not actually support loading data?
+
+       RESOLVE: This was done to be more consistent with the OES_depth_texture
+       extension and to make it easier to add support for loading texture
+       data if it is possible to support in the future.
+
+Revision History
+ 
+    05/30/2012  dgkoch  minor updates and add issues.
+    05/23/2012  dgkoch  intial revision based on OES_depth_texture and 
+                        OES_packed_depth_stencil and rebased against the ES 2.0 spec
+
diff -r 91d3e124dee2 gfx/angle/extensions/ANGLE_program_binary.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/extensions/ANGLE_program_binary.txt	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,94 @@
+Name
+
+    ANGLE_program_binary
+
+Name Strings
+
+    GL_ANGLE_program_binary
+
+Contributors
+
+    Alastair Patrick, Google Inc.
+    Daniel Koch, TransGaming Inc.
+
+Contact
+
+    Alastair Patrick, Google Inc. (apatrick 'at' google 'dot' com)
+
+Status
+
+    Under development.
+
+Version
+
+    Last Modifed Date: June 6, 2012
+    Revision: #1
+
+Number
+
+    TBD
+
+Dependencies
+
+    OpenGL ES 2.0 is required.
+    OES_get_program_binary is required.
+    This extension is written against the OpenGL ES 2.0.25 specification.
+
+Overview
+
+    This extension makes available a program binary format,
+    PROGRAM_BINARY_ANGLE. It enables retrieving and loading of pre-linked
+    ANGLE program objects.
+
+New Procedures and Functions
+
+    None
+
+New Tokens
+
+    Accepted by the <binaryFormat> parameter of ProgramBinaryOES:
+
+        PROGRAM_BINARY_ANGLE        0x93A6
+
+Additions to Chapter 2 of the OpenGL-ES 2.0 Specification (OpenGL Operation)
+
+    Add the following paragraph to the end of section 2.15.4, Program Binaries:
+    
+    "PROGRAM_BINARY_ANGLE, returned in the list of PROGRAM_BINARY_FORMATS_OES,
+    is a format that may be loaded into a program object via ProgramBinaryOES." 
+    
+Additions to Chapter 3 of the OpenGL ES 2.0 specification (Rasterizatoin)
+
+    None.
+
+Additions to Chapter 4 of the OpenGL ES 2.0 specification (Per-Fragment
+Operations and the Framebuffer)
+
+    None.
+
+Additions to Chapter 5 of the OpenGL ES 2.0 Specification (Special
+Functions)
+
+    None.
+
+Additions to Chapter 6 of the OpenGL ES 2.0 Specification (State and State
+Requests)
+
+    None.
+
+Errors
+
+    None
+
+New State
+
+    None.
+
+Issues
+
+    None
+
+Revision History
+ 
+    06/06/2012  apatrick  intial revision
+
diff -r 91d3e124dee2 gfx/angle/extensions/ANGLE_timer_query.txt
--- a/gfx/angle/extensions/ANGLE_timer_query.txt	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/extensions/ANGLE_timer_query.txt	Sat Jun 09 12:08:28 2012 +0900
@@ -1,591 +1,591 @@
-Name
-
-    ANGLE_timer_query
-
-Name Strings
-
-    GL_ANGLE_timer_query
-
-Contributors
-
-    Contributors to ARB_occlusion_query
-    Contributors to EXT_timer_query
-    Contributors to ARB_timer_query
-    Ben Vanik, Google Inc.
-    Daniel Koch, TransGaming Inc.
-
-Contact
-
-    Ben Vanik, Google Inc. (benvanik 'at' google 'dot' com)
-
-Status
-
-    Draft
-
-Version
-
-    Last Modified Date: Apr 28, 2011
-    Author Revision: 1
-
-Number
-
-    OpenGL ES Extension #??
-
-Dependencies
-
-    OpenGL ES 2.0 is required.
-
-    The extension is written against the OpenGL ES 2.0 specification.
-
-Overview
-
-    Applications can benefit from accurate timing information in a number of
-    different ways.  During application development, timing information can
-    help identify application or driver bottlenecks.  At run time,
-    applications can use timing information to dynamically adjust the amount
-    of detail in a scene to achieve constant frame rates.  OpenGL
-    implementations have historically provided little to no useful timing
-    information.  Applications can get some idea of timing by reading timers
-    on the CPU, but these timers are not synchronized with the graphics
-    rendering pipeline.  Reading a CPU timer does not guarantee the completion
-    of a potentially large amount of graphics work accumulated before the
-    timer is read, and will thus produce wildly inaccurate results.
-    glFinish() can be used to determine when previous rendering commands have
-    been completed, but will idle the graphics pipeline and adversely affect
-    application performance.
-
-    This extension provides a query mechanism that can be used to determine
-    the amount of time it takes to fully complete a set of GL commands, and
-    without stalling the rendering pipeline.  It uses the query object
-    mechanisms first introduced in the occlusion query extension, which allow
-    time intervals to be polled asynchronously by the application.
-
-IP Status
-
-    No known IP claims.
-
-New Procedures and Functions
-
-    void GenQueriesANGLE(sizei n, uint *ids);
-    void DeleteQueriesANGLE(sizei n, const uint *ids);
-    boolean IsQueryANGLE(uint id);
-    void BeginQueryANGLE(enum target, uint id);
-    void EndQueryANGLE(enum target);
-    void QueryCounterANGLE(uint id, enum target);
-    void GetQueryivANGLE(enum target, enum pname, int *params);
-    void GetQueryObjectivANGLE(uint id, enum pname, int *params);
-    void GetQueryObjectuivANGLE(uint id, enum pname, uint *params);
-    void GetQueryObjecti64vANGLE(uint id, enum pname, int64 *params);
-    void GetQueryObjectui64vANGLE(uint id, enum pname, uint64 *params);
-
-New Tokens
-
-    Accepted by the <pname> parameter of GetQueryivANGLE:
-
-        QUERY_COUNTER_BITS_ANGLE                       0x8864
-        CURRENT_QUERY_ANGLE                            0x8865
-
-    Accepted by the <pname> parameter of GetQueryObjectivANGLE,
-    GetQueryObjectuivANGLE, GetQueryObjecti64vANGLE, and
-    GetQueryObjectui64vANGLE:
-
-        QUERY_RESULT_ANGLE                             0x8866
-        QUERY_RESULT_AVAILABLE_ANGLE                   0x8867
-        
-    Accepted by the <target> parameter of BeginQueryANGLE, EndQueryANGLE, and
-    GetQueryivANGLE:
-
-        TIME_ELAPSED_ANGLE                             0x88BF
-
-    Accepted by the <target> parameter of GetQueryivANGLE and
-    QueryCounterANGLE:
-
-        TIMESTAMP_ANGLE                                0x8E28
-
-Additions to Chapter 2 of the OpenGL ES 2.0 Specification (OpenGL ES Operation)
-
-    (Modify table 2.1, Correspondence of command suffix letters to GL argument)
-    Add two new types:
-    
-    Letter Corresponding GL Type
-    ------ ---------------------
-    i64    int64ANGLE
-    ui64   uint64ANGLE
-
-    (Modify table 2.2, GL data types) Add two new types:
-    
-    GL Type       Minimum Bit Width   Description
-    -------       -----------------   -----------------------------
-    int64ANGLE    64                  Signed 2's complement integer
-    uint64ANGLE   64                  Unsigned binary integer
-
-Additions to Chapter 5 of the OpenGL ES 2.0 Specification (Special Functions)
-
-    Add a new section 5.3 "Timer Queries":
-
-    "5.3  Timer Queries
-
-    Timer queries use query objects to track the amount of time needed to
-    fully complete a set of GL commands, or to determine the current time
-    of the GL.
-    
-    Timer queries are associated with query objects.  The command
-
-      void GenQueriesANGLE(sizei n, uint *ids);
-
-    returns <n> previously unused query object names in <ids>.  These
-    names are marked as used, but no object is associated with them until
-    the first time they are used by BeginQueryANGLE.  Query objects contain
-    one piece of state, an integer result value.  This result value is
-    initialized to zero when the object is created.  Any positive integer
-    except for zero (which is reserved for the GL) is a valid query
-    object name.
-
-    Query objects are deleted by calling
-
-      void DeleteQueriesANGLE(sizei n, const uint *ids);
-
-    <ids> contains <n> names of query objects to be deleted.  After a
-    query object is deleted, its name is again unused.  Unused names in
-    <ids> are silently ignored.
-    If an active query object is deleted its name immediately becomes unused,
-    but the underlying object is not deleted until it is no longer active.
-
-    A timer query can be started and finished by calling
-
-      void BeginQueryANGLE(enum target, uint id);
-      void EndQueryANGLE(enum target);
-
-    where <target> is TIME_ELAPSED_ANGLE.  If BeginQueryANGLE is called
-    with an unused <id>, that name is marked as used and associated with
-    a new query object.
-    
-    If BeginQueryANGLE is called with an <id> of zero, if the active query
-    object name for <target> is non-zero, if <id> is the name of an existing
-    query object whose type does not match <target>, or if <id> is the active
-    query object name for any query type, the error INVALID_OPERATION is
-    generated.  If EndQueryANGLE is called while no query with the same target
-    is in progress, an INVALID_OPERATION error is generated.
-
-    When BeginQueryANGLE and EndQueryANGLE are called with a <target> of
-    TIME_ELAPSED_ANGLE, the GL prepares to start and stop the timer used for
-    timer queries.  The timer is started or stopped when the effects from all
-    previous commands on the GL client and server state and the framebuffer
-    have been fully realized.  The BeginQueryANGLE and EndQueryANGLE commands
-    may return before the timer is actually started or stopped.  When the timer
-    query timer is finally stopped, the elapsed time (in nanoseconds) is
-    written to the corresponding query object as the query result value, and
-    the query result for that object is marked as available.
-
-    If the elapsed time overflows the number of bits, <n>, available to hold
-    elapsed time, its value becomes undefined.  It is recommended, but not
-    required, that implementations handle this overflow case by saturating at
-    2^n - 1.
-
-    The necessary state is a single bit indicating whether an timer
-    query is active, the identifier of the currently active timer
-    query, and a counter keeping track of the time that has passed.
-
-    When the command
-
-         void QueryCounterANGLE(uint id, enum target);
-
-    is called with <target> TIMESTAMP_ANGLE, the GL records the current time
-    into the corresponding query object. The time is recorded after all
-    previous commands on the GL client and server state and the framebuffer
-    have been fully realized. When the time is recorded, the query result for
-    that object is marked available. QueryCounterANGLE timer queries can be
-    used within a BeginQueryANGLE / EndQueryANGLE block where the <target> is
-    TIME_ELAPSED_ANGLE and it does not affect the result of that query object.
-    The error INVALID_OPERATION is generated if the <id> is already in use
-    within a BeginQueryANGLE/EndQueryANGLE block."
-
-Additions to Chapter 6 of the OpenGL ES 2.0 Specification (State and State
-Requests)
-
-    Add a new section 6.1.9 "Timer Queries":
-
-    "The command
-
-      boolean IsQueryANGLE(uint id);
-
-    returns TRUE if <id> is the name of a query object.  If <id> is zero,
-    or if <id> is a non-zero value that is not the name of a query
-    object, IsQueryANGLE returns FALSE.
-
-    Information about a query target can be queried with the command
-
-      void GetQueryivANGLE(enum target, enum pname, int *params);
-
-    <target> identifies the query target and can be TIME_ELAPSED_ANGLE or
-    TIMESTAMP_ANGLE for timer queries.
-
-    If <pname> is CURRENT_QUERY_ANGLE, the name of the currently active query
-    for <target>, or zero if no query is active, will be placed in <params>.
-
-    If <pname> is QUERY_COUNTER_BITS_ANGLE, the implementation-dependent number
-    of bits used to hold the query result for <target> will be placed in
-    <params>.  The number of query counter bits may be zero, in which case
-    the counter contains no useful information.
-
-    For timer queries (TIME_ELAPSED_ANGLE and TIMESTAMP_ANGLE), if the number
-    of bits is non-zero, the minimum number of bits allowed is 30 which
-    will allow at least 1 second of timing.
-
-    The state of a query object can be queried with the commands
-
-      void GetQueryObjectivANGLE(uint id, enum pname, int *params);
-      void GetQueryObjectuivANGLE(uint id, enum pname, uint *params);
-      void GetQueryObjecti64vANGLE(uint id, enum pname, int64 *params);
-      void GetQueryObjectui64vANGLE(uint id, enum pname, uint64 *params);
-
-    If <id> is not the name of a query object, or if the query object
-    named by <id> is currently active, then an INVALID_OPERATION error is
-    generated.
-
-    If <pname> is QUERY_RESULT_ANGLE, then the query object's result
-    value is returned as a single integer in <params>. If the value is so
-    large in magnitude that it cannot be represented with the requested type,
-    then the nearest value representable using the requested type is
-    returned. If the number of query counter bits for target is zero, then
-    the result is returned as a single integer with the value zero.
-    
-    There may be an indeterminate delay before the above query returns. If
-    <pname> is QUERY_RESULT_AVAILABLE_ANGLE, FALSE is returned if such a delay
-    would be required; otherwise TRUE is returned. It must always be true
-    that if any query object returns a result available of TRUE, all queries
-    of the same type issued prior to that query must also return TRUE.
-
-    Querying the state for a given timer query forces that timer query to
-    complete within a finite amount of time.
-
-    If multiple queries are issued on the same target and id prior to 
-    calling GetQueryObject[u]i[64]vANGLE, the result returned will always be
-    from the last query issued.  The results from any queries before the
-    last one will be lost if the results are not retrieved before starting
-    a new query on the same <target> and <id>."
-
-Errors
-
-    The error INVALID_VALUE is generated if GenQueriesANGLE is called where
-    <n> is negative.
-
-    The error INVALID_VALUE is generated if DeleteQueriesANGLE is called
-    where <n> is negative.
-
-    The error INVALID_OPERATION is generated if BeginQueryANGLE is called
-    when a query of the given <target> is already active.
-
-    The error INVALID_OPERATION is generated if EndQueryANGLE is called
-    when a query of the given <target> is not active.
-
-    The error INVALID_OPERATION is generated if BeginQueryANGLE is called
-    where <id> is zero.
-
-    The error INVALID_OPERATION is generated if BeginQueryANGLE is called
-    where <id> is the name of a query currently in progress.
-    
-    The error INVALID_OPERATION is generated if BeginQueryANGLE is called
-    where <id> is the name of an existing query object whose type does not
-    match <target>.
-
-    The error INVALID_ENUM is generated if BeginQueryANGLE or EndQueryANGLE
-    is called where <target> is not TIME_ELAPSED_ANGLE.
-
-    The error INVALID_ENUM is generated if GetQueryivANGLE is called where
-    <target> is not TIME_ELAPSED_ANGLE or TIMESTAMP_ANGLE.
-
-    The error INVALID_ENUM is generated if GetQueryivANGLE is called where
-    <pname> is not QUERY_COUNTER_BITS_ANGLE or CURRENT_QUERY_ANGLE.
-
-    The error INVALID_ENUM is generated if QueryCounterANGLE is called where
-    <target> is not TIMESTAMP_ANGLE.
-
-    The error INVALID_OPERATION is generated if QueryCounterANGLE is called
-    on a query object that is already in use inside a
-    BeginQueryANGLE/EndQueryANGLE.
-
-    The error INVALID_OPERATION is generated if GetQueryObjectivANGLE,
-    GetQueryObjectuivANGLE, GetQueryObjecti64vANGLE, or
-    GetQueryObjectui64vANGLE is called where <id> is not the name of a query
-    object.
-
-    The error INVALID_OPERATION is generated if GetQueryObjectivANGLE,
-    GetQueryObjectuivANGLE, GetQueryObjecti64vANGLE, or
-    GetQueryObjectui64vANGLE is called where <id> is the name of a currently
-    active query object.
-
-    The error INVALID_ENUM is generated if GetQueryObjectivANGLE,
-    GetQueryObjectuivANGLE, GetQueryObjecti64vANGLE, or
-    GetQueryObjectui64vANGLE is called where <pname> is not
-    QUERY_RESULT_ANGLE or QUERY_RESULT_AVAILABLE_ANGLE.
-
-New State
-
-    (Add a new table 6.xx, "Query Operations")
-    
-    Get Value                      Type    Get Command              Initial Value   Description              Sec
-    ---------                      ----    -----------              -------------   -----------              ------
-    -                              B       -                        FALSE           query active             5.3
-    CURRENT_QUERY_ANGLE            Z+      GetQueryivANGLE          0               active query ID          5.3
-    QUERY_RESULT_ANGLE             Z+      GetQueryObjectuivANGLE,  0               samples-passed count     5.3
-                                           GetQueryObjectui64vANGLE
-    QUERY_RESULT_AVAILABLE_ANGLE   B       GetQueryObjectivANGLE    FALSE           query result available   5.3
-
-New Implementation Dependent State
-
-    (Add the following entry to table 6.18):
-
-    Get Value                      Type    Get Command      Minimum Value      Description           Sec
-    --------------------------     ----    -----------      -------------      ----------------      ------
-    QUERY_COUNTER_BITS_ANGLE       Z+      GetQueryivANGLE  see 6.1.9          Number of bits in     6.1.9
-                                                                               query counter
-
-Examples
-
-    (1) Here is some rough sample code that demonstrates the intended usage
-        of this extension.
-
-        GLint queries[N];
-        GLint available = 0;
-        // timer queries can contain more than 32 bits of data, so always
-        // query them using the 64 bit types to avoid overflow
-        GLuint64ANGLE timeElapsed = 0;
-
-        // Create a query object.
-        glGenQueriesANGLE(N, queries);
-
-        // Start query 1
-        glBeginQueryANGLE(GL_TIME_ELAPSED_ANGLE, queries[0]);
-
-        // Draw object 1
-        ....
-
-        // End query 1
-        glEndQueryANGLE(GL_TIME_ELAPSED_ANGLE);
-
-        ...
-
-        // Start query N
-        glBeginQueryANGLE(GL_TIME_ELAPSED_ANGLE, queries[N-1]);
-
-        // Draw object N
-        ....
-
-        // End query N
-        glEndQueryANGLE(GL_TIME_ELAPSED_ANGLE);
-
-        // Wait for all results to become available
-        while (!available) {
-            glGetQueryObjectivANGLE(queries[N-1], GL_QUERY_RESULT_AVAILABLE_ANGLE, &available);
-        }
-
-        for (i = 0; i < N; i++) {
-            // See how much time the rendering of object i took in nanoseconds.
-            glGetQueryObjectui64vANGLE(queries[i], GL_QUERY_RESULT_ANGLE, &timeElapsed);
-
-            // Do something useful with the time.  Note that care should be
-            // taken to use all significant bits of the result, not just the
-            // least significant 32 bits.
-            AdjustObjectLODBasedOnDrawTime(i, timeElapsed);
-        }
-
-        This example is sub-optimal in that it stalls at the end of every
-        frame to wait for query results.  Ideally, the collection of results
-        would be delayed one frame to minimize the amount of time spent
-        waiting for the GPU to finish rendering.
-        
-    (2) This example is basically the same as the example above but uses
-        QueryCounter instead.
-    
-        GLint queries[N+1];
-        GLint available = 0;
-        // timer queries can contain more than 32 bits of data, so always
-        // query them using the 64 bit types to avoid overflow
-        GLuint64ANGLE timeStart, timeEnd, timeElapsed = 0;
-
-        // Create a query object.
-        glGenQueriesANGLE(N+1, queries);
-
-        // Query current timestamp 1
-        glQueryCounterANGLE(queries[0], GL_TIMESTAMP_ANGLE);
-
-        // Draw object 1
-        ....
-
-        // Query current timestamp N
-        glQueryCounterANGLE(queries[N-1], GL_TIMESTAMP_ANGLE);
-
-        // Draw object N
-        ....
-
-        // Query current timestamp N+1
-        glQueryCounterANGLE(queries[N], GL_TIMESTAMP_ANGLE);
-
-        // Wait for all results to become available
-        while (!available) {
-            glGetQueryObjectivANGLE(queries[N], GL_QUERY_RESULT_AVAILABLE_ANGLE, &available);
-        }
-
-        for (i = 0; i < N; i++) {
-            // See how much time the rendering of object i took in nanoseconds.
-            glGetQueryObjectui64vANGLE(queries[i], GL_QUERY_RESULT_ANGLE, &timeStart);
-            glGetQueryObjectui64vANGLE(queries[i+1], GL_QUERY_RESULT_ANGLE, &timeEnd);
-            timeElapsed = timeEnd - timeStart;
-
-            // Do something useful with the time.  Note that care should be
-            // taken to use all significant bits of the result, not just the
-            // least significant 32 bits.
-            AdjustObjectLODBasedOnDrawTime(i, timeElapsed);
-        }
-
-Issues from EXT_timer_query
-
-    (1) What time interval is being measured?
-
-    RESOLVED:  The timer starts when all commands prior to BeginQuery() have
-    been fully executed.  At that point, everything that should be drawn by
-    those commands has been written to the framebuffer.  The timer stops
-    when all commands prior to EndQuery() have been fully executed.
-
-    (2) What unit of time will time intervals be returned in?
-
-    RESOLVED:  Nanoseconds (10^-9 seconds).  This unit of measurement allows
-    for reasonably accurate timing of even small blocks of rendering
-    commands.  The granularity of the timer is implementation-dependent.  A
-    32-bit query counter can express intervals of up to approximately 4
-    seconds.
-
-    (3) What should be the minimum number of counter bits for timer queries?
-
-    RESOLVED:  30 bits, which will allow timing sections that take up to 1
-    second to render.
-
-    (4) How are counter results of more than 32 bits returned?
-
-    RESOLVED:  Via two new datatypes, int64ANGLE and uint64ANGLE, and their
-    corresponding GetQueryObject entry points.  These types hold integer
-    values and have a minimum bit width of 64.
-
-    (5) Should the extension measure total time elapsed between the full
-        completion of the BeginQuery and EndQuery commands, or just time
-        spent in the graphics library?
-
-    RESOLVED:  This extension will measure the total time elapsed between
-    the full completion of these commands.  Future extensions may implement
-    a query to determine time elapsed at different stages of the graphics
-    pipeline.
-
-    (6) If multiple query types are supported, can multiple query types be
-        active simultaneously?
-
-    RESOLVED:  Yes; an application may perform a timer query and another
-    type of query simultaneously.  An application can not perform multiple
-    timer queries or multiple queries of other types simultaneously.  An
-    application also can not use the same query object for another query
-    and a timer query simultaneously.
-
-    (7) Do query objects have a query type permanently associated with them?
-
-    RESOLVED:  No.  A single query object can be used to perform different
-    types of queries, but not at the same time.
-
-    Having a fixed type for each query object simplifies some aspects of the
-    implementation -- not having to deal with queries with different result
-    sizes, for example.  It would also mean that BeginQuery() with a query
-    object of the "wrong" type would result in an INVALID_OPERATION error.
-
-    UPDATE: This resolution was relevant for EXT_timer_query and OpenGL 2.0.
-    Since EXT_transform_feedback has since been incorporated into the core,
-    the resolution is that BeginQuery will generate error INVALID_OPERATION
-    if <id> represents a query object of a different type.
-
-    (8) How predictable/repeatable are the results returned by the timer
-        query?
-
-    RESOLVED:  In general, the amount of time needed to render the same
-    primitives should be fairly constant.  But there may be many other
-    system issues (e.g., context switching on the CPU and GPU, virtual
-    memory page faults, memory cache behavior on the CPU and GPU) that can
-    cause times to vary wildly.
-
-    Note that modern GPUs are generally highly pipelined, and may be
-    processing different primitives in different pipeline stages
-    simultaneously.  In this extension, the timers start and stop when the
-    BeginQuery/EndQuery commands reach the bottom of the rendering pipeline.
-    What that means is that by the time the timer starts, the GL driver on
-    the CPU may have started work on GL commands issued after BeginQuery,
-    and the higher pipeline stages (e.g., vertex transformation) may have
-    started as well.
-
-   (9) What should the new 64 bit integer type be called?
-
-    RESOLVED: The new types will be called GLint64ANGLE/GLuint64ANGLE.  The new
-    command suffixes will be i64 and ui64.  These names clearly convey the
-    minimum size of the types.  These types are similar to the C99 standard
-    type int_least64_t, but we use names similar to the C99 optional type
-    int64_t for simplicity.
-
-Issues from ARB_timer_query
-
-   (10) What about tile-based implementations? The effects of a command are
-        not complete until the frame is completely rendered. Timing recorded
-        before the frame is complete may not be what developers expect. Also
-        the amount of time needed to render the same primitives is not
-        consistent, which conflicts with issue (8) above. The time depends on
-        how early or late in the scene it is placed.
-
-    RESOLVED: The current language supports tile-based rendering okay as it
-    is written. Developers are warned that using timers on tile-based
-    implementation may not produce results they expect since rendering is not
-    done in a linear order. Timing results are calculated when the frame is
-    completed and may depend on how early or late in the scene it is placed.
-    
-   (11) Can the GL implementation use different clocks to implement the
-        TIME_ELAPSED and TIMESTAMP queries?
-
-   RESOLVED: Yes, the implemenation can use different internal clocks to
-   implement TIME_ELAPSED and TIMESTAMP. If different clocks are
-   used it is possible there is a slight discrepancy when comparing queries
-   made from TIME_ELAPSED and TIMESTAMP; they may have slight
-   differences when both are used to measure the same sequence. However, this
-   is unlikely to affect real applications since comparing the two queries is
-   not expected to be useful.
-
-Issues
-
-    (12) What should we call this extension?
-
-    RESOLVED: ANGLE_timer_query
-
-    (13) Why is this done as a separate extension instead of just supporting
-         ARB_timer_query?
-
-    ARB_timer_query is written against OpenGL 3.2, which includes a lot of
-    the required support for dealing with query objects. None of these
-    functions or tokens exist in OpenGL ES, and as such have to be added in
-    this specification.
-
-    (14) How does this extension differ from ARB_timer_query?
-
-    This extension contains most ARB_timer_query behavior unchanged as well
-    as a subset of the query support required to use it from the core
-    OpenGL 3.2 spec. It omits the glGetInteger(TIMESTAMP) functionality used to
-    query the current time on the GPU, but the behavior for all remaining
-    functionality taken from ARB_timer_query is the same.
-    
-    (15) Are query objects shareable between multiple contexts?
-
-    RESOLVED: No.  Query objects are lightweight and we normally share 
-    large data across contexts.  Also, being able to share query objects
-    across contexts is not particularly useful.  In order to do the async 
-    query across contexts, a query on one context would have to be finished 
-    before the other context could query it. 
-
-Revision History
-
-    Revision 1, 2011/04/28
-      - copied from revision 9 of ARB_timer_query and revision 7 of
-        ARB_occlusion_query
-      - removed language that was clearly not relevant to ES2
-      - rebased changes against the OpenGL ES 2.0 specification
+Name
+
+    ANGLE_timer_query
+
+Name Strings
+
+    GL_ANGLE_timer_query
+
+Contributors
+
+    Contributors to ARB_occlusion_query
+    Contributors to EXT_timer_query
+    Contributors to ARB_timer_query
+    Ben Vanik, Google Inc.
+    Daniel Koch, TransGaming Inc.
+
+Contact
+
+    Ben Vanik, Google Inc. (benvanik 'at' google 'dot' com)
+
+Status
+
+    Draft
+
+Version
+
+    Last Modified Date: Apr 28, 2011
+    Author Revision: 1
+
+Number
+
+    OpenGL ES Extension #??
+
+Dependencies
+
+    OpenGL ES 2.0 is required.
+
+    The extension is written against the OpenGL ES 2.0 specification.
+
+Overview
+
+    Applications can benefit from accurate timing information in a number of
+    different ways.  During application development, timing information can
+    help identify application or driver bottlenecks.  At run time,
+    applications can use timing information to dynamically adjust the amount
+    of detail in a scene to achieve constant frame rates.  OpenGL
+    implementations have historically provided little to no useful timing
+    information.  Applications can get some idea of timing by reading timers
+    on the CPU, but these timers are not synchronized with the graphics
+    rendering pipeline.  Reading a CPU timer does not guarantee the completion
+    of a potentially large amount of graphics work accumulated before the
+    timer is read, and will thus produce wildly inaccurate results.
+    glFinish() can be used to determine when previous rendering commands have
+    been completed, but will idle the graphics pipeline and adversely affect
+    application performance.
+
+    This extension provides a query mechanism that can be used to determine
+    the amount of time it takes to fully complete a set of GL commands, and
+    without stalling the rendering pipeline.  It uses the query object
+    mechanisms first introduced in the occlusion query extension, which allow
+    time intervals to be polled asynchronously by the application.
+
+IP Status
+
+    No known IP claims.
+
+New Procedures and Functions
+
+    void GenQueriesANGLE(sizei n, uint *ids);
+    void DeleteQueriesANGLE(sizei n, const uint *ids);
+    boolean IsQueryANGLE(uint id);
+    void BeginQueryANGLE(enum target, uint id);
+    void EndQueryANGLE(enum target);
+    void QueryCounterANGLE(uint id, enum target);
+    void GetQueryivANGLE(enum target, enum pname, int *params);
+    void GetQueryObjectivANGLE(uint id, enum pname, int *params);
+    void GetQueryObjectuivANGLE(uint id, enum pname, uint *params);
+    void GetQueryObjecti64vANGLE(uint id, enum pname, int64 *params);
+    void GetQueryObjectui64vANGLE(uint id, enum pname, uint64 *params);
+
+New Tokens
+
+    Accepted by the <pname> parameter of GetQueryivANGLE:
+
+        QUERY_COUNTER_BITS_ANGLE                       0x8864
+        CURRENT_QUERY_ANGLE                            0x8865
+
+    Accepted by the <pname> parameter of GetQueryObjectivANGLE,
+    GetQueryObjectuivANGLE, GetQueryObjecti64vANGLE, and
+    GetQueryObjectui64vANGLE:
+
+        QUERY_RESULT_ANGLE                             0x8866
+        QUERY_RESULT_AVAILABLE_ANGLE                   0x8867
+        
+    Accepted by the <target> parameter of BeginQueryANGLE, EndQueryANGLE, and
+    GetQueryivANGLE:
+
+        TIME_ELAPSED_ANGLE                             0x88BF
+
+    Accepted by the <target> parameter of GetQueryivANGLE and
+    QueryCounterANGLE:
+
+        TIMESTAMP_ANGLE                                0x8E28
+
+Additions to Chapter 2 of the OpenGL ES 2.0 Specification (OpenGL ES Operation)
+
+    (Modify table 2.1, Correspondence of command suffix letters to GL argument)
+    Add two new types:
+    
+    Letter Corresponding GL Type
+    ------ ---------------------
+    i64    int64ANGLE
+    ui64   uint64ANGLE
+
+    (Modify table 2.2, GL data types) Add two new types:
+    
+    GL Type       Minimum Bit Width   Description
+    -------       -----------------   -----------------------------
+    int64ANGLE    64                  Signed 2's complement integer
+    uint64ANGLE   64                  Unsigned binary integer
+
+Additions to Chapter 5 of the OpenGL ES 2.0 Specification (Special Functions)
+
+    Add a new section 5.3 "Timer Queries":
+
+    "5.3  Timer Queries
+
+    Timer queries use query objects to track the amount of time needed to
+    fully complete a set of GL commands, or to determine the current time
+    of the GL.
+    
+    Timer queries are associated with query objects.  The command
+
+      void GenQueriesANGLE(sizei n, uint *ids);
+
+    returns <n> previously unused query object names in <ids>.  These
+    names are marked as used, but no object is associated with them until
+    the first time they are used by BeginQueryANGLE.  Query objects contain
+    one piece of state, an integer result value.  This result value is
+    initialized to zero when the object is created.  Any positive integer
+    except for zero (which is reserved for the GL) is a valid query
+    object name.
+
+    Query objects are deleted by calling
+
+      void DeleteQueriesANGLE(sizei n, const uint *ids);
+
+    <ids> contains <n> names of query objects to be deleted.  After a
+    query object is deleted, its name is again unused.  Unused names in
+    <ids> are silently ignored.
+    If an active query object is deleted its name immediately becomes unused,
+    but the underlying object is not deleted until it is no longer active.
+
+    A timer query can be started and finished by calling
+
+      void BeginQueryANGLE(enum target, uint id);
+      void EndQueryANGLE(enum target);
+
+    where <target> is TIME_ELAPSED_ANGLE.  If BeginQueryANGLE is called
+    with an unused <id>, that name is marked as used and associated with
+    a new query object.
+    
+    If BeginQueryANGLE is called with an <id> of zero, if the active query
+    object name for <target> is non-zero, if <id> is the name of an existing
+    query object whose type does not match <target>, or if <id> is the active
+    query object name for any query type, the error INVALID_OPERATION is
+    generated.  If EndQueryANGLE is called while no query with the same target
+    is in progress, an INVALID_OPERATION error is generated.
+
+    When BeginQueryANGLE and EndQueryANGLE are called with a <target> of
+    TIME_ELAPSED_ANGLE, the GL prepares to start and stop the timer used for
+    timer queries.  The timer is started or stopped when the effects from all
+    previous commands on the GL client and server state and the framebuffer
+    have been fully realized.  The BeginQueryANGLE and EndQueryANGLE commands
+    may return before the timer is actually started or stopped.  When the timer
+    query timer is finally stopped, the elapsed time (in nanoseconds) is
+    written to the corresponding query object as the query result value, and
+    the query result for that object is marked as available.
+
+    If the elapsed time overflows the number of bits, <n>, available to hold
+    elapsed time, its value becomes undefined.  It is recommended, but not
+    required, that implementations handle this overflow case by saturating at
+    2^n - 1.
+
+    The necessary state is a single bit indicating whether an timer
+    query is active, the identifier of the currently active timer
+    query, and a counter keeping track of the time that has passed.
+
+    When the command
+
+         void QueryCounterANGLE(uint id, enum target);
+
+    is called with <target> TIMESTAMP_ANGLE, the GL records the current time
+    into the corresponding query object. The time is recorded after all
+    previous commands on the GL client and server state and the framebuffer
+    have been fully realized. When the time is recorded, the query result for
+    that object is marked available. QueryCounterANGLE timer queries can be
+    used within a BeginQueryANGLE / EndQueryANGLE block where the <target> is
+    TIME_ELAPSED_ANGLE and it does not affect the result of that query object.
+    The error INVALID_OPERATION is generated if the <id> is already in use
+    within a BeginQueryANGLE/EndQueryANGLE block."
+
+Additions to Chapter 6 of the OpenGL ES 2.0 Specification (State and State
+Requests)
+
+    Add a new section 6.1.9 "Timer Queries":
+
+    "The command
+
+      boolean IsQueryANGLE(uint id);
+
+    returns TRUE if <id> is the name of a query object.  If <id> is zero,
+    or if <id> is a non-zero value that is not the name of a query
+    object, IsQueryANGLE returns FALSE.
+
+    Information about a query target can be queried with the command
+
+      void GetQueryivANGLE(enum target, enum pname, int *params);
+
+    <target> identifies the query target and can be TIME_ELAPSED_ANGLE or
+    TIMESTAMP_ANGLE for timer queries.
+
+    If <pname> is CURRENT_QUERY_ANGLE, the name of the currently active query
+    for <target>, or zero if no query is active, will be placed in <params>.
+
+    If <pname> is QUERY_COUNTER_BITS_ANGLE, the implementation-dependent number
+    of bits used to hold the query result for <target> will be placed in
+    <params>.  The number of query counter bits may be zero, in which case
+    the counter contains no useful information.
+
+    For timer queries (TIME_ELAPSED_ANGLE and TIMESTAMP_ANGLE), if the number
+    of bits is non-zero, the minimum number of bits allowed is 30 which
+    will allow at least 1 second of timing.
+
+    The state of a query object can be queried with the commands
+
+      void GetQueryObjectivANGLE(uint id, enum pname, int *params);
+      void GetQueryObjectuivANGLE(uint id, enum pname, uint *params);
+      void GetQueryObjecti64vANGLE(uint id, enum pname, int64 *params);
+      void GetQueryObjectui64vANGLE(uint id, enum pname, uint64 *params);
+
+    If <id> is not the name of a query object, or if the query object
+    named by <id> is currently active, then an INVALID_OPERATION error is
+    generated.
+
+    If <pname> is QUERY_RESULT_ANGLE, then the query object's result
+    value is returned as a single integer in <params>. If the value is so
+    large in magnitude that it cannot be represented with the requested type,
+    then the nearest value representable using the requested type is
+    returned. If the number of query counter bits for target is zero, then
+    the result is returned as a single integer with the value zero.
+    
+    There may be an indeterminate delay before the above query returns. If
+    <pname> is QUERY_RESULT_AVAILABLE_ANGLE, FALSE is returned if such a delay
+    would be required; otherwise TRUE is returned. It must always be true
+    that if any query object returns a result available of TRUE, all queries
+    of the same type issued prior to that query must also return TRUE.
+
+    Querying the state for a given timer query forces that timer query to
+    complete within a finite amount of time.
+
+    If multiple queries are issued on the same target and id prior to 
+    calling GetQueryObject[u]i[64]vANGLE, the result returned will always be
+    from the last query issued.  The results from any queries before the
+    last one will be lost if the results are not retrieved before starting
+    a new query on the same <target> and <id>."
+
+Errors
+
+    The error INVALID_VALUE is generated if GenQueriesANGLE is called where
+    <n> is negative.
+
+    The error INVALID_VALUE is generated if DeleteQueriesANGLE is called
+    where <n> is negative.
+
+    The error INVALID_OPERATION is generated if BeginQueryANGLE is called
+    when a query of the given <target> is already active.
+
+    The error INVALID_OPERATION is generated if EndQueryANGLE is called
+    when a query of the given <target> is not active.
+
+    The error INVALID_OPERATION is generated if BeginQueryANGLE is called
+    where <id> is zero.
+
+    The error INVALID_OPERATION is generated if BeginQueryANGLE is called
+    where <id> is the name of a query currently in progress.
+    
+    The error INVALID_OPERATION is generated if BeginQueryANGLE is called
+    where <id> is the name of an existing query object whose type does not
+    match <target>.
+
+    The error INVALID_ENUM is generated if BeginQueryANGLE or EndQueryANGLE
+    is called where <target> is not TIME_ELAPSED_ANGLE.
+
+    The error INVALID_ENUM is generated if GetQueryivANGLE is called where
+    <target> is not TIME_ELAPSED_ANGLE or TIMESTAMP_ANGLE.
+
+    The error INVALID_ENUM is generated if GetQueryivANGLE is called where
+    <pname> is not QUERY_COUNTER_BITS_ANGLE or CURRENT_QUERY_ANGLE.
+
+    The error INVALID_ENUM is generated if QueryCounterANGLE is called where
+    <target> is not TIMESTAMP_ANGLE.
+
+    The error INVALID_OPERATION is generated if QueryCounterANGLE is called
+    on a query object that is already in use inside a
+    BeginQueryANGLE/EndQueryANGLE.
+
+    The error INVALID_OPERATION is generated if GetQueryObjectivANGLE,
+    GetQueryObjectuivANGLE, GetQueryObjecti64vANGLE, or
+    GetQueryObjectui64vANGLE is called where <id> is not the name of a query
+    object.
+
+    The error INVALID_OPERATION is generated if GetQueryObjectivANGLE,
+    GetQueryObjectuivANGLE, GetQueryObjecti64vANGLE, or
+    GetQueryObjectui64vANGLE is called where <id> is the name of a currently
+    active query object.
+
+    The error INVALID_ENUM is generated if GetQueryObjectivANGLE,
+    GetQueryObjectuivANGLE, GetQueryObjecti64vANGLE, or
+    GetQueryObjectui64vANGLE is called where <pname> is not
+    QUERY_RESULT_ANGLE or QUERY_RESULT_AVAILABLE_ANGLE.
+
+New State
+
+    (Add a new table 6.xx, "Query Operations")
+    
+    Get Value                      Type    Get Command              Initial Value   Description              Sec
+    ---------                      ----    -----------              -------------   -----------              ------
+    -                              B       -                        FALSE           query active             5.3
+    CURRENT_QUERY_ANGLE            Z+      GetQueryivANGLE          0               active query ID          5.3
+    QUERY_RESULT_ANGLE             Z+      GetQueryObjectuivANGLE,  0               samples-passed count     5.3
+                                           GetQueryObjectui64vANGLE
+    QUERY_RESULT_AVAILABLE_ANGLE   B       GetQueryObjectivANGLE    FALSE           query result available   5.3
+
+New Implementation Dependent State
+
+    (Add the following entry to table 6.18):
+
+    Get Value                      Type    Get Command      Minimum Value      Description           Sec
+    --------------------------     ----    -----------      -------------      ----------------      ------
+    QUERY_COUNTER_BITS_ANGLE       Z+      GetQueryivANGLE  see 6.1.9          Number of bits in     6.1.9
+                                                                               query counter
+
+Examples
+
+    (1) Here is some rough sample code that demonstrates the intended usage
+        of this extension.
+
+        GLint queries[N];
+        GLint available = 0;
+        // timer queries can contain more than 32 bits of data, so always
+        // query them using the 64 bit types to avoid overflow
+        GLuint64ANGLE timeElapsed = 0;
+
+        // Create a query object.
+        glGenQueriesANGLE(N, queries);
+
+        // Start query 1
+        glBeginQueryANGLE(GL_TIME_ELAPSED_ANGLE, queries[0]);
+
+        // Draw object 1
+        ....
+
+        // End query 1
+        glEndQueryANGLE(GL_TIME_ELAPSED_ANGLE);
+
+        ...
+
+        // Start query N
+        glBeginQueryANGLE(GL_TIME_ELAPSED_ANGLE, queries[N-1]);
+
+        // Draw object N
+        ....
+
+        // End query N
+        glEndQueryANGLE(GL_TIME_ELAPSED_ANGLE);
+
+        // Wait for all results to become available
+        while (!available) {
+            glGetQueryObjectivANGLE(queries[N-1], GL_QUERY_RESULT_AVAILABLE_ANGLE, &available);
+        }
+
+        for (i = 0; i < N; i++) {
+            // See how much time the rendering of object i took in nanoseconds.
+            glGetQueryObjectui64vANGLE(queries[i], GL_QUERY_RESULT_ANGLE, &timeElapsed);
+
+            // Do something useful with the time.  Note that care should be
+            // taken to use all significant bits of the result, not just the
+            // least significant 32 bits.
+            AdjustObjectLODBasedOnDrawTime(i, timeElapsed);
+        }
+
+        This example is sub-optimal in that it stalls at the end of every
+        frame to wait for query results.  Ideally, the collection of results
+        would be delayed one frame to minimize the amount of time spent
+        waiting for the GPU to finish rendering.
+        
+    (2) This example is basically the same as the example above but uses
+        QueryCounter instead.
+    
+        GLint queries[N+1];
+        GLint available = 0;
+        // timer queries can contain more than 32 bits of data, so always
+        // query them using the 64 bit types to avoid overflow
+        GLuint64ANGLE timeStart, timeEnd, timeElapsed = 0;
+
+        // Create a query object.
+        glGenQueriesANGLE(N+1, queries);
+
+        // Query current timestamp 1
+        glQueryCounterANGLE(queries[0], GL_TIMESTAMP_ANGLE);
+
+        // Draw object 1
+        ....
+
+        // Query current timestamp N
+        glQueryCounterANGLE(queries[N-1], GL_TIMESTAMP_ANGLE);
+
+        // Draw object N
+        ....
+
+        // Query current timestamp N+1
+        glQueryCounterANGLE(queries[N], GL_TIMESTAMP_ANGLE);
+
+        // Wait for all results to become available
+        while (!available) {
+            glGetQueryObjectivANGLE(queries[N], GL_QUERY_RESULT_AVAILABLE_ANGLE, &available);
+        }
+
+        for (i = 0; i < N; i++) {
+            // See how much time the rendering of object i took in nanoseconds.
+            glGetQueryObjectui64vANGLE(queries[i], GL_QUERY_RESULT_ANGLE, &timeStart);
+            glGetQueryObjectui64vANGLE(queries[i+1], GL_QUERY_RESULT_ANGLE, &timeEnd);
+            timeElapsed = timeEnd - timeStart;
+
+            // Do something useful with the time.  Note that care should be
+            // taken to use all significant bits of the result, not just the
+            // least significant 32 bits.
+            AdjustObjectLODBasedOnDrawTime(i, timeElapsed);
+        }
+
+Issues from EXT_timer_query
+
+    (1) What time interval is being measured?
+
+    RESOLVED:  The timer starts when all commands prior to BeginQuery() have
+    been fully executed.  At that point, everything that should be drawn by
+    those commands has been written to the framebuffer.  The timer stops
+    when all commands prior to EndQuery() have been fully executed.
+
+    (2) What unit of time will time intervals be returned in?
+
+    RESOLVED:  Nanoseconds (10^-9 seconds).  This unit of measurement allows
+    for reasonably accurate timing of even small blocks of rendering
+    commands.  The granularity of the timer is implementation-dependent.  A
+    32-bit query counter can express intervals of up to approximately 4
+    seconds.
+
+    (3) What should be the minimum number of counter bits for timer queries?
+
+    RESOLVED:  30 bits, which will allow timing sections that take up to 1
+    second to render.
+
+    (4) How are counter results of more than 32 bits returned?
+
+    RESOLVED:  Via two new datatypes, int64ANGLE and uint64ANGLE, and their
+    corresponding GetQueryObject entry points.  These types hold integer
+    values and have a minimum bit width of 64.
+
+    (5) Should the extension measure total time elapsed between the full
+        completion of the BeginQuery and EndQuery commands, or just time
+        spent in the graphics library?
+
+    RESOLVED:  This extension will measure the total time elapsed between
+    the full completion of these commands.  Future extensions may implement
+    a query to determine time elapsed at different stages of the graphics
+    pipeline.
+
+    (6) If multiple query types are supported, can multiple query types be
+        active simultaneously?
+
+    RESOLVED:  Yes; an application may perform a timer query and another
+    type of query simultaneously.  An application can not perform multiple
+    timer queries or multiple queries of other types simultaneously.  An
+    application also can not use the same query object for another query
+    and a timer query simultaneously.
+
+    (7) Do query objects have a query type permanently associated with them?
+
+    RESOLVED:  No.  A single query object can be used to perform different
+    types of queries, but not at the same time.
+
+    Having a fixed type for each query object simplifies some aspects of the
+    implementation -- not having to deal with queries with different result
+    sizes, for example.  It would also mean that BeginQuery() with a query
+    object of the "wrong" type would result in an INVALID_OPERATION error.
+
+    UPDATE: This resolution was relevant for EXT_timer_query and OpenGL 2.0.
+    Since EXT_transform_feedback has since been incorporated into the core,
+    the resolution is that BeginQuery will generate error INVALID_OPERATION
+    if <id> represents a query object of a different type.
+
+    (8) How predictable/repeatable are the results returned by the timer
+        query?
+
+    RESOLVED:  In general, the amount of time needed to render the same
+    primitives should be fairly constant.  But there may be many other
+    system issues (e.g., context switching on the CPU and GPU, virtual
+    memory page faults, memory cache behavior on the CPU and GPU) that can
+    cause times to vary wildly.
+
+    Note that modern GPUs are generally highly pipelined, and may be
+    processing different primitives in different pipeline stages
+    simultaneously.  In this extension, the timers start and stop when the
+    BeginQuery/EndQuery commands reach the bottom of the rendering pipeline.
+    What that means is that by the time the timer starts, the GL driver on
+    the CPU may have started work on GL commands issued after BeginQuery,
+    and the higher pipeline stages (e.g., vertex transformation) may have
+    started as well.
+
+   (9) What should the new 64 bit integer type be called?
+
+    RESOLVED: The new types will be called GLint64ANGLE/GLuint64ANGLE.  The new
+    command suffixes will be i64 and ui64.  These names clearly convey the
+    minimum size of the types.  These types are similar to the C99 standard
+    type int_least64_t, but we use names similar to the C99 optional type
+    int64_t for simplicity.
+
+Issues from ARB_timer_query
+
+   (10) What about tile-based implementations? The effects of a command are
+        not complete until the frame is completely rendered. Timing recorded
+        before the frame is complete may not be what developers expect. Also
+        the amount of time needed to render the same primitives is not
+        consistent, which conflicts with issue (8) above. The time depends on
+        how early or late in the scene it is placed.
+
+    RESOLVED: The current language supports tile-based rendering okay as it
+    is written. Developers are warned that using timers on tile-based
+    implementation may not produce results they expect since rendering is not
+    done in a linear order. Timing results are calculated when the frame is
+    completed and may depend on how early or late in the scene it is placed.
+    
+   (11) Can the GL implementation use different clocks to implement the
+        TIME_ELAPSED and TIMESTAMP queries?
+
+   RESOLVED: Yes, the implemenation can use different internal clocks to
+   implement TIME_ELAPSED and TIMESTAMP. If different clocks are
+   used it is possible there is a slight discrepancy when comparing queries
+   made from TIME_ELAPSED and TIMESTAMP; they may have slight
+   differences when both are used to measure the same sequence. However, this
+   is unlikely to affect real applications since comparing the two queries is
+   not expected to be useful.
+
+Issues
+
+    (12) What should we call this extension?
+
+    RESOLVED: ANGLE_timer_query
+
+    (13) Why is this done as a separate extension instead of just supporting
+         ARB_timer_query?
+
+    ARB_timer_query is written against OpenGL 3.2, which includes a lot of
+    the required support for dealing with query objects. None of these
+    functions or tokens exist in OpenGL ES, and as such have to be added in
+    this specification.
+
+    (14) How does this extension differ from ARB_timer_query?
+
+    This extension contains most ARB_timer_query behavior unchanged as well
+    as a subset of the query support required to use it from the core
+    OpenGL 3.2 spec. It omits the glGetInteger(TIMESTAMP) functionality used to
+    query the current time on the GPU, but the behavior for all remaining
+    functionality taken from ARB_timer_query is the same.
+    
+    (15) Are query objects shareable between multiple contexts?
+
+    RESOLVED: No.  Query objects are lightweight and we normally share 
+    large data across contexts.  Also, being able to share query objects
+    across contexts is not particularly useful.  In order to do the async 
+    query across contexts, a query on one context would have to be finished 
+    before the other context could query it. 
+
+Revision History
+
+    Revision 1, 2011/04/28
+      - copied from revision 9 of ARB_timer_query and revision 7 of
+        ARB_occlusion_query
+      - removed language that was clearly not relevant to ES2
+      - rebased changes against the OpenGL ES 2.0 specification
diff -r 91d3e124dee2 gfx/angle/include/GLES2/gl2ext.h
--- a/gfx/angle/include/GLES2/gl2ext.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/include/GLES2/gl2ext.h	Sat Jun 09 12:08:28 2012 +0900
@@ -238,6 +238,11 @@
 #define GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE                    0x88FE
 #endif
 
+/* GL_ANGLE_program_binary */
+#ifndef GL_ANGLE_program_binary
+#define GL_PROGRAM_BINARY_ANGLE                                 0x93A6
+#endif
+
 /*------------------------------------------------------------------------*
  * APPLE extension tokens
  *------------------------------------------------------------------------*/
@@ -1487,6 +1492,11 @@
 #define GL_VIV_shader_binary 1
 #endif
 
+/* GL_ANGLE_program_binary */
+#ifndef GL_ANGLE_program_binary
+#define GL_ANGLE_program_binary 1
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff -r 91d3e124dee2 gfx/angle/include/GLSLANG/ShaderLang.h
--- a/gfx/angle/include/GLSLANG/ShaderLang.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/include/GLSLANG/ShaderLang.h	Sat Jun 09 12:08:28 2012 +0900
@@ -34,7 +34,7 @@
 
 // Version number for shader translation API.
 // It is incremented everytime the API changes.
-#define SH_VERSION 105
+#define SH_VERSION 107
 
 //
 // The names of the following enums have been derived by replacing GL prefix
@@ -49,7 +49,29 @@
 
 typedef enum {
   SH_GLES2_SPEC = 0x8B40,
-  SH_WEBGL_SPEC = 0x8B41
+  SH_WEBGL_SPEC = 0x8B41,
+
+  // The CSS Shaders spec is a subset of the WebGL spec.
+  //
+  // In both CSS vertex and fragment shaders, ANGLE:
+  // (1) Reserves the "css_" prefix.
+  // (2) Renames the main function to css_main.
+  // (3) Disables the gl_MaxDrawBuffers built-in.
+  //
+  // In CSS fragment shaders, ANGLE:
+  // (1) Disables the gl_FragColor built-in.
+  // (2) Disables the gl_FragData built-in.
+  // (3) Enables the css_MixColor built-in.
+  // (4) Enables the css_ColorMatrix built-in.
+  //
+  // After passing a CSS shader through ANGLE, the browser is expected to append
+  // a new main function to it.
+  // This new main function will call the css_main function.
+  // It may also perform additional operations like varying assignment, texture
+  // access, and gl_FragColor assignment in order to implement the CSS Shaders
+  // blend modes.
+  //
+  SH_CSS_SHADERS_SPEC = 0x8B42
 } ShShaderSpec;
 
 typedef enum {
@@ -104,7 +126,23 @@
   SH_UNROLL_FOR_LOOP_WITH_INTEGER_INDEX = 0x0080,
 
   // This is needed only as a workaround for certain OpenGL driver bugs.
-  SH_EMULATE_BUILT_IN_FUNCTIONS = 0x0100
+  SH_EMULATE_BUILT_IN_FUNCTIONS = 0x0100,
+
+  // This is an experimental flag to enforce restrictions that aim to prevent 
+  // timing attacks.
+  // It generates compilation errors for shaders that could expose sensitive
+  // texture information via the timing channel.
+  // To use this flag, you must compile the shader under the WebGL spec
+  // (using the SH_WEBGL_SPEC flag).
+  SH_TIMING_RESTRICTIONS = 0x0200,
+    
+  // This flag prints the dependency graph that is used to enforce timing
+  // restrictions on fragment shaders.
+  // This flag only has an effect if all of the following are true:
+  // - The shader spec is SH_WEBGL_SPEC.
+  // - The compile options contain the SH_TIMING_RESTRICTIONS flag.
+  // - The shader type is SH_FRAGMENT_SHADER.
+  SH_DEPENDENCY_GRAPH = 0x0400
 } ShCompileOptions;
 
 //
diff -r 91d3e124dee2 gfx/angle/samples/gles2_book/Common/esUtil.vcproj
--- a/gfx/angle/samples/gles2_book/Common/esUtil.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/samples/gles2_book/Common/esUtil.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,70 +1,190 @@
 <?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="esUtil" ProjectGUID="{47C93F52-AB4E-4FF9-8D4F-B38CD60A183F}" RootNamespace="esUtil" Keyword="Win32Proj" TargetFrameworkVersion="131072">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="4" CharacterSet="0">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="./;../../../include" PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLibrarianTool" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="4" CharacterSet="0" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" AdditionalIncludeDirectories="./;../../../include" PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" RuntimeLibrary="0" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLibrarianTool" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <Filter Name="Win32">
-      <File RelativePath=".\Win32\esUtil_TGA.c">
-      </File>
-      <File RelativePath=".\esUtil_win.h">
-      </File>
-      <File RelativePath=".\Win32\esUtil_win32.c">
-      </File>
-    </Filter>
-    <Filter Name="Common">
-      <File RelativePath=".\esShader.c">
-      </File>
-      <File RelativePath=".\esShapes.c">
-      </File>
-      <File RelativePath=".\esTransform.c">
-      </File>
-      <File RelativePath=".\esUtil.c">
-      </File>
-      <File RelativePath=".\esUtil.h">
-      </File>
-    </Filter>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="esUtil"
+	ProjectGUID="{47C93F52-AB4E-4FF9-8D4F-B38CD60A183F}"
+	RootNamespace="esUtil"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="./;../../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="./;../../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Win32"
+			>
+			<File
+				RelativePath=".\Win32\esUtil_TGA.c"
+				>
+			</File>
+			<File
+				RelativePath=".\esUtil_win.h"
+				>
+			</File>
+			<File
+				RelativePath=".\Win32\esUtil_win32.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Common"
+			>
+			<File
+				RelativePath=".\esShader.c"
+				>
+			</File>
+			<File
+				RelativePath=".\esShapes.c"
+				>
+			</File>
+			<File
+				RelativePath=".\esTransform.c"
+				>
+			</File>
+			<File
+				RelativePath=".\esUtil.c"
+				>
+			</File>
+			<File
+				RelativePath=".\esUtil.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/samples/gles2_book/Hello_Triangle/Hello_Triangle.vcproj
--- a/gfx/angle/samples/gles2_book/Hello_Triangle/Hello_Triangle.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/samples/gles2_book/Hello_Triangle/Hello_Triangle.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,56 +1,182 @@
 <?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="Hello_Triangle" ProjectGUID="{8278251F-6C1F-4D80-8499-FA7B590FAFE6}" RootNamespace="Hello_Triangle" Keyword="Win32Proj" TargetFrameworkVersion="131072">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" UsePrecompiledHeader="0" WarningLevel="3" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="2" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" EmbedManifest="true" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" RuntimeLibrary="0" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="1" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" OptimizeReferences="2" EnableCOMDATFolding="2" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <File RelativePath=".\Hello_Triangle.c">
-    </File>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="Hello_Triangle"
+	ProjectGUID="{8278251F-6C1F-4D80-8499-FA7B590FAFE6}"
+	RootNamespace="Hello_Triangle"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+				EmbedManifest="true"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\Hello_Triangle.c"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/samples/gles2_book/MipMap2D/MipMap2D.vcproj
--- a/gfx/angle/samples/gles2_book/MipMap2D/MipMap2D.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/samples/gles2_book/MipMap2D/MipMap2D.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,56 +1,183 @@
 <?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="MipMap2D" ProjectGUID="{4E69AC1F-1C7A-4D58-917C-E764FBEB489A}" RootNamespace="MipMap2D" Keyword="Win32Proj" TargetFrameworkVersion="131072">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="2" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" EmbedManifest="true" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" RuntimeLibrary="0" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="1" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" OptimizeReferences="2" EnableCOMDATFolding="2" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <File RelativePath=".\MipMap2D.c">
-    </File>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="MipMap2D"
+	ProjectGUID="{4E69AC1F-1C7A-4D58-917C-E764FBEB489A}"
+	RootNamespace="MipMap2D"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+				EmbedManifest="true"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\MipMap2D.c"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/samples/gles2_book/MultiTexture/MultiTexture.vcproj
--- a/gfx/angle/samples/gles2_book/MultiTexture/MultiTexture.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/samples/gles2_book/MultiTexture/MultiTexture.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,56 +1,185 @@
 <?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="MultiTexture" ProjectGUID="{120CFF94-ED4B-4C5B-9587-9E40889F15F7}" RootNamespace="MultiTexture" Keyword="Win32Proj" TargetFrameworkVersion="131072">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="2" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" EmbedManifest="true" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" CommandLine="xcopy /D /Y basemap.tga $(OutDir)&#xD;&#xA;xcopy /D /Y lightmap.tga $(OutDir)" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" RuntimeLibrary="0" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="1" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" OptimizeReferences="2" EnableCOMDATFolding="2" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" CommandLine="xcopy /D /Y basemap.tga $(OutDir)&#xD;&#xA;xcopy /D /Y lightmap.tga $(OutDir)" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <File RelativePath=".\MultiTexture.c">
-    </File>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="MultiTexture"
+	ProjectGUID="{120CFF94-ED4B-4C5B-9587-9E40889F15F7}"
+	RootNamespace="MultiTexture"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+				EmbedManifest="true"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="xcopy /D /Y basemap.tga &quot;$(OutDir)&quot;&#x0D;&#x0A;xcopy /D /Y lightmap.tga &quot;$(OutDir)&quot;&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="xcopy /D /Y basemap.tga &quot;$(OutDir)&quot;&#x0D;&#x0A;xcopy /D /Y lightmap.tga &quot;$(OutDir)&quot;&#x0D;&#x0A;"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\MultiTexture.c"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/samples/gles2_book/ParticleSystem/ParticleSystem.vcproj
--- a/gfx/angle/samples/gles2_book/ParticleSystem/ParticleSystem.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/samples/gles2_book/ParticleSystem/ParticleSystem.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,56 +1,185 @@
 <?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="ParticleSystem" ProjectGUID="{B9E5BFFC-D843-4E0E-9D3E-23913A613473}" RootNamespace="ParticleSystem" Keyword="Win32Proj" TargetFrameworkVersion="131072">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="2" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" EmbedManifest="true" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" CommandLine="xcopy /D /Y smoke.tga $(outDir)" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" RuntimeLibrary="0" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="1" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" OptimizeReferences="2" EnableCOMDATFolding="2" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" CommandLine="xcopy /D /Y smoke.tga $(outDir)" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <File RelativePath=".\ParticleSystem.c">
-    </File>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="ParticleSystem"
+	ProjectGUID="{B9E5BFFC-D843-4E0E-9D3E-23913A613473}"
+	RootNamespace="ParticleSystem"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+				EmbedManifest="true"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="xcopy /D /Y smoke.tga &quot;$(outDir)&quot;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="xcopy /D /Y smoke.tga &quot;$(outDir)&quot;"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\ParticleSystem.c"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/samples/gles2_book/PostSubBuffer/PostSubBuffer.vcproj
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/samples/gles2_book/PostSubBuffer/PostSubBuffer.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,183 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="PostSubBuffer"
+	ProjectGUID="{667CE95F-5DD8-4495-8C18-5CA8A175B12D}"
+	RootNamespace="Simple_VertexShader"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+				EmbedManifest="true"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\PostSubBuffer.c"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/samples/gles2_book/Simple_Texture2D/Simple_Texture2D.vcproj
--- a/gfx/angle/samples/gles2_book/Simple_Texture2D/Simple_Texture2D.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/samples/gles2_book/Simple_Texture2D/Simple_Texture2D.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,56 +1,183 @@
 <?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="Simple_Texture2D" ProjectGUID="{2E54D748-781B-4DF2-A1DD-B9384A821810}" RootNamespace="Simple_Texture2D" Keyword="Win32Proj" TargetFrameworkVersion="131072">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="2" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" EmbedManifest="true" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" RuntimeLibrary="0" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="1" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" OptimizeReferences="2" EnableCOMDATFolding="2" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <File RelativePath=".\Simple_Texture2D.c">
-    </File>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="Simple_Texture2D"
+	ProjectGUID="{2E54D748-781B-4DF2-A1DD-B9384A821810}"
+	RootNamespace="Simple_Texture2D"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+				EmbedManifest="true"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\Simple_Texture2D.c"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/samples/gles2_book/Simple_TextureCubemap/Simple_TextureCubemap.vcproj
--- a/gfx/angle/samples/gles2_book/Simple_TextureCubemap/Simple_TextureCubemap.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/samples/gles2_book/Simple_TextureCubemap/Simple_TextureCubemap.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,56 +1,184 @@
 <?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="Simple_TextureCubemap" ProjectGUID="{5EE56061-643D-406E-B42D-4299D2411056}" RootNamespace="Simple_TextureCubemap" Keyword="Win32Proj" TargetFrameworkVersion="131072">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" UseLibraryDependencyInputs="false" LinkIncremental="2" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" EmbedManifest="true" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" RuntimeLibrary="0" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="1" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" OptimizeReferences="2" EnableCOMDATFolding="2" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <File RelativePath=".\Simple_TextureCubemap.c">
-    </File>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="Simple_TextureCubemap"
+	ProjectGUID="{5EE56061-643D-406E-B42D-4299D2411056}"
+	RootNamespace="Simple_TextureCubemap"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				UseLibraryDependencyInputs="false"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+				EmbedManifest="true"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\Simple_TextureCubemap.c"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/samples/gles2_book/Simple_VertexShader/Simple_VertexShader.vcproj
--- a/gfx/angle/samples/gles2_book/Simple_VertexShader/Simple_VertexShader.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/samples/gles2_book/Simple_VertexShader/Simple_VertexShader.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,56 +1,183 @@
 <?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="Simple_VertexShader" ProjectGUID="{667CE95F-5DD8-4395-8C18-5CA8A175B12D}" RootNamespace="Simple_VertexShader" Keyword="Win32Proj" TargetFrameworkVersion="131072">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="2" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" EmbedManifest="true" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" RuntimeLibrary="0" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="1" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" OptimizeReferences="2" EnableCOMDATFolding="2" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <File RelativePath=".\Simple_VertexShader.c">
-    </File>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="Simple_VertexShader"
+	ProjectGUID="{667CE95F-5DD8-4395-8C18-5CA8A175B12D}"
+	RootNamespace="Simple_VertexShader"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+				EmbedManifest="true"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\Simple_VertexShader.c"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/samples/gles2_book/Stencil_Test/Stencil_Test.vcproj
--- a/gfx/angle/samples/gles2_book/Stencil_Test/Stencil_Test.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/samples/gles2_book/Stencil_Test/Stencil_Test.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,56 +1,177 @@
 <?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="Stencil_Test" ProjectGUID="{EEACE995-26BC-4D56-A8B3-3E7A9AB3EB26}" RootNamespace="Stencil_Test" TargetFrameworkVersion="131072">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="2">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="2" AdditionalLibraryDirectories="" IgnoreAllDefaultLibraries="false" GenerateDebugInformation="true" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="2" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" RuntimeLibrary="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" AdditionalLibraryDirectories="" GenerateDebugInformation="true" OptimizeReferences="2" EnableCOMDATFolding="2" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <File RelativePath=".\Stencil_Test.c">
-    </File>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="Stencil_Test"
+	ProjectGUID="{EEACE995-26BC-4D56-A8B3-3E7A9AB3EB26}"
+	RootNamespace="Stencil_Test"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories=""
+				IgnoreAllDefaultLibraries="false"
+				GenerateDebugInformation="true"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				RuntimeLibrary="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\Stencil_Test.c"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/samples/gles2_book/TextureWrap/TextureWrap.vcproj
--- a/gfx/angle/samples/gles2_book/TextureWrap/TextureWrap.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/samples/gles2_book/TextureWrap/TextureWrap.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,56 +1,183 @@
 <?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="TextureWrap" ProjectGUID="{CC1DE9A2-B456-4565-9C21-932253E969B9}" RootNamespace="TextureWrap" Keyword="Win32Proj" TargetFrameworkVersion="131072">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="2" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" EmbedManifest="true" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="0" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" AdditionalIncludeDirectories="../Common;../../../include" PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" RuntimeLibrary="0" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="1" AdditionalLibraryDirectories="" GenerateDebugInformation="true" SubSystem="1" OptimizeReferences="2" EnableCOMDATFolding="2" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <File RelativePath=".\TextureWrap.c">
-    </File>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="TextureWrap"
+	ProjectGUID="{CC1DE9A2-B456-4565-9C21-932253E969B9}"
+	RootNamespace="TextureWrap"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+				EmbedManifest="true"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../Common;../../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\TextureWrap.c"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/samples/samples.sln
--- a/gfx/angle/samples/samples.sln	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/samples/samples.sln	Sat Jun 09 12:08:28 2012 +0900
@@ -1,6 +1,5 @@
-﻿
-Microsoft Visual Studio Solution File, Format Version 9.00
-# Visual Studio 2005
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual C++ Express 2008
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "esUtil", "gles2_book\Common\esUtil.vcproj", "{47C93F52-AB4E-4FF9-8D4F-B38CD60A183F}"
 	ProjectSection(ProjectDependencies) = postProject
 		{B5871A7A-968C-42E3-A33B-981E6F448E78} = {B5871A7A-968C-42E3-A33B-981E6F448E78}
@@ -154,4 +153,3 @@
 		HideSolutionNode = FALSE
 	EndGlobalSection
 EndGlobal
-
diff -r 91d3e124dee2 gfx/angle/samples/translator/essl_to_hlsl.vcproj
--- a/gfx/angle/samples/translator/essl_to_hlsl.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/samples/translator/essl_to_hlsl.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,62 +1,195 @@
 <?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="essl_to_hlsl" ProjectGUID="{E12EA115-EBC7-47C2-B651-30A0CE986025}" RootNamespace="essl_to_hlsl" Keyword="Win32Proj" TargetFrameworkVersion="196613">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="../../include" PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" UsePrecompiledHeader="0" WarningLevel="3" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="2" GenerateDebugInformation="true" SubSystem="1" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="1" CharacterSet="1" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="2" EnableIntrinsicFunctions="true" AdditionalIncludeDirectories="../../include" PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS" RuntimeLibrary="0" EnableFunctionLevelLinking="true" UsePrecompiledHeader="0" WarningLevel="3" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" LinkIncremental="1" GenerateDebugInformation="true" SubSystem="1" OptimizeReferences="2" EnableCOMDATFolding="2" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <Filter Name="Source Files" Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx" UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
-      <File RelativePath="..\..\src\common\debug.cpp">
-      </File>
-      <File RelativePath=".\translator.cpp">
-      </File>
-    </Filter>
-    <Filter Name="Header Files" Filter="h;hpp;hxx;hm;inl;inc;xsd" UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
-    </Filter>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="essl_to_hlsl"
+	ProjectGUID="{E12EA115-EBC7-47C2-B651-30A0CE986025}"
+	RootNamespace="essl_to_hlsl"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="196613"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../include;../../src"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="d3d9.lib"
+				LinkIncremental="2"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../../include;../../src"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="d3d9.lib"
+				LinkIncremental="1"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\..\src\common\debug.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\translator.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/samples/translator/translator.cpp
--- a/gfx/angle/samples/translator/translator.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/samples/translator/translator.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -26,7 +26,7 @@
 static void usage();
 static ShShaderType FindShaderType(const char* fileName);
 static bool CompileFile(char* fileName, ShHandle compiler, int compileOptions);
-static void LogMsg(char* msg, const char* name, const int num, const char* logName);
+static void LogMsg(const char* msg, const char* name, const int num, const char* logName);
 static void PrintActiveVariables(ShHandle compiler, ShShaderInfo varType, bool mapLongVariableNames);
 
 // If NUM_SOURCE_STRINGS is set to a value > 1, the input file data is
@@ -67,6 +67,7 @@
     char* buffer = 0;
     int bufferLen = 0;
     int numAttribs = 0, numUniforms = 0;
+    ShShaderSpec spec = SH_GLES2_SPEC;
     ShShaderOutput output = SH_ESSL_OUTPUT;
 
     ShInitialize();
@@ -85,6 +86,20 @@
             case 'u': compileOptions |= SH_ATTRIBUTES_UNIFORMS; break;
             case 'l': compileOptions |= SH_UNROLL_FOR_LOOP_WITH_INTEGER_INDEX; break;
             case 'e': compileOptions |= SH_EMULATE_BUILT_IN_FUNCTIONS; break;
+            case 'd': compileOptions |= SH_DEPENDENCY_GRAPH; break;
+            case 't': compileOptions |= SH_TIMING_RESTRICTIONS; break;
+            case 's':
+                if (argv[0][2] == '=') {
+                    switch (argv[0][3]) {
+                        case 'e': spec = SH_GLES2_SPEC; break;
+                        case 'w': spec = SH_WEBGL_SPEC; break;
+                        case 'c': spec = SH_CSS_SHADERS_SPEC; break;
+                        default: failCode = EFailUsage;
+                    }                    
+                } else {
+                    failCode = EFailUsage;
+                }
+                break;
             case 'b':
                 if (argv[0][2] == '=') {
                     switch (argv[0][3]) {
@@ -116,13 +131,13 @@
             case SH_VERTEX_SHADER:
                 if (vertexCompiler == 0)
                     vertexCompiler = ShConstructCompiler(
-                        SH_VERTEX_SHADER, SH_GLES2_SPEC, output, &resources);
+                        SH_VERTEX_SHADER, spec, output, &resources);
                 compiler = vertexCompiler;
                 break;
             case SH_FRAGMENT_SHADER:
                 if (fragmentCompiler == 0)
                     fragmentCompiler = ShConstructCompiler(
-                        SH_FRAGMENT_SHADER, SH_GLES2_SPEC, output, &resources);
+                        SH_FRAGMENT_SHADER, spec, output, &resources);
                 compiler = fragmentCompiler;
                 break;
             default: break;
@@ -196,6 +211,11 @@
         "       -u       : print active attribs and uniforms\n"
         "       -l       : unroll for-loops with integer indices\n"
         "       -e       : emulate certain built-in functions (workaround for driver bugs)\n"
+        "       -t       : enforce experimental timing restrictions\n"
+        "       -d       : print dependency graph used to enforce timing restrictions\n"
+        "       -s=e     : use GLES2 spec (this is by default)\n"
+        "       -s=w     : use WebGL spec\n"
+        "       -s=c     : use CSS Shaders spec\n"
         "       -b=e     : output GLSL ES code (this is by default)\n"
         "       -b=g     : output GLSL code\n"
         "       -b=h     : output HLSL code\n"
@@ -243,7 +263,7 @@
     return ret ? true : false;
 }
 
-void LogMsg(char* msg, const char* name, const int num, const char* logName)
+void LogMsg(const char* msg, const char* name, const int num, const char* logName)
 {
     printf("#### %s %s %d %s ####\n", msg, name, num, logName);
 }
@@ -272,7 +292,7 @@
 
     int activeVars = 0, size = 0;
     ShDataType type = SH_NONE;
-    char* typeName = NULL;
+    const char* typeName = NULL;
     ShGetInfo(compiler, varType, &activeVars);
     for (int i = 0; i < activeVars; ++i) {
         switch (varType) {
diff -r 91d3e124dee2 gfx/angle/src/ANGLE.sln
--- a/gfx/angle/src/ANGLE.sln	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/ANGLE.sln	Sat Jun 09 12:08:28 2012 +0900
@@ -1,6 +1,6 @@
 ﻿
-Microsoft Visual Studio Solution File, Format Version 9.00
-# Visual Studio 2005
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual C++ Express 2008
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libEGL", "libEGL\libEGL.vcproj", "{E746FCA9-64C3-433E-85E8-9A5A67AB7ED6}"
 	ProjectSection(ProjectDependencies) = postProject
 		{B5871A7A-968C-42E3-A33B-981E6F448E78} = {B5871A7A-968C-42E3-A33B-981E6F448E78}
@@ -63,4 +63,3 @@
 		HideSolutionNode = FALSE
 	EndGlobalSection
 EndGlobal
-obal
diff -r 91d3e124dee2 gfx/angle/src/build_angle.gyp
--- a/gfx/angle/src/build_angle.gyp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/build_angle.gyp	Sat Jun 09 12:08:28 2012 +0900
@@ -1,4 +1,4 @@
-# Copyright (c) 2010 The ANGLE Project Authors. All rights reserved.
+# Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
@@ -16,15 +16,29 @@
       'include_dirs': [
       ],
       'sources': [
+        'compiler/preprocessor/new/Diagnostics.cpp',
+        'compiler/preprocessor/new/Diagnostics.h',
+        'compiler/preprocessor/new/DirectiveHandler.cpp',
+        'compiler/preprocessor/new/DirectiveHandler.h',
+        'compiler/preprocessor/new/DirectiveParser.cpp',
+        'compiler/preprocessor/new/DirectiveParser.h',
+        'compiler/preprocessor/new/ExpressionParser.cpp',
+        'compiler/preprocessor/new/ExpressionParser.h',
         'compiler/preprocessor/new/Input.cpp',
         'compiler/preprocessor/new/Input.h',
         'compiler/preprocessor/new/Lexer.cpp',
         'compiler/preprocessor/new/Lexer.h',
-        'compiler/preprocessor/new/pp_lex.cpp',
+        'compiler/preprocessor/new/Macro.cpp',
+        'compiler/preprocessor/new/Macro.h',
+        'compiler/preprocessor/new/MacroExpander.cpp',
+        'compiler/preprocessor/new/MacroExpander.h',
         'compiler/preprocessor/new/Preprocessor.cpp',
         'compiler/preprocessor/new/Preprocessor.h',
+        'compiler/preprocessor/new/SourceLocation.h',
         'compiler/preprocessor/new/Token.cpp',
         'compiler/preprocessor/new/Token.h',
+        'compiler/preprocessor/new/Tokenizer.cpp',
+        'compiler/preprocessor/new/Tokenizer.h',
       ],
     },
     {
@@ -112,6 +126,19 @@
         'compiler/preprocessor/symbols.h',
         'compiler/preprocessor/tokens.c',
         'compiler/preprocessor/tokens.h',
+        # Dependency graph
+        'compiler/depgraph/DependencyGraph.cpp',
+        'compiler/depgraph/DependencyGraph.h',
+        'compiler/depgraph/DependencyGraphBuilder.cpp',
+        'compiler/depgraph/DependencyGraphBuilder.h',
+        'compiler/depgraph/DependencyGraphOutput.cpp',
+        'compiler/depgraph/DependencyGraphOutput.h',
+        'compiler/depgraph/DependencyGraphTraverse.cpp',
+        # Timing restrictions
+        'compiler/timing/RestrictFragmentShaderTiming.cpp',
+        'compiler/timing/RestrictFragmentShaderTiming.h',
+        'compiler/timing/RestrictVertexShaderTiming.cpp',
+        'compiler/timing/RestrictVertexShaderTiming.h',
       ],
       'conditions': [
         ['OS=="win"', {
@@ -166,13 +193,15 @@
           ],
           'sources': [
             'compiler/ShaderLang.cpp',
+            'compiler/DetectDiscontinuity.cpp',
+            'compiler/DetectDiscontinuity.h',
             'compiler/CodeGenHLSL.cpp',
             'compiler/OutputHLSL.cpp',
             'compiler/OutputHLSL.h',
             'compiler/TranslatorHLSL.cpp',
             'compiler/TranslatorHLSL.h',
-            'compiler/UnfoldSelect.cpp',
-            'compiler/UnfoldSelect.h',
+            'compiler/UnfoldShortCircuit.cpp',
+            'compiler/UnfoldShortCircuit.h',
             'compiler/SearchSymbol.cpp',
             'compiler/SearchSymbol.h',
           ],
@@ -218,6 +247,8 @@
             'libGLESv2/mathutil.h',
             'libGLESv2/Program.cpp',
             'libGLESv2/Program.h',
+            'libGLESv2/ProgramBinary.cpp',
+            'libGLESv2/ProgramBinary.h',
             'libGLESv2/Query.h',
             'libGLESv2/Query.cpp',
             'libGLESv2/Renderbuffer.cpp',
diff -r 91d3e124dee2 gfx/angle/src/common/angleutils.h
--- a/gfx/angle/src/common/angleutils.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/common/angleutils.h	Sat Jun 09 12:08:28 2012 +0900
@@ -15,4 +15,8 @@
   TypeName(const TypeName&);               \
   void operator=(const TypeName&)
 
+#if defined(_MSC_VER)
+#define snprintf _snprintf
+#endif
+
 #endif // COMMON_ANGLEUTILS_H_
diff -r 91d3e124dee2 gfx/angle/src/common/debug.cpp
--- a/gfx/angle/src/common/debug.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/common/debug.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -1,103 +1,103 @@
-//
-// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-//
-
-// debug.cpp: Debugging utilities.
-
-#include "common/debug.h"
-
-#include <stdio.h>
-#include <stdarg.h>
-#include <d3d9.h>
-#include <windows.h>
-
-namespace gl
-{
-
-typedef void (WINAPI *PerfOutputFunction)(D3DCOLOR, LPCWSTR);
-
-static void output(bool traceFileDebugOnly, PerfOutputFunction perfFunc, const char *format, va_list vararg)
-{
-#if !defined(ANGLE_DISABLE_PERF)
-    if (perfActive())
-    {
-        char message[32768];
-        int len = vsprintf_s(message, format, vararg);
-        if (len < 0)
-        {
-            return;
-        }
-
-        // There are no ASCII variants of these D3DPERF functions.
-        wchar_t wideMessage[32768];
-        for (int i = 0; i < len; ++i)
-        {
-            wideMessage[i] = message[i];
-        }
-        wideMessage[len] = 0;
-
-        perfFunc(0, wideMessage);
-    }
-#endif
-
-#if !defined(ANGLE_DISABLE_TRACE)
-#if defined(NDEBUG)
-    if (traceFileDebugOnly)
-    {
-        return;
-    }
-#endif
-
-    FILE* file = fopen(TRACE_OUTPUT_FILE, "a");
-    if (file)
-    {
-        vfprintf(file, format, vararg);
-        fclose(file);
-    }
-#endif
-}
-
-void trace(bool traceFileDebugOnly, const char *format, ...)
-{
-    va_list vararg;
-    va_start(vararg, format);
-#if defined(ANGLE_DISABLE_PERF)
-    output(traceFileDebugOnly, NULL, format, vararg);
-#else
-    output(traceFileDebugOnly, D3DPERF_SetMarker, format, vararg);
-#endif
-    va_end(vararg);
-}
-
-bool perfActive()
-{
-#if defined(ANGLE_DISABLE_PERF)
-    return false;
-#else
-    static bool active = D3DPERF_GetStatus() != 0;
-    return active;
-#endif
-}
-
-ScopedPerfEventHelper::ScopedPerfEventHelper(const char* format, ...)
-{
-#if !defined(ANGLE_DISABLE_PERF)
-    va_list vararg;
-    va_start(vararg, format);
-    output(true, reinterpret_cast<PerfOutputFunction>(D3DPERF_BeginEvent), format, vararg);
-    va_end(vararg);
-#endif
-}
-
-ScopedPerfEventHelper::~ScopedPerfEventHelper()
-{
-#if !defined(ANGLE_DISABLE_PERF)
-    if (perfActive())
-    {
-        D3DPERF_EndEvent();
-    }
-#endif
-}
-}
+//
+// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+// debug.cpp: Debugging utilities.
+
+#include "common/debug.h"
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <d3d9.h>
+#include <windows.h>
+
+namespace gl
+{
+
+typedef void (WINAPI *PerfOutputFunction)(D3DCOLOR, LPCWSTR);
+
+static void output(bool traceFileDebugOnly, PerfOutputFunction perfFunc, const char *format, va_list vararg)
+{
+#if !defined(ANGLE_DISABLE_PERF)
+    if (perfActive())
+    {
+        char message[32768];
+        int len = vsprintf_s(message, format, vararg);
+        if (len < 0)
+        {
+            return;
+        }
+
+        // There are no ASCII variants of these D3DPERF functions.
+        wchar_t wideMessage[32768];
+        for (int i = 0; i < len; ++i)
+        {
+            wideMessage[i] = message[i];
+        }
+        wideMessage[len] = 0;
+
+        perfFunc(0, wideMessage);
+    }
+#endif
+
+#if !defined(ANGLE_DISABLE_TRACE)
+#if defined(NDEBUG)
+    if (traceFileDebugOnly)
+    {
+        return;
+    }
+#endif
+
+    FILE* file = fopen(TRACE_OUTPUT_FILE, "a");
+    if (file)
+    {
+        vfprintf(file, format, vararg);
+        fclose(file);
+    }
+#endif
+}
+
+void trace(bool traceFileDebugOnly, const char *format, ...)
+{
+    va_list vararg;
+    va_start(vararg, format);
+#if defined(ANGLE_DISABLE_PERF)
+    output(traceFileDebugOnly, NULL, format, vararg);
+#else
+    output(traceFileDebugOnly, D3DPERF_SetMarker, format, vararg);
+#endif
+    va_end(vararg);
+}
+
+bool perfActive()
+{
+#if defined(ANGLE_DISABLE_PERF)
+    return false;
+#else
+    static bool active = D3DPERF_GetStatus() != 0;
+    return active;
+#endif
+}
+
+ScopedPerfEventHelper::ScopedPerfEventHelper(const char* format, ...)
+{
+#if !defined(ANGLE_DISABLE_PERF)
+    va_list vararg;
+    va_start(vararg, format);
+    output(true, reinterpret_cast<PerfOutputFunction>(D3DPERF_BeginEvent), format, vararg);
+    va_end(vararg);
+#endif
+}
+
+ScopedPerfEventHelper::~ScopedPerfEventHelper()
+{
+#if !defined(ANGLE_DISABLE_PERF)
+    if (perfActive())
+    {
+        D3DPERF_EndEvent();
+    }
+#endif
+}
+}
diff -r 91d3e124dee2 gfx/angle/src/common/version.h
--- a/gfx/angle/src/common/version.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/common/version.h	Sat Jun 09 12:08:28 2012 +0900
@@ -1,7 +1,7 @@
 #define MAJOR_VERSION 1
 #define MINOR_VERSION 0
 #define BUILD_VERSION 0
-#define BUILD_REVISION 1041
+#define BUILD_REVISION 1143
 
 #define STRINGIFY(x) #x
 #define MACRO_STRINGIFY(x) STRINGIFY(x)
diff -r 91d3e124dee2 gfx/angle/src/compiler/Compiler.cpp
--- a/gfx/angle/src/compiler/Compiler.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/Compiler.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -10,8 +10,18 @@
 #include "compiler/Initialize.h"
 #include "compiler/MapLongVariableNames.h"
 #include "compiler/ParseHelper.h"
+#include "compiler/RenameFunction.h"
 #include "compiler/ShHandle.h"
 #include "compiler/ValidateLimitations.h"
+#include "compiler/depgraph/DependencyGraph.h"
+#include "compiler/depgraph/DependencyGraphOutput.h"
+#include "compiler/timing/RestrictFragmentShaderTiming.h"
+#include "compiler/timing/RestrictVertexShaderTiming.h"
+
+bool isWebGLBasedSpec(ShShaderSpec spec)
+{
+     return spec == SH_WEBGL_SPEC || spec == SH_CSS_SHADERS_SPEC;
+}
 
 namespace {
 bool InitializeSymbolTable(
@@ -123,7 +133,7 @@
         return true;
 
     // If compiling for WebGL, validate loop and indexing as well.
-    if (shaderSpec == SH_WEBGL_SPEC)
+    if (isWebGLBasedSpec(shaderSpec))
         compileOptions |= SH_VALIDATE_LOOP_INDEXING;
 
     // First string is path of source file if flag is set. The actual source follows.
@@ -161,6 +171,12 @@
         if (success && (compileOptions & SH_VALIDATE_LOOP_INDEXING))
             success = validateLimitations(root);
 
+        if (success && (compileOptions & SH_TIMING_RESTRICTIONS))
+            success = enforceTimingRestrictions(root, (compileOptions & SH_DEPENDENCY_GRAPH) != 0);
+
+        if (success && shaderSpec == SH_CSS_SHADERS_SPEC)
+            rewriteCSSShader(root);
+
         // Unroll for-loop markup needs to happen after validateLimitations pass.
         if (success && (compileOptions & SH_UNROLL_FOR_LOOP_WITH_INTEGER_INDEX))
             ForLoopUnroll::MarkForLoopsWithIntegerIndicesForUnrolling(root);
@@ -235,12 +251,58 @@
     }
 }
 
+void TCompiler::rewriteCSSShader(TIntermNode* root)
+{
+    RenameFunction renamer("main(", "css_main(");
+    root->traverse(&renamer);
+}
+
 bool TCompiler::validateLimitations(TIntermNode* root) {
     ValidateLimitations validate(shaderType, infoSink.info);
     root->traverse(&validate);
     return validate.numErrors() == 0;
 }
 
+bool TCompiler::enforceTimingRestrictions(TIntermNode* root, bool outputGraph)
+{
+    if (shaderSpec != SH_WEBGL_SPEC) {
+        infoSink.info << "Timing restrictions must be enforced under the WebGL spec.";
+        return false;
+    }
+
+    if (shaderType == SH_FRAGMENT_SHADER) {
+        TDependencyGraph graph(root);
+
+        // Output any errors first.
+        bool success = enforceFragmentShaderTimingRestrictions(graph);
+        
+        // Then, output the dependency graph.
+        if (outputGraph) {
+            TDependencyGraphOutput output(infoSink.info);
+            output.outputAllSpanningTrees(graph);
+        }
+        
+        return success;
+    }
+    else {
+        return enforceVertexShaderTimingRestrictions(root);
+    }
+}
+
+bool TCompiler::enforceFragmentShaderTimingRestrictions(const TDependencyGraph& graph)
+{
+    RestrictFragmentShaderTiming restrictor(infoSink.info);
+    restrictor.enforceRestrictions(graph);
+    return restrictor.numErrors() == 0;
+}
+
+bool TCompiler::enforceVertexShaderTimingRestrictions(TIntermNode* root)
+{
+    RestrictVertexShaderTiming restrictor(infoSink.info);
+    restrictor.enforceRestrictions(root);
+    return restrictor.numErrors() == 0;
+}
+
 void TCompiler::collectAttribsUniforms(TIntermNode* root)
 {
     CollectAttribsUniforms collect(attribs, uniforms);
diff -r 91d3e124dee2 gfx/angle/src/compiler/DetectDiscontinuity.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/DetectDiscontinuity.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,119 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// Contains analysis utilities for dealing with HLSL's lack of support for
+// the use of intrinsic functions which (implicitly or explicitly) compute
+// gradients of functions with discontinuities. 
+//
+
+#include "compiler/DetectDiscontinuity.h"
+
+#include "compiler/ParseHelper.h"
+
+namespace sh
+{
+bool DetectLoopDiscontinuity::traverse(TIntermNode *node)
+{
+    mLoopDiscontinuity = false;
+    node->traverse(this);
+    return mLoopDiscontinuity;
+}
+
+bool DetectLoopDiscontinuity::visitBranch(Visit visit, TIntermBranch *node)
+{
+    if (mLoopDiscontinuity)
+    {
+        return false;
+    }
+
+    switch (node->getFlowOp())
+    {
+      case EOpKill:
+        break;
+      case EOpBreak:
+      case EOpContinue:
+        mLoopDiscontinuity = true;
+      case EOpReturn:
+        break;
+      default: UNREACHABLE();
+    }
+
+    return !mLoopDiscontinuity;
+}
+
+bool DetectLoopDiscontinuity::visitAggregate(Visit visit, TIntermAggregate *node)
+{
+    return !mLoopDiscontinuity;
+}
+
+bool containsLoopDiscontinuity(TIntermNode *node)
+{
+    DetectLoopDiscontinuity detectLoopDiscontinuity;
+    return detectLoopDiscontinuity.traverse(node);
+}
+
+bool DetectGradientOperation::traverse(TIntermNode *node)
+{
+    mGradientOperation = false;
+    node->traverse(this);
+    return mGradientOperation;
+}
+
+bool DetectGradientOperation::visitUnary(Visit visit, TIntermUnary *node)
+{
+    if (mGradientOperation)
+    {
+        return false;
+    }
+
+    switch (node->getOp())
+    {
+      case EOpDFdx:
+      case EOpDFdy:
+        mGradientOperation = true;
+      default:
+        break;
+    }
+
+    return !mGradientOperation;
+}
+
+bool DetectGradientOperation::visitAggregate(Visit visit, TIntermAggregate *node)
+{
+    if (mGradientOperation)
+    {
+        return false;
+    }
+
+    if (node->getOp() == EOpFunctionCall)
+    {
+        if (!node->isUserDefined())
+        {
+            TString name = TFunction::unmangleName(node->getName());
+
+            if (name == "texture2D" ||
+                name == "texture2DProj" ||
+                name == "textureCube")
+            {
+                mGradientOperation = true;
+            }
+        }
+        else
+        {
+            // When a user defined function is called, we have to
+            // conservatively assume it to contain gradient operations
+            mGradientOperation = true;
+        }
+    }
+
+    return !mGradientOperation;
+}
+
+bool containsGradientOperation(TIntermNode *node)
+{
+    DetectGradientOperation detectGradientOperation;
+    return detectGradientOperation.traverse(node);
+}
+}
diff -r 91d3e124dee2 gfx/angle/src/compiler/DetectDiscontinuity.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/DetectDiscontinuity.h	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,50 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// Contains analysis utilities for dealing with HLSL's lack of support for
+// the use of intrinsic functions which (implicitly or explicitly) compute
+// gradients of functions with discontinuities. 
+//
+
+#ifndef COMPILER_DETECTDISCONTINUITY_H_
+#define COMPILER_DETECTDISCONTINUITY_H_
+
+#include "compiler/intermediate.h"
+
+namespace sh
+{
+// Checks whether a loop can run for a variable number of iterations
+class DetectLoopDiscontinuity : public TIntermTraverser
+{
+  public:
+    bool traverse(TIntermNode *node);
+
+  protected:
+    bool visitBranch(Visit visit, TIntermBranch *node);
+    bool visitAggregate(Visit visit, TIntermAggregate *node);
+
+    bool mLoopDiscontinuity;
+};
+
+bool containsLoopDiscontinuity(TIntermNode *node);
+
+// Checks for intrinsic functions which compute gradients
+class DetectGradientOperation : public TIntermTraverser
+{
+  public:
+    bool traverse(TIntermNode *node);
+
+  protected:
+    bool visitUnary(Visit visit, TIntermUnary *node);
+    bool visitAggregate(Visit visit, TIntermAggregate *node);
+
+    bool mGradientOperation;
+};
+
+bool containsGradientOperation(TIntermNode *node);
+
+}
+
+#endif   // COMPILER_DETECTDISCONTINUITY_H_
diff -r 91d3e124dee2 gfx/angle/src/compiler/Initialize.cpp
--- a/gfx/angle/src/compiler/Initialize.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/Initialize.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -475,7 +475,7 @@
 // Implementation dependent built-in constants.
 //
 //============================================================================
-static TString BuiltInConstants(const ShBuiltInResources &resources)
+static TString BuiltInConstants(ShShaderSpec spec, const ShBuiltInResources &resources)
 {
     TStringStream s;
 
@@ -487,7 +487,9 @@
     s << "const int gl_MaxCombinedTextureImageUnits = " << resources.MaxCombinedTextureImageUnits << ";";
     s << "const int gl_MaxTextureImageUnits = " << resources.MaxTextureImageUnits << ";";
     s << "const int gl_MaxFragmentUniformVectors = " << resources.MaxFragmentUniformVectors << ";";
-    s << "const int gl_MaxDrawBuffers = " << resources.MaxDrawBuffers << ";";
+
+    if (spec != SH_CSS_SHADERS_SPEC)
+        s << "const int gl_MaxDrawBuffers = " << resources.MaxDrawBuffers << ";";
 
     return s.str();
 }
@@ -513,7 +515,7 @@
     default: assert(false && "Language not supported");
     }
 
-    builtInStrings.push_back(BuiltInConstants(resources));
+    builtInStrings.push_back(BuiltInConstants(spec, resources));
 }
 
 void IdentifyBuiltIns(ShShaderType type, ShShaderSpec spec,
@@ -526,11 +528,22 @@
     //
     switch(type) {
     case SH_FRAGMENT_SHADER:
-        symbolTable.insert(*new TVariable(NewPoolTString("gl_FragCoord"),                   TType(EbtFloat, EbpMedium, EvqFragCoord,   4)));
-        symbolTable.insert(*new TVariable(NewPoolTString("gl_FrontFacing"),                 TType(EbtBool,  EbpUndefined, EvqFrontFacing, 1)));
-        symbolTable.insert(*new TVariable(NewPoolTString("gl_FragColor"),                   TType(EbtFloat, EbpMedium, EvqFragColor,   4)));
-        symbolTable.insert(*new TVariable(NewPoolTString("gl_FragData[gl_MaxDrawBuffers]"), TType(EbtFloat, EbpMedium, EvqFragData,    4)));
-        symbolTable.insert(*new TVariable(NewPoolTString("gl_PointCoord"),                  TType(EbtFloat, EbpMedium, EvqPointCoord,  2)));
+        symbolTable.insert(*new TVariable(NewPoolTString("gl_FragCoord"),                       TType(EbtFloat, EbpMedium, EvqFragCoord,   4)));
+        symbolTable.insert(*new TVariable(NewPoolTString("gl_FrontFacing"),                     TType(EbtBool,  EbpUndefined, EvqFrontFacing, 1)));
+        symbolTable.insert(*new TVariable(NewPoolTString("gl_PointCoord"),                      TType(EbtFloat, EbpMedium, EvqPointCoord,  2)));
+
+        //
+        // In CSS Shaders, gl_FragColor, gl_FragData, and gl_MaxDrawBuffers are not available.
+        // Instead, css_MixColor and css_ColorMatrix are available.
+        //
+        if (spec != SH_CSS_SHADERS_SPEC) {
+            symbolTable.insert(*new TVariable(NewPoolTString("gl_FragColor"),                   TType(EbtFloat, EbpMedium, EvqFragColor,   4)));
+            symbolTable.insert(*new TVariable(NewPoolTString("gl_FragData[gl_MaxDrawBuffers]"), TType(EbtFloat, EbpMedium, EvqFragData,    4)));
+        } else {
+            symbolTable.insert(*new TVariable(NewPoolTString("css_MixColor"),                   TType(EbtFloat, EbpMedium, EvqGlobal,      4)));
+            symbolTable.insert(*new TVariable(NewPoolTString("css_ColorMatrix"),                TType(EbtFloat, EbpMedium, EvqGlobal,      4, true)));
+        }
+
         break;
 
     case SH_VERTEX_SHADER:
@@ -620,7 +633,8 @@
 
     // Finally add resource-specific variables.
     switch(type) {
-    case SH_FRAGMENT_SHADER: {
+    case SH_FRAGMENT_SHADER:
+        if (spec != SH_CSS_SHADERS_SPEC) {
             // Set up gl_FragData.  The array size.
             TType fragData(EbtFloat, EbpMedium, EvqFragData, 4, false, true);
             fragData.setArraySize(resources.MaxDrawBuffers);
diff -r 91d3e124dee2 gfx/angle/src/compiler/MapLongVariableNames.cpp
--- a/gfx/angle/src/compiler/MapLongVariableNames.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/MapLongVariableNames.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -5,7 +5,6 @@
 //
 
 #include "compiler/MapLongVariableNames.h"
-#include "spooky.h"
 
 namespace {
 
@@ -13,19 +12,13 @@
 {
     ASSERT(name.size() > MAX_SHORTENED_IDENTIFIER_SIZE);
     TStringStream stream;
-    uint64 hash = SpookyHash::Hash64(name.data(), name.length(), 0);
-
-    // We want to avoid producing a string with a double underscore,
-    // which would be an illegal GLSL identifier. We can assume that the
-    // original identifier doesn't have a double underscore, otherwise
-    // it's illegal anyway.
-    stream << (name[0] == '_' ? "webgl" : "webgl_")
-           << name.substr(0, 9)
-           << (name[8] == '_' ? "" : "_")
-           << std::hex
-           << hash;
-    ASSERT(stream.str().length() <= MAX_SHORTENED_IDENTIFIER_SIZE);
-    ASSERT(stream.str().length() >= MAX_SHORTENED_IDENTIFIER_SIZE - 2);
+    stream << "webgl_";
+    if (isGlobal)
+        stream << "g";
+    stream << id;
+    if (name[0] != '_')
+        stream << "_";
+    stream << name.substr(0, MAX_SHORTENED_IDENTIFIER_SIZE - stream.str().size());
     return stream.str();
 }
 
diff -r 91d3e124dee2 gfx/angle/src/compiler/OutputHLSL.cpp
--- a/gfx/angle/src/compiler/OutputHLSL.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/OutputHLSL.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -6,10 +6,12 @@
 
 #include "compiler/OutputHLSL.h"
 
+#include "common/angleutils.h"
 #include "compiler/compilerdebug.h"
 #include "compiler/InfoSink.h"
-#include "compiler/UnfoldSelect.h"
+#include "compiler/UnfoldShortCircuit.h"
 #include "compiler/SearchSymbol.h"
+#include "compiler/DetectDiscontinuity.h"
 
 #include <stdio.h>
 #include <algorithm>
@@ -20,13 +22,13 @@
 TString str(int i)
 {
     char buffer[20];
-    sprintf(buffer, "%d", i);
+    snprintf(buffer, sizeof(buffer), "%d", i);
     return buffer;
 }
 
 OutputHLSL::OutputHLSL(TParseContext &context) : TIntermTraverser(true, true, true), mContext(context)
 {
-    mUnfoldSelect = new UnfoldSelect(context, this);
+    mUnfoldShortCircuit = new UnfoldShortCircuit(context, this);
     mInsideFunction = false;
 
     mUsesTexture2D = false;
@@ -38,6 +40,12 @@
     mUsesTextureCube = false;
     mUsesTextureCube_bias = false;
     mUsesTextureCubeLod = false;
+    mUsesTexture2DLod0 = false;
+    mUsesTexture2DLod0_bias = false;
+    mUsesTexture2DProjLod0 = false;
+    mUsesTexture2DProjLod0_bias = false;
+    mUsesTextureCubeLod0 = false;
+    mUsesTextureCubeLod0_bias = false;
     mUsesDepthRange = false;
     mUsesFragCoord = false;
     mUsesPointCoord = false;
@@ -75,15 +83,21 @@
     mScopeDepth = 0;
 
     mUniqueIndex = 0;
+
+    mContainsLoopDiscontinuity = false;
+    mOutputLod0Function = false;
+    mInsideDiscontinuousLoop = false;
 }
 
 OutputHLSL::~OutputHLSL()
 {
-    delete mUnfoldSelect;
+    delete mUnfoldShortCircuit;
 }
 
 void OutputHLSL::output()
 {
+    mContainsLoopDiscontinuity = containsLoopDiscontinuity(mContext.treeRoot);
+
     mContext.treeRoot->traverse(this);   // Output the body first to determine what has to go in the header
     header();
 
@@ -282,6 +296,72 @@
                    "}\n"
                    "\n";
         }
+
+        // These *Lod0 intrinsics are not available in GL fragment shaders.
+        // They are used to sample using discontinuous texture coordinates.
+        if (mUsesTexture2DLod0)
+        {
+            out << "float4 gl_texture2DLod0(sampler2D s, float2 t)\n"
+                   "{\n"
+                   "    return tex2Dlod(s, float4(t.x, 1 - t.y, 0, 0));\n"
+                   "}\n"
+                   "\n";
+        }
+
+        if (mUsesTexture2DLod0_bias)
+        {
+            out << "float4 gl_texture2DLod0(sampler2D s, float2 t, float bias)\n"
+                   "{\n"
+                   "    return tex2Dlod(s, float4(t.x, 1 - t.y, 0, 0));\n"
+                   "}\n"
+                   "\n";
+        }
+
+        if (mUsesTexture2DProjLod0)
+        {
+            out << "float4 gl_texture2DProjLod0(sampler2D s, float3 t)\n"
+                   "{\n"
+                   "    return tex2Dlod(s, float4(t.x / t.z, 1 - t.y / t.z, 0, 0));\n"
+                   "}\n"
+                   "\n"
+                   "float4 gl_texture2DProjLod(sampler2D s, float4 t)\n"
+                   "{\n"
+                   "    return tex2Dlod(s, float4(t.x / t.w, 1 - t.y / t.w, 0, 0));\n"
+                   "}\n"
+                   "\n";
+        }
+
+        if (mUsesTexture2DProjLod0_bias)
+        {
+            out << "float4 gl_texture2DProjLod0_bias(sampler2D s, float3 t, float bias)\n"
+                   "{\n"
+                   "    return tex2Dlod(s, float4(t.x / t.z, 1 - t.y / t.z, 0, 0));\n"
+                   "}\n"
+                   "\n"
+                   "float4 gl_texture2DProjLod_bias(sampler2D s, float4 t, float bias)\n"
+                   "{\n"
+                   "    return tex2Dlod(s, float4(t.x / t.w, 1 - t.y / t.w, 0, 0));\n"
+                   "}\n"
+                   "\n";
+        }
+
+        if (mUsesTextureCubeLod0)
+        {
+            out << "float4 gl_textureCubeLod0(samplerCUBE s, float3 t)\n"
+                   "{\n"
+                   "    return texCUBElod(s, float4(t.x, -t.y, t.z, 0));\n"
+                   "}\n"
+                   "\n";
+        }
+
+        if (mUsesTextureCubeLod0_bias)
+        {
+            out << "float4 gl_textureCubeLod0(samplerCUBE s, float3 t, float bias)\n"
+                   "{\n"
+                   "    return texCUBElod(s, float4(t.x, -t.y, t.z, 0));\n"
+                   "}\n"
+                   "\n";
+        }
     }
     else   // Vertex shader
     {
@@ -1054,12 +1134,16 @@
       case EOpVectorTimesMatrix: outputTriplet(visit, "mul(", ", transpose(", "))"); break;
       case EOpMatrixTimesVector: outputTriplet(visit, "mul(transpose(", "), ", ")"); break;
       case EOpMatrixTimesMatrix: outputTriplet(visit, "transpose(mul(transpose(", "), transpose(", ")))"); break;
-      case EOpLogicalOr:         outputTriplet(visit, "(", " || ", ")");  break;
+      case EOpLogicalOr:
+        out << "s" << mUnfoldShortCircuit->getNextTemporaryIndex();
+        return false;
       case EOpLogicalXor:
         mUsesXor = true;
         outputTriplet(visit, "xor(", ", ", ")");
         break;
-      case EOpLogicalAnd:        outputTriplet(visit, "(", " && ", ")");  break;
+      case EOpLogicalAnd:
+        out << "s" << mUnfoldShortCircuit->getNextTemporaryIndex();
+        return false;
       default: UNREACHABLE();
     }
 
@@ -1131,9 +1215,36 @@
       case EOpFract:            outputTriplet(visit, "frac(", "", ")");      break;
       case EOpLength:           outputTriplet(visit, "length(", "", ")");    break;
       case EOpNormalize:        outputTriplet(visit, "normalize(", "", ")"); break;
-      case EOpDFdx:             outputTriplet(visit, "ddx(", "", ")");       break;
-      case EOpDFdy:             outputTriplet(visit, "(-ddy(", "", "))");    break;
-      case EOpFwidth:           outputTriplet(visit, "fwidth(", "", ")");    break;        
+      case EOpDFdx:
+        if(mInsideDiscontinuousLoop || mOutputLod0Function)
+        {
+            outputTriplet(visit, "(", "", ", 0.0)");
+        }
+        else
+        {
+            outputTriplet(visit, "ddx(", "", ")");
+        }
+        break;
+      case EOpDFdy:
+        if(mInsideDiscontinuousLoop || mOutputLod0Function)
+        {
+            outputTriplet(visit, "(", "", ", 0.0)");
+        }
+        else
+        {
+           outputTriplet(visit, "(-ddy(", "", "))");
+        }
+        break;
+      case EOpFwidth:
+        if(mInsideDiscontinuousLoop || mOutputLod0Function)
+        {
+            outputTriplet(visit, "(", "", ", 0.0)");
+        }
+        else
+        {
+            outputTriplet(visit, "fwidth(", "", ")");
+        }
+        break;
       case EOpAny:              outputTriplet(visit, "any(", "", ")");       break;
       case EOpAll:              outputTriplet(visit, "all(", "", ")");       break;
       default: UNREACHABLE();
@@ -1171,12 +1282,7 @@
             {
                 outputLineDirective((*sit)->getLine());
 
-                if (isSingleStatement(*sit))
-                {
-                    mUnfoldSelect->traverse(*sit);
-                }
-
-                (*sit)->traverse(this);
+                traverseStatements(*sit);
 
                 out << ";\n";
             }
@@ -1290,59 +1396,64 @@
         {
             TString name = TFunction::unmangleName(node->getName());
 
-            if (visit == PreVisit)
+            out << typeString(node->getType()) << " ";
+
+            if (name == "main")
             {
-                out << typeString(node->getType()) << " ";
+                out << "gl_main(";
+            }
+            else
+            {
+                out << decorate(name) << (mOutputLod0Function ? "Lod0(" : "(");
+            }
 
-                if (name == "main")
+            TIntermSequence &sequence = node->getSequence();
+            TIntermSequence &arguments = sequence[0]->getAsAggregate()->getSequence();
+
+            for (unsigned int i = 0; i < arguments.size(); i++)
+            {
+                TIntermSymbol *symbol = arguments[i]->getAsSymbolNode();
+
+                if (symbol)
                 {
-                    out << "gl_main(";
+                    if (symbol->getType().getStruct())
+                    {
+                        addConstructor(symbol->getType(), scopedStruct(symbol->getType().getTypeName()), NULL);
+                    }
+
+                    out << argumentString(symbol);
+
+                    if (i < arguments.size() - 1)
+                    {
+                        out << ", ";
+                    }
                 }
-                else
-                {
-                    out << decorate(name) << "(";
-                }
+                else UNREACHABLE();
+            }
 
-                TIntermSequence &sequence = node->getSequence();
-                TIntermSequence &arguments = sequence[0]->getAsAggregate()->getSequence();
-
-                for (unsigned int i = 0; i < arguments.size(); i++)
-                {
-                    TIntermSymbol *symbol = arguments[i]->getAsSymbolNode();
-
-                    if (symbol)
-                    {
-                        if (symbol->getType().getStruct())
-                        {
-                            addConstructor(symbol->getType(), scopedStruct(symbol->getType().getTypeName()), NULL);
-                        }
-
-                        out << argumentString(symbol);
-
-                        if (i < arguments.size() - 1)
-                        {
-                            out << ", ";
-                        }
-                    }
-                    else UNREACHABLE();
-                }
-
-                sequence.erase(sequence.begin());
-
-                out << ")\n";
-                
-                outputLineDirective(node->getLine());
-                out << "{\n";
-                
+            out << ")\n"
+                "{\n";
+            
+            if (sequence.size() > 1)
+            {
                 mInsideFunction = true;
-            }
-            else if (visit == PostVisit)
-            {
-                outputLineDirective(node->getEndLine());
-                out << "}\n";
-
+                sequence[1]->traverse(this);
                 mInsideFunction = false;
             }
+            
+            out << "}\n";
+
+            if (mContainsLoopDiscontinuity && !mOutputLod0Function)
+            {
+                if (name != "main")
+                {
+                    mOutputLod0Function = true;
+                    node->traverse(this);
+                    mOutputLod0Function = false;
+                }
+            }
+
+            return false;
         }
         break;
       case EOpFunctionCall:
@@ -1350,54 +1461,106 @@
             if (visit == PreVisit)
             {
                 TString name = TFunction::unmangleName(node->getName());
+                bool lod0 = mInsideDiscontinuousLoop || mOutputLod0Function;
 
                 if (node->isUserDefined())
                 {
-                    out << decorate(name) << "(";
+                    out << decorate(name) << (lod0 ? "Lod0(" : "(");
                 }
                 else
                 {
                     if (name == "texture2D")
                     {
-                        if (node->getSequence().size() == 2)
+                        if (!lod0)
                         {
-                            mUsesTexture2D = true;
+                            if (node->getSequence().size() == 2)
+                            {
+                                mUsesTexture2D = true;
+                            }
+                            else if (node->getSequence().size() == 3)
+                            {
+                                mUsesTexture2D_bias = true;
+                            }
+                            else UNREACHABLE();
+
+                            out << "gl_texture2D(";
                         }
-                        else if (node->getSequence().size() == 3)
+                        else
                         {
-                            mUsesTexture2D_bias = true;
+                            if (node->getSequence().size() == 2)
+                            {
+                                mUsesTexture2DLod0 = true;
+                            }
+                            else if (node->getSequence().size() == 3)
+                            {
+                                mUsesTexture2DLod0_bias = true;
+                            }
+                            else UNREACHABLE();
+
+                            out << "gl_texture2DLod0(";
                         }
-                        else UNREACHABLE();
-
-                        out << "gl_texture2D(";
                     }
                     else if (name == "texture2DProj")
                     {
-                        if (node->getSequence().size() == 2)
+                        if (!lod0)
                         {
-                            mUsesTexture2DProj = true;
+                            if (node->getSequence().size() == 2)
+                            {
+                                mUsesTexture2DProj = true;
+                            }
+                            else if (node->getSequence().size() == 3)
+                            {
+                                mUsesTexture2DProj_bias = true;
+                            }
+                            else UNREACHABLE();
+
+                            out << "gl_texture2DProj(";
                         }
-                        else if (node->getSequence().size() == 3)
+                        else
                         {
-                            mUsesTexture2DProj_bias = true;
+                            if (node->getSequence().size() == 2)
+                            {
+                                mUsesTexture2DProjLod0 = true;
+                            }
+                            else if (node->getSequence().size() == 3)
+                            {
+                                mUsesTexture2DProjLod0_bias = true;
+                            }
+                            else UNREACHABLE();
+
+                            out << "gl_texture2DProjLod0(";
                         }
-                        else UNREACHABLE();
-
-                        out << "gl_texture2DProj(";
                     }
                     else if (name == "textureCube")
                     {
-                        if (node->getSequence().size() == 2)
+                        if (!lod0)
                         {
-                            mUsesTextureCube = true;
+                            if (node->getSequence().size() == 2)
+                            {
+                                mUsesTextureCube = true;
+                            }
+                            else if (node->getSequence().size() == 3)
+                            {
+                                mUsesTextureCube_bias = true;
+                            }
+                            else UNREACHABLE();
+
+                            out << "gl_textureCube(";
                         }
-                        else if (node->getSequence().size() == 3)
+                        else
                         {
-                            mUsesTextureCube_bias = true;
+                            if (node->getSequence().size() == 2)
+                            {
+                                mUsesTextureCubeLod0 = true;
+                            }
+                            else if (node->getSequence().size() == 3)
+                            {
+                                mUsesTextureCubeLod0_bias = true;
+                            }
+                            else UNREACHABLE();
+
+                            out << "gl_textureCubeLod0(";
                         }
-                        else UNREACHABLE();
-
-                        out << "gl_textureCube(";
                     }
                     else if (name == "texture2DLod")
                     {
@@ -1583,11 +1746,11 @@
 
     if (node->usesTernaryOperator())
     {
-        out << "s" << mUnfoldSelect->getNextTemporaryIndex();
+        out << "s" << mUnfoldShortCircuit->getNextTemporaryIndex();
     }
     else  // if/else statement
     {
-        mUnfoldSelect->traverse(node->getCondition());
+        mUnfoldShortCircuit->traverse(node->getCondition());
 
         out << "if(";
 
@@ -1600,11 +1763,11 @@
 
         if (node->getTrueBlock())
         {
-            node->getTrueBlock()->traverse(this);
+            traverseStatements(node->getTrueBlock());
         }
 
         outputLineDirective(node->getLine());
-        out << ";}\n";
+        out << ";\n}\n";
 
         if (node->getFalseBlock())
         {
@@ -1614,10 +1777,10 @@
             out << "{\n";
 
             outputLineDirective(node->getFalseBlock()->getLine());
-            node->getFalseBlock()->traverse(this);
+            traverseStatements(node->getFalseBlock());
 
             outputLineDirective(node->getFalseBlock()->getLine());
-            out << ";}\n";
+            out << ";\n}\n";
         }
     }
 
@@ -1631,6 +1794,13 @@
 
 bool OutputHLSL::visitLoop(Visit visit, TIntermLoop *node)
 {
+    bool wasDiscontinuous = mInsideDiscontinuousLoop;
+
+    if (!mInsideDiscontinuousLoop)
+    {
+        mInsideDiscontinuousLoop = containsLoopDiscontinuity(node);
+    }
+
     if (handleExcessiveLoop(node))
     {
         return false;
@@ -1676,7 +1846,7 @@
 
     if (node->getBody())
     {
-        node->getBody()->traverse(this);
+        traverseStatements(node->getBody());
     }
 
     outputLineDirective(node->getLine());
@@ -1694,6 +1864,8 @@
 
     out << "}\n";
 
+    mInsideDiscontinuousLoop = wasDiscontinuous;
+
     return false;
 }
 
@@ -1732,6 +1904,16 @@
     return true;
 }
 
+void OutputHLSL::traverseStatements(TIntermNode *node)
+{
+    if (isSingleStatement(node))
+    {
+        mUnfoldShortCircuit->traverse(node);
+    }
+
+    node->traverse(this);
+}
+
 bool OutputHLSL::isSingleStatement(TIntermNode *node)
 {
     TIntermAggregate *aggregate = node->getAsAggregate();
@@ -1759,9 +1941,11 @@
     return true;
 }
 
-// Handle loops with more than 255 iterations (unsupported by D3D9) by splitting them
+// Handle loops with more than 254 iterations (unsupported by D3D9) by splitting them
+// (The D3D documentation says 255 iterations, but the compiler complains at anything more than 254).
 bool OutputHLSL::handleExcessiveLoop(TIntermLoop *node)
 {
+    const int MAX_LOOP_ITERATIONS = 254;
     TInfoSinkBase &out = mBody;
 
     // Parse loops of the form:
@@ -1877,14 +2061,14 @@
         {
             int iterations = (limit - initial) / increment;
 
-            if (iterations <= 255)
+            if (iterations <= MAX_LOOP_ITERATIONS)
             {
                 return false;   // Not an excessive loop
             }
 
             while (iterations > 0)
             {
-                int clampedLimit = initial + increment * std::min(255, iterations);
+                int clampedLimit = initial + increment * std::min(MAX_LOOP_ITERATIONS, iterations);
 
                 // for(int index = initial; index < clampedLimit; index += increment)
 
@@ -1915,8 +2099,8 @@
                 outputLineDirective(node->getLine());
                 out << ";}\n";
 
-                initial += 255 * increment;
-                iterations -= 255;
+                initial += MAX_LOOP_ITERATIONS * increment;
+                iterations -= MAX_LOOP_ITERATIONS;
             }
 
             return true;
diff -r 91d3e124dee2 gfx/angle/src/compiler/OutputHLSL.h
--- a/gfx/angle/src/compiler/OutputHLSL.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/OutputHLSL.h	Sat Jun 09 12:08:28 2012 +0900
@@ -15,7 +15,7 @@
 
 namespace sh
 {
-class UnfoldSelect;
+class UnfoldShortCircuit;
 
 class OutputHLSL : public TIntermTraverser
 {
@@ -48,6 +48,7 @@
     bool visitLoop(Visit visit, TIntermLoop*);
     bool visitBranch(Visit visit, TIntermBranch*);
 
+    void traverseStatements(TIntermNode *node);
     bool isSingleStatement(TIntermNode *node);
     bool handleExcessiveLoop(TIntermLoop *node);
     void outputTriplet(Visit visit, const TString &preString, const TString &inString, const TString &postString);
@@ -63,7 +64,7 @@
     TString structLookup(const TString &typeName);
 
     TParseContext &mContext;
-    UnfoldSelect *mUnfoldSelect;
+    UnfoldShortCircuit *mUnfoldShortCircuit;
     bool mInsideFunction;
 
     // Output streams
@@ -85,6 +86,12 @@
     bool mUsesTextureCube;
     bool mUsesTextureCube_bias;
     bool mUsesTextureCubeLod;
+    bool mUsesTexture2DLod0;
+    bool mUsesTexture2DLod0_bias;
+    bool mUsesTexture2DProjLod0;
+    bool mUsesTexture2DProjLod0_bias;
+    bool mUsesTextureCubeLod0;
+    bool mUsesTextureCubeLod0_bias;
     bool mUsesDepthRange;
     bool mUsesFragCoord;
     bool mUsesPointCoord;
@@ -133,6 +140,10 @@
     unsigned int mScopeDepth;
 
     int mUniqueIndex;   // For creating unique names
+
+    bool mContainsLoopDiscontinuity;
+    bool mOutputLod0Function;
+    bool mInsideDiscontinuousLoop;
 };
 }
 
diff -r 91d3e124dee2 gfx/angle/src/compiler/ParseHelper.cpp
--- a/gfx/angle/src/compiler/ParseHelper.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/ParseHelper.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -452,7 +452,7 @@
             error(line, reservedErrMsg, "gl_", "");
             return true;
         }
-        if (shaderSpec == SH_WEBGL_SPEC) {
+        if (isWebGLBasedSpec(shaderSpec)) {
             if (identifier.compare(0, 6, "webgl_") == 0) {
                 error(line, reservedErrMsg, "webgl_", "");
                 return true;
@@ -461,6 +461,10 @@
                 error(line, reservedErrMsg, "_webgl_", "");
                 return true;
             }
+            if (shaderSpec == SH_CSS_SHADERS_SPEC && identifier.compare(0, 4, "css_") == 0) {
+                error(line, reservedErrMsg, "css_", "");
+                return true;
+            }
         }
         if (identifier.find("__") != TString::npos) {
             error(line, "identifiers containing two consecutive underscores (__) are reserved as possible future keywords", identifier.c_str(), "", "");
@@ -1451,7 +1455,7 @@
 
 bool TParseContext::structNestingErrorCheck(TSourceLoc line, const TType& fieldType)
 {
-    if (shaderSpec != SH_WEBGL_SPEC) {
+    if (!isWebGLBasedSpec(shaderSpec)) {
         return false;
     }
 
diff -r 91d3e124dee2 gfx/angle/src/compiler/PoolAlloc.cpp
--- a/gfx/angle/src/compiler/PoolAlloc.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/PoolAlloc.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -11,6 +11,7 @@
 #endif
 #include <stdio.h>
 
+#include "common/angleutils.h"
 #include "compiler/InitializeGlobals.h"
 #include "compiler/osinclude.h"
 
@@ -158,10 +159,10 @@
 
             // We don't print the assert message.  It's here just to be helpful.
 #if defined(_MSC_VER)
-            sprintf(assertMsg, "PoolAlloc: Damage %s %Iu byte allocation at 0x%p\n",
+            snprintf(assertMsg, sizeof(assertMsg), "PoolAlloc: Damage %s %Iu byte allocation at 0x%p\n",
                     locText, size, data());
 #else
-            sprintf(assertMsg, "PoolAlloc: Damage %s %zu byte allocation at 0x%p\n",
+            snprintf(assertMsg, sizeof(assertMsg), "PoolAlloc: Damage %s %zu byte allocation at 0x%p\n",
                     locText, size, data());
 #endif
             assert(0 && "PoolAlloc: Damage in guard block");
diff -r 91d3e124dee2 gfx/angle/src/compiler/RenameFunction.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/RenameFunction.h	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,36 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#ifndef COMPILER_RENAME_FUNCTION
+#define COMPILER_RENAME_FUNCTION
+
+#include "compiler/intermediate.h"
+
+//
+// Renames a function, including its declaration and any calls to it.
+//
+class RenameFunction : public TIntermTraverser
+{
+public:
+    RenameFunction(const TString& oldFunctionName, const TString& newFunctionName)
+    : TIntermTraverser(true, false, false)
+    , mOldFunctionName(oldFunctionName)
+    , mNewFunctionName(newFunctionName) {}
+
+    virtual bool visitAggregate(Visit visit, TIntermAggregate* node)
+    {
+        TOperator op = node->getOp();
+        if ((op == EOpFunction || op == EOpFunctionCall) && node->getName() == mOldFunctionName)
+            node->setName(mNewFunctionName);
+        return true;
+    }
+
+private:
+    const TString& mOldFunctionName;
+    const TString& mNewFunctionName;
+};
+
+#endif  // COMPILER_RENAME_FUNCTION
diff -r 91d3e124dee2 gfx/angle/src/compiler/ShHandle.h
--- a/gfx/angle/src/compiler/ShHandle.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/ShHandle.h	Sat Jun 09 12:08:28 2012 +0900
@@ -24,6 +24,13 @@
 
 class LongNameMap;
 class TCompiler;
+class TDependencyGraph;
+
+//
+// Helper function to identify specs that are based on the WebGL spec,
+// like the CSS Shaders spec.
+//
+bool isWebGLBasedSpec(ShShaderSpec spec);
 
 //
 // The base class used to back handles returned to the driver.
@@ -70,6 +77,8 @@
     void clearResults();
     // Return true if function recursion is detected.
     bool detectRecursion(TIntermNode* root);
+    // Rewrites a shader's intermediate tree according to the CSS Shaders spec.
+    void rewriteCSSShader(TIntermNode* root);
     // Returns true if the given shader does not exceed the minimum
     // functionality mandated in GLSL 1.0 spec Appendix A.
     bool validateLimitations(TIntermNode* root);
@@ -79,6 +88,13 @@
     void mapLongVariableNames(TIntermNode* root);
     // Translate to object code.
     virtual void translate(TIntermNode* root) = 0;
+    // Returns true if the shader passes the restrictions that aim to prevent timing attacks.
+    bool enforceTimingRestrictions(TIntermNode* root, bool outputGraph);
+    // Returns true if the shader does not use samplers.
+    bool enforceVertexShaderTimingRestrictions(TIntermNode* root);
+    // Returns true if the shader does not use sampler dependent values to affect control 
+    // flow or in operations whose time can depend on the input values.
+    bool enforceFragmentShaderTimingRestrictions(const TDependencyGraph& graph);
     // Get built-in extensions with default behavior.
     const TExtensionBehavior& getExtensionBehavior() const;
 
diff -r 91d3e124dee2 gfx/angle/src/compiler/SymbolTable.cpp
--- a/gfx/angle/src/compiler/SymbolTable.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/SymbolTable.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -16,8 +16,9 @@
 #include "compiler/SymbolTable.h"
 
 #include <stdio.h>
+#include <algorithm>
 
-#include <algorithm>
+#include "common/angleutils.h"
 
 //
 // TType helper function needs a place to live.
@@ -56,7 +57,7 @@
     mangledName += static_cast<char>('0' + getNominalSize());
     if (isArray()) {
         char buf[20];
-        sprintf(buf, "%d", arraySize);
+        snprintf(buf, sizeof(buf), "%d", arraySize);
         mangledName += '[';
         mangledName += buf;
         mangledName += ']';
diff -r 91d3e124dee2 gfx/angle/src/compiler/UnfoldSelect.cpp
--- a/gfx/angle/src/compiler/UnfoldSelect.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,96 +0,0 @@
-//
-// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-//
-// UnfoldSelect is an AST traverser to output the select operator ?: as if-else statements
-//
-
-#include "compiler/UnfoldSelect.h"
-
-#include "compiler/InfoSink.h"
-#include "compiler/OutputHLSL.h"
-
-namespace sh
-{
-UnfoldSelect::UnfoldSelect(TParseContext &context, OutputHLSL *outputHLSL) : mContext(context), mOutputHLSL(outputHLSL)
-{
-    mTemporaryIndex = 0;
-}
-
-void UnfoldSelect::traverse(TIntermNode *node)
-{
-    int rewindIndex = mTemporaryIndex;
-    node->traverse(this);
-    mTemporaryIndex = rewindIndex;
-}
-
-bool UnfoldSelect::visitSelection(Visit visit, TIntermSelection *node)
-{
-    TInfoSinkBase &out = mOutputHLSL->getBodyStream();
-
-    if (node->usesTernaryOperator())
-    {
-        int i = mTemporaryIndex;
-
-        out << mOutputHLSL->typeString(node->getType()) << " s" << i << ";\n";
-
-        mTemporaryIndex = i + 1;
-        node->getCondition()->traverse(this);
-        out << "if(";
-        mTemporaryIndex = i + 1;
-        node->getCondition()->traverse(mOutputHLSL);
-        out << ")\n"
-               "{\n";
-        mTemporaryIndex = i + 1;
-        node->getTrueBlock()->traverse(this);
-        out << "    s" << i << " = ";
-        mTemporaryIndex = i + 1;
-        node->getTrueBlock()->traverse(mOutputHLSL);
-        out << ";\n"
-               "}\n"
-               "else\n"
-               "{\n";
-        mTemporaryIndex = i + 1;
-        node->getFalseBlock()->traverse(this);
-        out << "    s" << i << " = ";
-        mTemporaryIndex = i + 1;
-        node->getFalseBlock()->traverse(mOutputHLSL);
-        out << ";\n"
-               "}\n";
-
-        mTemporaryIndex = i + 1;
-    }
-
-    return false;
-}
-
-bool UnfoldSelect::visitLoop(Visit visit, TIntermLoop *node)
-{
-    int rewindIndex = mTemporaryIndex;
-
-    if (node->getInit())
-    {
-        node->getInit()->traverse(this);
-    }
-    
-    if (node->getCondition())
-    {
-        node->getCondition()->traverse(this);
-    }
-
-    if (node->getExpression())
-    {
-        node->getExpression()->traverse(this);
-    }
-
-    mTemporaryIndex = rewindIndex;
-
-    return false;
-}
-
-int UnfoldSelect::getNextTemporaryIndex()
-{
-    return mTemporaryIndex++;
-}
-}
diff -r 91d3e124dee2 gfx/angle/src/compiler/UnfoldSelect.h
--- a/gfx/angle/src/compiler/UnfoldSelect.h	Tue Apr 24 18:02:41 2012 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,38 +0,0 @@
-//
-// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-//
-// UnfoldSelect is an AST traverser to output the select operator ?: as if-else statements
-//
-
-#ifndef COMPILER_UNFOLDSELECT_H_
-#define COMPILER_UNFOLDSELECT_H_
-
-#include "compiler/intermediate.h"
-#include "compiler/ParseHelper.h"
-
-namespace sh
-{
-class OutputHLSL;
-
-class UnfoldSelect : public TIntermTraverser
-{
-  public:
-    UnfoldSelect(TParseContext &context, OutputHLSL *outputHLSL);
-
-    void traverse(TIntermNode *node);
-    bool visitSelection(Visit visit, TIntermSelection *node);
-    bool visitLoop(Visit visit, TIntermLoop *node);
-
-    int getNextTemporaryIndex();
-
-  protected:
-    TParseContext &mContext;
-    OutputHLSL *const mOutputHLSL;
-
-    int mTemporaryIndex;
-};
-}
-
-#endif   // COMPILER_UNFOLDSELECT_H_
diff -r 91d3e124dee2 gfx/angle/src/compiler/UnfoldShortCircuit.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/UnfoldShortCircuit.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,172 @@
+//
+// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// UnfoldShortCircuit is an AST traverser to output short-circuiting operators as if-else statements.
+// The results are assigned to s# temporaries, which are used by the main translator instead of
+// the original expression.
+//
+
+#include "compiler/UnfoldShortCircuit.h"
+
+#include "compiler/InfoSink.h"
+#include "compiler/OutputHLSL.h"
+
+namespace sh
+{
+UnfoldShortCircuit::UnfoldShortCircuit(TParseContext &context, OutputHLSL *outputHLSL) : mContext(context), mOutputHLSL(outputHLSL)
+{
+    mTemporaryIndex = 0;
+}
+
+void UnfoldShortCircuit::traverse(TIntermNode *node)
+{
+    int rewindIndex = mTemporaryIndex;
+    node->traverse(this);
+    mTemporaryIndex = rewindIndex;
+}
+
+bool UnfoldShortCircuit::visitBinary(Visit visit, TIntermBinary *node)
+{
+    TInfoSinkBase &out = mOutputHLSL->getBodyStream();
+
+    switch (node->getOp())
+    {
+      case EOpLogicalOr:
+        // "x || y" is equivalent to "x ? true : y", which unfolds to "bool s; if(x) s = true; else s = y;",
+        // and then further simplifies down to "bool s = x; if(!s) s = y;".
+        {
+            int i = mTemporaryIndex;
+
+            out << "bool s" << i << ";\n";
+
+            out << "{\n";
+
+            mTemporaryIndex = i + 1;
+            node->getLeft()->traverse(this);
+            out << "s" << i << " = ";
+            mTemporaryIndex = i + 1;
+            node->getLeft()->traverse(mOutputHLSL);
+            out << ";\n";
+            out << "if(!s" << i << ")\n"
+                   "{\n";
+            mTemporaryIndex = i + 1;
+            node->getRight()->traverse(this);
+            out << "    s" << i << " = ";
+            mTemporaryIndex = i + 1;
+            node->getRight()->traverse(mOutputHLSL);
+            out << ";\n"
+                   "}\n";
+
+            out << "}\n";
+
+            mTemporaryIndex = i + 1;
+        }
+        return false;
+      case EOpLogicalAnd:
+        // "x && y" is equivalent to "x ? y : false", which unfolds to "bool s; if(x) s = y; else s = false;",
+        // and then further simplifies down to "bool s = x; if(s) s = y;".
+        {
+            int i = mTemporaryIndex;
+
+            out << "bool s" << i << ";\n";
+
+            out << "{\n";
+
+            mTemporaryIndex = i + 1;
+            node->getLeft()->traverse(this);
+            out << "s" << i << " = ";
+            mTemporaryIndex = i + 1;
+            node->getLeft()->traverse(mOutputHLSL);
+            out << ";\n";
+            out << "if(s" << i << ")\n"
+                   "{\n";
+            mTemporaryIndex = i + 1;
+            node->getRight()->traverse(this);
+            out << "    s" << i << " = ";
+            mTemporaryIndex = i + 1;
+            node->getRight()->traverse(mOutputHLSL);
+            out << ";\n"
+                   "}\n";
+
+            out << "}\n";
+
+            mTemporaryIndex = i + 1;
+        }
+        return false;
+    }
+
+    return true;
+}
+
+bool UnfoldShortCircuit::visitSelection(Visit visit, TIntermSelection *node)
+{
+    TInfoSinkBase &out = mOutputHLSL->getBodyStream();
+
+    // Unfold "b ? x : y" into "type s; if(b) s = x; else s = y;"
+    if (node->usesTernaryOperator())
+    {
+        int i = mTemporaryIndex;
+
+        out << mOutputHLSL->typeString(node->getType()) << " s" << i << ";\n";
+
+        mTemporaryIndex = i + 1;
+        node->getCondition()->traverse(this);
+        out << "if(";
+        mTemporaryIndex = i + 1;
+        node->getCondition()->traverse(mOutputHLSL);
+        out << ")\n"
+               "{\n";
+        mTemporaryIndex = i + 1;
+        node->getTrueBlock()->traverse(this);
+        out << "    s" << i << " = ";
+        mTemporaryIndex = i + 1;
+        node->getTrueBlock()->traverse(mOutputHLSL);
+        out << ";\n"
+               "}\n"
+               "else\n"
+               "{\n";
+        mTemporaryIndex = i + 1;
+        node->getFalseBlock()->traverse(this);
+        out << "    s" << i << " = ";
+        mTemporaryIndex = i + 1;
+        node->getFalseBlock()->traverse(mOutputHLSL);
+        out << ";\n"
+               "}\n";
+
+        mTemporaryIndex = i + 1;
+    }
+
+    return false;
+}
+
+bool UnfoldShortCircuit::visitLoop(Visit visit, TIntermLoop *node)
+{
+    int rewindIndex = mTemporaryIndex;
+
+    if (node->getInit())
+    {
+        node->getInit()->traverse(this);
+    }
+    
+    if (node->getCondition())
+    {
+        node->getCondition()->traverse(this);
+    }
+
+    if (node->getExpression())
+    {
+        node->getExpression()->traverse(this);
+    }
+
+    mTemporaryIndex = rewindIndex;
+
+    return false;
+}
+
+int UnfoldShortCircuit::getNextTemporaryIndex()
+{
+    return mTemporaryIndex++;
+}
+}
diff -r 91d3e124dee2 gfx/angle/src/compiler/UnfoldShortCircuit.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/UnfoldShortCircuit.h	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,39 @@
+//
+// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// UnfoldShortCircuit is an AST traverser to output short-circuiting operators as if-else statements
+//
+
+#ifndef COMPILER_UNFOLDSHORTCIRCUIT_H_
+#define COMPILER_UNFOLDSHORTCIRCUIT_H_
+
+#include "compiler/intermediate.h"
+#include "compiler/ParseHelper.h"
+
+namespace sh
+{
+class OutputHLSL;
+
+class UnfoldShortCircuit : public TIntermTraverser
+{
+  public:
+    UnfoldShortCircuit(TParseContext &context, OutputHLSL *outputHLSL);
+
+    void traverse(TIntermNode *node);
+    bool visitBinary(Visit visit, TIntermBinary*);
+    bool visitSelection(Visit visit, TIntermSelection *node);
+    bool visitLoop(Visit visit, TIntermLoop *node);
+
+    int getNextTemporaryIndex();
+
+  protected:
+    TParseContext &mContext;
+    OutputHLSL *const mOutputHLSL;
+
+    int mTemporaryIndex;
+};
+}
+
+#endif   // COMPILER_UNFOLDSHORTCIRCUIT_H_
diff -r 91d3e124dee2 gfx/angle/src/compiler/depgraph/DependencyGraph.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/depgraph/DependencyGraph.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,97 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#pragma warning(disable: 4718)
+
+#include "compiler/depgraph/DependencyGraph.h"
+#include "compiler/depgraph/DependencyGraphBuilder.h"
+
+TDependencyGraph::TDependencyGraph(TIntermNode* intermNode)
+{
+    TDependencyGraphBuilder::build(intermNode, this);
+}
+
+TDependencyGraph::~TDependencyGraph()
+{
+    for (TGraphNodeVector::const_iterator iter = mAllNodes.begin(); iter != mAllNodes.end(); ++iter)
+    {
+        TGraphNode* node = *iter;
+        delete node;
+    }
+}
+
+TGraphArgument* TDependencyGraph::createArgument(TIntermAggregate* intermFunctionCall,
+                                                 int argumentNumber)
+{
+    TGraphArgument* argument = new TGraphArgument(intermFunctionCall, argumentNumber);
+    mAllNodes.push_back(argument);
+    return argument;
+}
+
+TGraphFunctionCall* TDependencyGraph::createFunctionCall(TIntermAggregate* intermFunctionCall)
+{
+    TGraphFunctionCall* functionCall = new TGraphFunctionCall(intermFunctionCall);
+    mAllNodes.push_back(functionCall);
+    if (functionCall->getIntermFunctionCall()->isUserDefined())
+        mUserDefinedFunctionCalls.push_back(functionCall);
+    return functionCall;
+}
+
+TGraphSymbol* TDependencyGraph::getOrCreateSymbol(TIntermSymbol* intermSymbol)
+{
+    TSymbolIdMap::const_iterator iter = mSymbolIdMap.find(intermSymbol->getId());
+
+    TGraphSymbol* symbol = NULL;
+
+    if (iter != mSymbolIdMap.end()) {
+        TSymbolIdPair pair = *iter;
+        symbol = pair.second;
+    } else {
+        symbol = new TGraphSymbol(intermSymbol);
+        mAllNodes.push_back(symbol);
+
+        TSymbolIdPair pair(intermSymbol->getId(), symbol);
+        mSymbolIdMap.insert(pair);
+
+        // We save all sampler symbols in a collection, so we can start graph traversals from them quickly.
+        if (IsSampler(intermSymbol->getBasicType()))
+            mSamplerSymbols.push_back(symbol);
+    }
+
+    return symbol;
+}
+
+TGraphSelection* TDependencyGraph::createSelection(TIntermSelection* intermSelection)
+{
+    TGraphSelection* selection = new TGraphSelection(intermSelection);
+    mAllNodes.push_back(selection);
+    return selection;
+}
+
+TGraphLoop* TDependencyGraph::createLoop(TIntermLoop* intermLoop)
+{
+    TGraphLoop* loop = new TGraphLoop(intermLoop);
+    mAllNodes.push_back(loop);
+    return loop;
+}
+
+TGraphLogicalOp* TDependencyGraph::createLogicalOp(TIntermBinary* intermLogicalOp)
+{
+    TGraphLogicalOp* logicalOp = new TGraphLogicalOp(intermLogicalOp);
+    mAllNodes.push_back(logicalOp);
+    return logicalOp;
+}
+
+const char* TGraphLogicalOp::getOpString() const
+{
+    const char* opString = NULL;
+    switch (getIntermLogicalOp()->getOp()) {
+        case EOpLogicalAnd: opString = "and"; break;
+        case EOpLogicalOr: opString = "or"; break;
+        default: opString = "unknown"; break;
+    }
+    return opString;
+}
diff -r 91d3e124dee2 gfx/angle/src/compiler/depgraph/DependencyGraph.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/depgraph/DependencyGraph.h	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,212 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#ifndef COMPILER_DEPGRAPH_DEPENDENCY_GRAPH_H
+#define COMPILER_DEPGRAPH_DEPENDENCY_GRAPH_H
+
+#include "compiler/intermediate.h"
+
+#include <set>
+#include <stack>
+
+class TGraphNode;
+class TGraphParentNode;
+class TGraphArgument;
+class TGraphFunctionCall;
+class TGraphSymbol;
+class TGraphSelection;
+class TGraphLoop;
+class TGraphLogicalOp;
+class TDependencyGraphTraverser;
+class TDependencyGraphOutput;
+
+typedef std::set<TGraphNode*> TGraphNodeSet;
+typedef std::vector<TGraphNode*> TGraphNodeVector;
+typedef std::vector<TGraphSymbol*> TGraphSymbolVector;
+typedef std::vector<TGraphFunctionCall*> TFunctionCallVector;
+
+//
+// Base class for all dependency graph nodes.
+//
+class TGraphNode {
+public:
+    TGraphNode(TIntermNode* node) : intermNode(node) {}
+    virtual ~TGraphNode() {}
+    virtual void traverse(TDependencyGraphTraverser* graphTraverser);
+protected:
+    TIntermNode* intermNode;
+};
+
+//
+// Base class for dependency graph nodes that may have children.
+//
+class TGraphParentNode : public TGraphNode {
+public:
+    TGraphParentNode(TIntermNode* node) : TGraphNode(node) {}
+    virtual ~TGraphParentNode() {}
+    void addDependentNode(TGraphNode* node) { if (node != this) mDependentNodes.insert(node); }
+    virtual void traverse(TDependencyGraphTraverser* graphTraverser);
+private:
+    TGraphNodeSet mDependentNodes;
+};
+
+//
+// Handle function call arguments.
+//
+class TGraphArgument : public TGraphParentNode {
+public:
+    TGraphArgument(TIntermAggregate* intermFunctionCall, int argumentNumber)
+        : TGraphParentNode(intermFunctionCall)
+        , mArgumentNumber(argumentNumber) {}
+    virtual ~TGraphArgument() {}
+    const TIntermAggregate* getIntermFunctionCall() const { return intermNode->getAsAggregate(); }
+    int getArgumentNumber() const { return mArgumentNumber; }
+    virtual void traverse(TDependencyGraphTraverser* graphTraverser);
+private:
+    int mArgumentNumber;
+};
+
+//
+// Handle function calls.
+//
+class TGraphFunctionCall : public TGraphParentNode {
+public:
+    TGraphFunctionCall(TIntermAggregate* intermFunctionCall)
+        : TGraphParentNode(intermFunctionCall) {}
+    virtual ~TGraphFunctionCall() {}
+    const TIntermAggregate* getIntermFunctionCall() const { return intermNode->getAsAggregate(); }
+    virtual void traverse(TDependencyGraphTraverser* graphTraverser);
+};
+
+//
+// Handle symbols.
+//
+class TGraphSymbol : public TGraphParentNode {
+public:
+    TGraphSymbol(TIntermSymbol* intermSymbol) : TGraphParentNode(intermSymbol) {}
+    virtual ~TGraphSymbol() {}
+    const TIntermSymbol* getIntermSymbol() const { return intermNode->getAsSymbolNode(); }
+    virtual void traverse(TDependencyGraphTraverser* graphTraverser);
+};
+
+//
+// Handle if statements and ternary operators.
+//
+class TGraphSelection : public TGraphNode {
+public:
+    TGraphSelection(TIntermSelection* intermSelection) : TGraphNode(intermSelection) {}
+    virtual ~TGraphSelection() {}
+    const TIntermSelection* getIntermSelection() const { return intermNode->getAsSelectionNode(); }
+    virtual void traverse(TDependencyGraphTraverser* graphTraverser);
+};
+
+//
+// Handle for, do-while, and while loops.
+//
+class TGraphLoop : public TGraphNode {
+public:
+    TGraphLoop(TIntermLoop* intermLoop) : TGraphNode(intermLoop) {}
+    virtual ~TGraphLoop() {}
+    const TIntermLoop* getIntermLoop() const { return intermNode->getAsLoopNode(); }
+    virtual void traverse(TDependencyGraphTraverser* graphTraverser);
+};
+
+//
+// Handle logical and, or.
+//
+class TGraphLogicalOp : public TGraphNode {
+public:
+    TGraphLogicalOp(TIntermBinary* intermLogicalOp) : TGraphNode(intermLogicalOp) {}
+    virtual ~TGraphLogicalOp() {}
+    const TIntermBinary* getIntermLogicalOp() const { return intermNode->getAsBinaryNode(); }
+    const char* getOpString() const;
+    virtual void traverse(TDependencyGraphTraverser* graphTraverser);
+};
+
+//
+// A dependency graph of symbols, function calls, conditions etc.
+//
+// This class provides an interface to the entry points of the dependency graph.
+//
+// Dependency graph nodes should be created by using one of the provided "create..." methods.
+// This class (and nobody else) manages the memory of the created nodes.
+// Nodes may not be removed after being added, so all created nodes will exist while the
+// TDependencyGraph instance exists.
+//
+class TDependencyGraph {
+public:
+    TDependencyGraph(TIntermNode* intermNode);
+    ~TDependencyGraph();
+    TGraphNodeVector::const_iterator begin() const { return mAllNodes.begin(); }
+    TGraphNodeVector::const_iterator end() const { return mAllNodes.end(); }
+
+    TGraphSymbolVector::const_iterator beginSamplerSymbols() const
+    {
+        return mSamplerSymbols.begin();
+    }
+
+    TGraphSymbolVector::const_iterator endSamplerSymbols() const
+    {
+        return mSamplerSymbols.end();
+    }
+
+    TFunctionCallVector::const_iterator beginUserDefinedFunctionCalls() const
+    {
+        return mUserDefinedFunctionCalls.begin();
+    }
+
+    TFunctionCallVector::const_iterator endUserDefinedFunctionCalls() const
+    {
+        return mUserDefinedFunctionCalls.end();
+    }
+
+    TGraphArgument* createArgument(TIntermAggregate* intermFunctionCall, int argumentNumber);
+    TGraphFunctionCall* createFunctionCall(TIntermAggregate* intermFunctionCall);
+    TGraphSymbol* getOrCreateSymbol(TIntermSymbol* intermSymbol);
+    TGraphSelection* createSelection(TIntermSelection* intermSelection);
+    TGraphLoop* createLoop(TIntermLoop* intermLoop);
+    TGraphLogicalOp* createLogicalOp(TIntermBinary* intermLogicalOp);
+private:
+    typedef TMap<int, TGraphSymbol*> TSymbolIdMap;
+    typedef std::pair<int, TGraphSymbol*> TSymbolIdPair;
+
+    TGraphNodeVector mAllNodes;
+    TGraphSymbolVector mSamplerSymbols;
+    TFunctionCallVector mUserDefinedFunctionCalls;
+    TSymbolIdMap mSymbolIdMap;
+};
+
+//
+// For traversing the dependency graph. Users should derive from this,
+// put their traversal specific data in it, and then pass it to a
+// traverse method.
+//
+// When using this, just fill in the methods for nodes you want visited.
+//
+class TDependencyGraphTraverser {
+public:
+    TDependencyGraphTraverser() : mDepth(0) {}
+
+    virtual void visitSymbol(TGraphSymbol* symbol) {};
+    virtual void visitArgument(TGraphArgument* selection) {};
+    virtual void visitFunctionCall(TGraphFunctionCall* functionCall) {};
+    virtual void visitSelection(TGraphSelection* selection) {};
+    virtual void visitLoop(TGraphLoop* loop) {};
+    virtual void visitLogicalOp(TGraphLogicalOp* logicalOp) {};
+
+    int getDepth() const { return mDepth; }
+    void incrementDepth() { ++mDepth; }
+    void decrementDepth() { --mDepth; }
+
+    void clearVisited() { mVisited.clear(); }
+    void markVisited(TGraphNode* node) { mVisited.insert(node); }
+    bool isVisited(TGraphNode* node) const { return mVisited.find(node) != mVisited.end(); }
+private:
+    int mDepth;
+    TGraphNodeSet mVisited;
+};
+
+#endif
diff -r 91d3e124dee2 gfx/angle/src/compiler/depgraph/DependencyGraphBuilder.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/depgraph/DependencyGraphBuilder.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,234 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#include "compiler/depgraph/DependencyGraphBuilder.h"
+
+TDependencyGraphBuilder::TLeftmostSymbolMaintainer::TSubtreePlaceholder
+    TDependencyGraphBuilder::TLeftmostSymbolMaintainer::kLeftSubtree;
+
+TDependencyGraphBuilder::TLeftmostSymbolMaintainer::TSubtreePlaceholder
+    TDependencyGraphBuilder::TLeftmostSymbolMaintainer::kRightSubtree;
+
+void TDependencyGraphBuilder::build(TIntermNode* node, TDependencyGraph* graph)
+{
+    TDependencyGraphBuilder builder(graph);
+    builder.build(node);
+}
+
+bool TDependencyGraphBuilder::visitAggregate(Visit visit, TIntermAggregate* intermAggregate)
+{
+    switch (intermAggregate->getOp()) {
+        case EOpFunction: visitFunctionDefinition(intermAggregate); break;
+        case EOpFunctionCall: visitFunctionCall(intermAggregate); break;
+        default: visitAggregateChildren(intermAggregate); break;
+    }
+
+    return false;
+}
+
+void TDependencyGraphBuilder::visitFunctionDefinition(TIntermAggregate* intermAggregate)
+{
+    // Currently, we do not support user defined functions.
+    if (intermAggregate->getName() != "main(")
+        return;
+
+    visitAggregateChildren(intermAggregate);
+}
+
+// Takes an expression like "f(x)" and creates a dependency graph like
+// "x -> argument 0 -> function call".
+void TDependencyGraphBuilder::visitFunctionCall(TIntermAggregate* intermFunctionCall)
+{
+    TGraphFunctionCall* functionCall = mGraph->createFunctionCall(intermFunctionCall);
+
+    // Run through the function call arguments.
+    int argumentNumber = 0;
+    TIntermSequence& intermArguments = intermFunctionCall->getSequence();
+    for (TIntermSequence::const_iterator iter = intermArguments.begin();
+         iter != intermArguments.end();
+         ++iter, ++argumentNumber)
+    {
+        TNodeSetMaintainer nodeSetMaintainer(this);
+
+        TIntermNode* intermArgument = *iter;
+        intermArgument->traverse(this);
+
+        if (TParentNodeSet* argumentNodes = mNodeSets.getTopSet()) {
+            TGraphArgument* argument = mGraph->createArgument(intermFunctionCall, argumentNumber);
+            connectMultipleNodesToSingleNode(argumentNodes, argument);
+            argument->addDependentNode(functionCall);
+        }
+    }
+
+    // Push the leftmost symbol of this function call into the current set of dependent symbols to
+    // represent the result of this function call.
+    // Thus, an expression like "y = f(x)" will yield a dependency graph like
+    // "x -> argument 0 -> function call -> y".
+    // This line essentially passes the function call node back up to an earlier visitAssignment
+    // call, which will create the connection "function call -> y".
+    mNodeSets.insertIntoTopSet(functionCall);
+}
+
+void TDependencyGraphBuilder::visitAggregateChildren(TIntermAggregate* intermAggregate)
+{
+    TIntermSequence& sequence = intermAggregate->getSequence();
+    for(TIntermSequence::const_iterator iter = sequence.begin(); iter != sequence.end(); ++iter)
+    {
+        TIntermNode* intermChild = *iter;
+        intermChild->traverse(this);
+    }
+}
+
+void TDependencyGraphBuilder::visitSymbol(TIntermSymbol* intermSymbol)
+{
+    // Push this symbol into the set of dependent symbols for the current assignment or condition
+    // that we are traversing.
+    TGraphSymbol* symbol = mGraph->getOrCreateSymbol(intermSymbol);
+    mNodeSets.insertIntoTopSet(symbol);
+
+    // If this symbol is the current leftmost symbol under an assignment, replace the previous
+    // leftmost symbol with this symbol.
+    if (!mLeftmostSymbols.empty() && mLeftmostSymbols.top() !=
+        &TLeftmostSymbolMaintainer::kRightSubtree) {
+        mLeftmostSymbols.pop();
+        mLeftmostSymbols.push(symbol);
+    }
+}
+
+bool TDependencyGraphBuilder::visitBinary(Visit visit, TIntermBinary* intermBinary)
+{
+    TOperator op = intermBinary->getOp();
+    if (op == EOpInitialize || intermBinary->modifiesState())
+        visitAssignment(intermBinary);
+    else if (op == EOpLogicalAnd || op == EOpLogicalOr)
+        visitLogicalOp(intermBinary);
+    else
+        visitBinaryChildren(intermBinary);
+
+    return false;
+}
+
+void TDependencyGraphBuilder::visitAssignment(TIntermBinary* intermAssignment)
+{
+    TIntermTyped* intermLeft = intermAssignment->getLeft();
+    if (!intermLeft)
+        return;
+
+    TGraphSymbol* leftmostSymbol = NULL;
+
+    {
+        TNodeSetMaintainer nodeSetMaintainer(this);
+
+        {
+            TLeftmostSymbolMaintainer leftmostSymbolMaintainer(this, TLeftmostSymbolMaintainer::kLeftSubtree);
+            intermLeft->traverse(this);
+            leftmostSymbol = mLeftmostSymbols.top();
+
+            // After traversing the left subtree of this assignment, we should have found a real
+            // leftmost symbol, and the leftmost symbol should not be a placeholder.
+            ASSERT(leftmostSymbol != &TLeftmostSymbolMaintainer::kLeftSubtree);
+            ASSERT(leftmostSymbol != &TLeftmostSymbolMaintainer::kRightSubtree);
+        }
+
+        if (TIntermTyped* intermRight = intermAssignment->getRight()) {
+            TLeftmostSymbolMaintainer leftmostSymbolMaintainer(this, TLeftmostSymbolMaintainer::kRightSubtree);
+            intermRight->traverse(this);
+        }
+
+        if (TParentNodeSet* assignmentNodes = mNodeSets.getTopSet())
+            connectMultipleNodesToSingleNode(assignmentNodes, leftmostSymbol);
+    }
+
+    // Push the leftmost symbol of this assignment into the current set of dependent symbols to
+    // represent the result of this assignment.
+    // An expression like "a = (b = c)" will yield a dependency graph like "c -> b -> a".
+    // This line essentially passes the leftmost symbol of the nested assignment ("b" in this
+    // example) back up to the earlier visitAssignment call for the outer assignment, which will
+    // create the connection "b -> a".
+    mNodeSets.insertIntoTopSet(leftmostSymbol);
+}
+
+void TDependencyGraphBuilder::visitLogicalOp(TIntermBinary* intermLogicalOp)
+{
+    if (TIntermTyped* intermLeft = intermLogicalOp->getLeft()) {
+        TNodeSetPropagatingMaintainer nodeSetMaintainer(this);
+
+        intermLeft->traverse(this);
+        if (TParentNodeSet* leftNodes = mNodeSets.getTopSet()) {
+            TGraphLogicalOp* logicalOp = mGraph->createLogicalOp(intermLogicalOp);
+            connectMultipleNodesToSingleNode(leftNodes, logicalOp);
+        }
+    }
+
+    if (TIntermTyped* intermRight = intermLogicalOp->getRight()) {
+        TLeftmostSymbolMaintainer leftmostSymbolMaintainer(this, TLeftmostSymbolMaintainer::kRightSubtree);
+        intermRight->traverse(this);
+    }
+}
+
+void TDependencyGraphBuilder::visitBinaryChildren(TIntermBinary* intermBinary)
+{
+    if (TIntermTyped* intermLeft = intermBinary->getLeft())
+        intermLeft->traverse(this);
+
+    if (TIntermTyped* intermRight = intermBinary->getRight()) {
+        TLeftmostSymbolMaintainer leftmostSymbolMaintainer(this, TLeftmostSymbolMaintainer::kRightSubtree);
+        intermRight->traverse(this);
+    }
+}
+
+bool TDependencyGraphBuilder::visitSelection(Visit visit, TIntermSelection* intermSelection)
+{
+    if (TIntermNode* intermCondition = intermSelection->getCondition()) {
+        TNodeSetMaintainer nodeSetMaintainer(this);
+
+        intermCondition->traverse(this);
+        if (TParentNodeSet* conditionNodes = mNodeSets.getTopSet()) {
+            TGraphSelection* selection = mGraph->createSelection(intermSelection);
+            connectMultipleNodesToSingleNode(conditionNodes, selection);
+        }
+    }
+
+    if (TIntermNode* intermTrueBlock = intermSelection->getTrueBlock())
+        intermTrueBlock->traverse(this);
+
+    if (TIntermNode* intermFalseBlock = intermSelection->getFalseBlock())
+        intermFalseBlock->traverse(this);
+
+    return false;
+}
+
+bool TDependencyGraphBuilder::visitLoop(Visit visit, TIntermLoop* intermLoop)
+{
+    if (TIntermTyped* intermCondition = intermLoop->getCondition()) {
+        TNodeSetMaintainer nodeSetMaintainer(this);
+
+        intermCondition->traverse(this);
+        if (TParentNodeSet* conditionNodes = mNodeSets.getTopSet()) {
+            TGraphLoop* loop = mGraph->createLoop(intermLoop);
+            connectMultipleNodesToSingleNode(conditionNodes, loop);
+        }
+    }
+
+    if (TIntermNode* intermBody = intermLoop->getBody())
+        intermBody->traverse(this);
+
+    if (TIntermTyped* intermExpression = intermLoop->getExpression())
+        intermExpression->traverse(this);
+
+    return false;
+}
+
+
+void TDependencyGraphBuilder::connectMultipleNodesToSingleNode(TParentNodeSet* nodes,
+                                                               TGraphNode* node) const
+{
+    for (TParentNodeSet::const_iterator iter = nodes->begin(); iter != nodes->end(); ++iter)
+    {
+        TGraphParentNode* currentNode = *iter;
+        currentNode->addDependentNode(node);
+    }
+}
diff -r 91d3e124dee2 gfx/angle/src/compiler/depgraph/DependencyGraphBuilder.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/depgraph/DependencyGraphBuilder.h	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,184 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#ifndef COMPILER_DEPGRAPH_DEPENDENCY_GRAPH_BUILDER_H
+#define COMPILER_DEPGRAPH_DEPENDENCY_GRAPH_BUILDER_H
+
+#include "compiler/depgraph/DependencyGraph.h"
+
+//
+// Creates a dependency graph of symbols, function calls, conditions etc. by traversing a
+// intermediate tree.
+//
+class TDependencyGraphBuilder : public TIntermTraverser {
+public:
+    static void build(TIntermNode* node, TDependencyGraph* graph);
+
+    virtual void visitSymbol(TIntermSymbol*);
+    virtual bool visitBinary(Visit visit, TIntermBinary*);
+    virtual bool visitSelection(Visit visit, TIntermSelection*);
+    virtual bool visitAggregate(Visit visit, TIntermAggregate*);
+    virtual bool visitLoop(Visit visit, TIntermLoop*);
+
+private:
+    typedef std::stack<TGraphSymbol*> TSymbolStack;
+    typedef std::set<TGraphParentNode*> TParentNodeSet;
+
+    //
+    // For collecting the dependent nodes of assignments, conditions, etc.
+    // while traversing the intermediate tree.
+    //
+    // This data structure is stack of sets. Each set contains dependency graph parent nodes.
+    //
+    class TNodeSetStack {
+    public:
+        TNodeSetStack() {};
+        ~TNodeSetStack() { clear(); }
+
+        // This should only be called after a pushSet.
+        // Returns NULL if the top set is empty.
+        TParentNodeSet* getTopSet() const
+        {
+            ASSERT(!nodeSets.empty());
+            TParentNodeSet* topSet = nodeSets.top();
+            return !topSet->empty() ? topSet : NULL;
+        }
+
+        void pushSet() { nodeSets.push(new TParentNodeSet()); }
+        void popSet()
+        {
+            ASSERT(!nodeSets.empty());
+            delete nodeSets.top();
+            nodeSets.pop();
+        }
+
+        // Pops the top set and adds its contents to the new top set.
+        // This should only be called after a pushSet.
+        // If there is no set below the top set, the top set is just deleted.
+        void popSetIntoNext()
+        {
+            ASSERT(!nodeSets.empty());
+            TParentNodeSet* oldTopSet = nodeSets.top();
+            nodeSets.pop();
+
+            if (!nodeSets.empty()) {
+                TParentNodeSet* newTopSet = nodeSets.top();
+                newTopSet->insert(oldTopSet->begin(), oldTopSet->end());
+            }
+
+            delete oldTopSet;
+        }
+
+        // Does nothing if there is no top set.
+        // This can be called when there is no top set if we are visiting
+        // symbols that are not under an assignment or condition.
+        // We don't need to track those symbols.
+        void insertIntoTopSet(TGraphParentNode* node)
+        {
+            if (nodeSets.empty())
+                return;
+
+            nodeSets.top()->insert(node);
+        }
+
+        void clear()
+        {
+            while (!nodeSets.empty())
+                popSet();
+        }
+
+    private:
+        typedef std::stack<TParentNodeSet*> TParentNodeSetStack;
+
+        TParentNodeSetStack nodeSets;
+    };
+
+    //
+    // An instance of this class pushes a new node set when instantiated.
+    // When the instance goes out of scope, it and pops the node set.
+    //
+    class TNodeSetMaintainer {
+    public:
+        TNodeSetMaintainer(TDependencyGraphBuilder* factory)
+            : sets(factory->mNodeSets) { sets.pushSet(); }
+        ~TNodeSetMaintainer() { sets.popSet(); }
+    protected:
+        TNodeSetStack& sets;
+    };
+
+    //
+    // An instance of this class pushes a new node set when instantiated.
+    // When the instance goes out of scope, it and pops the top node set and adds its contents to
+    // the new top node set.
+    //
+    class TNodeSetPropagatingMaintainer {
+    public:
+        TNodeSetPropagatingMaintainer(TDependencyGraphBuilder* factory)
+            : sets(factory->mNodeSets) { sets.pushSet(); }
+        ~TNodeSetPropagatingMaintainer() { sets.popSetIntoNext(); }
+    protected:
+        TNodeSetStack& sets;
+    };
+
+    //
+    // An instance of this class keeps track of the leftmost symbol while we're exploring an
+    // assignment.
+    // It will push the placeholder symbol kLeftSubtree when instantiated under a left subtree,
+    // and kRightSubtree under a right subtree.
+    // When it goes out of scope, it will pop the leftmost symbol at the top of the scope.
+    // During traversal, the TDependencyGraphBuilder will replace kLeftSubtree with a real symbol.
+    // kRightSubtree will never be replaced by a real symbol because we are tracking the leftmost
+    // symbol.
+    //
+    class TLeftmostSymbolMaintainer {
+    public:
+        class TSubtreePlaceholder : public TGraphSymbol {
+        public:
+            TSubtreePlaceholder() : TGraphSymbol(NULL) {}
+        };
+
+        static TSubtreePlaceholder kLeftSubtree;
+        static TSubtreePlaceholder kRightSubtree;
+
+        TLeftmostSymbolMaintainer(TDependencyGraphBuilder* factory, TSubtreePlaceholder& subtree)
+            : leftmostSymbols(factory->mLeftmostSymbols)
+        {
+            needsPlaceholderSymbol = leftmostSymbols.empty() || leftmostSymbols.top() != &subtree;
+            if (needsPlaceholderSymbol)
+                leftmostSymbols.push(&subtree);
+        }
+
+        ~TLeftmostSymbolMaintainer()
+        {
+            if (needsPlaceholderSymbol)
+                leftmostSymbols.pop();
+        }
+
+    protected:
+        TSymbolStack& leftmostSymbols;
+        bool needsPlaceholderSymbol;
+    };
+
+    TDependencyGraphBuilder(TDependencyGraph* graph)
+        : TIntermTraverser(true, false, false)
+        , mGraph(graph) {}
+    void build(TIntermNode* intermNode) { intermNode->traverse(this); }
+
+    void connectMultipleNodesToSingleNode(TParentNodeSet* nodes, TGraphNode* node) const;
+
+    void visitAssignment(TIntermBinary*);
+    void visitLogicalOp(TIntermBinary*);
+    void visitBinaryChildren(TIntermBinary*);
+    void visitFunctionDefinition(TIntermAggregate*);
+    void visitFunctionCall(TIntermAggregate* intermFunctionCall);
+    void visitAggregateChildren(TIntermAggregate*);
+
+    TDependencyGraph* mGraph;
+    TNodeSetStack mNodeSets;
+    TSymbolStack mLeftmostSymbols;
+};
+
+#endif  // COMPILER_DEPGRAPH_DEPENDENCY_GRAPH_BUILDER_H
diff -r 91d3e124dee2 gfx/angle/src/compiler/depgraph/DependencyGraphOutput.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/depgraph/DependencyGraphOutput.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,65 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#include "compiler/depgraph/DependencyGraphOutput.h"
+
+void TDependencyGraphOutput::outputIndentation()
+{
+    for (int i = 0; i < getDepth(); ++i)
+        mSink << "  ";
+}
+
+void TDependencyGraphOutput::visitArgument(TGraphArgument* parameter)
+{
+    outputIndentation();
+    mSink << "argument " << parameter->getArgumentNumber() << " of call to "
+          << parameter->getIntermFunctionCall()->getName() << "\n";
+}
+
+void TDependencyGraphOutput::visitFunctionCall(TGraphFunctionCall* functionCall)
+{
+    outputIndentation();
+    mSink << "function call " <<  functionCall->getIntermFunctionCall()->getName() << "\n";
+}
+
+void TDependencyGraphOutput::visitSymbol(TGraphSymbol* symbol)
+{
+    outputIndentation();
+    mSink << symbol->getIntermSymbol()->getSymbol() << " (symbol id: "
+          << symbol->getIntermSymbol()->getId() << ")\n";
+}
+
+void TDependencyGraphOutput::visitSelection(TGraphSelection* selection)
+{
+    outputIndentation();
+    mSink << "selection\n";
+}
+
+void TDependencyGraphOutput::visitLoop(TGraphLoop* loop)
+{
+    outputIndentation();
+    mSink << "loop condition\n";
+}
+
+void TDependencyGraphOutput::visitLogicalOp(TGraphLogicalOp* logicalOp)
+{
+    outputIndentation();
+    mSink << "logical " << logicalOp->getOpString() << "\n";
+}
+
+void TDependencyGraphOutput::outputAllSpanningTrees(TDependencyGraph& graph)
+{
+    mSink << "\n";
+
+    for (TGraphNodeVector::const_iterator iter = graph.begin(); iter != graph.end(); ++iter)
+    {
+        TGraphNode* symbol = *iter;
+        mSink << "--- Dependency graph spanning tree ---\n";
+        clearVisited();
+        symbol->traverse(this);
+        mSink << "\n";
+    }
+}
diff -r 91d3e124dee2 gfx/angle/src/compiler/depgraph/DependencyGraphOutput.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/depgraph/DependencyGraphOutput.h	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,30 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#ifndef COMPILER_DEPGRAPH_DEPENDENCY_GRAPH_OUTPUT_H
+#define COMPILER_DEPGRAPH_DEPENDENCY_GRAPH_OUTPUT_H
+
+#include "compiler/depgraph/DependencyGraph.h"
+#include "compiler/InfoSink.h"
+
+class TDependencyGraphOutput : public TDependencyGraphTraverser {
+public:
+    TDependencyGraphOutput(TInfoSinkBase& sink) : mSink(sink) {}
+    virtual void visitSymbol(TGraphSymbol* symbol);
+    virtual void visitArgument(TGraphArgument* parameter);
+    virtual void visitFunctionCall(TGraphFunctionCall* functionCall);
+    virtual void visitSelection(TGraphSelection* selection);
+    virtual void visitLoop(TGraphLoop* loop);
+    virtual void visitLogicalOp(TGraphLogicalOp* logicalOp);
+
+    void outputAllSpanningTrees(TDependencyGraph& graph);
+private:
+    void outputIndentation();
+
+    TInfoSinkBase& mSink;
+};
+
+#endif  // COMPILER_DEPGRAPH_DEPENDENCY_GRAPH_OUTPUT_H
diff -r 91d3e124dee2 gfx/angle/src/compiler/depgraph/DependencyGraphTraverse.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/depgraph/DependencyGraphTraverse.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,69 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#include "compiler/depgraph/DependencyGraph.h"
+
+// These methods do a breadth-first traversal through the graph and mark visited nodes.
+
+void TGraphNode::traverse(TDependencyGraphTraverser* graphTraverser)
+{
+    graphTraverser->markVisited(this);
+}
+
+void TGraphParentNode::traverse(TDependencyGraphTraverser* graphTraverser)
+{
+    TGraphNode::traverse(graphTraverser);
+
+    graphTraverser->incrementDepth();
+
+    // Visit the parent node's children.
+    for (TGraphNodeSet::const_iterator iter = mDependentNodes.begin();
+         iter != mDependentNodes.end();
+         ++iter)
+    {
+        TGraphNode* node = *iter;
+        if (!graphTraverser->isVisited(node))
+            node->traverse(graphTraverser);
+    }
+
+    graphTraverser->decrementDepth();
+}
+
+void TGraphArgument::traverse(TDependencyGraphTraverser* graphTraverser)
+{
+    graphTraverser->visitArgument(this);
+    TGraphParentNode::traverse(graphTraverser);
+}
+
+void TGraphFunctionCall::traverse(TDependencyGraphTraverser* graphTraverser)
+{
+    graphTraverser->visitFunctionCall(this);
+    TGraphParentNode::traverse(graphTraverser);
+}
+
+void TGraphSymbol::traverse(TDependencyGraphTraverser* graphTraverser)
+{
+    graphTraverser->visitSymbol(this);
+    TGraphParentNode::traverse(graphTraverser);
+}
+
+void TGraphSelection::traverse(TDependencyGraphTraverser* graphTraverser)
+{
+    graphTraverser->visitSelection(this);
+    TGraphNode::traverse(graphTraverser);
+}
+
+void TGraphLoop::traverse(TDependencyGraphTraverser* graphTraverser)
+{
+    graphTraverser->visitLoop(this);
+    TGraphNode::traverse(graphTraverser);
+}
+
+void TGraphLogicalOp::traverse(TDependencyGraphTraverser* graphTraverser)
+{
+    graphTraverser->visitLogicalOp(this);
+    TGraphNode::traverse(graphTraverser);
+}
diff -r 91d3e124dee2 gfx/angle/src/compiler/intermediate.h
--- a/gfx/angle/src/compiler/intermediate.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/intermediate.h	Sat Jun 09 12:08:28 2012 +0900
@@ -452,7 +452,7 @@
     const TString& getName() const { return name; }
 
     void setUserDefined() { userDefined = true; }
-    bool isUserDefined() { return userDefined; }
+    bool isUserDefined() const { return userDefined; }
 
     void setOptimize(bool o) { optimize = o; }
     bool getOptimize() { return optimize; }
diff -r 91d3e124dee2 gfx/angle/src/compiler/preprocessor/atom.c
--- a/gfx/angle/src/compiler/preprocessor/atom.c	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/preprocessor/atom.c	Sat Jun 09 12:08:28 2012 +0900
@@ -50,6 +50,7 @@
 #include <stdio.h>
 #include <string.h>
 
+#include "common/angleutils.h"
 #include "compiler/compilerdebug.h"
 #include "compiler/preprocessor/slglobals.h"
 
@@ -331,7 +332,12 @@
             atable->size = 0;
         }
         if (!newmap || !newrev) {
-            abort();
+            /* failed to grow -- error */
+            if (newmap)
+                atable->amap = newmap;
+            if (newrev)
+                atable->arev = newrev;
+            return -1;
         }
         memset(&newmap[atable->size], 0, (size - atable->size) * sizeof(int));
         memset(&newrev[atable->size], 0, (size - atable->size) * sizeof(int));
@@ -429,14 +435,14 @@
             if (cpp->options.DumpAtomTable) {
                 int ii;
                 char str[200];
-                sprintf(str, "*** Hash failed with more than %d collisions. Must increase hash table size. ***",
+                snprintf(str, sizeof(str), "*** Hash failed with more than %d collisions. Must increase hash table size. ***",
                        HASH_TABLE_MAX_COLLISIONS);
                 CPPShInfoLogMsg(str);
 
-                sprintf(str, "*** New string \"%s\", hash=%04x, delta=%04x", s, collision[0], hashdelta);
+                snprintf(str, sizeof(str), "*** New string \"%s\", hash=%04x, delta=%04x", s, collision[0], hashdelta);
                 CPPShInfoLogMsg(str);
                 for (ii = 0; ii <= HASH_TABLE_MAX_COLLISIONS; ii++) {
-                    sprintf(str, "*** Collides on try %d at hash entry %04x with \"%s\"",
+                    snprintf(str, sizeof(str), "*** Collides on try %d at hash entry %04x with \"%s\"",
                            ii + 1, collision[ii], GetAtomString(atable, atable->htable.entry[collision[ii]].value));
                     CPPShInfoLogMsg(str);
                 }
@@ -680,14 +686,14 @@
     char str[200];
 
     for (ii = 0; ii < atable->nextFree; ii++) {
-        sprintf(str, "%d: \"%s\"", ii, &atable->stable.strings[atable->amap[ii]]);
+        snprintf(str, sizeof(str), "%d: \"%s\"", ii, &atable->stable.strings[atable->amap[ii]]);
         CPPDebugLogMsg(str);
     }
-    sprintf(str, "Hash table: size=%d, entries=%d, collisions=",
+    snprintf(str, sizeof(str), "Hash table: size=%d, entries=%d, collisions=",
            atable->htable.size, atable->htable.entries);
     CPPDebugLogMsg(str);
     for (ii = 0; ii < HASH_TABLE_MAX_COLLISIONS; ii++) {
-        sprintf(str, " %d", atable->htable.counts[ii]);
+        snprintf(str, sizeof(str), " %d", atable->htable.counts[ii]);
         CPPDebugLogMsg(str);
     }
 
diff -r 91d3e124dee2 gfx/angle/src/compiler/preprocessor/cpp.c
--- a/gfx/angle/src/compiler/preprocessor/cpp.c	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/preprocessor/cpp.c	Sat Jun 09 12:08:28 2012 +0900
@@ -51,6 +51,7 @@
 #include <string.h>
 #include <ctype.h>
 
+#include "common/angleutils.h"
 #include "compiler/preprocessor/slglobals.h"
 
 #if defined(_MSC_VER)
@@ -678,7 +679,7 @@
 		case -1:
             // EOF
             CPPShInfoLogMsg("#pragma directive must end with a newline");			
-			return token;
+			goto freeMemoryAndReturnToken;
 		default:
 			SrcStrName[0] = token;
 			SrcStrName[1] = '\0';
@@ -690,6 +691,7 @@
 
 	HandlePragma((const char**)allTokens, tokenCount);
 	
+freeMemoryAndReturnToken:
 	for (i = 0; i < tokenCount; ++i) {
 		free (allTokens[i]);
 	}
@@ -892,7 +894,7 @@
 
     macro.body = NewTokenStream(name, macros->pool);
     val.sc_int = value;
-    sprintf(val.symbol_name, "%d", value);
+    snprintf(val.symbol_name, MAX_SYMBOL_NAME_LEN+1, "%d", value);
     RecordToken(macro.body, CPP_INTCONSTANT, &val);
     atom = LookUpAddString(atable, name);
     symbol = AddSymbol(&location, macros, atom, MACRO_S);
@@ -989,13 +991,13 @@
     const char *message;
 	if (atom == __LINE__Atom) {
         yylvalpp->sc_int = GetLineNumber();
-        sprintf(yylvalpp->symbol_name,"%d",yylvalpp->sc_int);
+        snprintf(yylvalpp->symbol_name, MAX_SYMBOL_NAME_LEN+1, "%d", yylvalpp->sc_int);
         UngetToken(CPP_INTCONSTANT, yylvalpp);
         return 1;
     }
     if (atom == __FILE__Atom) {
         yylvalpp->sc_int = GetStringNumber();
-        sprintf(yylvalpp->symbol_name,"%d",yylvalpp->sc_int);
+        snprintf(yylvalpp->symbol_name, MAX_SYMBOL_NAME_LEN+1, "%d", yylvalpp->sc_int);
         UngetToken(CPP_INTCONSTANT, yylvalpp);
         return 1;
     }
diff -r 91d3e124dee2 gfx/angle/src/compiler/preprocessor/new/Context.cpp
--- a/gfx/angle/src/compiler/preprocessor/new/Context.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/preprocessor/new/Context.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -9,7 +9,7 @@
 #include <algorithm>
 #include <sstream>
 
-#include "compiler/debug.h"
+#include "compiler/compilerdebug.h"
 #include "Lexer.h"
 #include "stl_utils.h"
 #include "token_type.h"
diff -r 91d3e124dee2 gfx/angle/src/compiler/preprocessor/tokens.c
--- a/gfx/angle/src/compiler/preprocessor/tokens.c	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/preprocessor/tokens.c	Sat Jun 09 12:08:28 2012 +0900
@@ -50,6 +50,7 @@
 #include <string.h>
 #include <ctype.h>
 
+#include "common/angleutils.h"
 #include "compiler/compilerdebug.h"
 #include "compiler/preprocessor/slglobals.h"
 #include "compiler/util.h"
@@ -439,10 +440,10 @@
         switch (token) {
         case CPP_IDENTIFIER:
         case CPP_TYPEIDENTIFIER:
-            sprintf(str, "%s ", GetAtomString(atable, yylvalpp->sc_ident));
+            snprintf(str, sizeof(str), "%s ", GetAtomString(atable, yylvalpp->sc_ident));
             break;
         case CPP_STRCONSTANT:
-            sprintf(str, "\"%s\"", GetAtomString(atable, yylvalpp->sc_ident));
+            snprintf(str, sizeof(str), "\"%s\"", GetAtomString(atable, yylvalpp->sc_ident));
             break;
         case CPP_FLOATCONSTANT:
             //printf("%g9.6 ", yylvalpp->sc_fval);
@@ -452,9 +453,9 @@
             break;
         default:
             if (token >= 127)
-                sprintf(str, "%s ", GetAtomString(atable, token));
+                snprintf(str, sizeof(str), "%s ", GetAtomString(atable, token));
             else
-                sprintf(str, "%c", token);
+                snprintf(str, sizeof(str), "%c", token);
             break;
         }
         CPPDebugLogMsg(str);
diff -r 91d3e124dee2 gfx/angle/src/compiler/timing/RestrictFragmentShaderTiming.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/timing/RestrictFragmentShaderTiming.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,85 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#include "compiler/InfoSink.h"
+#include "compiler/ParseHelper.h"
+#include "compiler/depgraph/DependencyGraphOutput.h"
+#include "compiler/timing/RestrictFragmentShaderTiming.h"
+
+// FIXME(mvujovic): We do not know if the execution time of built-in operations like sin, pow, etc.
+// can vary based on the value of the input arguments. If so, we should restrict those as well.
+void RestrictFragmentShaderTiming::enforceRestrictions(const TDependencyGraph& graph)
+{
+    mNumErrors = 0;
+
+    // FIXME(mvujovic): The dependency graph does not support user defined function calls right now,
+    // so we generate errors for them.
+    validateUserDefinedFunctionCallUsage(graph);
+
+    // Starting from each sampler, traverse the dependency graph and generate an error each time we
+    // hit a node where sampler dependent values are not allowed.
+    for (TGraphSymbolVector::const_iterator iter = graph.beginSamplerSymbols();
+         iter != graph.endSamplerSymbols();
+         ++iter)
+    {
+        TGraphSymbol* samplerSymbol = *iter;
+        clearVisited();
+        samplerSymbol->traverse(this);
+    }
+}
+
+void RestrictFragmentShaderTiming::validateUserDefinedFunctionCallUsage(const TDependencyGraph& graph)
+{
+    for (TFunctionCallVector::const_iterator iter = graph.beginUserDefinedFunctionCalls();
+         iter != graph.endUserDefinedFunctionCalls();
+         ++iter)
+    {
+        TGraphFunctionCall* functionCall = *iter;
+        beginError(functionCall->getIntermFunctionCall());
+        mSink << "A call to a user defined function is not permitted.\n";
+    }
+}
+
+void RestrictFragmentShaderTiming::beginError(const TIntermNode* node)
+{
+    ++mNumErrors;
+    mSink.prefix(EPrefixError);
+    mSink.location(node->getLine());
+}
+
+void RestrictFragmentShaderTiming::visitArgument(TGraphArgument* parameter)
+{
+    // FIXME(mvujovic): We should restrict sampler dependent values from being texture coordinates 
+    // in all available sampling operations supported in GLSL ES.
+    // This includes overloaded signatures of texture2D, textureCube, and others.
+    if (parameter->getIntermFunctionCall()->getName() != "texture2D(s21;vf2;" ||
+        parameter->getArgumentNumber() != 1)
+        return;
+
+    beginError(parameter->getIntermFunctionCall());
+    mSink << "An expression dependent on a sampler is not permitted to be the second argument"
+          << " of a texture2D call.\n";
+}
+
+void RestrictFragmentShaderTiming::visitSelection(TGraphSelection* selection)
+{
+    beginError(selection->getIntermSelection());
+    mSink << "An expression dependent on a sampler is not permitted in a conditional statement.\n";
+}
+
+void RestrictFragmentShaderTiming::visitLoop(TGraphLoop* loop)
+{
+    beginError(loop->getIntermLoop());
+    mSink << "An expression dependent on a sampler is not permitted in a loop condition.\n";
+}
+
+void RestrictFragmentShaderTiming::visitLogicalOp(TGraphLogicalOp* logicalOp)
+{
+    beginError(logicalOp->getIntermLogicalOp());
+    mSink << "An expression dependent on a sampler is not permitted on the left hand side of a logical "
+          << logicalOp->getOpString()
+          << " operator.\n";
+}
diff -r 91d3e124dee2 gfx/angle/src/compiler/timing/RestrictFragmentShaderTiming.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/timing/RestrictFragmentShaderTiming.h	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,39 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#ifndef COMPILER_TIMING_RESTRICT_FRAGMENT_SHADER_TIMING_H_
+#define COMPILER_TIMING_RESTRICT_FRAGMENT_SHADER_TIMING_H_
+
+#include "GLSLANG/ShaderLang.h"
+
+#include "compiler/intermediate.h"
+#include "compiler/depgraph/DependencyGraph.h"
+
+class TInfoSinkBase;
+
+class RestrictFragmentShaderTiming : TDependencyGraphTraverser {
+public:
+    RestrictFragmentShaderTiming(TInfoSinkBase& sink)
+        : mSink(sink)
+        , mNumErrors(0) {}
+
+    void enforceRestrictions(const TDependencyGraph& graph);
+    int numErrors() const { return mNumErrors; }
+
+    virtual void visitArgument(TGraphArgument* parameter);
+    virtual void visitSelection(TGraphSelection* selection);
+    virtual void visitLoop(TGraphLoop* loop);
+    virtual void visitLogicalOp(TGraphLogicalOp* logicalOp);
+
+private:
+    void beginError(const TIntermNode* node);
+    void validateUserDefinedFunctionCallUsage(const TDependencyGraph& graph);
+
+	TInfoSinkBase& mSink;
+    int mNumErrors;
+};
+
+#endif  // COMPILER_TIMING_RESTRICT_FRAGMENT_SHADER_TIMING_H_
diff -r 91d3e124dee2 gfx/angle/src/compiler/timing/RestrictVertexShaderTiming.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/timing/RestrictVertexShaderTiming.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,17 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#include "compiler/timing/RestrictVertexShaderTiming.h"
+
+void RestrictVertexShaderTiming::visitSymbol(TIntermSymbol* node)
+{
+    if (IsSampler(node->getBasicType())) {
+        ++mNumErrors;
+        mSink.prefix(EPrefixError);
+        mSink.location(node->getLine());
+        mSink << "Samplers are not permitted in vertex shaders.\n";
+    }
+}
diff -r 91d3e124dee2 gfx/angle/src/compiler/timing/RestrictVertexShaderTiming.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/compiler/timing/RestrictVertexShaderTiming.h	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,33 @@
+//
+// Copyright (c) 2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#ifndef COMPILER_TIMING_RESTRICT_VERTEX_SHADER_TIMING_H_
+#define COMPILER_TIMING_RESTRICT_VERTEX_SHADER_TIMING_H_
+
+#include "GLSLANG/ShaderLang.h"
+
+#include "compiler/intermediate.h"
+#include "compiler/InfoSink.h"
+
+class TInfoSinkBase;
+
+class RestrictVertexShaderTiming : public TIntermTraverser {
+public:
+    RestrictVertexShaderTiming(TInfoSinkBase& sink)
+        : TIntermTraverser(true, false, false)
+        , mSink(sink)
+        , mNumErrors(0) {}
+
+    void enforceRestrictions(TIntermNode* root) { root->traverse(this); }
+    int numErrors() { return mNumErrors; }
+
+    virtual void visitSymbol(TIntermSymbol*);
+private:
+    TInfoSinkBase& mSink;
+    int mNumErrors;
+};
+
+#endif  // COMPILER_TIMING_RESTRICT_VERTEX_SHADER_TIMING_H_
diff -r 91d3e124dee2 gfx/angle/src/compiler/translator_common.vcproj
--- a/gfx/angle/src/compiler/translator_common.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/translator_common.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,206 +1,767 @@
 <?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="translator_common" ProjectGUID="{5B3A6DB8-1E7E-40D7-92B9-DA8AAE619FAD}" RootNamespace="compiler" Keyword="Win32Proj" TargetFrameworkVersion="131072">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)\common" ConfigurationType="4" CharacterSet="0">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="$(ProjectDir);$(ProjectDir)../;$(ProjectDir)../../include" PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLibrarianTool" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)\common" ConfigurationType="4" CharacterSet="0" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="2" InlineFunctionExpansion="2" AdditionalIncludeDirectories="$(ProjectDir);$(ProjectDir)../;$(ProjectDir)../../include" PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;_SECURE_SCL=0" RuntimeLibrary="0" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLibrarianTool" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <Filter Name="Source Files" Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx" UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
-      <File RelativePath=".\Compiler.cpp">
-      </File>
-      <File RelativePath=".\debug.cpp">
-      </File>
-      <File RelativePath=".\glslang.l">
-        <FileConfiguration Name="Debug|Win32">
-          <Tool Name="VCCustomBuildTool" Description="" CommandLine="" AdditionalDependencies="" Outputs="" />
-        </FileConfiguration>
-        <FileConfiguration Name="Release|Win32">
-          <Tool Name="VCCustomBuildTool" Description="" CommandLine="" AdditionalDependencies="" Outputs="" />
-        </FileConfiguration>
-      </File>
-      <File RelativePath=".\glslang.y">
-        <FileConfiguration Name="Debug|Win32">
-          <Tool Name="VCCustomBuildTool" Description="" CommandLine="" Outputs="" />
-        </FileConfiguration>
-        <FileConfiguration Name="Release|Win32">
-          <Tool Name="VCCustomBuildTool" Description="" CommandLine="" Outputs="" />
-        </FileConfiguration>
-      </File>
-      <File RelativePath=".\InfoSink.cpp">
-      </File>
-      <File RelativePath=".\Initialize.cpp">
-      </File>
-      <File RelativePath=".\InitializeDll.cpp">
-      </File>
-      <File RelativePath=".\Intermediate.cpp">
-      </File>
-      <File RelativePath=".\intermOut.cpp">
-      </File>
-      <File RelativePath=".\IntermTraverse.cpp">
-      </File>
-      <File RelativePath=".\ossource_win.cpp">
-      </File>
-      <File RelativePath=".\parseConst.cpp">
-      </File>
-      <File RelativePath=".\ParseHelper.cpp">
-      </File>
-      <File RelativePath=".\PoolAlloc.cpp">
-      </File>
-      <File RelativePath=".\QualifierAlive.cpp">
-      </File>
-      <File RelativePath=".\RemoveTree.cpp">
-      </File>
-      <File RelativePath=".\ShaderLang.cpp">
-      </File>
-      <File RelativePath=".\SymbolTable.cpp">
-      </File>
-      <File RelativePath=".\util.cpp">
-      </File>
-      <File RelativePath=".\ValidateLimitations.cpp">
-      </File>
-      <File RelativePath=".\VariableInfo.cpp">
-      </File>
-      <Filter Name="preprocessor">
-        <File RelativePath=".\preprocessor\atom.c">
-        </File>
-        <File RelativePath=".\preprocessor\cpp.c">
-        </File>
-        <File RelativePath=".\preprocessor\cppstruct.c">
-        </File>
-        <File RelativePath=".\preprocessor\memory.c">
-        </File>
-        <File RelativePath=".\preprocessor\scanner.c">
-        </File>
-        <File RelativePath=".\preprocessor\symbols.c">
-        </File>
-        <File RelativePath=".\preprocessor\tokens.c">
-        </File>
-      </Filter>
-      <Filter Name="generated">
-        <File RelativePath=".\glslang_lex.cpp">
-        </File>
-        <File RelativePath=".\glslang_tab.cpp">
-        </File>
-      </Filter>
-    </Filter>
-    <Filter Name="Header Files" Filter="h;hpp;hxx;hm;inl;inc;xsd" UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
-      <File RelativePath=".\BaseTypes.h">
-      </File>
-      <File RelativePath=".\Common.h">
-      </File>
-      <File RelativePath=".\ConstantUnion.h">
-      </File>
-      <File RelativePath=".\debug.h">
-      </File>
-      <File RelativePath=".\InfoSink.h">
-      </File>
-      <File RelativePath=".\Initialize.h">
-      </File>
-      <File RelativePath=".\InitializeDll.h">
-      </File>
-      <File RelativePath=".\InitializeGlobals.h">
-      </File>
-      <File RelativePath=".\InitializeParseContext.h">
-      </File>
-      <File RelativePath=".\intermediate.h">
-      </File>
-      <File RelativePath=".\localintermediate.h">
-      </File>
-      <File RelativePath=".\MMap.h">
-      </File>
-      <File RelativePath=".\osinclude.h">
-      </File>
-      <File RelativePath=".\ParseHelper.h">
-      </File>
-      <File RelativePath=".\PoolAlloc.h">
-      </File>
-      <File RelativePath=".\QualifierAlive.h">
-      </File>
-      <File RelativePath=".\RemoveTree.h">
-      </File>
-      <File RelativePath="..\..\include\GLSLANG\ResourceLimits.h">
-      </File>
-      <File RelativePath="..\..\include\GLSLANG\ShaderLang.h">
-      </File>
-      <File RelativePath=".\ShHandle.h">
-      </File>
-      <File RelativePath=".\SymbolTable.h">
-      </File>
-      <File RelativePath=".\Types.h">
-      </File>
-      <File RelativePath=".\util.h">
-      </File>
-      <File RelativePath=".\ValidateLimitations.h">
-      </File>
-      <File RelativePath=".\VariableInfo.h">
-      </File>
-      <Filter Name="preprocessor">
-        <File RelativePath=".\preprocessor\atom.h">
-        </File>
-        <File RelativePath=".\preprocessor\compile.h">
-        </File>
-        <File RelativePath=".\preprocessor\cpp.h">
-        </File>
-        <File RelativePath=".\preprocessor\memory.h">
-        </File>
-        <File RelativePath=".\preprocessor\parser.h">
-        </File>
-        <File RelativePath=".\preprocessor\preprocess.h">
-        </File>
-        <File RelativePath=".\preprocessor\scanner.h">
-        </File>
-        <File RelativePath=".\preprocessor\slglobals.h">
-        </File>
-        <File RelativePath=".\preprocessor\symbols.h">
-        </File>
-        <File RelativePath=".\preprocessor\tokens.h">
-        </File>
-      </Filter>
-      <Filter Name="generated">
-        <File RelativePath=".\glslang_tab.h">
-        </File>
-      </Filter>
-    </Filter>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="translator_common"
+	ProjectGUID="{5B3A6DB8-1E7E-40D7-92B9-DA8AAE619FAD}"
+	RootNamespace="compiler"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)\common"
+			ConfigurationType="4"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="$(ProjectDir);$(ProjectDir)../;$(ProjectDir)../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				DisableSpecificWarnings="4100;4127;4189;4239;4244;4245;4512;4702;4718"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+				WarnAsError="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)\common"
+			ConfigurationType="4"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				AdditionalIncludeDirectories="$(ProjectDir);$(ProjectDir)../;$(ProjectDir)../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;_SECURE_SCL=0"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				DisableSpecificWarnings="4100;4127;4189;4239;4244;4245;4512;4702;4718"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				WarnAsError="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="$(ProjectDir);$(ProjectDir)../;$(ProjectDir)../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				DisableSpecificWarnings="4100;4127;4189;4239;4244;4245;4512;4702;4718"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				WarnAsError="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				AdditionalIncludeDirectories="$(ProjectDir);$(ProjectDir)../;$(ProjectDir)../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;_SECURE_SCL=0"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				DisableSpecificWarnings="4100;4127;4189;4239;4244;4245;4512;4702;4718"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				WarnAsError="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath=".\BuiltInFunctionEmulator.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\Compiler.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\debug.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\DetectRecursion.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\ForLoopUnroll.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\glslang.l"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCustomBuildTool"
+						Description=""
+						CommandLine=""
+						AdditionalDependencies=""
+						Outputs=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCustomBuildTool"
+						Description=""
+						CommandLine=""
+						AdditionalDependencies=""
+						Outputs=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCustomBuildTool"
+						Description=""
+						CommandLine=""
+						AdditionalDependencies=""
+						Outputs=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCustomBuildTool"
+						Description=""
+						CommandLine=""
+						AdditionalDependencies=""
+						Outputs=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\glslang.y"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCustomBuildTool"
+						Description=""
+						CommandLine=""
+						Outputs=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCustomBuildTool"
+						Description=""
+						CommandLine=""
+						Outputs=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCustomBuildTool"
+						Description=""
+						CommandLine=""
+						Outputs=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCustomBuildTool"
+						Description=""
+						CommandLine=""
+						Outputs=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\InfoSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\Initialize.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\InitializeDll.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\Intermediate.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\intermOut.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\IntermTraverse.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\MapLongVariableNames.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\ossource_win.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\parseConst.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\ParseHelper.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\PoolAlloc.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\QualifierAlive.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\RemoveTree.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\ShaderLang.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\SymbolTable.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\util.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\ValidateLimitations.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\VariableInfo.cpp"
+				>
+			</File>
+			<Filter
+				Name="preprocessor"
+				>
+				<File
+					RelativePath=".\preprocessor\atom.c"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\cpp.c"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\cppstruct.c"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\memory.c"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\scanner.c"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\symbols.c"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\tokens.c"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="generated"
+				>
+				<File
+					RelativePath=".\glslang_lex.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\glslang_tab.cpp"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="depgraph"
+				>
+				<File
+					RelativePath=".\depgraph\DependencyGraph.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\depgraph\DependencyGraphBuilder.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\depgraph\DependencyGraphOutput.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\depgraph\DependencyGraphTraverse.cpp"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="timing"
+				>
+				<File
+					RelativePath=".\timing\RestrictFragmentShaderTiming.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\timing\RestrictVertexShaderTiming.cpp"
+					>
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath=".\BaseTypes.h"
+				>
+			</File>
+			<File
+				RelativePath=".\BuiltInFunctionEmulator.h"
+				>
+			</File>
+			<File
+				RelativePath=".\Common.h"
+				>
+			</File>
+			<File
+				RelativePath=".\ConstantUnion.h"
+				>
+			</File>
+			<File
+				RelativePath=".\debug.h"
+				>
+			</File>
+			<File
+				RelativePath=".\DetectRecursion.h"
+				>
+			</File>
+			<File
+				RelativePath=".\ForLoopUnroll.h"
+				>
+			</File>
+			<File
+				RelativePath=".\InfoSink.h"
+				>
+			</File>
+			<File
+				RelativePath=".\Initialize.h"
+				>
+			</File>
+			<File
+				RelativePath=".\InitializeDll.h"
+				>
+			</File>
+			<File
+				RelativePath=".\InitializeGlobals.h"
+				>
+			</File>
+			<File
+				RelativePath=".\InitializeParseContext.h"
+				>
+			</File>
+			<File
+				RelativePath=".\intermediate.h"
+				>
+			</File>
+			<File
+				RelativePath=".\localintermediate.h"
+				>
+			</File>
+			<File
+				RelativePath=".\MapLongVariableNames.h"
+				>
+			</File>
+			<File
+				RelativePath=".\MMap.h"
+				>
+			</File>
+			<File
+				RelativePath=".\osinclude.h"
+				>
+			</File>
+			<File
+				RelativePath=".\ParseHelper.h"
+				>
+			</File>
+			<File
+				RelativePath=".\PoolAlloc.h"
+				>
+			</File>
+			<File
+				RelativePath=".\QualifierAlive.h"
+				>
+			</File>
+			<File
+				RelativePath=".\RemoveTree.h"
+				>
+			</File>
+			<File
+				RelativePath=".\RenameFunction.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\GLSLANG\ResourceLimits.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\GLSLANG\ShaderLang.h"
+				>
+			</File>
+			<File
+				RelativePath=".\ShHandle.h"
+				>
+			</File>
+			<File
+				RelativePath=".\SymbolTable.h"
+				>
+			</File>
+			<File
+				RelativePath=".\Types.h"
+				>
+			</File>
+			<File
+				RelativePath=".\util.h"
+				>
+			</File>
+			<File
+				RelativePath=".\ValidateLimitations.h"
+				>
+			</File>
+			<File
+				RelativePath=".\VariableInfo.h"
+				>
+			</File>
+			<Filter
+				Name="preprocessor"
+				>
+				<File
+					RelativePath=".\preprocessor\atom.h"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\compile.h"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\cpp.h"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\length_limits.h"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\memory.h"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\parser.h"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\preprocess.h"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\scanner.h"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\slglobals.h"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\symbols.h"
+					>
+				</File>
+				<File
+					RelativePath=".\preprocessor\tokens.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="generated"
+				>
+				<File
+					RelativePath=".\glslang_tab.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="timing"
+				>
+				<File
+					RelativePath=".\timing\RestrictFragmentShaderTiming.h"
+					>
+				</File>
+				<File
+					RelativePath=".\timing\RestrictVertexShaderTiming.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="depgraph"
+				>
+				<File
+					RelativePath=".\depgraph\DependencyGraph.h"
+					>
+				</File>
+				<File
+					RelativePath=".\depgraph\DependencyGraphBuilder.h"
+					>
+				</File>
+				<File
+					RelativePath=".\depgraph\DependencyGraphOutput.h"
+					>
+				</File>
+			</Filter>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/src/compiler/translator_hlsl.vcproj
--- a/gfx/angle/src/compiler/translator_hlsl.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/compiler/translator_hlsl.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,72 +1,347 @@
 <?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="translator_hlsl" ProjectGUID="{5620F0E4-6C43-49BC-A178-B804E1A0C3A7}" RootNamespace="CrossCompilerHLSL" Keyword="Win32Proj" TargetFrameworkVersion="196613">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)\hlsl" ConfigurationType="4" CharacterSet="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="$(ProjectDir)../;$(ProjectDir)../../include" PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;NOMINMAX" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" UsePrecompiledHeader="0" WarningLevel="3" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLibrarianTool" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)\hlsl" ConfigurationType="4" CharacterSet="1" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="2" InlineFunctionExpansion="2" EnableIntrinsicFunctions="true" AdditionalIncludeDirectories="$(ProjectDir)../;$(ProjectDir)../../include" PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;NOMINMAX;_SECURE_SCL=0" RuntimeLibrary="0" EnableFunctionLevelLinking="true" UsePrecompiledHeader="0" WarningLevel="3" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLibrarianTool" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCPostBuildEventTool" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <Filter Name="Source Files" Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx" UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
-      <File RelativePath=".\CodeGenHLSL.cpp">
-      </File>
-      <File RelativePath=".\OutputHLSL.cpp">
-      </File>
-      <File RelativePath=".\SearchSymbol.cpp">
-      </File>
-      <File RelativePath=".\TranslatorHLSL.cpp">
-      </File>
-      <File RelativePath=".\UnfoldSelect.cpp">
-      </File>
-    </Filter>
-    <Filter Name="Header Files" Filter="h;hpp;hxx;hm;inl;inc;xsd" UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
-      <File RelativePath=".\OutputHLSL.h">
-      </File>
-      <File RelativePath=".\SearchSymbol.h">
-      </File>
-      <File RelativePath=".\TranslatorHLSL.h">
-      </File>
-      <File RelativePath=".\UnfoldSelect.h">
-      </File>
-    </Filter>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="translator_hlsl"
+	ProjectGUID="{5620F0E4-6C43-49BC-A178-B804E1A0C3A7}"
+	RootNamespace="CrossCompilerHLSL"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="196613"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)\hlsl"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="$(ProjectDir)../;$(ProjectDir)../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				WarnAsError="true"
+				DebugInformationFormat="4"
+				DisableSpecificWarnings="4100;4127;4189;4239;4244;4245;4512;4702"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)\hlsl"
+			ConfigurationType="4"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="$(ProjectDir)../;$(ProjectDir)../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;NOMINMAX;_SECURE_SCL=0"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				WarnAsError="true"
+				DebugInformationFormat="3"
+				DisableSpecificWarnings="4100;4127;4189;4239;4244;4245;4512;4702"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="$(ProjectDir)../;$(ProjectDir)../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				DisableSpecificWarnings="4100;4127;4189;4239;4244;4245;4512;4702"
+				DebugInformationFormat="3"
+				WarnAsError="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="$(ProjectDir)../;$(ProjectDir)../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;NOMINMAX;_SECURE_SCL=0"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				DisableSpecificWarnings="4100;4127;4189;4239;4244;4245;4512;4702"
+				DebugInformationFormat="3"
+				WarnAsError="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath=".\CodeGenHLSL.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\DetectDiscontinuity.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\OutputHLSL.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\SearchSymbol.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\TranslatorHLSL.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\UnfoldShortCircuit.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath=".\DetectDiscontinuity.h"
+				>
+			</File>
+			<File
+				RelativePath=".\OutputHLSL.h"
+				>
+			</File>
+			<File
+				RelativePath=".\SearchSymbol.h"
+				>
+			</File>
+			<File
+				RelativePath=".\TranslatorHLSL.h"
+				>
+			</File>
+			<File
+				RelativePath=".\UnfoldShortCircuit.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/src/libEGL/Display.cpp
--- a/gfx/angle/src/libEGL/Display.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libEGL/Display.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -992,6 +992,22 @@
     return SUCCEEDED(mD3d9->CheckDeviceFormat(mAdapter, mDeviceType, currentDisplayMode.Format, 0, D3DRTYPE_TEXTURE, D3DFMT_DXT5));
 }
 
+// we use INTZ for depth textures in Direct3D9
+// we also want NULL texture support to ensure the we can make depth-only FBOs
+// see http://aras-p.info/texts/D3D9GPUHacks.html
+bool Display::getDepthTextureSupport() const
+{
+    D3DDISPLAYMODE currentDisplayMode;
+    mD3d9->GetAdapterDisplayMode(mAdapter, &currentDisplayMode);
+
+    bool intz = SUCCEEDED(mD3d9->CheckDeviceFormat(mAdapter, mDeviceType, currentDisplayMode.Format,
+                                                   D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_TEXTURE, D3DFMT_INTZ));
+    bool null = SUCCEEDED(mD3d9->CheckDeviceFormat(mAdapter, mDeviceType, currentDisplayMode.Format,
+                                                   D3DUSAGE_RENDERTARGET, D3DRTYPE_SURFACE, D3DFMT_NULL));
+
+    return intz && null;
+}
+
 bool Display::getFloat32TextureSupport(bool *filtering, bool *renderable)
 {
     D3DDISPLAYMODE currentDisplayMode;
@@ -1081,7 +1097,7 @@
     return D3DPOOL_DEFAULT;
 }
 
-D3DPOOL Display::getTexturePool(bool renderable) const
+D3DPOOL Display::getTexturePool(DWORD usage) const
 {
     if (mD3d9Ex != NULL)
     {
@@ -1089,7 +1105,7 @@
     }
     else
     {
-        if (!renderable)
+        if (!(usage & (D3DUSAGE_DEPTHSTENCIL | D3DUSAGE_RENDERTARGET)))
         {
             return D3DPOOL_MANAGED;
         }
diff -r 91d3e124dee2 gfx/angle/src/libEGL/Display.h
--- a/gfx/angle/src/libEGL/Display.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libEGL/Display.h	Sat Jun 09 12:08:28 2012 +0900
@@ -78,10 +78,11 @@
     virtual bool getLuminanceAlphaTextureSupport();
     virtual bool getVertexTextureSupport() const;
     virtual bool getNonPower2TextureSupport() const;
+    virtual bool getDepthTextureSupport() const;
     virtual bool getOcclusionQuerySupport() const;
     virtual bool getInstancingSupport() const;
     virtual D3DPOOL getBufferPool(DWORD usage) const;
-    virtual D3DPOOL getTexturePool(bool renderable) const;
+    virtual D3DPOOL getTexturePool(DWORD usage) const;
 
     virtual void notifyDeviceLost();
     bool isDeviceLost();
diff -r 91d3e124dee2 gfx/angle/src/libEGL/Makefile.in
--- a/gfx/angle/src/libEGL/Makefile.in	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libEGL/Makefile.in	Sat Jun 09 12:08:28 2012 +0900
@@ -69,6 +69,8 @@
   $(srcdir)/../compiler \
   $(srcdir)/../compiler/preprocessor \
   $(srcdir)/../compiler/preprocessor/new \
+  $(srcdir)/../compiler/timing \
+  $(srcdir)/../compiler/depgraph \
   $(srcdir)/../common \
   $(NULL)
 
@@ -76,6 +78,8 @@
 
 CPPSRCS = \
   Compiler.cpp \
+  DetectDiscontinuity.cpp \
+  DetectDiscontinuity.cpp \
   DetectRecursion.cpp \
   InfoSink.cpp \
   Initialize.cpp \
@@ -118,13 +122,27 @@
   CodeGenHLSL.cpp \
   OutputHLSL.cpp \
   TranslatorHLSL.cpp \
-  UnfoldSelect.cpp \
+  UnfoldShortCircuit.cpp \
   SearchSymbol.cpp \
   OutputESSL.cpp \
   OutputGLSLBase.cpp \
   TranslatorESSL.cpp \
   $(NULL)
 
+# depgraph
+CPPSRCS += \
+  DependencyGraph.cpp \
+  DependencyGraphBuilder.cpp \
+  DependencyGraphOutput.cpp \
+  DependencyGraphTraverse.cpp \
+  $(NULL)
+
+# Timing
+CPPSRCS += \
+  RestrictFragmentShaderTiming.cpp \
+  RestrictVertexShaderTiming.cpp \
+  $(NULL)
+
 CSRCS   = \
   atom.c \
   cpp.c \
diff -r 91d3e124dee2 gfx/angle/src/libEGL/Surface.cpp
--- a/gfx/angle/src/libEGL/Surface.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libEGL/Surface.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -565,6 +565,8 @@
     return mPostSubBufferSupported;
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *Surface::getRenderTarget()
 {
     if (mRenderTarget)
@@ -575,6 +577,8 @@
     return mRenderTarget;
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *Surface::getDepthStencil()
 {
     if (mDepthStencil)
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/Context.cpp
--- a/gfx/angle/src/libGLESv2/Context.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/Context.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -22,6 +22,7 @@
 #include "libGLESv2/Fence.h"
 #include "libGLESv2/FrameBuffer.h"
 #include "libGLESv2/Program.h"
+#include "libGLESv2/ProgramBinary.h"
 #include "libGLESv2/Query.h"
 #include "libGLESv2/RenderBuffer.h"
 #include "libGLESv2/Shader.h"
@@ -310,6 +311,7 @@
         mSupportsFloat16Textures = mDisplay->getFloat16TextureSupport(&mSupportsFloat16LinearFilter, &mSupportsFloat16RenderableTextures);
         mSupportsLuminanceTextures = mDisplay->getLuminanceTextureSupport();
         mSupportsLuminanceAlphaTextures = mDisplay->getLuminanceAlphaTextureSupport();
+        mSupportsDepthTextures = mDisplay->getDepthTextureSupport();
 
         mSupports32bitIndices = mDeviceCaps.MaxVertexIndex >= (1 << 16);
 
@@ -405,6 +407,11 @@
     mCachedCurrentProgram = NULL;
 }
 
+void Context::markDxUniformsDirty()
+{
+    mDxUniformsDirty = true;
+}
+
 void Context::markContextLost()
 {
     if (mResetStrategy == GL_LOSE_CONTEXT_ON_RESET_EXT)
@@ -1646,6 +1653,12 @@
       case GL_RESET_NOTIFICATION_STRATEGY_EXT:
         *params = mResetStrategy;
         break;
+      case GL_NUM_PROGRAM_BINARY_FORMATS_OES:
+        *params = 1;
+        break;
+      case GL_PROGRAM_BINARY_FORMATS_OES:
+        *params = GL_PROGRAM_BINARY_ANGLE;
+        break;
       default:
         return false;
     }
@@ -1737,6 +1750,8 @@
       case GL_TEXTURE_BINDING_2D:
       case GL_TEXTURE_BINDING_CUBE_MAP:
       case GL_RESET_NOTIFICATION_STRATEGY_EXT:
+      case GL_NUM_PROGRAM_BINARY_FORMATS_OES:
+      case GL_PROGRAM_BINARY_FORMATS_OES:
         {
             *type = GL_INT;
             *numParams = 1;
@@ -1835,13 +1850,31 @@
         return error(GL_INVALID_FRAMEBUFFER_OPERATION, false);
     }
 
+    // if there is no color attachment we must synthesize a NULL colorattachment
+    // to keep the D3D runtime happy.  This should only be possible if depth texturing.
+    Renderbuffer *renderbufferObject = NULL;
+    if (framebufferObject->getColorbufferType() != GL_NONE)
+    {
+        renderbufferObject = framebufferObject->getColorbuffer();
+    }
+    else
+    {
+        renderbufferObject = framebufferObject->getNullColorbuffer();
+    }
+    if (!renderbufferObject)
+    {
+        ERR("unable to locate renderbuffer for FBO.");
+        return false;
+    }
+
     bool renderTargetChanged = false;
-    unsigned int renderTargetSerial = framebufferObject->getRenderTargetSerial();
+    unsigned int renderTargetSerial = renderbufferObject->getSerial();
     if (renderTargetSerial != mAppliedRenderTargetSerial)
     {
-        IDirect3DSurface9 *renderTarget = framebufferObject->getRenderTarget();
+        IDirect3DSurface9 *renderTarget = renderbufferObject->getRenderTarget();
         if (!renderTarget)
         {
+            ERR("render target pointer unexpectedly null.");
             return false;   // Context must be lost
         }
         mDevice->SetRenderTarget(0, renderTarget);
@@ -1856,25 +1889,27 @@
     unsigned int stencilbufferSerial = 0;
     if (framebufferObject->getDepthbufferType() != GL_NONE)
     {
-        depthStencil = framebufferObject->getDepthbuffer()->getDepthStencil();
+        Renderbuffer *depthbuffer = framebufferObject->getDepthbuffer();
+        depthStencil = depthbuffer->getDepthStencil();
         if (!depthStencil)
         {
             ERR("Depth stencil pointer unexpectedly null.");
             return false;
         }
         
-        depthbufferSerial = framebufferObject->getDepthbuffer()->getSerial();
+        depthbufferSerial = depthbuffer->getSerial();
     }
     else if (framebufferObject->getStencilbufferType() != GL_NONE)
     {
-        depthStencil = framebufferObject->getStencilbuffer()->getDepthStencil();
+        Renderbuffer *stencilbuffer = framebufferObject->getStencilbuffer();
+        depthStencil = stencilbuffer->getDepthStencil();
         if (!depthStencil)
         {
             ERR("Depth stencil pointer unexpectedly null.");
             return false;
         }
         
-        stencilbufferSerial = framebufferObject->getStencilbuffer()->getSerial();
+        stencilbufferSerial = stencilbuffer->getSerial();
     }
 
     if (depthbufferSerial != mAppliedDepthbufferSerial ||
@@ -1887,9 +1922,14 @@
         mDepthStencilInitialized = true;
     }
 
+    if (depthStencil)
+    {
+        depthStencil->Release();
+    }
+
     if (!mRenderTargetDescInitialized || renderTargetChanged)
     {
-        IDirect3DSurface9 *renderTarget = framebufferObject->getRenderTarget();
+        IDirect3DSurface9 *renderTarget = renderbufferObject->getRenderTarget();
         if (!renderTarget)
         {
             return false;   // Context must be lost
@@ -1960,26 +2000,27 @@
     if (mState.currentProgram && mDxUniformsDirty)
     {
         Program *programObject = getCurrentProgram();
-
-        GLint halfPixelSize = programObject->getDxHalfPixelSizeLocation();
+        ProgramBinary *programBinary = programObject->getProgramBinary();
+
+        GLint halfPixelSize = programBinary->getDxHalfPixelSizeLocation();
         GLfloat xy[2] = {1.0f / viewport.Width, -1.0f / viewport.Height};
-        programObject->setUniform2fv(halfPixelSize, 1, xy);
+        programBinary->setUniform2fv(halfPixelSize, 1, xy);
 
         // These values are used for computing gl_FragCoord in Program::linkVaryings(). The approach depends on Shader Model 3.0 support.
-        GLint coord = programObject->getDxCoordLocation();
+        GLint coord = programBinary->getDxCoordLocation();
         float h = mSupportsShaderModel3 ? mRenderTargetDesc.Height : mState.viewportHeight / 2.0f;
         GLfloat whxy[4] = {mState.viewportWidth / 2.0f, h, 
                           (float)mState.viewportX + mState.viewportWidth / 2.0f, 
                           (float)mState.viewportY + mState.viewportHeight / 2.0f};
-        programObject->setUniform4fv(coord, 1, whxy);
-
-        GLint depth = programObject->getDxDepthLocation();
+        programBinary->setUniform4fv(coord, 1, whxy);
+
+        GLint depth = programBinary->getDxDepthLocation();
         GLfloat dz[2] = {(zFar - zNear) / 2.0f, (zNear + zFar) / 2.0f};
-        programObject->setUniform2fv(depth, 1, dz);
-
-        GLint depthRange = programObject->getDxDepthRangeLocation();
+        programBinary->setUniform2fv(depth, 1, dz);
+
+        GLint depthRange = programBinary->getDxDepthRangeLocation();
         GLfloat nearFarDiff[3] = {zNear, zFar, zFar - zNear};
-        programObject->setUniform3fv(depthRange, 1, nearFarDiff);
+        programBinary->setUniform3fv(depthRange, 1, nearFarDiff);
         mDxUniformsDirty = false;
     }
 
@@ -1990,18 +2031,19 @@
 void Context::applyState(GLenum drawMode)
 {
     Program *programObject = getCurrentProgram();
+    ProgramBinary *programBinary = programObject->getProgramBinary();
 
     Framebuffer *framebufferObject = getDrawFramebuffer();
 
     GLenum adjustedFrontFace = adjustWinding(mState.frontFace);
 
-    GLint frontCCW = programObject->getDxFrontCCWLocation();
+    GLint frontCCW = programBinary->getDxFrontCCWLocation();
     GLint ccw = (adjustedFrontFace == GL_CCW);
-    programObject->setUniform1iv(frontCCW, 1, &ccw);
-
-    GLint pointsOrLines = programObject->getDxPointsOrLinesLocation();
+    programBinary->setUniform1iv(frontCCW, 1, &ccw);
+
+    GLint pointsOrLines = programBinary->getDxPointsOrLinesLocation();
     GLint alwaysFront = !isTriangleMode(drawMode);
-    programObject->setUniform1iv(pointsOrLines, 1, &alwaysFront);
+    programBinary->setUniform1iv(pointsOrLines, 1, &alwaysFront);
 
     D3DADAPTER_IDENTIFIER9 *identifier = mDisplay->getAdapterIdentifier();
     bool zeroColorMaskAllowed = identifier->VendorId != 0x1002;
@@ -2280,18 +2322,20 @@
 void Context::applyShaders()
 {
     Program *programObject = getCurrentProgram();
+    ProgramBinary *programBinary = programObject->getProgramBinary();
+
     if (programObject->getSerial() != mAppliedProgramSerial)
     {
-        IDirect3DVertexShader9 *vertexShader = programObject->getVertexShader();
-        IDirect3DPixelShader9 *pixelShader = programObject->getPixelShader();
+        IDirect3DVertexShader9 *vertexShader = programBinary->getVertexShader();
+        IDirect3DPixelShader9 *pixelShader = programBinary->getPixelShader();
 
         mDevice->SetPixelShader(pixelShader);
         mDevice->SetVertexShader(vertexShader);
-        programObject->dirtyAllUniforms();
+        programBinary->dirtyAllUniforms();
         mAppliedProgramSerial = programObject->getSerial();
     }
 
-    programObject->applyUniforms();
+    programBinary->applyUniforms();
 }
 
 // Applies the textures and sampler states to the Direct3D 9 device
@@ -2311,30 +2355,32 @@
 void Context::applyTextures(SamplerType type)
 {
     Program *programObject = getCurrentProgram();
+    ProgramBinary *programBinary = programObject->getProgramBinary();
 
     int samplerCount = (type == SAMPLER_PIXEL) ? MAX_TEXTURE_IMAGE_UNITS : MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF;   // Range of Direct3D 9 samplers of given sampler type
     unsigned int *appliedTextureSerial = (type == SAMPLER_PIXEL) ? mAppliedTextureSerialPS : mAppliedTextureSerialVS;
     int d3dSamplerOffset = (type == SAMPLER_PIXEL) ? 0 : D3DVERTEXTEXTURESAMPLER0;
-    int samplerRange = programObject->getUsedSamplerRange(type);
+    int samplerRange = programBinary->getUsedSamplerRange(type);
 
     for (int samplerIndex = 0; samplerIndex < samplerRange; samplerIndex++)
     {
-        int textureUnit = programObject->getSamplerMapping(type, samplerIndex);   // OpenGL texture image unit index
+        int textureUnit = programBinary->getSamplerMapping(type, samplerIndex);   // OpenGL texture image unit index
         int d3dSampler = samplerIndex + d3dSamplerOffset;
 
         if (textureUnit != -1)
         {
-            TextureType textureType = programObject->getSamplerTextureType(type, samplerIndex);
+            TextureType textureType = programBinary->getSamplerTextureType(type, samplerIndex);
 
             Texture *texture = getSamplerTexture(textureUnit, textureType);
-
-            if (appliedTextureSerial[samplerIndex] != texture->getTextureSerial() || texture->hasDirtyParameters() || texture->hasDirtyImages())
+            unsigned int texSerial = texture->getTextureSerial();
+
+            if (appliedTextureSerial[samplerIndex] != texSerial || texture->hasDirtyParameters() || texture->hasDirtyImages())
             {
                 IDirect3DBaseTexture9 *d3dTexture = texture->getTexture();
 
                 if (d3dTexture)
                 {
-                    if (appliedTextureSerial[samplerIndex] != texture->getTextureSerial() || texture->hasDirtyParameters())
+                    if (appliedTextureSerial[samplerIndex] != texSerial || texture->hasDirtyParameters())
                     {
                         GLenum wrapS = texture->getWrapS();
                         GLenum wrapT = texture->getWrapT();
@@ -2351,7 +2397,7 @@
                         mDevice->SetSamplerState(d3dSampler, D3DSAMP_MIPFILTER, d3dMipFilter);
                     }
 
-                    if (appliedTextureSerial[samplerIndex] != texture->getTextureSerial() || texture->hasDirtyImages())
+                    if (appliedTextureSerial[samplerIndex] != texSerial || texture->hasDirtyImages())
                     {
                         mDevice->SetTexture(d3dSampler, d3dTexture);
                     }
@@ -2361,7 +2407,7 @@
                     mDevice->SetTexture(d3dSampler, getIncompleteTexture(textureType)->getTexture());
                 }
 
-                appliedTextureSerial[samplerIndex] = texture->getTextureSerial();
+                appliedTextureSerial[samplerIndex] = texSerial;
                 texture->resetDirty();
             }
         }
@@ -2451,6 +2497,7 @@
         if (FAILED(result))
         {
             ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
+            renderTarget->Release();
             return error(GL_OUT_OF_MEMORY);
         }
     }
@@ -2523,7 +2570,6 @@
             // Fast path for EXT_read_format_bgra, given
             // an RGBA source buffer.  Note that buffers with no
             // alpha go through the slow path below.
-            // Note that this is also the combo exposed by IMPLEMENTATION_COLOR_READ_TYPE/FORMAT
             memcpy(dest + j * outputPitch,
                    source + j * inputPitch,
                    (rect.right - rect.left) * 4);
@@ -2671,10 +2717,10 @@
                   default: UNREACHABLE();
                 }
                 break;
-              case GL_RGB:
+              case GL_RGB:   // IMPLEMENTATION_COLOR_READ_FORMAT
                 switch (type)
                 {
-                  case GL_UNSIGNED_SHORT_5_6_5:
+                  case GL_UNSIGNED_SHORT_5_6_5:   // IMPLEMENTATION_COLOR_READ_TYPE
                     dest16[i + j * outputPitch / sizeof(unsigned short)] = 
                         ((unsigned short)(31 * b + 0.5f) << 0) |
                         ((unsigned short)(63 * g + 0.5f) << 5) |
@@ -2739,6 +2785,7 @@
             
             D3DSURFACE_DESC desc;
             depthStencil->GetDesc(&desc);
+            depthStencil->Release();
 
             unsigned int stencilSize = dx2es::GetStencilSize(desc.Format);
             stencilUnmasked = (0x1 << stencilSize) - 1;
@@ -2953,7 +3000,7 @@
     applyShaders();
     applyTextures();
 
-    if (!getCurrentProgram()->validateSamplers(false))
+    if (!getCurrentProgram()->getProgramBinary()->validateSamplers(false))
     {
         return error(GL_INVALID_OPERATION);
     }
@@ -3043,7 +3090,7 @@
     applyShaders();
     applyTextures();
 
-    if (!getCurrentProgram()->validateSamplers(false))
+    if (!getCurrentProgram()->getProgramBinary()->validateSamplers(false))
     {
         return error(GL_INVALID_OPERATION);
     }
@@ -3453,6 +3500,11 @@
     return mSupportsLuminanceAlphaTextures;
 }
 
+bool Context::supportsDepthTextures() const
+{
+    return mSupportsDepthTextures;
+}
+
 bool Context::supports32bitIndices() const
 {
     return mSupports32bitIndices;
@@ -3678,6 +3730,7 @@
     }
 
     mExtensionString += "GL_OES_packed_depth_stencil ";
+    //mExtensionString += "GL_OES_get_program_binary ";
     mExtensionString += "GL_OES_rgb8_rgba8 ";
     mExtensionString += "GL_OES_standard_derivatives ";
 
@@ -3721,6 +3774,11 @@
     mExtensionString += "GL_EXT_texture_storage ";
 
     // ANGLE-specific extensions
+    if (supportsDepthTextures())
+    {
+        mExtensionString += "GL_ANGLE_depth_texture ";
+    }
+
     mExtensionString += "GL_ANGLE_framebuffer_blit ";
     if (getMaxSupportedSamples() != 0)
     {
@@ -4044,7 +4102,13 @@
 
         if (blitDepthStencil)
         {
-            HRESULT result = mDevice->StretchRect(readFramebuffer->getDepthStencil(), NULL, drawFramebuffer->getDepthStencil(), NULL, D3DTEXF_NONE);
+            IDirect3DSurface9* readDepthStencil = readFramebuffer->getDepthStencil();
+            IDirect3DSurface9* drawDepthStencil = drawFramebuffer->getDepthStencil();
+
+            HRESULT result = mDevice->StretchRect(readDepthStencil, NULL, drawDepthStencil, NULL, D3DTEXF_NONE);
+
+            readDepthStencil->Release();
+            drawDepthStencil->Release();
 
             if (FAILED(result))
             {
@@ -4116,6 +4180,8 @@
     D3DVERTEXELEMENT9 elements[MAX_VERTEX_ATTRIBS + 1];
     D3DVERTEXELEMENT9 *element = &elements[0];
 
+    ProgramBinary *programBinary = program->getProgramBinary();
+
     for (int i = 0; i < MAX_VERTEX_ATTRIBS; i++)
     {
         if (attributes[i].active)
@@ -4171,7 +4237,7 @@
             element->Type = attributes[i].type;
             element->Method = D3DDECLMETHOD_DEFAULT;
             element->Usage = D3DDECLUSAGE_TEXCOORD;
-            element->UsageIndex = program->getSemanticIndex(i);
+            element->UsageIndex = programBinary->getSemanticIndex(i);
             element++;
         }
     }
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/Context.h
--- a/gfx/angle/src/libGLESv2/Context.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/Context.h	Sat Jun 09 12:08:28 2012 +0900
@@ -74,8 +74,8 @@
     MAX_FRAGMENT_UNIFORM_VECTORS_SM3 = 224 - 3,
     MAX_DRAW_BUFFERS = 1,
 
-    IMPLEMENTATION_COLOR_READ_FORMAT = GL_BGRA_EXT,
-    IMPLEMENTATION_COLOR_READ_TYPE = GL_UNSIGNED_BYTE
+    IMPLEMENTATION_COLOR_READ_FORMAT = GL_RGB,
+    IMPLEMENTATION_COLOR_READ_TYPE = GL_UNSIGNED_SHORT_5_6_5
 };
 
 enum QueryType
@@ -282,6 +282,7 @@
     void makeCurrent(egl::Display *display, egl::Surface *surface);
 
     void markAllStateDirty();
+    void markDxUniformsDirty();
 
     virtual void markContextLost();
     bool isContextLost();
@@ -495,6 +496,7 @@
     bool supportsFloat16RenderableTextures() const;
     bool supportsLuminanceTextures() const;
     bool supportsLuminanceAlphaTextures() const;
+    bool supportsDepthTextures() const;
     bool supports32bitIndices() const;
     bool supportsNonPower2Texture() const;
     bool supportsInstancing() const;
@@ -617,6 +619,7 @@
     bool mSupportsFloat16RenderableTextures;
     bool mSupportsLuminanceTextures;
     bool mSupportsLuminanceAlphaTextures;
+    bool mSupportsDepthTextures;
     bool mSupports32bitIndices;
     int mNumCompressedTextureFormats;
 
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/Framebuffer.cpp
--- a/gfx/angle/src/libGLESv2/Framebuffer.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/Framebuffer.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -1,5 +1,5 @@
 //
-// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
+// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 //
@@ -29,6 +29,7 @@
     mColorbufferPointer.set(NULL);
     mDepthbufferPointer.set(NULL);
     mStencilbufferPointer.set(NULL);
+    mNullColorbufferPointer.set(NULL);
 }
 
 Renderbuffer *Framebuffer::lookupRenderbuffer(GLenum type, GLuint handle) const
@@ -128,6 +129,8 @@
     return 0;
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *Framebuffer::getRenderTarget()
 {
     Renderbuffer *colorbuffer = mColorbufferPointer.get();
@@ -140,6 +143,8 @@
     return NULL;
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *Framebuffer::getDepthStencil()
 {
     Renderbuffer *depthstencilbuffer = mDepthbufferPointer.get();
@@ -196,6 +201,30 @@
     return mStencilbufferPointer.get();
 }
 
+Renderbuffer *Framebuffer::getNullColorbuffer()
+{
+    Renderbuffer *nullbuffer  = mNullColorbufferPointer.get();
+    Renderbuffer *depthbuffer = getDepthbuffer();
+
+    if (!depthbuffer)
+    {
+        ERR("Unexpected null depthbuffer for depth-only FBO.");
+        return NULL;
+    }
+
+    GLsizei width  = depthbuffer->getWidth();
+    GLsizei height = depthbuffer->getHeight();
+
+    if (!nullbuffer ||
+        width != nullbuffer->getWidth() || height != nullbuffer->getHeight())
+    {
+        nullbuffer = new Renderbuffer(0, new Colorbuffer(width, height, GL_NONE, 0));
+        mNullColorbufferPointer.set(nullbuffer);
+    }
+
+    return nullbuffer;
+}
+
 GLenum Framebuffer::getColorbufferType()
 {
     return mColorbufferType;
@@ -243,9 +272,11 @@
 
 GLenum Framebuffer::completeness()
 {
+    gl::Context *context = gl::getContext();
     int width = 0;
     int height = 0;
     int samples = -1;
+    bool missingAttachment = true;
 
     if (mColorbufferType != GL_NONE)
     {
@@ -270,31 +301,38 @@
         }
         else if (IsInternalTextureTarget(mColorbufferType))
         {
-            if (IsCompressed(colorbuffer->getInternalFormat()))
+            GLenum internalformat = colorbuffer->getInternalFormat();
+            D3DFORMAT d3dformat = colorbuffer->getD3DFormat();
+
+            if (IsCompressed(internalformat) ||
+                internalformat == GL_ALPHA ||
+                internalformat == GL_LUMINANCE ||
+                internalformat == GL_LUMINANCE_ALPHA)
             {
                 return GL_FRAMEBUFFER_UNSUPPORTED;
             }
 
-            if ((dx2es::IsFloat32Format(colorbuffer->getD3DFormat()) && !getContext()->supportsFloat32RenderableTextures()) || 
-                (dx2es::IsFloat16Format(colorbuffer->getD3DFormat()) && !getContext()->supportsFloat16RenderableTextures()))
+            if ((dx2es::IsFloat32Format(d3dformat) && !context->supportsFloat32RenderableTextures()) ||
+                (dx2es::IsFloat16Format(d3dformat) && !context->supportsFloat16RenderableTextures()))
             {
                 return GL_FRAMEBUFFER_UNSUPPORTED;
             }
 
-            if (colorbuffer->getInternalFormat() == GL_LUMINANCE || colorbuffer->getInternalFormat() == GL_LUMINANCE_ALPHA)
+            if (dx2es::IsDepthFormat(d3dformat) || dx2es::IsStencilFormat(d3dformat))
             {
-                return GL_FRAMEBUFFER_UNSUPPORTED;
+                return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
             }
         }
-        else UNREACHABLE();
+        else
+        {
+            UNREACHABLE();
+            return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
+        }
 
         width = colorbuffer->getWidth();
         height = colorbuffer->getHeight();
         samples = colorbuffer->getSamples();
-    }
-    else
-    {
-        return GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
+        missingAttachment = false;
     }
 
     Renderbuffer *depthbuffer = NULL;
@@ -302,11 +340,6 @@
 
     if (mDepthbufferType != GL_NONE)
     {
-        if (mDepthbufferType != GL_RENDERBUFFER)
-        {
-            return GL_FRAMEBUFFER_UNSUPPORTED;   // Requires GL_OES_depth_texture
-        }
-
         depthbuffer = getDepthbuffer();
 
         if (!depthbuffer)
@@ -319,20 +352,45 @@
             return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
         }
 
-        if (width == 0)
+        if (mDepthbufferType == GL_RENDERBUFFER)
+        {
+            if (!gl::IsDepthRenderable(depthbuffer->getInternalFormat()))
+            {
+                return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
+            }
+        }
+        else if (IsInternalTextureTarget(mDepthbufferType))
+        {
+            D3DFORMAT d3dformat = depthbuffer->getD3DFormat();
+
+            // depth texture attachments require OES/ANGLE_depth_texture
+            if (!context->supportsDepthTextures())
+            {
+                return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
+            }
+
+            if (!dx2es::IsDepthFormat(d3dformat))
+            {
+                return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
+            }
+        }
+        else
+        {
+            UNREACHABLE();
+            return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
+        }
+
+        if (missingAttachment)
         {
             width = depthbuffer->getWidth();
             height = depthbuffer->getHeight();
+            samples = depthbuffer->getSamples();
+            missingAttachment = false;
         }
         else if (width != depthbuffer->getWidth() || height != depthbuffer->getHeight())
         {
             return GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
         }
-
-        if (samples == -1)
-        {
-            samples = depthbuffer->getSamples();
-        }
         else if (samples != depthbuffer->getSamples())
         {
             return GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE;
@@ -341,11 +399,6 @@
 
     if (mStencilbufferType != GL_NONE)
     {
-        if (mStencilbufferType != GL_RENDERBUFFER)
-        {
-            return GL_FRAMEBUFFER_UNSUPPORTED;
-        }
-
         stencilbuffer = getStencilbuffer();
 
         if (!stencilbuffer)
@@ -358,34 +411,63 @@
             return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
         }
 
-        if (width == 0)
+        if (mStencilbufferType == GL_RENDERBUFFER)
+        {
+            if (!gl::IsStencilRenderable(stencilbuffer->getInternalFormat()))
+            {
+                return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
+            }
+        }
+        else if (IsInternalTextureTarget(mStencilbufferType))
+        {
+            D3DFORMAT d3dformat = stencilbuffer->getD3DFormat();
+
+            // texture stencil attachments come along as part
+            // of OES_packed_depth_stencil + OES/ANGLE_depth_texture
+            if (!context->supportsDepthTextures())
+            {
+                return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
+            }
+
+            if (!dx2es::IsStencilFormat(d3dformat))
+            {
+                return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
+            }
+        }
+        else
+        {
+            UNREACHABLE();
+            return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
+        }
+
+        if (missingAttachment)
         {
             width = stencilbuffer->getWidth();
             height = stencilbuffer->getHeight();
+            samples = stencilbuffer->getSamples();
+            missingAttachment = false;
         }
         else if (width != stencilbuffer->getWidth() || height != stencilbuffer->getHeight())
         {
             return GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
         }
-
-        if (samples == -1)
-        {
-            samples = stencilbuffer->getSamples();
-        }
         else if (samples != stencilbuffer->getSamples())
         {
             return GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE;
         }
     }
 
-    if (mDepthbufferType == GL_RENDERBUFFER && mStencilbufferType == GL_RENDERBUFFER)
+    // if we have both a depth and stencil buffer, they must refer to the same object
+    // since we only support packed_depth_stencil and not separate depth and stencil
+    if (depthbuffer && stencilbuffer && (depthbuffer != stencilbuffer))
     {
-        if (depthbuffer->getInternalFormat() != GL_DEPTH24_STENCIL8_OES ||
-            stencilbuffer->getInternalFormat() != GL_DEPTH24_STENCIL8_OES ||
-            depthbuffer->getSerial() != stencilbuffer->getSerial())
-        {
-            return GL_FRAMEBUFFER_UNSUPPORTED;
-        }
+        return GL_FRAMEBUFFER_UNSUPPORTED;
+    }
+
+    // we need to have at least one attachment to be complete
+    if (missingAttachment)
+    {
+        return GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
     }
 
     return GL_FRAMEBUFFER_COMPLETE;
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/Framebuffer.h
--- a/gfx/angle/src/libGLESv2/Framebuffer.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/Framebuffer.h	Sat Jun 09 12:08:28 2012 +0900
@@ -49,6 +49,7 @@
     Renderbuffer *getColorbuffer();
     Renderbuffer *getDepthbuffer();
     Renderbuffer *getStencilbuffer();
+    Renderbuffer *getNullColorbuffer();
 
     GLenum getColorbufferType();
     GLenum getDepthbufferType();
@@ -73,6 +74,8 @@
     GLenum mStencilbufferType;
     BindingPointer<Renderbuffer> mStencilbufferPointer;
 
+    BindingPointer<Renderbuffer> mNullColorbufferPointer;
+
   private:
     DISALLOW_COPY_AND_ASSIGN(Framebuffer);
 
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/Makefile.in
--- a/gfx/angle/src/libGLESv2/Makefile.in	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/Makefile.in	Sat Jun 09 12:08:28 2012 +0900
@@ -70,12 +70,15 @@
 VPATH += $(srcdir)/../compiler
 VPATH += $(srcdir)/../compiler/preprocessor
 VPATH += $(srcdir)/../compiler/preprocessor/new
+VPATH += $(srcdir)/../compiler/timing
+VPATH += $(srcdir)/../compiler/depgraph
 VPATH += $(srcdir)/../common
 
 # Translator/compiler first
 
 CPPSRCS = \
 	Compiler.cpp \
+	DetectDiscontinuity.cpp \
         DetectRecursion.cpp \
         InfoSink.cpp \
         Initialize.cpp \
@@ -118,13 +121,27 @@
 	CodeGenHLSL.cpp \
 	OutputHLSL.cpp \
 	TranslatorHLSL.cpp \
-	UnfoldSelect.cpp \
+	UnfoldShortCircuit.cpp \
 	SearchSymbol.cpp \
         OutputESSL.cpp \
         OutputGLSLBase.cpp \
         TranslatorESSL.cpp \
 	$(NULL)
 
+# depgraph
+CPPSRCS += \
+	DependencyGraph.cpp \
+	DependencyGraphBuilder.cpp \
+	DependencyGraphOutput.cpp \
+	DependencyGraphTraverse.cpp \
+	$(NULL)
+
+# Timing
+CPPSRCS += \
+	RestrictFragmentShaderTiming.cpp \
+	RestrictVertexShaderTiming.cpp \
+	$(NULL)
+
 CSRCS   = \
         atom.c \
         cpp.c \
@@ -155,6 +172,7 @@
 	libGLESv2.cpp \
 	main.cpp \
 	Program.cpp \
+	ProgramBinary.cpp \
 	RefCountObject.cpp \
 	Query.cpp \
 	Renderbuffer.cpp \
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/Program.cpp
--- a/gfx/angle/src/libGLESv2/Program.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/Program.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -8,6 +8,7 @@
 // and related functionality. [OpenGL ES 2.0.24] section 2.10.3 page 28.
 
 #include "libGLESv2/Program.h"
+#include "libGLESv2/ProgramBinary.h"
 
 #include "common/debug.h"
 
@@ -17,64 +18,24 @@
 
 #include <string>
 
-#if !defined(ANGLE_COMPILE_OPTIMIZATION_LEVEL)
-#define ANGLE_COMPILE_OPTIMIZATION_LEVEL D3DCOMPILE_OPTIMIZATION_LEVEL3
-#endif
-
 namespace gl
 {
 unsigned int Program::mCurrentSerial = 1;
-const char *fakepath = "C:\\fakepath";
 
-std::string str(int i)
+AttributeBindings::AttributeBindings()
 {
-    char buffer[20];
-    sprintf(buffer, "%d", i);
-    return buffer;
 }
 
-Uniform::Uniform(GLenum type, const std::string &_name, unsigned int arraySize)
-    : type(type), _name(_name), name(Program::undecorateUniform(_name)), arraySize(arraySize)
-{
-    int bytes = UniformInternalSize(type) * arraySize;
-    data = new unsigned char[bytes];
-    memset(data, 0, bytes);
-    dirty = true;
-}
-
-Uniform::~Uniform()
-{
-    delete[] data;
-}
-
-bool Uniform::isArray()
-{
-    return _name.compare(0, 3, "ar_") == 0;
-}
-
-UniformLocation::UniformLocation(const std::string &_name, unsigned int element, unsigned int index) 
-    : name(Program::undecorateUniform(_name)), element(element), index(index)
+AttributeBindings::~AttributeBindings()
 {
 }
 
 Program::Program(ResourceManager *manager, GLuint handle) : mResourceManager(manager), mHandle(handle), mSerial(issueSerial())
 {
-    mDevice = getDevice();
     mFragmentShader = NULL;
     mVertexShader = NULL;
-
-    mPixelExecutable = NULL;
-    mVertexExecutable = NULL;
-    mConstantTablePS = NULL;
-    mConstantTableVS = NULL;
-
-    mInfoLog = NULL;
-    mValidated = false;
-
-    unlink();
-
+    mProgramBinary = NULL;
     mDeleteStatus = false;
-
     mRefCount = 0;
 }
 
@@ -152,17 +113,7 @@
     return (mVertexShader ? 1 : 0) + (mFragmentShader ? 1 : 0);
 }
 
-IDirect3DPixelShader9 *Program::getPixelShader()
-{
-    return mPixelExecutable;
-}
-
-IDirect3DVertexShader9 *Program::getVertexShader()
-{
-    return mVertexExecutable;
-}
-
-void Program::bindAttributeLocation(GLuint index, const char *name)
+void AttributeBindings::bindAttributeLocation(GLuint index, const char *name)
 {
     if (index < MAX_VERTEX_ATTRIBS)
     {
@@ -175,1458 +126,9 @@
     }
 }
 
-GLuint Program::getAttributeLocation(const char *name)
+void Program::bindAttributeLocation(GLuint index, const char *name)
 {
-    if (name)
-    {
-        for (int index = 0; index < MAX_VERTEX_ATTRIBS; index++)
-        {
-            if (mLinkedAttribute[index].name == std::string(name))
-            {
-                return index;
-            }
-        }
-    }
-
-    return -1;
-}
-
-int Program::getSemanticIndex(int attributeIndex)
-{
-    ASSERT(attributeIndex >= 0 && attributeIndex < MAX_VERTEX_ATTRIBS);
-    
-    return mSemanticIndex[attributeIndex];
-}
-
-// Returns one more than the highest sampler index used.
-GLint Program::getUsedSamplerRange(SamplerType type)
-{
-    switch (type)
-    {
-      case SAMPLER_PIXEL:
-        return mUsedPixelSamplerRange;
-      case SAMPLER_VERTEX:
-        return mUsedVertexSamplerRange;
-      default:
-        UNREACHABLE();
-        return 0;
-    }
-}
-
-// Returns the index of the texture image unit (0-19) corresponding to a Direct3D 9 sampler
-// index (0-15 for the pixel shader and 0-3 for the vertex shader).
-GLint Program::getSamplerMapping(SamplerType type, unsigned int samplerIndex)
-{
-    GLint logicalTextureUnit = -1;
-
-    switch (type)
-    {
-      case SAMPLER_PIXEL:
-        ASSERT(samplerIndex < sizeof(mSamplersPS)/sizeof(mSamplersPS[0]));
-
-        if (mSamplersPS[samplerIndex].active)
-        {
-            logicalTextureUnit = mSamplersPS[samplerIndex].logicalTextureUnit;
-        }
-        break;
-      case SAMPLER_VERTEX:
-        ASSERT(samplerIndex < sizeof(mSamplersVS)/sizeof(mSamplersVS[0]));
-
-        if (mSamplersVS[samplerIndex].active)
-        {
-            logicalTextureUnit = mSamplersVS[samplerIndex].logicalTextureUnit;
-        }
-        break;
-      default: UNREACHABLE();
-    }
-
-    if (logicalTextureUnit >= 0 && logicalTextureUnit < (GLint)getContext()->getMaximumCombinedTextureImageUnits())
-    {
-        return logicalTextureUnit;
-    }
-
-    return -1;
-}
-
-// Returns the texture type for a given Direct3D 9 sampler type and
-// index (0-15 for the pixel shader and 0-3 for the vertex shader).
-TextureType Program::getSamplerTextureType(SamplerType type, unsigned int samplerIndex)
-{
-    switch (type)
-    {
-      case SAMPLER_PIXEL:
-        ASSERT(samplerIndex < sizeof(mSamplersPS)/sizeof(mSamplersPS[0]));
-        ASSERT(mSamplersPS[samplerIndex].active);
-        return mSamplersPS[samplerIndex].textureType;
-      case SAMPLER_VERTEX:
-        ASSERT(samplerIndex < sizeof(mSamplersVS)/sizeof(mSamplersVS[0]));
-        ASSERT(mSamplersVS[samplerIndex].active);
-        return mSamplersVS[samplerIndex].textureType;
-      default: UNREACHABLE();
-    }
-
-    return TEXTURE_2D;
-}
-
-GLint Program::getUniformLocation(std::string name)
-{
-    unsigned int subscript = 0;
-
-    // Strip any trailing array operator and retrieve the subscript
-    size_t open = name.find_last_of('[');
-    size_t close = name.find_last_of(']');
-    if (open != std::string::npos && close == name.length() - 1)
-    {
-        subscript = atoi(name.substr(open + 1).c_str());
-        name.erase(open);
-    }
-
-    unsigned int numUniforms = mUniformIndex.size();
-    for (unsigned int location = 0; location < numUniforms; location++)
-    {
-        if (mUniformIndex[location].name == name &&
-            mUniformIndex[location].element == subscript)
-        {
-            return location;
-        }
-    }
-
-    return -1;
-}
-
-bool Program::setUniform1fv(GLint location, GLsizei count, const GLfloat* v)
-{
-    if (location < 0 || location >= (int)mUniformIndex.size())
-    {
-        return false;
-    }
-
-    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
-    targetUniform->dirty = true;
-
-    if (targetUniform->type == GL_FLOAT)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-
-        GLfloat *target = (GLfloat*)targetUniform->data + mUniformIndex[location].element * 4;
-
-        for (int i = 0; i < count; i++)
-        {
-            target[0] = v[0];
-            target[1] = 0;
-            target[2] = 0;
-            target[3] = 0;
-            target += 4;
-            v += 1;
-        }
-    }
-    else if (targetUniform->type == GL_BOOL)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element;
-
-        for (int i = 0; i < count; ++i)
-        {
-            if (v[i] == 0.0f)
-            {
-                boolParams[i] = GL_FALSE;
-            }
-            else
-            {
-                boolParams[i] = GL_TRUE;
-            }
-        }
-    }
-    else
-    {
-        return false;
-    }
-
-    return true;
-}
-
-bool Program::setUniform2fv(GLint location, GLsizei count, const GLfloat *v)
-{
-    if (location < 0 || location >= (int)mUniformIndex.size())
-    {
-        return false;
-    }
-
-    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
-    targetUniform->dirty = true;
-
-    if (targetUniform->type == GL_FLOAT_VEC2)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-
-        GLfloat *target = (GLfloat*)targetUniform->data + mUniformIndex[location].element * 4;
-
-        for (int i = 0; i < count; i++)
-        {
-            target[0] = v[0];
-            target[1] = v[1];
-            target[2] = 0;
-            target[3] = 0;
-            target += 4;
-            v += 2;
-        }
-    }
-    else if (targetUniform->type == GL_BOOL_VEC2)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-
-        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * 2;
-
-        for (int i = 0; i < count * 2; ++i)
-        {
-            if (v[i] == 0.0f)
-            {
-                boolParams[i] = GL_FALSE;
-            }
-            else
-            {
-                boolParams[i] = GL_TRUE;
-            }
-        }
-    }
-    else 
-    {
-        return false;
-    }
-
-    return true;
-}
-
-bool Program::setUniform3fv(GLint location, GLsizei count, const GLfloat *v)
-{
-    if (location < 0 || location >= (int)mUniformIndex.size())
-    {
-        return false;
-    }
-
-    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
-    targetUniform->dirty = true;
-
-    if (targetUniform->type == GL_FLOAT_VEC3)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-
-        GLfloat *target = (GLfloat*)targetUniform->data + mUniformIndex[location].element * 4;
-
-        for (int i = 0; i < count; i++)
-        {
-            target[0] = v[0];
-            target[1] = v[1];
-            target[2] = v[2];
-            target[3] = 0;
-            target += 4;
-            v += 3;
-        }
-    }
-    else if (targetUniform->type == GL_BOOL_VEC3)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * 3;
-
-        for (int i = 0; i < count * 3; ++i)
-        {
-            if (v[i] == 0.0f)
-            {
-                boolParams[i] = GL_FALSE;
-            }
-            else
-            {
-                boolParams[i] = GL_TRUE;
-            }
-        }
-    }
-    else 
-    {
-        return false;
-    }
-
-    return true;
-}
-
-bool Program::setUniform4fv(GLint location, GLsizei count, const GLfloat *v)
-{
-    if (location < 0 || location >= (int)mUniformIndex.size())
-    {
-        return false;
-    }
-
-    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
-    targetUniform->dirty = true;
-
-    if (targetUniform->type == GL_FLOAT_VEC4)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-
-        memcpy(targetUniform->data + mUniformIndex[location].element * sizeof(GLfloat) * 4,
-               v, 4 * sizeof(GLfloat) * count);
-    }
-    else if (targetUniform->type == GL_BOOL_VEC4)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * 4;
-
-        for (int i = 0; i < count * 4; ++i)
-        {
-            if (v[i] == 0.0f)
-            {
-                boolParams[i] = GL_FALSE;
-            }
-            else
-            {
-                boolParams[i] = GL_TRUE;
-            }
-        }
-    }
-    else 
-    {
-        return false;
-    }
-
-    return true;
-}
-
-template<typename T, int targetWidth, int targetHeight, int srcWidth, int srcHeight>
-void transposeMatrix(T *target, const GLfloat *value)
-{
-    int copyWidth = std::min(targetWidth, srcWidth);
-    int copyHeight = std::min(targetHeight, srcHeight);
-
-    for (int x = 0; x < copyWidth; x++)
-    {
-        for (int y = 0; y < copyHeight; y++)
-        {
-            target[x * targetWidth + y] = (T)value[y * srcWidth + x];
-        }
-    }
-    // clear unfilled right side
-    for (int y = 0; y < copyHeight; y++)
-    {
-        for (int x = srcWidth; x < targetWidth; x++)
-        {
-            target[y * targetWidth + x] = (T)0;
-        }
-    }
-    // clear unfilled bottom.
-    for (int y = srcHeight; y < targetHeight; y++)
-    {
-        for (int x = 0; x < targetWidth; x++)
-        {
-            target[y * targetWidth + x] = (T)0;
-        }
-    }
-}
-
-bool Program::setUniformMatrix2fv(GLint location, GLsizei count, const GLfloat *value)
-{
-    if (location < 0 || location >= (int)mUniformIndex.size())
-    {
-        return false;
-    }
-
-    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
-    targetUniform->dirty = true;
-
-    if (targetUniform->type != GL_FLOAT_MAT2)
-    {
-        return false;
-    }
-
-    int arraySize = targetUniform->arraySize;
-
-    if (arraySize == 1 && count > 1)
-        return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-    count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-
-    GLfloat *target = (GLfloat*)targetUniform->data + mUniformIndex[location].element * 8;
-    for (int i = 0; i < count; i++)
-    {
-        transposeMatrix<GLfloat,4,2,2,2>(target, value);
-        target += 8;
-        value += 4;
-    }
-
-    return true;
-}
-
-bool Program::setUniformMatrix3fv(GLint location, GLsizei count, const GLfloat *value)
-{
-    if (location < 0 || location >= (int)mUniformIndex.size())
-    {
-        return false;
-    }
-
-    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
-    targetUniform->dirty = true;
-
-    if (targetUniform->type != GL_FLOAT_MAT3)
-    {
-        return false;
-    }
-
-    int arraySize = targetUniform->arraySize;
-
-    if (arraySize == 1 && count > 1)
-        return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-    count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-
-    GLfloat *target = (GLfloat*)targetUniform->data + mUniformIndex[location].element * 12;
-    for (int i = 0; i < count; i++)
-    {
-        transposeMatrix<GLfloat,4,3,3,3>(target, value);
-        target += 12;
-        value += 9;
-    }
-
-    return true;
-}
-
-
-bool Program::setUniformMatrix4fv(GLint location, GLsizei count, const GLfloat *value)
-{
-    if (location < 0 || location >= (int)mUniformIndex.size())
-    {
-        return false;
-    }
-
-    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
-    targetUniform->dirty = true;
-
-    if (targetUniform->type != GL_FLOAT_MAT4)
-    {
-        return false;
-    }
-
-    int arraySize = targetUniform->arraySize;
-
-    if (arraySize == 1 && count > 1)
-        return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-    count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-
-    GLfloat *target = (GLfloat*)(targetUniform->data + mUniformIndex[location].element * sizeof(GLfloat) * 16);
-    for (int i = 0; i < count; i++)
-    {
-        transposeMatrix<GLfloat,4,4,4,4>(target, value);
-        target += 16;
-        value += 16;
-    }
-
-    return true;
-}
-
-bool Program::setUniform1iv(GLint location, GLsizei count, const GLint *v)
-{
-    if (location < 0 || location >= (int)mUniformIndex.size())
-    {
-        return false;
-    }
-
-    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
-    targetUniform->dirty = true;
-
-    if (targetUniform->type == GL_INT ||
-        targetUniform->type == GL_SAMPLER_2D ||
-        targetUniform->type == GL_SAMPLER_CUBE)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-
-        memcpy(targetUniform->data + mUniformIndex[location].element * sizeof(GLint),
-               v, sizeof(GLint) * count);
-    }
-    else if (targetUniform->type == GL_BOOL)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element;
-
-        for (int i = 0; i < count; ++i)
-        {
-            if (v[i] == 0)
-            {
-                boolParams[i] = GL_FALSE;
-            }
-            else
-            {
-                boolParams[i] = GL_TRUE;
-            }
-        }
-    }
-    else
-    {
-        return false;
-    }
-
-    return true;
-}
-
-bool Program::setUniform2iv(GLint location, GLsizei count, const GLint *v)
-{
-    if (location < 0 || location >= (int)mUniformIndex.size())
-    {
-        return false;
-    }
-
-    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
-    targetUniform->dirty = true;
-
-    if (targetUniform->type == GL_INT_VEC2)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-
-        memcpy(targetUniform->data + mUniformIndex[location].element * sizeof(GLint) * 2,
-               v, 2 * sizeof(GLint) * count);
-    }
-    else if (targetUniform->type == GL_BOOL_VEC2)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * 2;
-
-        for (int i = 0; i < count * 2; ++i)
-        {
-            if (v[i] == 0)
-            {
-                boolParams[i] = GL_FALSE;
-            }
-            else
-            {
-                boolParams[i] = GL_TRUE;
-            }
-        }
-    }
-    else
-    {
-        return false;
-    }
-
-    return true;
-}
-
-bool Program::setUniform3iv(GLint location, GLsizei count, const GLint *v)
-{
-    if (location < 0 || location >= (int)mUniformIndex.size())
-    {
-        return false;
-    }
-
-    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
-    targetUniform->dirty = true;
-
-    if (targetUniform->type == GL_INT_VEC3)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-
-        memcpy(targetUniform->data + mUniformIndex[location].element * sizeof(GLint) * 3,
-               v, 3 * sizeof(GLint) * count);
-    }
-    else if (targetUniform->type == GL_BOOL_VEC3)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * 3;
-
-        for (int i = 0; i < count * 3; ++i)
-        {
-            if (v[i] == 0)
-            {
-                boolParams[i] = GL_FALSE;
-            }
-            else
-            {
-                boolParams[i] = GL_TRUE;
-            }
-        }
-    }
-    else
-    {
-        return false;
-    }
-
-    return true;
-}
-
-bool Program::setUniform4iv(GLint location, GLsizei count, const GLint *v)
-{
-    if (location < 0 || location >= (int)mUniformIndex.size())
-    {
-        return false;
-    }
-
-    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
-    targetUniform->dirty = true;
-
-    if (targetUniform->type == GL_INT_VEC4)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-
-        memcpy(targetUniform->data + mUniformIndex[location].element * sizeof(GLint) * 4,
-               v, 4 * sizeof(GLint) * count);
-    }
-    else if (targetUniform->type == GL_BOOL_VEC4)
-    {
-        int arraySize = targetUniform->arraySize;
-
-        if (arraySize == 1 && count > 1)
-            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
-
-        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
-        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * 4;
-
-        for (int i = 0; i < count * 4; ++i)
-        {
-            if (v[i] == 0)
-            {
-                boolParams[i] = GL_FALSE;
-            }
-            else
-            {
-                boolParams[i] = GL_TRUE;
-            }
-        }
-    }
-    else
-    {
-        return false;
-    }
-
-    return true;
-}
-
-bool Program::getUniformfv(GLint location, GLsizei *bufSize, GLfloat *params)
-{
-    if (location < 0 || location >= (int)mUniformIndex.size())
-    {
-        return false;
-    }
-
-    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
-
-    // sized queries -- ensure the provided buffer is large enough
-    if (bufSize)
-    {
-        int requiredBytes = UniformExternalSize(targetUniform->type);
-        if (*bufSize < requiredBytes)
-        {
-            return false;
-        }
-    }
-
-    switch (targetUniform->type)
-    {
-      case GL_FLOAT_MAT2:
-        transposeMatrix<GLfloat,2,2,4,2>(params, (GLfloat*)targetUniform->data + mUniformIndex[location].element * 8);
-        break;
-      case GL_FLOAT_MAT3:
-        transposeMatrix<GLfloat,3,3,4,3>(params, (GLfloat*)targetUniform->data + mUniformIndex[location].element * 12);
-        break;
-      case GL_FLOAT_MAT4:
-        transposeMatrix<GLfloat,4,4,4,4>(params, (GLfloat*)targetUniform->data + mUniformIndex[location].element * 16);
-        break;
-      default:
-        {
-            unsigned int count = UniformExternalComponentCount(targetUniform->type);
-            unsigned int internalCount = UniformInternalComponentCount(targetUniform->type);
-
-            switch (UniformComponentType(targetUniform->type))
-            {
-              case GL_BOOL:
-                {
-                    GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * internalCount;
-
-                    for (unsigned int i = 0; i < count; ++i)
-                    {
-                        params[i] = (boolParams[i] == GL_FALSE) ? 0.0f : 1.0f;
-                    }
-                }
-                break;
-              case GL_FLOAT:
-                memcpy(params, targetUniform->data + mUniformIndex[location].element * internalCount * sizeof(GLfloat),
-                       count * sizeof(GLfloat));
-                break;
-              case GL_INT:
-                {
-                    GLint *intParams = (GLint*)targetUniform->data + mUniformIndex[location].element * internalCount;
-
-                    for (unsigned int i = 0; i < count; ++i)
-                    {
-                        params[i] = (float)intParams[i];
-                    }
-                }
-                break;
-              default: UNREACHABLE();
-            }
-        }
-    }
-
-    return true;
-}
-
-bool Program::getUniformiv(GLint location, GLsizei *bufSize, GLint *params)
-{
-    if (location < 0 || location >= (int)mUniformIndex.size())
-    {
-        return false;
-    }
-
-    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
-
-    // sized queries -- ensure the provided buffer is large enough
-    if (bufSize)
-    {
-        int requiredBytes = UniformExternalSize(targetUniform->type);
-        if (*bufSize < requiredBytes)
-        {
-            return false;
-        }
-    }
-
-    switch (targetUniform->type)
-    {
-      case GL_FLOAT_MAT2:
-        {
-            transposeMatrix<GLint,2,2,4,2>(params, (GLfloat*)targetUniform->data + mUniformIndex[location].element * 8);
-        }
-        break;
-      case GL_FLOAT_MAT3:
-        {
-            transposeMatrix<GLint,3,3,4,3>(params, (GLfloat*)targetUniform->data + mUniformIndex[location].element * 12);
-        }
-        break;
-      case GL_FLOAT_MAT4:
-        {
-            transposeMatrix<GLint,4,4,4,4>(params, (GLfloat*)targetUniform->data + mUniformIndex[location].element * 16);
-        }
-        break;
-      default:
-        {
-            unsigned int count = UniformExternalComponentCount(targetUniform->type);
-            unsigned int internalCount = UniformInternalComponentCount(targetUniform->type);
-
-            switch (UniformComponentType(targetUniform->type))
-            {
-              case GL_BOOL:
-                {
-                    GLboolean *boolParams = targetUniform->data + mUniformIndex[location].element * internalCount;
-
-                    for (unsigned int i = 0; i < count; ++i)
-                    {
-                        params[i] = (GLint)boolParams[i];
-                    }
-                }
-                break;
-              case GL_FLOAT:
-                {
-                    GLfloat *floatParams = (GLfloat*)targetUniform->data + mUniformIndex[location].element * internalCount;
-
-                    for (unsigned int i = 0; i < count; ++i)
-                    {
-                        params[i] = (GLint)floatParams[i];
-                    }
-                }
-                break;
-              case GL_INT:
-                memcpy(params, targetUniform->data + mUniformIndex[location].element * internalCount * sizeof(GLint),
-                       count * sizeof(GLint));
-                break;
-              default: UNREACHABLE();
-            }
-        }
-    }
-
-    return true;
-}
-
-void Program::dirtyAllUniforms()
-{
-    unsigned int numUniforms = mUniforms.size();
-    for (unsigned int index = 0; index < numUniforms; index++)
-    {
-        mUniforms[index]->dirty = true;
-    }
-}
-
-// Applies all the uniforms set for this program object to the Direct3D 9 device
-void Program::applyUniforms()
-{
-    for (std::vector<Uniform*>::iterator ub = mUniforms.begin(), ue = mUniforms.end(); ub != ue; ++ub) {
-        Uniform *targetUniform = *ub;
-
-        if (targetUniform->dirty)
-        {
-            int arraySize = targetUniform->arraySize;
-            GLfloat *f = (GLfloat*)targetUniform->data;
-            GLint *i = (GLint*)targetUniform->data;
-            GLboolean *b = (GLboolean*)targetUniform->data;
-
-            switch (targetUniform->type)
-            {
-              case GL_BOOL:       applyUniformnbv(targetUniform, arraySize, 1, b);    break;
-              case GL_BOOL_VEC2:  applyUniformnbv(targetUniform, arraySize, 2, b);    break;
-              case GL_BOOL_VEC3:  applyUniformnbv(targetUniform, arraySize, 3, b);    break;
-              case GL_BOOL_VEC4:  applyUniformnbv(targetUniform, arraySize, 4, b);    break;
-              case GL_FLOAT:
-              case GL_FLOAT_VEC2:
-              case GL_FLOAT_VEC3:
-              case GL_FLOAT_VEC4:
-              case GL_FLOAT_MAT2:
-              case GL_FLOAT_MAT3:
-              case GL_FLOAT_MAT4: applyUniformnfv(targetUniform, f);                  break;
-              case GL_SAMPLER_2D:
-              case GL_SAMPLER_CUBE:
-              case GL_INT:        applyUniform1iv(targetUniform, arraySize, i);       break;
-              case GL_INT_VEC2:   applyUniform2iv(targetUniform, arraySize, i);       break;
-              case GL_INT_VEC3:   applyUniform3iv(targetUniform, arraySize, i);       break;
-              case GL_INT_VEC4:   applyUniform4iv(targetUniform, arraySize, i);       break;
-              default:
-                UNREACHABLE();
-            }
-
-            targetUniform->dirty = false;
-        }
-    }
-}
-
-// Compiles the HLSL code of the attached shaders into executable binaries
-ID3D10Blob *Program::compileToBinary(const char *hlsl, const char *profile, ID3DXConstantTable **constantTable)
-{
-    if (!hlsl)
-    {
-        return NULL;
-    }
-
-    DWORD result;
-    UINT flags = 0;
-    std::string sourceText;
-    if (perfActive())
-    {
-        flags |= D3DCOMPILE_DEBUG;
-#ifdef NDEBUG
-        flags |= ANGLE_COMPILE_OPTIMIZATION_LEVEL;
-#else
-        flags |= D3DCOMPILE_SKIP_OPTIMIZATION;
-#endif
-
-        std::string sourcePath = getTempPath();
-        sourceText = std::string("#line 2 \"") + sourcePath + std::string("\"\n\n") + std::string(hlsl);
-        writeFile(sourcePath.c_str(), sourceText.c_str(), sourceText.size());
-    }
-    else
-    {
-        flags |= ANGLE_COMPILE_OPTIMIZATION_LEVEL;
-        sourceText = hlsl;
-    }
-
-    ID3D10Blob *binary = NULL;
-    ID3D10Blob *errorMessage = NULL;
-    result = D3DCompile(hlsl, strlen(hlsl), fakepath, NULL, NULL, "main", profile, flags, 0, &binary, &errorMessage);
-
-    if (errorMessage)
-    {
-        const char *message = (const char*)errorMessage->GetBufferPointer();
-
-        appendToInfoLogSanitized(message);
-        TRACE("\n%s", hlsl);
-        TRACE("\n%s", message);
-
-        errorMessage->Release();
-        errorMessage = NULL;
-    }
-
-    if (FAILED(result))
-    {
-        if (result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY)
-        {
-            error(GL_OUT_OF_MEMORY);
-        }
-
-        return NULL;
-    }
-
-    result = D3DXGetShaderConstantTable(static_cast<const DWORD*>(binary->GetBufferPointer()), constantTable);
-
-    if (FAILED(result))
-    {
-        if (result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY)
-        {
-            error(GL_OUT_OF_MEMORY);
-        }
-
-        binary->Release();
-
-        return NULL;
-    }
-
-    return binary;
-}
-
-// Packs varyings into generic varying registers, using the algorithm from [OpenGL ES Shading Language 1.00 rev. 17] appendix A section 7 page 111
-// Returns the number of used varying registers, or -1 if unsuccesful
-int Program::packVaryings(const Varying *packing[][4])
-{
-    Context *context = getContext();
-    const int maxVaryingVectors = context->getMaximumVaryingVectors();
-
-    for (VaryingList::iterator varying = mFragmentShader->mVaryings.begin(); varying != mFragmentShader->mVaryings.end(); varying++)
-    {
-        int n = VariableRowCount(varying->type) * varying->size;
-        int m = VariableColumnCount(varying->type);
-        bool success = false;
-
-        if (m == 2 || m == 3 || m == 4)
-        {
-            for (int r = 0; r <= maxVaryingVectors - n && !success; r++)
-            {
-                bool available = true;
-
-                for (int y = 0; y < n && available; y++)
-                {
-                    for (int x = 0; x < m && available; x++)
-                    {
-                        if (packing[r + y][x])
-                        {
-                            available = false;
-                        }
-                    }
-                }
-
-                if (available)
-                {
-                    varying->reg = r;
-                    varying->col = 0;
-
-                    for (int y = 0; y < n; y++)
-                    {
-                        for (int x = 0; x < m; x++)
-                        {
-                            packing[r + y][x] = &*varying;
-                        }
-                    }
-
-                    success = true;
-                }
-            }
-
-            if (!success && m == 2)
-            {
-                for (int r = maxVaryingVectors - n; r >= 0 && !success; r--)
-                {
-                    bool available = true;
-
-                    for (int y = 0; y < n && available; y++)
-                    {
-                        for (int x = 2; x < 4 && available; x++)
-                        {
-                            if (packing[r + y][x])
-                            {
-                                available = false;
-                            }
-                        }
-                    }
-
-                    if (available)
-                    {
-                        varying->reg = r;
-                        varying->col = 2;
-
-                        for (int y = 0; y < n; y++)
-                        {
-                            for (int x = 2; x < 4; x++)
-                            {
-                                packing[r + y][x] = &*varying;
-                            }
-                        }
-
-                        success = true;
-                    }
-                }
-            }
-        }
-        else if (m == 1)
-        {
-            int space[4] = {0};
-
-            for (int y = 0; y < maxVaryingVectors; y++)
-            {
-                for (int x = 0; x < 4; x++)
-                {
-                    space[x] += packing[y][x] ? 0 : 1;
-                }
-            }
-
-            int column = 0;
-
-            for (int x = 0; x < 4; x++)
-            {
-                if (space[x] >= n && space[x] < space[column])
-                {
-                    column = x;
-                }
-            }
-
-            if (space[column] >= n)
-            {
-                for (int r = 0; r < maxVaryingVectors; r++)
-                {
-                    if (!packing[r][column])
-                    {
-                        varying->reg = r;
-
-                        for (int y = r; y < r + n; y++)
-                        {
-                            packing[y][column] = &*varying;
-                        }
-
-                        break;
-                    }
-                }
-
-                varying->col = column;
-
-                success = true;
-            }
-        }
-        else UNREACHABLE();
-
-        if (!success)
-        {
-            appendToInfoLog("Could not pack varying %s", varying->name.c_str());
-
-            return -1;
-        }
-    }
-
-    // Return the number of used registers
-    int registers = 0;
-
-    for (int r = 0; r < maxVaryingVectors; r++)
-    {
-        if (packing[r][0] || packing[r][1] || packing[r][2] || packing[r][3])
-        {
-            registers++;
-        }
-    }
-
-    return registers;
-}
-
-bool Program::linkVaryings()
-{
-    if (mPixelHLSL.empty() || mVertexHLSL.empty())
-    {
-        return false;
-    }
-
-    // Reset the varying register assignments
-    for (VaryingList::iterator fragVar = mFragmentShader->mVaryings.begin(); fragVar != mFragmentShader->mVaryings.end(); fragVar++)
-    {
-        fragVar->reg = -1;
-        fragVar->col = -1;
-    }
-
-    for (VaryingList::iterator vtxVar = mVertexShader->mVaryings.begin(); vtxVar != mVertexShader->mVaryings.end(); vtxVar++)
-    {
-        vtxVar->reg = -1;
-        vtxVar->col = -1;
-    }
-
-    // Map the varyings to the register file
-    const Varying *packing[MAX_VARYING_VECTORS_SM3][4] = {NULL};
-    int registers = packVaryings(packing);
-
-    if (registers < 0)
-    {
-        return false;
-    }
-
-    // Write the HLSL input/output declarations
-    Context *context = getContext();
-    const bool sm3 = context->supportsShaderModel3();
-    const int maxVaryingVectors = context->getMaximumVaryingVectors();
-
-    if (registers == maxVaryingVectors && mFragmentShader->mUsesFragCoord)
-    {
-        appendToInfoLog("No varying registers left to support gl_FragCoord");
-
-        return false;
-    }
-
-    for (VaryingList::iterator input = mFragmentShader->mVaryings.begin(); input != mFragmentShader->mVaryings.end(); input++)
-    {
-        bool matched = false;
-
-        for (VaryingList::iterator output = mVertexShader->mVaryings.begin(); output != mVertexShader->mVaryings.end(); output++)
-        {
-            if (output->name == input->name)
-            {
-                if (output->type != input->type || output->size != input->size)
-                {
-                    appendToInfoLog("Type of vertex varying %s does not match that of the fragment varying", output->name.c_str());
-
-                    return false;
-                }
-
-                output->reg = input->reg;
-                output->col = input->col;
-
-                matched = true;
-                break;
-            }
-        }
-
-        if (!matched)
-        {
-            appendToInfoLog("Fragment varying %s does not match any vertex varying", input->name.c_str());
-
-            return false;
-        }
-    }
-
-    std::string varyingSemantic = (sm3 ? "COLOR" : "TEXCOORD");
-
-    mVertexHLSL += "struct VS_INPUT\n"
-                   "{\n";
-
-    int semanticIndex = 0;
-    for (AttributeArray::iterator attribute = mVertexShader->mAttributes.begin(); attribute != mVertexShader->mAttributes.end(); attribute++)
-    {
-        switch (attribute->type)
-        {
-          case GL_FLOAT:      mVertexHLSL += "    float ";    break;
-          case GL_FLOAT_VEC2: mVertexHLSL += "    float2 ";   break;
-          case GL_FLOAT_VEC3: mVertexHLSL += "    float3 ";   break;
-          case GL_FLOAT_VEC4: mVertexHLSL += "    float4 ";   break;
-          case GL_FLOAT_MAT2: mVertexHLSL += "    float2x2 "; break;
-          case GL_FLOAT_MAT3: mVertexHLSL += "    float3x3 "; break;
-          case GL_FLOAT_MAT4: mVertexHLSL += "    float4x4 "; break;
-          default:  UNREACHABLE();
-        }
-
-        mVertexHLSL += decorateAttribute(attribute->name) + " : TEXCOORD" + str(semanticIndex) + ";\n";
-
-        semanticIndex += VariableRowCount(attribute->type);
-    }
-
-    mVertexHLSL += "};\n"
-                   "\n"
-                   "struct VS_OUTPUT\n"
-                   "{\n"
-                   "    float4 gl_Position : POSITION;\n";
-
-    for (int r = 0; r < registers; r++)
-    {
-        int registerSize = packing[r][3] ? 4 : (packing[r][2] ? 3 : (packing[r][1] ? 2 : 1));
-
-        mVertexHLSL += "    float" + str(registerSize) + " v" + str(r) + " : " + varyingSemantic + str(r) + ";\n";
-    }
-
-    if (mFragmentShader->mUsesFragCoord)
-    {
-        mVertexHLSL += "    float4 gl_FragCoord : " + varyingSemantic + str(registers) + ";\n";
-    }
-
-    if (mVertexShader->mUsesPointSize && sm3)
-    {
-        mVertexHLSL += "    float gl_PointSize : PSIZE;\n";
-    }
-
-    mVertexHLSL += "};\n"
-                   "\n"
-                   "VS_OUTPUT main(VS_INPUT input)\n"
-                   "{\n";
-
-    for (AttributeArray::iterator attribute = mVertexShader->mAttributes.begin(); attribute != mVertexShader->mAttributes.end(); attribute++)
-    {
-        mVertexHLSL += "    " + decorateAttribute(attribute->name) + " = ";
-
-        if (VariableRowCount(attribute->type) > 1)   // Matrix
-        {
-            mVertexHLSL += "transpose";
-        }
-
-        mVertexHLSL += "(input." + decorateAttribute(attribute->name) + ");\n";
-    }
-
-    mVertexHLSL += "\n"
-                   "    gl_main();\n"
-                   "\n"
-                   "    VS_OUTPUT output;\n"
-                   "    output.gl_Position.x = gl_Position.x - dx_HalfPixelSize.x * gl_Position.w;\n"
-                   "    output.gl_Position.y = gl_Position.y - dx_HalfPixelSize.y * gl_Position.w;\n"
-                   "    output.gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n"
-                   "    output.gl_Position.w = gl_Position.w;\n";
-
-    if (mVertexShader->mUsesPointSize && sm3)
-    {
-        mVertexHLSL += "    output.gl_PointSize = clamp(gl_PointSize, 1.0, " + str((int)ALIASED_POINT_SIZE_RANGE_MAX_SM3) + ");\n";
-    }
-
-    if (mFragmentShader->mUsesFragCoord)
-    {
-        mVertexHLSL += "    output.gl_FragCoord = gl_Position;\n";
-    }
-
-    for (VaryingList::iterator varying = mVertexShader->mVaryings.begin(); varying != mVertexShader->mVaryings.end(); varying++)
-    {
-        if (varying->reg >= 0)
-        {
-            for (int i = 0; i < varying->size; i++)
-            {
-                int rows = VariableRowCount(varying->type);
-
-                for (int j = 0; j < rows; j++)
-                {
-                    int r = varying->reg + i * rows + j;
-                    mVertexHLSL += "    output.v" + str(r);
-
-                    bool sharedRegister = false;   // Register used by multiple varyings
-                    
-                    for (int x = 0; x < 4; x++)
-                    {
-                        if (packing[r][x] && packing[r][x] != packing[r][0])
-                        {
-                            sharedRegister = true;
-                            break;
-                        }
-                    }
-
-                    if(sharedRegister)
-                    {
-                        mVertexHLSL += ".";
-
-                        for (int x = 0; x < 4; x++)
-                        {
-                            if (packing[r][x] == &*varying)
-                            {
-                                switch(x)
-                                {
-                                  case 0: mVertexHLSL += "x"; break;
-                                  case 1: mVertexHLSL += "y"; break;
-                                  case 2: mVertexHLSL += "z"; break;
-                                  case 3: mVertexHLSL += "w"; break;
-                                }
-                            }
-                        }
-                    }
-
-                    mVertexHLSL += " = " + varying->name;
-                    
-                    if (varying->array)
-                    {
-                        mVertexHLSL += "[" + str(i) + "]";
-                    }
-
-                    if (rows > 1)
-                    {
-                        mVertexHLSL += "[" + str(j) + "]";
-                    }
-                    
-                    mVertexHLSL += ";\n";
-                }
-            }
-        }
-    }
-
-    mVertexHLSL += "\n"
-                   "    return output;\n"
-                   "}\n";
-
-    mPixelHLSL += "struct PS_INPUT\n"
-                  "{\n";
-    
-    for (VaryingList::iterator varying = mFragmentShader->mVaryings.begin(); varying != mFragmentShader->mVaryings.end(); varying++)
-    {
-        if (varying->reg >= 0)
-        {
-            for (int i = 0; i < varying->size; i++)
-            {
-                int rows = VariableRowCount(varying->type);
-                for (int j = 0; j < rows; j++)
-                {
-                    std::string n = str(varying->reg + i * rows + j);
-                    mPixelHLSL += "    float4 v" + n + " : " + varyingSemantic + n + ";\n";
-                }
-            }
-        }
-        else UNREACHABLE();
-    }
-
-    if (mFragmentShader->mUsesFragCoord)
-    {
-        mPixelHLSL += "    float4 gl_FragCoord : " + varyingSemantic + str(registers) + ";\n";
-        if (sm3) {
-            mPixelHLSL += "    float2 dx_VPos : VPOS;\n";
-        }
-    }
-
-    if (mFragmentShader->mUsesPointCoord && sm3)
-    {
-        mPixelHLSL += "    float2 gl_PointCoord : TEXCOORD0;\n";
-    }
-
-    if (mFragmentShader->mUsesFrontFacing)
-    {
-        mPixelHLSL += "    float vFace : VFACE;\n";
-    }
-
-    mPixelHLSL += "};\n"
-                  "\n"
-                  "struct PS_OUTPUT\n"
-                  "{\n"
-                  "    float4 gl_Color[1] : COLOR;\n"
-                  "};\n"
-                  "\n"
-                  "PS_OUTPUT main(PS_INPUT input)\n"
-                  "{\n";
-
-    if (mFragmentShader->mUsesFragCoord)
-    {
-        mPixelHLSL += "    float rhw = 1.0 / input.gl_FragCoord.w;\n";
-        
-        if (sm3)
-        {
-            // dx_Coord.y contains the render target height. See Context::applyRenderTarget()
-            mPixelHLSL += "    gl_FragCoord.x = input.dx_VPos.x + 0.5;\n"
-                          "    gl_FragCoord.y = dx_Coord.y - input.dx_VPos.y - 0.5;\n";
-        }
-        else
-        {
-            // dx_Coord contains the viewport width/2, height/2, center.x and center.y. See Context::applyRenderTarget()
-            mPixelHLSL += "    gl_FragCoord.x = (input.gl_FragCoord.x * rhw) * dx_Coord.x + dx_Coord.z;\n"
-                          "    gl_FragCoord.y = -(input.gl_FragCoord.y * rhw) * dx_Coord.y + dx_Coord.w;\n";
-        }
-        
-        mPixelHLSL += "    gl_FragCoord.z = (input.gl_FragCoord.z * rhw) * dx_Depth.x + dx_Depth.y;\n"
-                      "    gl_FragCoord.w = rhw;\n";
-    }
-
-    if (mFragmentShader->mUsesPointCoord && sm3)
-    {
-        mPixelHLSL += "    gl_PointCoord = input.gl_PointCoord;\n";
-    }
-
-    if (mFragmentShader->mUsesFrontFacing)
-    {
-        mPixelHLSL += "    gl_FrontFacing = dx_PointsOrLines || (dx_FrontCCW ? (input.vFace >= 0.0) : (input.vFace <= 0.0));\n";
-    }
-
-    for (VaryingList::iterator varying = mFragmentShader->mVaryings.begin(); varying != mFragmentShader->mVaryings.end(); varying++)
-    {
-        if (varying->reg >= 0)
-        {
-            for (int i = 0; i < varying->size; i++)
-            {
-                int rows = VariableRowCount(varying->type);
-                for (int j = 0; j < rows; j++)
-                {
-                    std::string n = str(varying->reg + i * rows + j);
-                    mPixelHLSL += "    " + varying->name;
-
-                    if (varying->array)
-                    {
-                        mPixelHLSL += "[" + str(i) + "]";
-                    }
-
-                    if (rows > 1)
-                    {
-                        mPixelHLSL += "[" + str(j) + "]";
-                    }
-
-                    mPixelHLSL += " = input.v" + n + ";\n";
-                }
-            }
-        }
-        else UNREACHABLE();
-    }
-
-    mPixelHLSL += "\n"
-                  "    gl_main();\n"
-                  "\n"
-                  "    PS_OUTPUT output;\n"                 
-                  "    output.gl_Color[0] = gl_Color[0];\n"
-                  "\n"
-                  "    return output;\n"
-                  "}\n";
-
-    return true;
+    mAttributeBindings.bindAttributeLocation(index, name);
 }
 
 // Links the HLSL code of the vertex and pixel shader by matching up their varyings,
@@ -1634,152 +136,16 @@
 // a list of uniforms
 void Program::link()
 {
-    unlink();
+    unlink(false);
 
-    if (!mFragmentShader || !mFragmentShader->isCompiled())
+    mProgramBinary = new ProgramBinary;
+    if (!mProgramBinary->link(mAttributeBindings, mFragmentShader, mVertexShader))
     {
-        return;
-    }
-
-    if (!mVertexShader || !mVertexShader->isCompiled())
-    {
-        return;
-    }
-
-    mPixelHLSL = mFragmentShader->getHLSL();
-    mVertexHLSL = mVertexShader->getHLSL();
-
-    if (!linkVaryings())
-    {
-        return;
-    }
-
-    Context *context = getContext();
-    const char *vertexProfile = context->supportsShaderModel3() ? "vs_3_0" : "vs_2_0";
-    const char *pixelProfile = context->supportsShaderModel3() ? "ps_3_0" : "ps_2_0";
-
-    ID3D10Blob *vertexBinary = compileToBinary(mVertexHLSL.c_str(), vertexProfile, &mConstantTableVS);
-    ID3D10Blob *pixelBinary = compileToBinary(mPixelHLSL.c_str(), pixelProfile, &mConstantTablePS);
-
-    if (vertexBinary && pixelBinary)
-    {
-        HRESULT vertexResult = mDevice->CreateVertexShader((DWORD*)vertexBinary->GetBufferPointer(), &mVertexExecutable);
-        HRESULT pixelResult = mDevice->CreatePixelShader((DWORD*)pixelBinary->GetBufferPointer(), &mPixelExecutable);
-
-        if (vertexResult == D3DERR_OUTOFVIDEOMEMORY || vertexResult == E_OUTOFMEMORY || pixelResult == D3DERR_OUTOFVIDEOMEMORY || pixelResult == E_OUTOFMEMORY)
-        {
-            return error(GL_OUT_OF_MEMORY);
-        }
-
-        ASSERT(SUCCEEDED(vertexResult) && SUCCEEDED(pixelResult));
-
-        vertexBinary->Release();
-        pixelBinary->Release();
-        vertexBinary = NULL;
-        pixelBinary = NULL;
-
-        if (mVertexExecutable && mPixelExecutable)
-        {
-            if (!linkAttributes())
-            {
-                return;
-            }
-
-            if (!linkUniforms(mConstantTablePS))
-            {
-                return;
-            }
-
-            if (!linkUniforms(mConstantTableVS))
-            {
-                return;
-            }
-
-            // these uniforms are searched as already-decorated because gl_ and dx_
-            // are reserved prefixes, and do not receive additional decoration
-            mDxDepthRangeLocation = getUniformLocation("dx_DepthRange");
-            mDxDepthLocation = getUniformLocation("dx_Depth");
-            mDxCoordLocation = getUniformLocation("dx_Coord");
-            mDxHalfPixelSizeLocation = getUniformLocation("dx_HalfPixelSize");
-            mDxFrontCCWLocation = getUniformLocation("dx_FrontCCW");
-            mDxPointsOrLinesLocation = getUniformLocation("dx_PointsOrLines");
-
-            mLinked = true;   // Success
-        }
+        unlink(false);
     }
 }
 
-// Determines the mapping between GL attributes and Direct3D 9 vertex stream usage indices
-bool Program::linkAttributes()
-{
-    unsigned int usedLocations = 0;
-
-    // Link attributes that have a binding location
-    for (AttributeArray::iterator attribute = mVertexShader->mAttributes.begin(); attribute != mVertexShader->mAttributes.end(); attribute++)
-    {
-        int location = getAttributeBinding(attribute->name);
-
-        if (location != -1)   // Set by glBindAttribLocation
-        {
-            if (!mLinkedAttribute[location].name.empty())
-            {
-                // Multiple active attributes bound to the same location; not an error
-            }
-
-            mLinkedAttribute[location] = *attribute;
-
-            int rows = VariableRowCount(attribute->type);
-
-            if (rows + location > MAX_VERTEX_ATTRIBS)
-            {
-                appendToInfoLog("Active attribute (%s) at location %d is too big to fit", attribute->name.c_str(), location);
-
-                return false;
-            }
-
-            for (int i = 0; i < rows; i++)
-            {
-                usedLocations |= 1 << (location + i);
-            }
-        }
-    }
-
-    // Link attributes that don't have a binding location
-    for (AttributeArray::iterator attribute = mVertexShader->mAttributes.begin(); attribute != mVertexShader->mAttributes.end(); attribute++)
-    {
-        int location = getAttributeBinding(attribute->name);
-
-        if (location == -1)   // Not set by glBindAttribLocation
-        {
-            int rows = VariableRowCount(attribute->type);
-            int availableIndex = AllocateFirstFreeBits(&usedLocations, rows, MAX_VERTEX_ATTRIBS);
-
-            if (availableIndex == -1 || availableIndex + rows > MAX_VERTEX_ATTRIBS)
-            {
-                appendToInfoLog("Too many active attributes (%s)", attribute->name.c_str());
-
-                return false;   // Fail to link
-            }
-
-            mLinkedAttribute[availableIndex] = *attribute;
-        }
-    }
-
-    for (int attributeIndex = 0; attributeIndex < MAX_VERTEX_ATTRIBS; )
-    {
-        int index = mVertexShader->getSemanticIndex(mLinkedAttribute[attributeIndex].name);
-        int rows = std::max(VariableRowCount(mLinkedAttribute[attributeIndex].type), 1);
-
-        for (int r = 0; r < rows; r++)
-        {
-            mSemanticIndex[attributeIndex++] = index++;
-        }
-    }
-
-    return true;
-}
-
-int Program::getAttributeBinding(const std::string &name)
+int AttributeBindings::getAttributeBinding(const std::string &name) const
 {
     for (int location = 0; location < MAX_VERTEX_ATTRIBS; location++)
     {
@@ -1792,537 +158,6 @@
     return -1;
 }
 
-bool Program::linkUniforms(ID3DXConstantTable *constantTable)
-{
-    D3DXCONSTANTTABLE_DESC constantTableDescription;
-    D3DXCONSTANT_DESC constantDescription;
-    UINT descriptionCount = 1;
-
-    constantTable->GetDesc(&constantTableDescription);
-
-    for (unsigned int constantIndex = 0; constantIndex < constantTableDescription.Constants; constantIndex++)
-    {
-        D3DXHANDLE constantHandle = constantTable->GetConstant(0, constantIndex);
-        HRESULT result = constantTable->GetConstantDesc(constantHandle, &constantDescription, &descriptionCount);
-        ASSERT(SUCCEEDED(result));
-
-        if (!defineUniform(constantHandle, constantDescription))
-        {
-            return false;
-        }
-    }
-
-    return true;
-}
-
-// Adds the description of a constant found in the binary shader to the list of uniforms
-// Returns true if succesful (uniform not already defined)
-bool Program::defineUniform(const D3DXHANDLE &constantHandle, const D3DXCONSTANT_DESC &constantDescription, std::string name)
-{
-    if (constantDescription.RegisterSet == D3DXRS_SAMPLER)
-    {
-        for (unsigned int i = 0; i < constantDescription.RegisterCount; i++)
-        {
-            D3DXHANDLE psConstant = mConstantTablePS->GetConstantByName(NULL, constantDescription.Name);
-            D3DXHANDLE vsConstant = mConstantTableVS->GetConstantByName(NULL, constantDescription.Name);
-
-            if (psConstant)
-            {
-                unsigned int samplerIndex = mConstantTablePS->GetSamplerIndex(psConstant) + i;
-
-                if (samplerIndex < MAX_TEXTURE_IMAGE_UNITS)
-                {
-                    mSamplersPS[samplerIndex].active = true;
-                    mSamplersPS[samplerIndex].textureType = (constantDescription.Type == D3DXPT_SAMPLERCUBE) ? TEXTURE_CUBE : TEXTURE_2D;
-                    mSamplersPS[samplerIndex].logicalTextureUnit = 0;
-                    mUsedPixelSamplerRange = std::max(samplerIndex + 1, mUsedPixelSamplerRange);
-                }
-                else
-                {
-                    appendToInfoLog("Pixel shader sampler count exceeds MAX_TEXTURE_IMAGE_UNITS (%d).", MAX_TEXTURE_IMAGE_UNITS);
-                    return false;
-                }
-            }
-            
-            if (vsConstant)
-            {
-                unsigned int samplerIndex = mConstantTableVS->GetSamplerIndex(vsConstant) + i;
-
-                if (samplerIndex < getContext()->getMaximumVertexTextureImageUnits())
-                {
-                    mSamplersVS[samplerIndex].active = true;
-                    mSamplersVS[samplerIndex].textureType = (constantDescription.Type == D3DXPT_SAMPLERCUBE) ? TEXTURE_CUBE : TEXTURE_2D;
-                    mSamplersVS[samplerIndex].logicalTextureUnit = 0;
-                    mUsedVertexSamplerRange = std::max(samplerIndex + 1, mUsedVertexSamplerRange);
-                }
-                else
-                {
-                    appendToInfoLog("Vertex shader sampler count exceeds MAX_VERTEX_TEXTURE_IMAGE_UNITS (%d).", getContext()->getMaximumVertexTextureImageUnits());
-                    return false;
-                }
-            }
-        }
-    }
-
-    switch(constantDescription.Class)
-    {
-      case D3DXPC_STRUCT:
-        {
-            for (unsigned int arrayIndex = 0; arrayIndex < constantDescription.Elements; arrayIndex++)
-            {
-                for (unsigned int field = 0; field < constantDescription.StructMembers; field++)
-                {
-                    D3DXHANDLE fieldHandle = mConstantTablePS->GetConstant(constantHandle, field);
-
-                    D3DXCONSTANT_DESC fieldDescription;
-                    UINT descriptionCount = 1;
-
-                    HRESULT result = mConstantTablePS->GetConstantDesc(fieldHandle, &fieldDescription, &descriptionCount);
-                    ASSERT(SUCCEEDED(result));
-
-                    std::string structIndex = (constantDescription.Elements > 1) ? ("[" + str(arrayIndex) + "]") : "";
-
-                    if (!defineUniform(fieldHandle, fieldDescription, name + constantDescription.Name + structIndex + "."))
-                    {
-                        return false;
-                    }
-                }
-            }
-
-            return true;
-        }
-      case D3DXPC_SCALAR:
-      case D3DXPC_VECTOR:
-      case D3DXPC_MATRIX_COLUMNS:
-      case D3DXPC_OBJECT:
-        return defineUniform(constantDescription, name + constantDescription.Name);
-      default:
-        UNREACHABLE();
-        return false;
-    }
-}
-
-bool Program::defineUniform(const D3DXCONSTANT_DESC &constantDescription, const std::string &_name)
-{
-    Uniform *uniform = createUniform(constantDescription, _name);
-
-    if(!uniform)
-    {
-        return false;
-    }
-
-    // Check if already defined
-    GLint location = getUniformLocation(uniform->name);
-    GLenum type = uniform->type;
-
-    if (location >= 0)
-    {
-        delete uniform;
-
-        if (mUniforms[mUniformIndex[location].index]->type != type)
-        {
-            return false;
-        }
-        else
-        {
-            return true;
-        }
-    }
-
-    initializeConstantHandles(uniform, &uniform->ps, mConstantTablePS);
-    initializeConstantHandles(uniform, &uniform->vs, mConstantTableVS);
-
-    mUniforms.push_back(uniform);
-    unsigned int uniformIndex = mUniforms.size() - 1;
-
-    for (unsigned int i = 0; i < uniform->arraySize; ++i)
-    {
-        mUniformIndex.push_back(UniformLocation(_name, i, uniformIndex));
-    }
-
-    return true;
-}
-
-Uniform *Program::createUniform(const D3DXCONSTANT_DESC &constantDescription, const std::string &_name)
-{
-    if (constantDescription.Rows == 1)   // Vectors and scalars
-    {
-        switch (constantDescription.Type)
-        {
-          case D3DXPT_SAMPLER2D:
-            switch (constantDescription.Columns)
-            {
-              case 1: return new Uniform(GL_SAMPLER_2D, _name, constantDescription.Elements);
-              default: UNREACHABLE();
-            }
-            break;
-          case D3DXPT_SAMPLERCUBE:
-            switch (constantDescription.Columns)
-            {
-              case 1: return new Uniform(GL_SAMPLER_CUBE, _name, constantDescription.Elements);
-              default: UNREACHABLE();
-            }
-            break;
-          case D3DXPT_BOOL:
-            switch (constantDescription.Columns)
-            {
-              case 1: return new Uniform(GL_BOOL, _name, constantDescription.Elements);
-              case 2: return new Uniform(GL_BOOL_VEC2, _name, constantDescription.Elements);
-              case 3: return new Uniform(GL_BOOL_VEC3, _name, constantDescription.Elements);
-              case 4: return new Uniform(GL_BOOL_VEC4, _name, constantDescription.Elements);
-              default: UNREACHABLE();
-            }
-            break;
-          case D3DXPT_INT:
-            switch (constantDescription.Columns)
-            {
-              case 1: return new Uniform(GL_INT, _name, constantDescription.Elements);
-              case 2: return new Uniform(GL_INT_VEC2, _name, constantDescription.Elements);
-              case 3: return new Uniform(GL_INT_VEC3, _name, constantDescription.Elements);
-              case 4: return new Uniform(GL_INT_VEC4, _name, constantDescription.Elements);
-              default: UNREACHABLE();
-            }
-            break;
-          case D3DXPT_FLOAT:
-            switch (constantDescription.Columns)
-            {
-              case 1: return new Uniform(GL_FLOAT, _name, constantDescription.Elements);
-              case 2: return new Uniform(GL_FLOAT_VEC2, _name, constantDescription.Elements);
-              case 3: return new Uniform(GL_FLOAT_VEC3, _name, constantDescription.Elements);
-              case 4: return new Uniform(GL_FLOAT_VEC4, _name, constantDescription.Elements);
-              default: UNREACHABLE();
-            }
-            break;
-          default:
-            UNREACHABLE();
-        }
-    }
-    else if (constantDescription.Rows == constantDescription.Columns)  // Square matrices
-    {
-        switch (constantDescription.Type)
-        {
-          case D3DXPT_FLOAT:
-            switch (constantDescription.Rows)
-            {
-              case 2: return new Uniform(GL_FLOAT_MAT2, _name, constantDescription.Elements);
-              case 3: return new Uniform(GL_FLOAT_MAT3, _name, constantDescription.Elements);
-              case 4: return new Uniform(GL_FLOAT_MAT4, _name, constantDescription.Elements);
-              default: UNREACHABLE();
-            }
-            break;
-          default: UNREACHABLE();
-        }
-    }
-    else UNREACHABLE();
-
-    return 0;
-}
-
-// This method needs to match OutputHLSL::decorate
-std::string Program::decorateAttribute(const std::string &name)
-{
-    if (name.compare(0, 3, "gl_") != 0 && name.compare(0, 3, "dx_") != 0)
-    {
-        return "_" + name;
-    }
-    
-    return name;
-}
-
-std::string Program::undecorateUniform(const std::string &_name)
-{
-    std::string name = _name;
-    
-    // Remove any structure field decoration
-    size_t pos = 0;
-    while ((pos = name.find("._", pos)) != std::string::npos)
-    {
-        name.replace(pos, 2, ".");
-    }
-
-    // Remove the leading decoration
-    if (name[0] == '_')
-    {
-        return name.substr(1);
-    }
-    else if (name.compare(0, 3, "ar_") == 0)
-    {
-        return name.substr(3);
-    }
-    
-    return name;
-}
-
-void Program::applyUniformnbv(Uniform *targetUniform, GLsizei count, int width, const GLboolean *v)
-{
-    float vector[D3D9_MAX_FLOAT_CONSTANTS * 4];
-    BOOL boolVector[D3D9_MAX_BOOL_CONSTANTS];
-
-    if (targetUniform->ps.registerCount && targetUniform->ps.registerSet == D3DXRS_FLOAT4 ||
-        targetUniform->vs.registerCount && targetUniform->vs.registerSet == D3DXRS_FLOAT4)
-    {
-        ASSERT(count <= D3D9_MAX_FLOAT_CONSTANTS);
-        for (int i = 0; i < count; i++)
-        {
-            for (int j = 0; j < 4; j++)
-            {
-                if (j < width)
-                {
-                    vector[i * 4 + j] = (v[i * width + j] == GL_FALSE) ? 0.0f : 1.0f;
-                }
-                else
-                {
-                    vector[i * 4 + j] = 0.0f;
-                }
-            }
-        }
-    }
-
-    if (targetUniform->ps.registerCount && targetUniform->ps.registerSet == D3DXRS_BOOL ||
-        targetUniform->vs.registerCount && targetUniform->vs.registerSet == D3DXRS_BOOL)
-    {
-        int psCount = targetUniform->ps.registerSet == D3DXRS_BOOL ? targetUniform->ps.registerCount : 0;
-        int vsCount = targetUniform->vs.registerSet == D3DXRS_BOOL ? targetUniform->vs.registerCount : 0;
-        int copyCount = std::min(count * width, std::max(psCount, vsCount));
-        ASSERT(copyCount <= D3D9_MAX_BOOL_CONSTANTS);
-        for (int i = 0; i < copyCount; i++)
-        {
-            boolVector[i] = v[i] != GL_FALSE;
-        }
-    }
-
-    if (targetUniform->ps.registerCount)
-    {
-        if (targetUniform->ps.registerSet == D3DXRS_FLOAT4)
-        {
-            mDevice->SetPixelShaderConstantF(targetUniform->ps.registerIndex, vector, targetUniform->ps.registerCount);
-        }
-        else if (targetUniform->ps.registerSet == D3DXRS_BOOL)
-        {
-            mDevice->SetPixelShaderConstantB(targetUniform->ps.registerIndex, boolVector, targetUniform->ps.registerCount);
-        }
-        else UNREACHABLE();
-    }
-
-    if (targetUniform->vs.registerCount)
-    {
-        if (targetUniform->vs.registerSet == D3DXRS_FLOAT4)
-        {
-            mDevice->SetVertexShaderConstantF(targetUniform->vs.registerIndex, vector, targetUniform->vs.registerCount);
-        }
-        else if (targetUniform->vs.registerSet == D3DXRS_BOOL)
-        {
-            mDevice->SetVertexShaderConstantB(targetUniform->vs.registerIndex, boolVector, targetUniform->vs.registerCount);
-        }
-        else UNREACHABLE();
-    }
-}
-
-bool Program::applyUniformnfv(Uniform *targetUniform, const GLfloat *v)
-{
-    if (targetUniform->ps.registerCount)
-    {
-        mDevice->SetPixelShaderConstantF(targetUniform->ps.registerIndex, v, targetUniform->ps.registerCount);
-    }
-
-    if (targetUniform->vs.registerCount)
-    {
-        mDevice->SetVertexShaderConstantF(targetUniform->vs.registerIndex, v, targetUniform->vs.registerCount);
-    }
-
-    return true;
-}
-
-bool Program::applyUniform1iv(Uniform *targetUniform, GLsizei count, const GLint *v)
-{
-    ASSERT(count <= D3D9_MAX_FLOAT_CONSTANTS);
-    D3DXVECTOR4 vector[D3D9_MAX_FLOAT_CONSTANTS];
-
-    for (int i = 0; i < count; i++)
-    {
-        vector[i] = D3DXVECTOR4((float)v[i], 0, 0, 0);
-    }
-
-    if (targetUniform->ps.registerCount)
-    {
-        if (targetUniform->ps.registerSet == D3DXRS_SAMPLER)
-        {
-            unsigned int firstIndex = targetUniform->ps.registerIndex;
-
-            for (int i = 0; i < count; i++)
-            {
-                unsigned int samplerIndex = firstIndex + i;
-
-                if (samplerIndex < MAX_TEXTURE_IMAGE_UNITS)
-                {
-                    ASSERT(mSamplersPS[samplerIndex].active);
-                    mSamplersPS[samplerIndex].logicalTextureUnit = v[i];
-                }
-            }
-        }
-        else
-        {
-            ASSERT(targetUniform->ps.registerSet == D3DXRS_FLOAT4);
-            mDevice->SetPixelShaderConstantF(targetUniform->ps.registerIndex, (const float*)vector, targetUniform->ps.registerCount);
-        }
-    }
-
-    if (targetUniform->vs.registerCount)
-    {
-        if (targetUniform->vs.registerSet == D3DXRS_SAMPLER)
-        {
-            unsigned int firstIndex = targetUniform->vs.registerIndex;
-
-            for (int i = 0; i < count; i++)
-            {
-                unsigned int samplerIndex = firstIndex + i;
-
-                if (samplerIndex < MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF)
-                {
-                    ASSERT(mSamplersVS[samplerIndex].active);
-                    mSamplersVS[samplerIndex].logicalTextureUnit = v[i];
-                }
-            }
-        }
-        else
-        {
-            ASSERT(targetUniform->vs.registerSet == D3DXRS_FLOAT4);
-            mDevice->SetVertexShaderConstantF(targetUniform->vs.registerIndex, (const float *)vector, targetUniform->vs.registerCount);
-        }
-    }
-
-    return true;
-}
-
-bool Program::applyUniform2iv(Uniform *targetUniform, GLsizei count, const GLint *v)
-{
-    ASSERT(count <= D3D9_MAX_FLOAT_CONSTANTS);
-    D3DXVECTOR4 vector[D3D9_MAX_FLOAT_CONSTANTS];
-
-    for (int i = 0; i < count; i++)
-    {
-        vector[i] = D3DXVECTOR4((float)v[0], (float)v[1], 0, 0);
-
-        v += 2;
-    }
-
-    applyUniformniv(targetUniform, count, vector);
-
-    return true;
-}
-
-bool Program::applyUniform3iv(Uniform *targetUniform, GLsizei count, const GLint *v)
-{
-    ASSERT(count <= D3D9_MAX_FLOAT_CONSTANTS);
-    D3DXVECTOR4 vector[D3D9_MAX_FLOAT_CONSTANTS];
-
-    for (int i = 0; i < count; i++)
-    {
-        vector[i] = D3DXVECTOR4((float)v[0], (float)v[1], (float)v[2], 0);
-
-        v += 3;
-    }
-
-    applyUniformniv(targetUniform, count, vector);
-
-    return true;
-}
-
-bool Program::applyUniform4iv(Uniform *targetUniform, GLsizei count, const GLint *v)
-{
-    ASSERT(count <= D3D9_MAX_FLOAT_CONSTANTS);
-    D3DXVECTOR4 vector[D3D9_MAX_FLOAT_CONSTANTS];
-
-    for (int i = 0; i < count; i++)
-    {
-        vector[i] = D3DXVECTOR4((float)v[0], (float)v[1], (float)v[2], (float)v[3]);
-
-        v += 4;
-    }
-
-    applyUniformniv(targetUniform, count, vector);
-
-    return true;
-}
-
-void Program::applyUniformniv(Uniform *targetUniform, GLsizei count, const D3DXVECTOR4 *vector)
-{
-    if (targetUniform->ps.registerCount)
-    {
-        ASSERT(targetUniform->ps.registerSet == D3DXRS_FLOAT4);
-        mDevice->SetPixelShaderConstantF(targetUniform->ps.registerIndex, (const float *)vector, targetUniform->ps.registerCount);
-    }
-
-    if (targetUniform->vs.registerCount)
-    {
-        ASSERT(targetUniform->vs.registerSet == D3DXRS_FLOAT4);
-        mDevice->SetVertexShaderConstantF(targetUniform->vs.registerIndex, (const float *)vector, targetUniform->vs.registerCount);
-    }
-}
-
-// append a santized message to the program info log.
-// The D3D compiler includes a fake file path in some of the warning or error 
-// messages, so lets remove all occurrences of this fake file path from the log.
-void Program::appendToInfoLogSanitized(const char *message)
-{
-    std::string msg(message);
-
-    size_t found;
-    do
-    {
-        found = msg.find(fakepath);
-        if (found != std::string::npos)
-        {
-            msg.erase(found, strlen(fakepath));
-        }
-    }
-    while (found != std::string::npos);
-
-    appendToInfoLog("%s\n", msg.c_str());
-}
-
-void Program::appendToInfoLog(const char *format, ...)
-{
-    if (!format)
-    {
-        return;
-    }
-
-    char info[1024];
-
-    va_list vararg;
-    va_start(vararg, format);
-    vsnprintf(info, sizeof(info), format, vararg);
-    va_end(vararg);
-
-    size_t infoLength = strlen(info);
-
-    if (!mInfoLog)
-    {
-        mInfoLog = new char[infoLength + 1];
-        strcpy(mInfoLog, info);
-    }
-    else
-    {
-        size_t logLength = strlen(mInfoLog);
-        char *newLog = new char[logLength + infoLength + 1];
-        strcpy(newLog, mInfoLog);
-        strcpy(newLog + logLength, info);
-
-        delete[] mInfoLog;
-        mInfoLog = newLog;
-    }
-}
-
-void Program::resetInfoLog()
-{
-    if (mInfoLog)
-    {
-        delete [] mInfoLog;
-        mInfoLog = NULL;
-    }
-}
-
 // Returns the program object to an unlinked state, before re-linking, or at destruction
 void Program::unlink(bool destroy)
 {
@@ -2341,81 +176,22 @@
         }
     }
 
-    if (mPixelExecutable)
+    if (mProgramBinary)
     {
-        mPixelExecutable->Release();
-        mPixelExecutable = NULL;
+        delete mProgramBinary;
+        mProgramBinary = NULL;
     }
-
-    if (mVertexExecutable)
-    {
-        mVertexExecutable->Release();
-        mVertexExecutable = NULL;
-    }
-
-    if (mConstantTablePS)
-    {
-        mConstantTablePS->Release();
-        mConstantTablePS = NULL;
-    }
-
-    if (mConstantTableVS)
-    {
-        mConstantTableVS->Release();
-        mConstantTableVS = NULL;
-    }
-
-    for (int index = 0; index < MAX_VERTEX_ATTRIBS; index++)
-    {
-        mLinkedAttribute[index].name.clear();
-        mSemanticIndex[index] = -1;
-    }
-
-    for (int index = 0; index < MAX_TEXTURE_IMAGE_UNITS; index++)
-    {
-        mSamplersPS[index].active = false;
-    }
-
-    for (int index = 0; index < MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF; index++)
-    {
-        mSamplersVS[index].active = false;
-    }
-
-    mUsedVertexSamplerRange = 0;
-    mUsedPixelSamplerRange = 0;
-
-    while (!mUniforms.empty())
-    {
-        delete mUniforms.back();
-        mUniforms.pop_back();
-    }
-
-    mDxDepthRangeLocation = -1;
-    mDxDepthLocation = -1;
-    mDxCoordLocation = -1;
-    mDxHalfPixelSizeLocation = -1;
-    mDxFrontCCWLocation = -1;
-    mDxPointsOrLinesLocation = -1;
-
-    mUniformIndex.clear();
-
-    mPixelHLSL.clear();
-    mVertexHLSL.clear();
-
-    delete[] mInfoLog;
-    mInfoLog = NULL;
-
-    mLinked = false;
 }
 
-bool Program::isLinked()
+ProgramBinary* Program::getProgramBinary()
 {
-    return mLinked;
+    return mProgramBinary;
 }
 
-bool Program::isValidated() const 
+void Program::setProgramBinary(ProgramBinary *programBinary)
 {
-    return mValidated;
+    unlink(false);
+    mProgramBinary = programBinary;
 }
 
 void Program::release()
@@ -2450,34 +226,33 @@
 
 int Program::getInfoLogLength() const
 {
-    if (!mInfoLog)
+    if (mProgramBinary)
     {
-        return 0;
+        return mProgramBinary->getInfoLogLength();
     }
     else
     {
-       return strlen(mInfoLog) + 1;
+       return 0;
     }
 }
 
 void Program::getInfoLog(GLsizei bufSize, GLsizei *length, char *infoLog)
 {
-    int index = 0;
-
-    if (bufSize > 0)
+    if (mProgramBinary)
     {
-        if (mInfoLog)
+        return mProgramBinary->getInfoLog(bufSize, length, infoLog);
+    }
+    else
+    {
+        if (bufSize > 0)
         {
-            index = std::min(bufSize - 1, (int)strlen(mInfoLog));
-            memcpy(infoLog, mInfoLog, index);
+            infoLog[0] = '\0';
         }
 
-        infoLog[index] = '\0';
-    }
-
-    if (length)
-    {
-        *length = index;
+        if (length)
+        {
+            *length = 0;
+        }
     }
 }
 
@@ -2513,152 +288,96 @@
 
 void Program::getActiveAttribute(GLuint index, GLsizei bufsize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
 {
-    // Skip over inactive attributes
-    unsigned int activeAttribute = 0;
-    unsigned int attribute;
-    for (attribute = 0; attribute < MAX_VERTEX_ATTRIBS; attribute++)
+    if (mProgramBinary)
     {
-        if (mLinkedAttribute[attribute].name.empty())
+        mProgramBinary->getActiveAttribute(index, bufsize, length, size, type, name);
+    }
+    else
+    {
+        if (bufsize > 0)
         {
-            continue;
+            name[0] = '\0';
+        }
+        
+        if (length)
+        {
+            *length = 0;
         }
 
-        if (activeAttribute == index)
-        {
-            break;
-        }
-
-        activeAttribute++;
+        *type = GL_NONE;
+        *size = 1;
     }
-
-    if (bufsize > 0)
-    {
-        const char *string = mLinkedAttribute[attribute].name.c_str();
-
-        strncpy(name, string, bufsize);
-        name[bufsize - 1] = '\0';
-
-        if (length)
-        {
-            *length = strlen(name);
-        }
-    }
-
-    *size = 1;   // Always a single 'type' instance
-
-    *type = mLinkedAttribute[attribute].type;
 }
 
 GLint Program::getActiveAttributeCount()
 {
-    int count = 0;
-
-    for (int attributeIndex = 0; attributeIndex < MAX_VERTEX_ATTRIBS; attributeIndex++)
+    if (mProgramBinary)
     {
-        if (!mLinkedAttribute[attributeIndex].name.empty())
-        {
-            count++;
-        }
+        return mProgramBinary->getActiveAttributeCount();
     }
-
-    return count;
+    else
+    {
+        return 0;
+    }
 }
 
 GLint Program::getActiveAttributeMaxLength()
 {
-    int maxLength = 0;
-
-    for (int attributeIndex = 0; attributeIndex < MAX_VERTEX_ATTRIBS; attributeIndex++)
+    if (mProgramBinary)
     {
-        if (!mLinkedAttribute[attributeIndex].name.empty())
-        {
-            maxLength = std::max((int)(mLinkedAttribute[attributeIndex].name.length() + 1), maxLength);
-        }
+        return mProgramBinary->getActiveAttributeMaxLength();
     }
-
-    return maxLength;
+    else
+    {
+        return 0;
+    }
 }
 
 void Program::getActiveUniform(GLuint index, GLsizei bufsize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
 {
-    // Skip over internal uniforms
-    unsigned int activeUniform = 0;
-    unsigned int uniform;
-    for (uniform = 0; uniform < mUniforms.size(); uniform++)
+    if (mProgramBinary)
     {
-        if (mUniforms[uniform]->name.compare(0, 3, "dx_") == 0)
+        return mProgramBinary->getActiveUniform(index, bufsize, length, size, type, name);
+    }
+    else
+    {
+        if (bufsize > 0)
         {
-            continue;
+            name[0] = '\0';
         }
 
-        if (activeUniform == index)
-        {
-            break;
-        }
-
-        activeUniform++;
-    }
-
-    ASSERT(uniform < mUniforms.size());   // index must be smaller than getActiveUniformCount()
-
-    if (bufsize > 0)
-    {
-        std::string string = mUniforms[uniform]->name;
-
-        if (mUniforms[uniform]->isArray())
-        {
-            string += "[0]";
-        }
-
-        strncpy(name, string.c_str(), bufsize);
-        name[bufsize - 1] = '\0';
-
         if (length)
         {
-            *length = strlen(name);
+            *length = 0;
         }
+
+        *size = 0;
+        *type = GL_NONE;
     }
-
-    *size = mUniforms[uniform]->arraySize;
-
-    *type = mUniforms[uniform]->type;
 }
 
 GLint Program::getActiveUniformCount()
 {
-    int count = 0;
-
-    unsigned int numUniforms = mUniforms.size();
-    for (unsigned int uniformIndex = 0; uniformIndex < numUniforms; uniformIndex++)
+    if (mProgramBinary)
     {
-        if (mUniforms[uniformIndex]->name.compare(0, 3, "dx_") != 0)
-        {
-            count++;
-        }
+        return mProgramBinary->getActiveUniformCount();
     }
-
-    return count;
+    else
+    {
+        return 0;
+    }
 }
 
 GLint Program::getActiveUniformMaxLength()
 {
-    int maxLength = 0;
-
-    unsigned int numUniforms = mUniforms.size();
-    for (unsigned int uniformIndex = 0; uniformIndex < numUniforms; uniformIndex++)
+    if (mProgramBinary)
     {
-        if (!mUniforms[uniformIndex]->name.empty() && mUniforms[uniformIndex]->name.compare(0, 3, "dx_") != 0)
-        {
-            int length = (int)(mUniforms[uniformIndex]->name.length() + 1);
-            if (mUniforms[uniformIndex]->isArray())
-            {
-                length += 3;  // Counting in "[0]".
-            }
-            maxLength = std::max(length, maxLength);
-        }
+        return mProgramBinary->getActiveUniformMaxLength();
     }
-
-    return maxLength;
+    else
+    {
+        return 0;
+    }
 }
 
 void Program::flagForDeletion()
@@ -2671,163 +390,16 @@
     return mDeleteStatus;
 }
 
-void Program::validate()
+bool Program::isValidated() const
 {
-    resetInfoLog();
-
-    if (!isLinked()) 
+    if (mProgramBinary)
     {
-        appendToInfoLog("Program has not been successfully linked.");
-        mValidated = false;
+        return mProgramBinary->isValidated();
     }
     else
     {
-        applyUniforms();
-        if (!validateSamplers(true))
-        {
-            mValidated = false;
-        }
-        else
-        {
-            mValidated = true;
-        }
+        return false;
     }
 }
 
-bool Program::validateSamplers(bool logErrors)
-{
-    // if any two active samplers in a program are of different types, but refer to the same
-    // texture image unit, and this is the current program, then ValidateProgram will fail, and
-    // DrawArrays and DrawElements will issue the INVALID_OPERATION error.
-
-    const unsigned int maxCombinedTextureImageUnits = getContext()->getMaximumCombinedTextureImageUnits();
-    TextureType textureUnitType[MAX_COMBINED_TEXTURE_IMAGE_UNITS_VTF];
-
-    for (unsigned int i = 0; i < MAX_COMBINED_TEXTURE_IMAGE_UNITS_VTF; ++i)
-    {
-        textureUnitType[i] = TEXTURE_UNKNOWN;
-    }
-
-    for (unsigned int i = 0; i < mUsedPixelSamplerRange; ++i)
-    {
-        if (mSamplersPS[i].active)
-        {
-            unsigned int unit = mSamplersPS[i].logicalTextureUnit;
-            
-            if (unit >= maxCombinedTextureImageUnits)
-            {
-                if (logErrors)
-                {
-                    appendToInfoLog("Sampler uniform (%d) exceeds MAX_COMBINED_TEXTURE_IMAGE_UNITS (%d)", unit, maxCombinedTextureImageUnits);
-                }
-
-                return false;
-            }
-
-            if (textureUnitType[unit] != TEXTURE_UNKNOWN)
-            {
-                if (mSamplersPS[i].textureType != textureUnitType[unit])
-                {
-                    if (logErrors)
-                    {
-                        appendToInfoLog("Samplers of conflicting types refer to the same texture image unit (%d).", unit);
-                    }
-
-                    return false;
-                }
-            }
-            else
-            {
-                textureUnitType[unit] = mSamplersPS[i].textureType;
-            }
-        }
-    }
-
-    for (unsigned int i = 0; i < mUsedVertexSamplerRange; ++i)
-    {
-        if (mSamplersVS[i].active)
-        {
-            unsigned int unit = mSamplersVS[i].logicalTextureUnit;
-            
-            if (unit >= maxCombinedTextureImageUnits)
-            {
-                if (logErrors)
-                {
-                    appendToInfoLog("Sampler uniform (%d) exceeds MAX_COMBINED_TEXTURE_IMAGE_UNITS (%d)", unit, maxCombinedTextureImageUnits);
-                }
-
-                return false;
-            }
-
-            if (textureUnitType[unit] != TEXTURE_UNKNOWN)
-            {
-                if (mSamplersVS[i].textureType != textureUnitType[unit])
-                {
-                    if (logErrors)
-                    {
-                        appendToInfoLog("Samplers of conflicting types refer to the same texture image unit (%d).", unit);
-                    }
-
-                    return false;
-                }
-            }
-            else
-            {
-                textureUnitType[unit] = mSamplersVS[i].textureType;
-            }
-        }
-    }
-
-    return true;
 }
-
-void Program::initializeConstantHandles(Uniform *targetUniform, Uniform::RegisterInfo *ri, ID3DXConstantTable *constantTable)
-{
-    D3DXHANDLE handle = constantTable->GetConstantByName(0, targetUniform->_name.c_str());
-    if (handle)
-    {
-        UINT descriptionCount = 1;
-        D3DXCONSTANT_DESC constantDescription;
-        HRESULT result = constantTable->GetConstantDesc(handle, &constantDescription, &descriptionCount);
-        ASSERT(SUCCEEDED(result));
-        ri->registerIndex = constantDescription.RegisterIndex;
-        ri->registerCount = constantDescription.RegisterCount;
-        ri->registerSet = constantDescription.RegisterSet;
-    }
-    else
-    {
-        ri->registerCount = 0;
-    }
-}
-
-GLint Program::getDxDepthRangeLocation() const
-{
-    return mDxDepthRangeLocation;
-}
-
-GLint Program::getDxDepthLocation() const
-{
-    return mDxDepthLocation;
-}
-
-GLint Program::getDxCoordLocation() const
-{
-    return mDxCoordLocation;
-}
-
-GLint Program::getDxHalfPixelSizeLocation() const
-{
-    return mDxHalfPixelSizeLocation;
-}
-
-GLint Program::getDxFrontCCWLocation() const
-{
-    return mDxFrontCCWLocation;
-}
-
-GLint Program::getDxPointsOrLinesLocation() const
-{
-    return mDxPointsOrLinesLocation;
-}
-
-}
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/Program.h
--- a/gfx/angle/src/libGLESv2/Program.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/Program.h	Sat Jun 09 12:08:28 2012 +0900
@@ -1,5 +1,5 @@
 //
-// Copyright (c) 2002-2011 The ANGLE Project Authors. All rights reserved.
+// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 //
@@ -11,9 +11,7 @@
 #define LIBGLESV2_PROGRAM_H_
 
 #include <d3dx9.h>
-#include <d3dcompiler.h>
 #include <string>
-#include <vector>
 #include <set>
 
 #include "libGLESv2/Shader.h"
@@ -25,42 +23,17 @@
 class FragmentShader;
 class VertexShader;
 
-// Helper struct representing a single shader uniform
-struct Uniform
+class AttributeBindings
 {
-    Uniform(GLenum type, const std::string &_name, unsigned int arraySize);
+  public:
+    AttributeBindings();
+    ~AttributeBindings();
 
-    ~Uniform();
+    void bindAttributeLocation(GLuint index, const char *name);
+    int getAttributeBinding(const std::string &name) const;
 
-    bool isArray();
-
-    const GLenum type;
-    const std::string _name;   // Decorated name
-    const std::string name;    // Undecorated name
-    const unsigned int arraySize;
-
-    unsigned char *data;
-    bool dirty;
-
-    struct RegisterInfo
-    {
-        int registerSet;
-        int registerIndex;
-        int registerCount;
-    };
-
-    RegisterInfo ps;
-    RegisterInfo vs;
-};
-
-// Struct used for correlating uniforms/elements of uniform arrays to handles
-struct UniformLocation
-{
-    UniformLocation(const std::string &_name, unsigned int element, unsigned int index);
-
-    std::string name;
-    unsigned int element;
-    unsigned int index;
+  private:
+    std::set<std::string> mAttributeBinding[MAX_VERTEX_ATTRIBS];
 };
 
 class Program
@@ -74,45 +47,12 @@
     bool detachShader(Shader *shader);
     int getAttachedShadersCount() const;
 
-    IDirect3DPixelShader9 *getPixelShader();
-    IDirect3DVertexShader9 *getVertexShader();
-
     void bindAttributeLocation(GLuint index, const char *name);
-    GLuint getAttributeLocation(const char *name);
-    int getSemanticIndex(int attributeIndex);
-
-    GLint getSamplerMapping(SamplerType type, unsigned int samplerIndex);
-    TextureType getSamplerTextureType(SamplerType type, unsigned int samplerIndex);
-    GLint getUsedSamplerRange(SamplerType type);
-
-    GLint getUniformLocation(std::string name);
-    bool setUniform1fv(GLint location, GLsizei count, const GLfloat *v);
-    bool setUniform2fv(GLint location, GLsizei count, const GLfloat *v);
-    bool setUniform3fv(GLint location, GLsizei count, const GLfloat *v);
-    bool setUniform4fv(GLint location, GLsizei count, const GLfloat *v);
-    bool setUniformMatrix2fv(GLint location, GLsizei count, const GLfloat *value);
-    bool setUniformMatrix3fv(GLint location, GLsizei count, const GLfloat *value);
-    bool setUniformMatrix4fv(GLint location, GLsizei count, const GLfloat *value);
-    bool setUniform1iv(GLint location, GLsizei count, const GLint *v);
-    bool setUniform2iv(GLint location, GLsizei count, const GLint *v);
-    bool setUniform3iv(GLint location, GLsizei count, const GLint *v);
-    bool setUniform4iv(GLint location, GLsizei count, const GLint *v);
-
-    bool getUniformfv(GLint location, GLsizei *bufSize, GLfloat *params);
-    bool getUniformiv(GLint location, GLsizei *bufSize, GLint *params);
-
-    GLint getDxDepthRangeLocation() const;
-    GLint getDxDepthLocation() const;
-    GLint getDxCoordLocation() const;
-    GLint getDxHalfPixelSizeLocation() const;
-    GLint getDxFrontCCWLocation() const;
-    GLint getDxPointsOrLinesLocation() const;
-
-    void dirtyAllUniforms();
-    void applyUniforms();
 
     void link();
-    bool isLinked();
+    void setProgramBinary(ProgramBinary *programBinary);
+    ProgramBinary *getProgramBinary();
+
     int getInfoLogLength() const;
     void getInfoLog(GLsizei bufSize, GLsizei *length, char *infoLog);
     void getAttachedShaders(GLsizei maxCount, GLsizei *count, GLuint *shaders);
@@ -131,91 +71,24 @@
     void flagForDeletion();
     bool isFlaggedForDeletion() const;
 
-    void validate();
-    bool validateSamplers(bool logErrors);
     bool isValidated() const;
 
     unsigned int getSerial() const;
 
-    static std::string decorateAttribute(const std::string &name);    // Prepend an underscore
-    static std::string undecorateUniform(const std::string &_name);   // Remove leading underscore
-
   private:
     DISALLOW_COPY_AND_ASSIGN(Program);
 
-    ID3D10Blob *compileToBinary(const char *hlsl, const char *profile, ID3DXConstantTable **constantTable);
     void unlink(bool destroy = false);
 
-    int packVaryings(const Varying *packing[][4]);
-    bool linkVaryings();
-
-    bool linkAttributes();
-    int getAttributeBinding(const std::string &name);
-
-    bool linkUniforms(ID3DXConstantTable *constantTable);
-    bool defineUniform(const D3DXHANDLE &constantHandle, const D3DXCONSTANT_DESC &constantDescription, std::string name = "");
-    bool defineUniform(const D3DXCONSTANT_DESC &constantDescription, const std::string &name);
-    Uniform *createUniform(const D3DXCONSTANT_DESC &constantDescription, const std::string &name);
-    bool applyUniformnfv(Uniform *targetUniform, const GLfloat *v);
-    bool applyUniform1iv(Uniform *targetUniform, GLsizei count, const GLint *v);
-    bool applyUniform2iv(Uniform *targetUniform, GLsizei count, const GLint *v);
-    bool applyUniform3iv(Uniform *targetUniform, GLsizei count, const GLint *v);
-    bool applyUniform4iv(Uniform *targetUniform, GLsizei count, const GLint *v);
-    void applyUniformniv(Uniform *targetUniform, GLsizei count, const D3DXVECTOR4 *vector);
-    void applyUniformnbv(Uniform *targetUniform, GLsizei count, int width, const GLboolean *v);
-
-    void initializeConstantHandles(Uniform *targetUniform, Uniform::RegisterInfo *rs, ID3DXConstantTable *constantTable);
-
-    void appendToInfoLogSanitized(const char *message);
-    void appendToInfoLog(const char *info, ...);
-    void resetInfoLog();
-
     static unsigned int issueSerial();
 
-    IDirect3DDevice9 *mDevice;
     FragmentShader *mFragmentShader;
     VertexShader *mVertexShader;
 
-    std::string mPixelHLSL;
-    std::string mVertexHLSL;
+    AttributeBindings mAttributeBindings;
 
-    IDirect3DPixelShader9 *mPixelExecutable;
-    IDirect3DVertexShader9 *mVertexExecutable;
-    ID3DXConstantTable *mConstantTablePS;
-    ID3DXConstantTable *mConstantTableVS;
-
-    std::set<std::string> mAttributeBinding[MAX_VERTEX_ATTRIBS];
-    Attribute mLinkedAttribute[MAX_VERTEX_ATTRIBS];
-    int mSemanticIndex[MAX_VERTEX_ATTRIBS];
-
-    struct Sampler
-    {
-        bool active;
-        GLint logicalTextureUnit;
-        TextureType textureType;
-    };
-
-    Sampler mSamplersPS[MAX_TEXTURE_IMAGE_UNITS];
-    Sampler mSamplersVS[MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF];
-    GLuint mUsedVertexSamplerRange;
-    GLuint mUsedPixelSamplerRange;
-
-    typedef std::vector<Uniform*> UniformArray;
-    UniformArray mUniforms;
-    typedef std::vector<UniformLocation> UniformIndex;
-    UniformIndex mUniformIndex;
-
-    GLint mDxDepthRangeLocation;
-    GLint mDxDepthLocation;
-    GLint mDxCoordLocation;
-    GLint mDxHalfPixelSizeLocation;
-    GLint mDxFrontCCWLocation;
-    GLint mDxPointsOrLinesLocation;
-
-    bool mLinked;
+    ProgramBinary* mProgramBinary;
     bool mDeleteStatus;   // Flag to indicate that the program can be deleted when no longer in use
-    char *mInfoLog;
-    bool mValidated;
 
     unsigned int mRefCount;
 
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/ProgramBinary.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/libGLESv2/ProgramBinary.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,2583 @@
+//
+// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+// Program.cpp: Implements the gl::Program class. Implements GL program objects
+// and related functionality. [OpenGL ES 2.0.24] section 2.10.3 page 28.
+
+#include "libGLESv2/Program.h"
+#include "libGLESv2/ProgramBinary.h"
+
+#include "common/debug.h"
+
+#include "libGLESv2/main.h"
+#include "libGLESv2/Shader.h"
+#include "libGLESv2/utilities.h"
+
+#include <string>
+
+#if !defined(ANGLE_COMPILE_OPTIMIZATION_LEVEL)
+#define ANGLE_COMPILE_OPTIMIZATION_LEVEL D3DCOMPILE_OPTIMIZATION_LEVEL3
+#endif
+
+namespace gl
+{
+const char *fakepath = "C:\\fakepath";
+
+std::string str(int i)
+{
+    char buffer[20];
+    snprintf(buffer, sizeof(buffer), "%d", i);
+    return buffer;
+}
+
+Uniform::Uniform(GLenum type, const std::string &_name, unsigned int arraySize)
+    : type(type), _name(_name), name(ProgramBinary::undecorateUniform(_name)), arraySize(arraySize)
+{
+    int bytes = UniformInternalSize(type) * arraySize;
+    data = new unsigned char[bytes];
+    memset(data, 0, bytes);
+    dirty = true;
+}
+
+Uniform::~Uniform()
+{
+    delete[] data;
+}
+
+bool Uniform::isArray()
+{
+    return _name.compare(0, 3, "ar_") == 0;
+}
+
+UniformLocation::UniformLocation(const std::string &_name, unsigned int element, unsigned int index) 
+    : name(ProgramBinary::undecorateUniform(_name)), element(element), index(index)
+{
+}
+
+ProgramBinary::ProgramBinary()
+{
+    mDevice = getDevice();
+
+    mPixelExecutable = NULL;
+    mVertexExecutable = NULL;
+    mConstantTablePS = NULL;
+    mConstantTableVS = NULL;
+
+    mInfoLog = NULL;
+    mValidated = false;
+
+    for (int index = 0; index < MAX_VERTEX_ATTRIBS; index++)
+    {
+        mSemanticIndex[index] = -1;
+    }
+
+    for (int index = 0; index < MAX_TEXTURE_IMAGE_UNITS; index++)
+    {
+        mSamplersPS[index].active = false;
+    }
+
+    for (int index = 0; index < MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF; index++)
+    {
+        mSamplersVS[index].active = false;
+    }
+
+    mUsedVertexSamplerRange = 0;
+    mUsedPixelSamplerRange = 0;
+
+    mDxDepthRangeLocation = -1;
+    mDxDepthLocation = -1;
+    mDxCoordLocation = -1;
+    mDxHalfPixelSizeLocation = -1;
+    mDxFrontCCWLocation = -1;
+    mDxPointsOrLinesLocation = -1;
+}
+
+ProgramBinary::~ProgramBinary()
+{
+    if (mPixelExecutable)
+    {
+        mPixelExecutable->Release();
+    }
+
+    if (mVertexExecutable)
+    {
+        mVertexExecutable->Release();
+    }
+
+    if (mConstantTablePS)
+    {
+        mConstantTablePS->Release();
+    }
+
+    if (mConstantTableVS)
+    {
+        mConstantTableVS->Release();
+    }
+
+    while (!mUniforms.empty())
+    {
+        delete mUniforms.back();
+        mUniforms.pop_back();
+    }
+
+    delete[] mInfoLog;
+}
+
+IDirect3DPixelShader9 *ProgramBinary::getPixelShader()
+{
+    return mPixelExecutable;
+}
+
+IDirect3DVertexShader9 *ProgramBinary::getVertexShader()
+{
+    return mVertexExecutable;
+}
+
+GLuint ProgramBinary::getAttributeLocation(const char *name)
+{
+    if (name)
+    {
+        for (int index = 0; index < MAX_VERTEX_ATTRIBS; index++)
+        {
+            if (mLinkedAttribute[index].name == std::string(name))
+            {
+                return index;
+            }
+        }
+    }
+
+    return -1;
+}
+
+int ProgramBinary::getSemanticIndex(int attributeIndex)
+{
+    ASSERT(attributeIndex >= 0 && attributeIndex < MAX_VERTEX_ATTRIBS);
+    
+    return mSemanticIndex[attributeIndex];
+}
+
+// Returns one more than the highest sampler index used.
+GLint ProgramBinary::getUsedSamplerRange(SamplerType type)
+{
+    switch (type)
+    {
+      case SAMPLER_PIXEL:
+        return mUsedPixelSamplerRange;
+      case SAMPLER_VERTEX:
+        return mUsedVertexSamplerRange;
+      default:
+        UNREACHABLE();
+        return 0;
+    }
+}
+
+// Returns the index of the texture image unit (0-19) corresponding to a Direct3D 9 sampler
+// index (0-15 for the pixel shader and 0-3 for the vertex shader).
+GLint ProgramBinary::getSamplerMapping(SamplerType type, unsigned int samplerIndex)
+{
+    GLint logicalTextureUnit = -1;
+
+    switch (type)
+    {
+      case SAMPLER_PIXEL:
+        ASSERT(samplerIndex < sizeof(mSamplersPS)/sizeof(mSamplersPS[0]));
+
+        if (mSamplersPS[samplerIndex].active)
+        {
+            logicalTextureUnit = mSamplersPS[samplerIndex].logicalTextureUnit;
+        }
+        break;
+      case SAMPLER_VERTEX:
+        ASSERT(samplerIndex < sizeof(mSamplersVS)/sizeof(mSamplersVS[0]));
+
+        if (mSamplersVS[samplerIndex].active)
+        {
+            logicalTextureUnit = mSamplersVS[samplerIndex].logicalTextureUnit;
+        }
+        break;
+      default: UNREACHABLE();
+    }
+
+    if (logicalTextureUnit >= 0 && logicalTextureUnit < (GLint)getContext()->getMaximumCombinedTextureImageUnits())
+    {
+        return logicalTextureUnit;
+    }
+
+    return -1;
+}
+
+// Returns the texture type for a given Direct3D 9 sampler type and
+// index (0-15 for the pixel shader and 0-3 for the vertex shader).
+TextureType ProgramBinary::getSamplerTextureType(SamplerType type, unsigned int samplerIndex)
+{
+    switch (type)
+    {
+      case SAMPLER_PIXEL:
+        ASSERT(samplerIndex < sizeof(mSamplersPS)/sizeof(mSamplersPS[0]));
+        ASSERT(mSamplersPS[samplerIndex].active);
+        return mSamplersPS[samplerIndex].textureType;
+      case SAMPLER_VERTEX:
+        ASSERT(samplerIndex < sizeof(mSamplersVS)/sizeof(mSamplersVS[0]));
+        ASSERT(mSamplersVS[samplerIndex].active);
+        return mSamplersVS[samplerIndex].textureType;
+      default: UNREACHABLE();
+    }
+
+    return TEXTURE_2D;
+}
+
+GLint ProgramBinary::getUniformLocation(std::string name)
+{
+    unsigned int subscript = 0;
+
+    // Strip any trailing array operator and retrieve the subscript
+    size_t open = name.find_last_of('[');
+    size_t close = name.find_last_of(']');
+    if (open != std::string::npos && close == name.length() - 1)
+    {
+        subscript = atoi(name.substr(open + 1).c_str());
+        name.erase(open);
+    }
+
+    unsigned int numUniforms = mUniformIndex.size();
+    for (unsigned int location = 0; location < numUniforms; location++)
+    {
+        if (mUniformIndex[location].name == name &&
+            mUniformIndex[location].element == subscript)
+        {
+            return location;
+        }
+    }
+
+    return -1;
+}
+
+bool ProgramBinary::setUniform1fv(GLint location, GLsizei count, const GLfloat* v)
+{
+    if (location < 0 || location >= (int)mUniformIndex.size())
+    {
+        return false;
+    }
+
+    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
+    targetUniform->dirty = true;
+
+    if (targetUniform->type == GL_FLOAT)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+
+        GLfloat *target = (GLfloat*)targetUniform->data + mUniformIndex[location].element * 4;
+
+        for (int i = 0; i < count; i++)
+        {
+            target[0] = v[0];
+            target[1] = 0;
+            target[2] = 0;
+            target[3] = 0;
+            target += 4;
+            v += 1;
+        }
+    }
+    else if (targetUniform->type == GL_BOOL)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element;
+
+        for (int i = 0; i < count; ++i)
+        {
+            if (v[i] == 0.0f)
+            {
+                boolParams[i] = GL_FALSE;
+            }
+            else
+            {
+                boolParams[i] = GL_TRUE;
+            }
+        }
+    }
+    else
+    {
+        return false;
+    }
+
+    return true;
+}
+
+bool ProgramBinary::setUniform2fv(GLint location, GLsizei count, const GLfloat *v)
+{
+    if (location < 0 || location >= (int)mUniformIndex.size())
+    {
+        return false;
+    }
+
+    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
+    targetUniform->dirty = true;
+
+    if (targetUniform->type == GL_FLOAT_VEC2)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+
+        GLfloat *target = (GLfloat*)targetUniform->data + mUniformIndex[location].element * 4;
+
+        for (int i = 0; i < count; i++)
+        {
+            target[0] = v[0];
+            target[1] = v[1];
+            target[2] = 0;
+            target[3] = 0;
+            target += 4;
+            v += 2;
+        }
+    }
+    else if (targetUniform->type == GL_BOOL_VEC2)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+
+        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * 2;
+
+        for (int i = 0; i < count * 2; ++i)
+        {
+            if (v[i] == 0.0f)
+            {
+                boolParams[i] = GL_FALSE;
+            }
+            else
+            {
+                boolParams[i] = GL_TRUE;
+            }
+        }
+    }
+    else 
+    {
+        return false;
+    }
+
+    return true;
+}
+
+bool ProgramBinary::setUniform3fv(GLint location, GLsizei count, const GLfloat *v)
+{
+    if (location < 0 || location >= (int)mUniformIndex.size())
+    {
+        return false;
+    }
+
+    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
+    targetUniform->dirty = true;
+
+    if (targetUniform->type == GL_FLOAT_VEC3)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+
+        GLfloat *target = (GLfloat*)targetUniform->data + mUniformIndex[location].element * 4;
+
+        for (int i = 0; i < count; i++)
+        {
+            target[0] = v[0];
+            target[1] = v[1];
+            target[2] = v[2];
+            target[3] = 0;
+            target += 4;
+            v += 3;
+        }
+    }
+    else if (targetUniform->type == GL_BOOL_VEC3)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * 3;
+
+        for (int i = 0; i < count * 3; ++i)
+        {
+            if (v[i] == 0.0f)
+            {
+                boolParams[i] = GL_FALSE;
+            }
+            else
+            {
+                boolParams[i] = GL_TRUE;
+            }
+        }
+    }
+    else 
+    {
+        return false;
+    }
+
+    return true;
+}
+
+bool ProgramBinary::setUniform4fv(GLint location, GLsizei count, const GLfloat *v)
+{
+    if (location < 0 || location >= (int)mUniformIndex.size())
+    {
+        return false;
+    }
+
+    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
+    targetUniform->dirty = true;
+
+    if (targetUniform->type == GL_FLOAT_VEC4)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+
+        memcpy(targetUniform->data + mUniformIndex[location].element * sizeof(GLfloat) * 4,
+               v, 4 * sizeof(GLfloat) * count);
+    }
+    else if (targetUniform->type == GL_BOOL_VEC4)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * 4;
+
+        for (int i = 0; i < count * 4; ++i)
+        {
+            if (v[i] == 0.0f)
+            {
+                boolParams[i] = GL_FALSE;
+            }
+            else
+            {
+                boolParams[i] = GL_TRUE;
+            }
+        }
+    }
+    else 
+    {
+        return false;
+    }
+
+    return true;
+}
+
+template<typename T, int targetWidth, int targetHeight, int srcWidth, int srcHeight>
+void transposeMatrix(T *target, const GLfloat *value)
+{
+    int copyWidth = std::min(targetWidth, srcWidth);
+    int copyHeight = std::min(targetHeight, srcHeight);
+
+    for (int x = 0; x < copyWidth; x++)
+    {
+        for (int y = 0; y < copyHeight; y++)
+        {
+            target[x * targetWidth + y] = (T)value[y * srcWidth + x];
+        }
+    }
+    // clear unfilled right side
+    for (int y = 0; y < copyHeight; y++)
+    {
+        for (int x = srcWidth; x < targetWidth; x++)
+        {
+            target[y * targetWidth + x] = (T)0;
+        }
+    }
+    // clear unfilled bottom.
+    for (int y = srcHeight; y < targetHeight; y++)
+    {
+        for (int x = 0; x < targetWidth; x++)
+        {
+            target[y * targetWidth + x] = (T)0;
+        }
+    }
+}
+
+bool ProgramBinary::setUniformMatrix2fv(GLint location, GLsizei count, const GLfloat *value)
+{
+    if (location < 0 || location >= (int)mUniformIndex.size())
+    {
+        return false;
+    }
+
+    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
+    targetUniform->dirty = true;
+
+    if (targetUniform->type != GL_FLOAT_MAT2)
+    {
+        return false;
+    }
+
+    int arraySize = targetUniform->arraySize;
+
+    if (arraySize == 1 && count > 1)
+        return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+    count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+
+    GLfloat *target = (GLfloat*)targetUniform->data + mUniformIndex[location].element * 8;
+    for (int i = 0; i < count; i++)
+    {
+        transposeMatrix<GLfloat,4,2,2,2>(target, value);
+        target += 8;
+        value += 4;
+    }
+
+    return true;
+}
+
+bool ProgramBinary::setUniformMatrix3fv(GLint location, GLsizei count, const GLfloat *value)
+{
+    if (location < 0 || location >= (int)mUniformIndex.size())
+    {
+        return false;
+    }
+
+    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
+    targetUniform->dirty = true;
+
+    if (targetUniform->type != GL_FLOAT_MAT3)
+    {
+        return false;
+    }
+
+    int arraySize = targetUniform->arraySize;
+
+    if (arraySize == 1 && count > 1)
+        return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+    count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+
+    GLfloat *target = (GLfloat*)targetUniform->data + mUniformIndex[location].element * 12;
+    for (int i = 0; i < count; i++)
+    {
+        transposeMatrix<GLfloat,4,3,3,3>(target, value);
+        target += 12;
+        value += 9;
+    }
+
+    return true;
+}
+
+
+bool ProgramBinary::setUniformMatrix4fv(GLint location, GLsizei count, const GLfloat *value)
+{
+    if (location < 0 || location >= (int)mUniformIndex.size())
+    {
+        return false;
+    }
+
+    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
+    targetUniform->dirty = true;
+
+    if (targetUniform->type != GL_FLOAT_MAT4)
+    {
+        return false;
+    }
+
+    int arraySize = targetUniform->arraySize;
+
+    if (arraySize == 1 && count > 1)
+        return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+    count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+
+    GLfloat *target = (GLfloat*)(targetUniform->data + mUniformIndex[location].element * sizeof(GLfloat) * 16);
+    for (int i = 0; i < count; i++)
+    {
+        transposeMatrix<GLfloat,4,4,4,4>(target, value);
+        target += 16;
+        value += 16;
+    }
+
+    return true;
+}
+
+bool ProgramBinary::setUniform1iv(GLint location, GLsizei count, const GLint *v)
+{
+    if (location < 0 || location >= (int)mUniformIndex.size())
+    {
+        return false;
+    }
+
+    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
+    targetUniform->dirty = true;
+
+    if (targetUniform->type == GL_INT ||
+        targetUniform->type == GL_SAMPLER_2D ||
+        targetUniform->type == GL_SAMPLER_CUBE)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+
+        memcpy(targetUniform->data + mUniformIndex[location].element * sizeof(GLint),
+               v, sizeof(GLint) * count);
+    }
+    else if (targetUniform->type == GL_BOOL)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element;
+
+        for (int i = 0; i < count; ++i)
+        {
+            if (v[i] == 0)
+            {
+                boolParams[i] = GL_FALSE;
+            }
+            else
+            {
+                boolParams[i] = GL_TRUE;
+            }
+        }
+    }
+    else
+    {
+        return false;
+    }
+
+    return true;
+}
+
+bool ProgramBinary::setUniform2iv(GLint location, GLsizei count, const GLint *v)
+{
+    if (location < 0 || location >= (int)mUniformIndex.size())
+    {
+        return false;
+    }
+
+    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
+    targetUniform->dirty = true;
+
+    if (targetUniform->type == GL_INT_VEC2)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+
+        memcpy(targetUniform->data + mUniformIndex[location].element * sizeof(GLint) * 2,
+               v, 2 * sizeof(GLint) * count);
+    }
+    else if (targetUniform->type == GL_BOOL_VEC2)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * 2;
+
+        for (int i = 0; i < count * 2; ++i)
+        {
+            if (v[i] == 0)
+            {
+                boolParams[i] = GL_FALSE;
+            }
+            else
+            {
+                boolParams[i] = GL_TRUE;
+            }
+        }
+    }
+    else
+    {
+        return false;
+    }
+
+    return true;
+}
+
+bool ProgramBinary::setUniform3iv(GLint location, GLsizei count, const GLint *v)
+{
+    if (location < 0 || location >= (int)mUniformIndex.size())
+    {
+        return false;
+    }
+
+    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
+    targetUniform->dirty = true;
+
+    if (targetUniform->type == GL_INT_VEC3)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+
+        memcpy(targetUniform->data + mUniformIndex[location].element * sizeof(GLint) * 3,
+               v, 3 * sizeof(GLint) * count);
+    }
+    else if (targetUniform->type == GL_BOOL_VEC3)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * 3;
+
+        for (int i = 0; i < count * 3; ++i)
+        {
+            if (v[i] == 0)
+            {
+                boolParams[i] = GL_FALSE;
+            }
+            else
+            {
+                boolParams[i] = GL_TRUE;
+            }
+        }
+    }
+    else
+    {
+        return false;
+    }
+
+    return true;
+}
+
+bool ProgramBinary::setUniform4iv(GLint location, GLsizei count, const GLint *v)
+{
+    if (location < 0 || location >= (int)mUniformIndex.size())
+    {
+        return false;
+    }
+
+    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
+    targetUniform->dirty = true;
+
+    if (targetUniform->type == GL_INT_VEC4)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+
+        memcpy(targetUniform->data + mUniformIndex[location].element * sizeof(GLint) * 4,
+               v, 4 * sizeof(GLint) * count);
+    }
+    else if (targetUniform->type == GL_BOOL_VEC4)
+    {
+        int arraySize = targetUniform->arraySize;
+
+        if (arraySize == 1 && count > 1)
+            return false; // attempting to write an array to a non-array uniform is an INVALID_OPERATION
+
+        count = std::min(arraySize - (int)mUniformIndex[location].element, count);
+        GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * 4;
+
+        for (int i = 0; i < count * 4; ++i)
+        {
+            if (v[i] == 0)
+            {
+                boolParams[i] = GL_FALSE;
+            }
+            else
+            {
+                boolParams[i] = GL_TRUE;
+            }
+        }
+    }
+    else
+    {
+        return false;
+    }
+
+    return true;
+}
+
+bool ProgramBinary::getUniformfv(GLint location, GLsizei *bufSize, GLfloat *params)
+{
+    if (location < 0 || location >= (int)mUniformIndex.size())
+    {
+        return false;
+    }
+
+    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
+
+    // sized queries -- ensure the provided buffer is large enough
+    if (bufSize)
+    {
+        int requiredBytes = UniformExternalSize(targetUniform->type);
+        if (*bufSize < requiredBytes)
+        {
+            return false;
+        }
+    }
+
+    switch (targetUniform->type)
+    {
+      case GL_FLOAT_MAT2:
+        transposeMatrix<GLfloat,2,2,4,2>(params, (GLfloat*)targetUniform->data + mUniformIndex[location].element * 8);
+        break;
+      case GL_FLOAT_MAT3:
+        transposeMatrix<GLfloat,3,3,4,3>(params, (GLfloat*)targetUniform->data + mUniformIndex[location].element * 12);
+        break;
+      case GL_FLOAT_MAT4:
+        transposeMatrix<GLfloat,4,4,4,4>(params, (GLfloat*)targetUniform->data + mUniformIndex[location].element * 16);
+        break;
+      default:
+        {
+            unsigned int count = UniformExternalComponentCount(targetUniform->type);
+            unsigned int internalCount = UniformInternalComponentCount(targetUniform->type);
+
+            switch (UniformComponentType(targetUniform->type))
+            {
+              case GL_BOOL:
+                {
+                    GLboolean *boolParams = (GLboolean*)targetUniform->data + mUniformIndex[location].element * internalCount;
+
+                    for (unsigned int i = 0; i < count; ++i)
+                    {
+                        params[i] = (boolParams[i] == GL_FALSE) ? 0.0f : 1.0f;
+                    }
+                }
+                break;
+              case GL_FLOAT:
+                memcpy(params, targetUniform->data + mUniformIndex[location].element * internalCount * sizeof(GLfloat),
+                       count * sizeof(GLfloat));
+                break;
+              case GL_INT:
+                {
+                    GLint *intParams = (GLint*)targetUniform->data + mUniformIndex[location].element * internalCount;
+
+                    for (unsigned int i = 0; i < count; ++i)
+                    {
+                        params[i] = (float)intParams[i];
+                    }
+                }
+                break;
+              default: UNREACHABLE();
+            }
+        }
+    }
+
+    return true;
+}
+
+bool ProgramBinary::getUniformiv(GLint location, GLsizei *bufSize, GLint *params)
+{
+    if (location < 0 || location >= (int)mUniformIndex.size())
+    {
+        return false;
+    }
+
+    Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
+
+    // sized queries -- ensure the provided buffer is large enough
+    if (bufSize)
+    {
+        int requiredBytes = UniformExternalSize(targetUniform->type);
+        if (*bufSize < requiredBytes)
+        {
+            return false;
+        }
+    }
+
+    switch (targetUniform->type)
+    {
+      case GL_FLOAT_MAT2:
+        {
+            transposeMatrix<GLint,2,2,4,2>(params, (GLfloat*)targetUniform->data + mUniformIndex[location].element * 8);
+        }
+        break;
+      case GL_FLOAT_MAT3:
+        {
+            transposeMatrix<GLint,3,3,4,3>(params, (GLfloat*)targetUniform->data + mUniformIndex[location].element * 12);
+        }
+        break;
+      case GL_FLOAT_MAT4:
+        {
+            transposeMatrix<GLint,4,4,4,4>(params, (GLfloat*)targetUniform->data + mUniformIndex[location].element * 16);
+        }
+        break;
+      default:
+        {
+            unsigned int count = UniformExternalComponentCount(targetUniform->type);
+            unsigned int internalCount = UniformInternalComponentCount(targetUniform->type);
+
+            switch (UniformComponentType(targetUniform->type))
+            {
+              case GL_BOOL:
+                {
+                    GLboolean *boolParams = targetUniform->data + mUniformIndex[location].element * internalCount;
+
+                    for (unsigned int i = 0; i < count; ++i)
+                    {
+                        params[i] = (GLint)boolParams[i];
+                    }
+                }
+                break;
+              case GL_FLOAT:
+                {
+                    GLfloat *floatParams = (GLfloat*)targetUniform->data + mUniformIndex[location].element * internalCount;
+
+                    for (unsigned int i = 0; i < count; ++i)
+                    {
+                        params[i] = (GLint)floatParams[i];
+                    }
+                }
+                break;
+              case GL_INT:
+                memcpy(params, targetUniform->data + mUniformIndex[location].element * internalCount * sizeof(GLint),
+                       count * sizeof(GLint));
+                break;
+              default: UNREACHABLE();
+            }
+        }
+    }
+
+    return true;
+}
+
+void ProgramBinary::dirtyAllUniforms()
+{
+    unsigned int numUniforms = mUniforms.size();
+    for (unsigned int index = 0; index < numUniforms; index++)
+    {
+        mUniforms[index]->dirty = true;
+    }
+}
+
+// Applies all the uniforms set for this program object to the Direct3D 9 device
+void ProgramBinary::applyUniforms()
+{
+    for (std::vector<Uniform*>::iterator ub = mUniforms.begin(), ue = mUniforms.end(); ub != ue; ++ub) {
+        Uniform *targetUniform = *ub;
+
+        if (targetUniform->dirty)
+        {
+            int arraySize = targetUniform->arraySize;
+            GLfloat *f = (GLfloat*)targetUniform->data;
+            GLint *i = (GLint*)targetUniform->data;
+            GLboolean *b = (GLboolean*)targetUniform->data;
+
+            switch (targetUniform->type)
+            {
+              case GL_BOOL:       applyUniformnbv(targetUniform, arraySize, 1, b);    break;
+              case GL_BOOL_VEC2:  applyUniformnbv(targetUniform, arraySize, 2, b);    break;
+              case GL_BOOL_VEC3:  applyUniformnbv(targetUniform, arraySize, 3, b);    break;
+              case GL_BOOL_VEC4:  applyUniformnbv(targetUniform, arraySize, 4, b);    break;
+              case GL_FLOAT:
+              case GL_FLOAT_VEC2:
+              case GL_FLOAT_VEC3:
+              case GL_FLOAT_VEC4:
+              case GL_FLOAT_MAT2:
+              case GL_FLOAT_MAT3:
+              case GL_FLOAT_MAT4: applyUniformnfv(targetUniform, f);                  break;
+              case GL_SAMPLER_2D:
+              case GL_SAMPLER_CUBE:
+              case GL_INT:        applyUniform1iv(targetUniform, arraySize, i);       break;
+              case GL_INT_VEC2:   applyUniform2iv(targetUniform, arraySize, i);       break;
+              case GL_INT_VEC3:   applyUniform3iv(targetUniform, arraySize, i);       break;
+              case GL_INT_VEC4:   applyUniform4iv(targetUniform, arraySize, i);       break;
+              default:
+                UNREACHABLE();
+            }
+
+            targetUniform->dirty = false;
+        }
+    }
+}
+
+// Compiles the HLSL code of the attached shaders into executable binaries
+ID3D10Blob *ProgramBinary::compileToBinary(const char *hlsl, const char *profile, ID3DXConstantTable **constantTable)
+{
+    if (!hlsl)
+    {
+        return NULL;
+    }
+
+    DWORD result;
+    UINT flags = 0;
+    std::string sourceText;
+    if (perfActive())
+    {
+        flags |= D3DCOMPILE_DEBUG;
+#ifdef NDEBUG
+        flags |= ANGLE_COMPILE_OPTIMIZATION_LEVEL;
+#else
+        flags |= D3DCOMPILE_SKIP_OPTIMIZATION;
+#endif
+
+        std::string sourcePath = getTempPath();
+        sourceText = std::string("#line 2 \"") + sourcePath + std::string("\"\n\n") + std::string(hlsl);
+        writeFile(sourcePath.c_str(), sourceText.c_str(), sourceText.size());
+    }
+    else
+    {
+        flags |= ANGLE_COMPILE_OPTIMIZATION_LEVEL;
+        sourceText = hlsl;
+    }
+
+    ID3D10Blob *binary = NULL;
+    ID3D10Blob *errorMessage = NULL;
+    result = D3DCompile(hlsl, strlen(hlsl), fakepath, NULL, NULL, "main", profile, flags, 0, &binary, &errorMessage);
+
+    if (errorMessage)
+    {
+        const char *message = (const char*)errorMessage->GetBufferPointer();
+
+        appendToInfoLogSanitized(message);
+        TRACE("\n%s", hlsl);
+        TRACE("\n%s", message);
+
+        errorMessage->Release();
+        errorMessage = NULL;
+    }
+
+    if (FAILED(result))
+    {
+        if (result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY)
+        {
+            error(GL_OUT_OF_MEMORY);
+        }
+
+        return NULL;
+    }
+
+    result = D3DXGetShaderConstantTable(static_cast<const DWORD*>(binary->GetBufferPointer()), constantTable);
+
+    if (FAILED(result))
+    {
+        if (result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY)
+        {
+            error(GL_OUT_OF_MEMORY);
+        }
+
+        binary->Release();
+
+        return NULL;
+    }
+
+    return binary;
+}
+
+// Packs varyings into generic varying registers, using the algorithm from [OpenGL ES Shading Language 1.00 rev. 17] appendix A section 7 page 111
+// Returns the number of used varying registers, or -1 if unsuccesful
+int ProgramBinary::packVaryings(const Varying *packing[][4], FragmentShader *fragmentShader)
+{
+    Context *context = getContext();
+    const int maxVaryingVectors = context->getMaximumVaryingVectors();
+
+    for (VaryingList::iterator varying = fragmentShader->mVaryings.begin(); varying != fragmentShader->mVaryings.end(); varying++)
+    {
+        int n = VariableRowCount(varying->type) * varying->size;
+        int m = VariableColumnCount(varying->type);
+        bool success = false;
+
+        if (m == 2 || m == 3 || m == 4)
+        {
+            for (int r = 0; r <= maxVaryingVectors - n && !success; r++)
+            {
+                bool available = true;
+
+                for (int y = 0; y < n && available; y++)
+                {
+                    for (int x = 0; x < m && available; x++)
+                    {
+                        if (packing[r + y][x])
+                        {
+                            available = false;
+                        }
+                    }
+                }
+
+                if (available)
+                {
+                    varying->reg = r;
+                    varying->col = 0;
+
+                    for (int y = 0; y < n; y++)
+                    {
+                        for (int x = 0; x < m; x++)
+                        {
+                            packing[r + y][x] = &*varying;
+                        }
+                    }
+
+                    success = true;
+                }
+            }
+
+            if (!success && m == 2)
+            {
+                for (int r = maxVaryingVectors - n; r >= 0 && !success; r--)
+                {
+                    bool available = true;
+
+                    for (int y = 0; y < n && available; y++)
+                    {
+                        for (int x = 2; x < 4 && available; x++)
+                        {
+                            if (packing[r + y][x])
+                            {
+                                available = false;
+                            }
+                        }
+                    }
+
+                    if (available)
+                    {
+                        varying->reg = r;
+                        varying->col = 2;
+
+                        for (int y = 0; y < n; y++)
+                        {
+                            for (int x = 2; x < 4; x++)
+                            {
+                                packing[r + y][x] = &*varying;
+                            }
+                        }
+
+                        success = true;
+                    }
+                }
+            }
+        }
+        else if (m == 1)
+        {
+            int space[4] = {0};
+
+            for (int y = 0; y < maxVaryingVectors; y++)
+            {
+                for (int x = 0; x < 4; x++)
+                {
+                    space[x] += packing[y][x] ? 0 : 1;
+                }
+            }
+
+            int column = 0;
+
+            for (int x = 0; x < 4; x++)
+            {
+                if (space[x] >= n && space[x] < space[column])
+                {
+                    column = x;
+                }
+            }
+
+            if (space[column] >= n)
+            {
+                for (int r = 0; r < maxVaryingVectors; r++)
+                {
+                    if (!packing[r][column])
+                    {
+                        varying->reg = r;
+
+                        for (int y = r; y < r + n; y++)
+                        {
+                            packing[y][column] = &*varying;
+                        }
+
+                        break;
+                    }
+                }
+
+                varying->col = column;
+
+                success = true;
+            }
+        }
+        else UNREACHABLE();
+
+        if (!success)
+        {
+            appendToInfoLog("Could not pack varying %s", varying->name.c_str());
+
+            return -1;
+        }
+    }
+
+    // Return the number of used registers
+    int registers = 0;
+
+    for (int r = 0; r < maxVaryingVectors; r++)
+    {
+        if (packing[r][0] || packing[r][1] || packing[r][2] || packing[r][3])
+        {
+            registers++;
+        }
+    }
+
+    return registers;
+}
+
+bool ProgramBinary::linkVaryings(std::string& pixelHLSL, std::string& vertexHLSL, FragmentShader *fragmentShader, VertexShader *vertexShader)
+{
+    if (pixelHLSL.empty() || vertexHLSL.empty())
+    {
+        return false;
+    }
+
+    // Reset the varying register assignments
+    for (VaryingList::iterator fragVar = fragmentShader->mVaryings.begin(); fragVar != fragmentShader->mVaryings.end(); fragVar++)
+    {
+        fragVar->reg = -1;
+        fragVar->col = -1;
+    }
+
+    for (VaryingList::iterator vtxVar = vertexShader->mVaryings.begin(); vtxVar != vertexShader->mVaryings.end(); vtxVar++)
+    {
+        vtxVar->reg = -1;
+        vtxVar->col = -1;
+    }
+
+    // Map the varyings to the register file
+    const Varying *packing[MAX_VARYING_VECTORS_SM3][4] = {NULL};
+    int registers = packVaryings(packing, fragmentShader);
+
+    if (registers < 0)
+    {
+        return false;
+    }
+
+    // Write the HLSL input/output declarations
+    Context *context = getContext();
+    const bool sm3 = context->supportsShaderModel3();
+    const int maxVaryingVectors = context->getMaximumVaryingVectors();
+
+    if (registers == maxVaryingVectors && fragmentShader->mUsesFragCoord)
+    {
+        appendToInfoLog("No varying registers left to support gl_FragCoord");
+
+        return false;
+    }
+
+    for (VaryingList::iterator input = fragmentShader->mVaryings.begin(); input != fragmentShader->mVaryings.end(); input++)
+    {
+        bool matched = false;
+
+        for (VaryingList::iterator output = vertexShader->mVaryings.begin(); output != vertexShader->mVaryings.end(); output++)
+        {
+            if (output->name == input->name)
+            {
+                if (output->type != input->type || output->size != input->size)
+                {
+                    appendToInfoLog("Type of vertex varying %s does not match that of the fragment varying", output->name.c_str());
+
+                    return false;
+                }
+
+                output->reg = input->reg;
+                output->col = input->col;
+
+                matched = true;
+                break;
+            }
+        }
+
+        if (!matched)
+        {
+            appendToInfoLog("Fragment varying %s does not match any vertex varying", input->name.c_str());
+
+            return false;
+        }
+    }
+
+    std::string varyingSemantic = (sm3 ? "COLOR" : "TEXCOORD");
+
+    vertexHLSL += "struct VS_INPUT\n"
+                   "{\n";
+
+    int semanticIndex = 0;
+    for (AttributeArray::iterator attribute = vertexShader->mAttributes.begin(); attribute != vertexShader->mAttributes.end(); attribute++)
+    {
+        switch (attribute->type)
+        {
+          case GL_FLOAT:      vertexHLSL += "    float ";    break;
+          case GL_FLOAT_VEC2: vertexHLSL += "    float2 ";   break;
+          case GL_FLOAT_VEC3: vertexHLSL += "    float3 ";   break;
+          case GL_FLOAT_VEC4: vertexHLSL += "    float4 ";   break;
+          case GL_FLOAT_MAT2: vertexHLSL += "    float2x2 "; break;
+          case GL_FLOAT_MAT3: vertexHLSL += "    float3x3 "; break;
+          case GL_FLOAT_MAT4: vertexHLSL += "    float4x4 "; break;
+          default:  UNREACHABLE();
+        }
+
+        vertexHLSL += decorateAttribute(attribute->name) + " : TEXCOORD" + str(semanticIndex) + ";\n";
+
+        semanticIndex += VariableRowCount(attribute->type);
+    }
+
+    vertexHLSL += "};\n"
+                   "\n"
+                   "struct VS_OUTPUT\n"
+                   "{\n"
+                   "    float4 gl_Position : POSITION;\n";
+
+    for (int r = 0; r < registers; r++)
+    {
+        int registerSize = packing[r][3] ? 4 : (packing[r][2] ? 3 : (packing[r][1] ? 2 : 1));
+
+        vertexHLSL += "    float" + str(registerSize) + " v" + str(r) + " : " + varyingSemantic + str(r) + ";\n";
+    }
+
+    if (fragmentShader->mUsesFragCoord)
+    {
+        vertexHLSL += "    float4 gl_FragCoord : " + varyingSemantic + str(registers) + ";\n";
+    }
+
+    if (vertexShader->mUsesPointSize && sm3)
+    {
+        vertexHLSL += "    float gl_PointSize : PSIZE;\n";
+    }
+
+    vertexHLSL += "};\n"
+                   "\n"
+                   "VS_OUTPUT main(VS_INPUT input)\n"
+                   "{\n";
+
+    for (AttributeArray::iterator attribute = vertexShader->mAttributes.begin(); attribute != vertexShader->mAttributes.end(); attribute++)
+    {
+        vertexHLSL += "    " + decorateAttribute(attribute->name) + " = ";
+
+        if (VariableRowCount(attribute->type) > 1)   // Matrix
+        {
+            vertexHLSL += "transpose";
+        }
+
+        vertexHLSL += "(input." + decorateAttribute(attribute->name) + ");\n";
+    }
+
+    vertexHLSL += "\n"
+                   "    gl_main();\n"
+                   "\n"
+                   "    VS_OUTPUT output;\n"
+                   "    output.gl_Position.x = gl_Position.x - dx_HalfPixelSize.x * gl_Position.w;\n"
+                   "    output.gl_Position.y = gl_Position.y - dx_HalfPixelSize.y * gl_Position.w;\n"
+                   "    output.gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n"
+                   "    output.gl_Position.w = gl_Position.w;\n";
+
+    if (vertexShader->mUsesPointSize && sm3)
+    {
+        vertexHLSL += "    output.gl_PointSize = clamp(gl_PointSize, 1.0, " + str((int)ALIASED_POINT_SIZE_RANGE_MAX_SM3) + ");\n";
+    }
+
+    if (fragmentShader->mUsesFragCoord)
+    {
+        vertexHLSL += "    output.gl_FragCoord = gl_Position;\n";
+    }
+
+    for (VaryingList::iterator varying = vertexShader->mVaryings.begin(); varying != vertexShader->mVaryings.end(); varying++)
+    {
+        if (varying->reg >= 0)
+        {
+            for (int i = 0; i < varying->size; i++)
+            {
+                int rows = VariableRowCount(varying->type);
+
+                for (int j = 0; j < rows; j++)
+                {
+                    int r = varying->reg + i * rows + j;
+                    vertexHLSL += "    output.v" + str(r);
+
+                    bool sharedRegister = false;   // Register used by multiple varyings
+                    
+                    for (int x = 0; x < 4; x++)
+                    {
+                        if (packing[r][x] && packing[r][x] != packing[r][0])
+                        {
+                            sharedRegister = true;
+                            break;
+                        }
+                    }
+
+                    if(sharedRegister)
+                    {
+                        vertexHLSL += ".";
+
+                        for (int x = 0; x < 4; x++)
+                        {
+                            if (packing[r][x] == &*varying)
+                            {
+                                switch(x)
+                                {
+                                  case 0: vertexHLSL += "x"; break;
+                                  case 1: vertexHLSL += "y"; break;
+                                  case 2: vertexHLSL += "z"; break;
+                                  case 3: vertexHLSL += "w"; break;
+                                }
+                            }
+                        }
+                    }
+
+                    vertexHLSL += " = " + varying->name;
+                    
+                    if (varying->array)
+                    {
+                        vertexHLSL += "[" + str(i) + "]";
+                    }
+
+                    if (rows > 1)
+                    {
+                        vertexHLSL += "[" + str(j) + "]";
+                    }
+                    
+                    vertexHLSL += ";\n";
+                }
+            }
+        }
+    }
+
+    vertexHLSL += "\n"
+                   "    return output;\n"
+                   "}\n";
+
+    pixelHLSL += "struct PS_INPUT\n"
+                  "{\n";
+    
+    for (VaryingList::iterator varying = fragmentShader->mVaryings.begin(); varying != fragmentShader->mVaryings.end(); varying++)
+    {
+        if (varying->reg >= 0)
+        {
+            for (int i = 0; i < varying->size; i++)
+            {
+                int rows = VariableRowCount(varying->type);
+                for (int j = 0; j < rows; j++)
+                {
+                    std::string n = str(varying->reg + i * rows + j);
+                    pixelHLSL += "    float4 v" + n + " : " + varyingSemantic + n + ";\n";
+                }
+            }
+        }
+        else UNREACHABLE();
+    }
+
+    if (fragmentShader->mUsesFragCoord)
+    {
+        pixelHLSL += "    float4 gl_FragCoord : " + varyingSemantic + str(registers) + ";\n";
+        if (sm3) {
+            pixelHLSL += "    float2 dx_VPos : VPOS;\n";
+        }
+    }
+
+    if (fragmentShader->mUsesPointCoord && sm3)
+    {
+        pixelHLSL += "    float2 gl_PointCoord : TEXCOORD0;\n";
+    }
+
+    if (fragmentShader->mUsesFrontFacing)
+    {
+        pixelHLSL += "    float vFace : VFACE;\n";
+    }
+
+    pixelHLSL += "};\n"
+                  "\n"
+                  "struct PS_OUTPUT\n"
+                  "{\n"
+                  "    float4 gl_Color[1] : COLOR;\n"
+                  "};\n"
+                  "\n"
+                  "PS_OUTPUT main(PS_INPUT input)\n"
+                  "{\n";
+
+    if (fragmentShader->mUsesFragCoord)
+    {
+        pixelHLSL += "    float rhw = 1.0 / input.gl_FragCoord.w;\n";
+        
+        if (sm3)
+        {
+            // dx_Coord.y contains the render target height. See Context::applyRenderTarget()
+            pixelHLSL += "    gl_FragCoord.x = input.dx_VPos.x + 0.5;\n"
+                          "    gl_FragCoord.y = dx_Coord.y - input.dx_VPos.y - 0.5;\n";
+        }
+        else
+        {
+            // dx_Coord contains the viewport width/2, height/2, center.x and center.y. See Context::applyRenderTarget()
+            pixelHLSL += "    gl_FragCoord.x = (input.gl_FragCoord.x * rhw) * dx_Coord.x + dx_Coord.z;\n"
+                          "    gl_FragCoord.y = -(input.gl_FragCoord.y * rhw) * dx_Coord.y + dx_Coord.w;\n";
+        }
+        
+        pixelHLSL += "    gl_FragCoord.z = (input.gl_FragCoord.z * rhw) * dx_Depth.x + dx_Depth.y;\n"
+                      "    gl_FragCoord.w = rhw;\n";
+    }
+
+    if (fragmentShader->mUsesPointCoord && sm3)
+    {
+        pixelHLSL += "    gl_PointCoord = input.gl_PointCoord;\n";
+    }
+
+    if (fragmentShader->mUsesFrontFacing)
+    {
+        pixelHLSL += "    gl_FrontFacing = dx_PointsOrLines || (dx_FrontCCW ? (input.vFace >= 0.0) : (input.vFace <= 0.0));\n";
+    }
+
+    for (VaryingList::iterator varying = fragmentShader->mVaryings.begin(); varying != fragmentShader->mVaryings.end(); varying++)
+    {
+        if (varying->reg >= 0)
+        {
+            for (int i = 0; i < varying->size; i++)
+            {
+                int rows = VariableRowCount(varying->type);
+                for (int j = 0; j < rows; j++)
+                {
+                    std::string n = str(varying->reg + i * rows + j);
+                    pixelHLSL += "    " + varying->name;
+
+                    if (varying->array)
+                    {
+                        pixelHLSL += "[" + str(i) + "]";
+                    }
+
+                    if (rows > 1)
+                    {
+                        pixelHLSL += "[" + str(j) + "]";
+                    }
+
+                    pixelHLSL += " = input.v" + n + ";\n";
+                }
+            }
+        }
+        else UNREACHABLE();
+    }
+
+    pixelHLSL += "\n"
+                  "    gl_main();\n"
+                  "\n"
+                  "    PS_OUTPUT output;\n"                 
+                  "    output.gl_Color[0] = gl_Color[0];\n"
+                  "\n"
+                  "    return output;\n"
+                  "}\n";
+
+    return true;
+}
+
+bool ProgramBinary::link(const AttributeBindings &attributeBindings, FragmentShader *fragmentShader, VertexShader *vertexShader)
+{
+    if (!fragmentShader || !fragmentShader->isCompiled())
+    {
+        return false;
+    }
+
+    if (!vertexShader || !vertexShader->isCompiled())
+    {
+        return false;
+    }
+
+    std::string pixelHLSL = fragmentShader->getHLSL();
+    std::string vertexHLSL = vertexShader->getHLSL();
+
+    if (!linkVaryings(pixelHLSL, vertexHLSL, fragmentShader, vertexShader))
+    {
+        return false;
+    }
+
+    Context *context = getContext();
+    const char *vertexProfile = context->supportsShaderModel3() ? "vs_3_0" : "vs_2_0";
+    const char *pixelProfile = context->supportsShaderModel3() ? "ps_3_0" : "ps_2_0";
+
+    ID3D10Blob *vertexBinary = compileToBinary(vertexHLSL.c_str(), vertexProfile, &mConstantTableVS);
+    ID3D10Blob *pixelBinary = compileToBinary(pixelHLSL.c_str(), pixelProfile, &mConstantTablePS);
+
+    if (vertexBinary && pixelBinary)
+    {
+        HRESULT vertexResult = mDevice->CreateVertexShader((DWORD*)vertexBinary->GetBufferPointer(), &mVertexExecutable);
+        HRESULT pixelResult = mDevice->CreatePixelShader((DWORD*)pixelBinary->GetBufferPointer(), &mPixelExecutable);
+
+        if (vertexResult == D3DERR_OUTOFVIDEOMEMORY || vertexResult == E_OUTOFMEMORY || pixelResult == D3DERR_OUTOFVIDEOMEMORY || pixelResult == E_OUTOFMEMORY)
+        {
+            return error(GL_OUT_OF_MEMORY, false);
+        }
+
+        ASSERT(SUCCEEDED(vertexResult) && SUCCEEDED(pixelResult));
+
+        vertexBinary->Release();
+        pixelBinary->Release();
+        vertexBinary = NULL;
+        pixelBinary = NULL;
+
+        if (mVertexExecutable && mPixelExecutable)
+        {
+            if (!linkAttributes(attributeBindings, fragmentShader, vertexShader))
+            {
+                return false;
+            }
+
+            if (!linkUniforms(GL_FRAGMENT_SHADER, mConstantTablePS))
+            {
+                return false;
+            }
+
+            if (!linkUniforms(GL_VERTEX_SHADER, mConstantTableVS))
+            {
+                return false;
+            }
+
+            // these uniforms are searched as already-decorated because gl_ and dx_
+            // are reserved prefixes, and do not receive additional decoration
+            mDxDepthRangeLocation = getUniformLocation("dx_DepthRange");
+            mDxDepthLocation = getUniformLocation("dx_Depth");
+            mDxCoordLocation = getUniformLocation("dx_Coord");
+            mDxHalfPixelSizeLocation = getUniformLocation("dx_HalfPixelSize");
+            mDxFrontCCWLocation = getUniformLocation("dx_FrontCCW");
+            mDxPointsOrLinesLocation = getUniformLocation("dx_PointsOrLines");
+
+            context->markDxUniformsDirty();
+
+            return true;
+        }
+    }
+
+    return false;
+}
+
+// Determines the mapping between GL attributes and Direct3D 9 vertex stream usage indices
+bool ProgramBinary::linkAttributes(const AttributeBindings &attributeBindings, FragmentShader *fragmentShader, VertexShader *vertexShader)
+{
+    unsigned int usedLocations = 0;
+
+    // Link attributes that have a binding location
+    for (AttributeArray::iterator attribute = vertexShader->mAttributes.begin(); attribute != vertexShader->mAttributes.end(); attribute++)
+    {
+        int location = attributeBindings.getAttributeBinding(attribute->name);
+
+        if (location != -1)   // Set by glBindAttribLocation
+        {
+            if (!mLinkedAttribute[location].name.empty())
+            {
+                // Multiple active attributes bound to the same location; not an error
+            }
+
+            mLinkedAttribute[location] = *attribute;
+
+            int rows = VariableRowCount(attribute->type);
+
+            if (rows + location > MAX_VERTEX_ATTRIBS)
+            {
+                appendToInfoLog("Active attribute (%s) at location %d is too big to fit", attribute->name.c_str(), location);
+
+                return false;
+            }
+
+            for (int i = 0; i < rows; i++)
+            {
+                usedLocations |= 1 << (location + i);
+            }
+        }
+    }
+
+    // Link attributes that don't have a binding location
+    for (AttributeArray::iterator attribute = vertexShader->mAttributes.begin(); attribute != vertexShader->mAttributes.end(); attribute++)
+    {
+        int location = attributeBindings.getAttributeBinding(attribute->name);
+
+        if (location == -1)   // Not set by glBindAttribLocation
+        {
+            int rows = VariableRowCount(attribute->type);
+            int availableIndex = AllocateFirstFreeBits(&usedLocations, rows, MAX_VERTEX_ATTRIBS);
+
+            if (availableIndex == -1 || availableIndex + rows > MAX_VERTEX_ATTRIBS)
+            {
+                appendToInfoLog("Too many active attributes (%s)", attribute->name.c_str());
+
+                return false;   // Fail to link
+            }
+
+            mLinkedAttribute[availableIndex] = *attribute;
+        }
+    }
+
+    for (int attributeIndex = 0; attributeIndex < MAX_VERTEX_ATTRIBS; )
+    {
+        int index = vertexShader->getSemanticIndex(mLinkedAttribute[attributeIndex].name);
+        int rows = std::max(VariableRowCount(mLinkedAttribute[attributeIndex].type), 1);
+
+        for (int r = 0; r < rows; r++)
+        {
+            mSemanticIndex[attributeIndex++] = index++;
+        }
+    }
+
+    return true;
+}
+
+bool ProgramBinary::linkUniforms(GLenum shader, ID3DXConstantTable *constantTable)
+{
+    D3DXCONSTANTTABLE_DESC constantTableDescription;
+
+    constantTable->GetDesc(&constantTableDescription);
+
+    for (unsigned int constantIndex = 0; constantIndex < constantTableDescription.Constants; constantIndex++)
+    {
+        D3DXHANDLE constantHandle = constantTable->GetConstant(0, constantIndex);
+
+        D3DXCONSTANT_DESC constantDescription;
+        UINT descriptionCount = 1;
+        HRESULT result = constantTable->GetConstantDesc(constantHandle, &constantDescription, &descriptionCount);
+        ASSERT(SUCCEEDED(result));
+
+        if (!defineUniform(shader, constantHandle, constantDescription))
+        {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+// Adds the description of a constant found in the binary shader to the list of uniforms
+// Returns true if succesful (uniform not already defined)
+bool ProgramBinary::defineUniform(GLenum shader, const D3DXHANDLE &constantHandle, const D3DXCONSTANT_DESC &constantDescription, std::string name)
+{
+    if (constantDescription.RegisterSet == D3DXRS_SAMPLER)
+    {
+        for (unsigned int i = 0; i < constantDescription.RegisterCount; i++)
+        {
+            D3DXHANDLE psConstant = mConstantTablePS->GetConstantByName(NULL, constantDescription.Name);
+            D3DXHANDLE vsConstant = mConstantTableVS->GetConstantByName(NULL, constantDescription.Name);
+
+            if (psConstant)
+            {
+                unsigned int samplerIndex = mConstantTablePS->GetSamplerIndex(psConstant) + i;
+
+                if (samplerIndex < MAX_TEXTURE_IMAGE_UNITS)
+                {
+                    mSamplersPS[samplerIndex].active = true;
+                    mSamplersPS[samplerIndex].textureType = (constantDescription.Type == D3DXPT_SAMPLERCUBE) ? TEXTURE_CUBE : TEXTURE_2D;
+                    mSamplersPS[samplerIndex].logicalTextureUnit = 0;
+                    mUsedPixelSamplerRange = std::max(samplerIndex + 1, mUsedPixelSamplerRange);
+                }
+                else
+                {
+                    appendToInfoLog("Pixel shader sampler count exceeds MAX_TEXTURE_IMAGE_UNITS (%d).", MAX_TEXTURE_IMAGE_UNITS);
+                    return false;
+                }
+            }
+            
+            if (vsConstant)
+            {
+                unsigned int samplerIndex = mConstantTableVS->GetSamplerIndex(vsConstant) + i;
+
+                if (samplerIndex < getContext()->getMaximumVertexTextureImageUnits())
+                {
+                    mSamplersVS[samplerIndex].active = true;
+                    mSamplersVS[samplerIndex].textureType = (constantDescription.Type == D3DXPT_SAMPLERCUBE) ? TEXTURE_CUBE : TEXTURE_2D;
+                    mSamplersVS[samplerIndex].logicalTextureUnit = 0;
+                    mUsedVertexSamplerRange = std::max(samplerIndex + 1, mUsedVertexSamplerRange);
+                }
+                else
+                {
+                    appendToInfoLog("Vertex shader sampler count exceeds MAX_VERTEX_TEXTURE_IMAGE_UNITS (%d).", getContext()->getMaximumVertexTextureImageUnits());
+                    return false;
+                }
+            }
+        }
+    }
+
+    switch(constantDescription.Class)
+    {
+      case D3DXPC_STRUCT:
+        {
+            for (unsigned int arrayIndex = 0; arrayIndex < constantDescription.Elements; arrayIndex++)
+            {
+                for (unsigned int field = 0; field < constantDescription.StructMembers; field++)
+                {
+                    D3DXHANDLE fieldHandle = mConstantTablePS->GetConstant(constantHandle, field);
+
+                    D3DXCONSTANT_DESC fieldDescription;
+                    UINT descriptionCount = 1;
+
+                    HRESULT result = mConstantTablePS->GetConstantDesc(fieldHandle, &fieldDescription, &descriptionCount);
+                    ASSERT(SUCCEEDED(result));
+
+                    std::string structIndex = (constantDescription.Elements > 1) ? ("[" + str(arrayIndex) + "]") : "";
+
+                    if (!defineUniform(shader, fieldHandle, fieldDescription, name + constantDescription.Name + structIndex + "."))
+                    {
+                        return false;
+                    }
+                }
+            }
+
+            return true;
+        }
+      case D3DXPC_SCALAR:
+      case D3DXPC_VECTOR:
+      case D3DXPC_MATRIX_COLUMNS:
+      case D3DXPC_OBJECT:
+        return defineUniform(shader, constantDescription, name + constantDescription.Name);
+      default:
+        UNREACHABLE();
+        return false;
+    }
+}
+
+bool ProgramBinary::defineUniform(GLenum shader, const D3DXCONSTANT_DESC &constantDescription, const std::string &_name)
+{
+    Uniform *uniform = createUniform(constantDescription, _name);
+
+    if(!uniform)
+    {
+        return false;
+    }
+
+    // Check if already defined
+    GLint location = getUniformLocation(uniform->name);
+    GLenum type = uniform->type;
+
+    if (location >= 0)
+    {
+        delete uniform;
+        uniform = mUniforms[mUniformIndex[location].index];
+    }
+
+    if (shader == GL_FRAGMENT_SHADER) uniform->ps.set(constantDescription);
+    if (shader == GL_VERTEX_SHADER)   uniform->vs.set(constantDescription);
+
+    if (location >= 0)
+    {
+        return uniform->type == type;
+    }
+
+    mUniforms.push_back(uniform);
+    unsigned int uniformIndex = mUniforms.size() - 1;
+
+    for (unsigned int i = 0; i < uniform->arraySize; ++i)
+    {
+        mUniformIndex.push_back(UniformLocation(_name, i, uniformIndex));
+    }
+
+    return true;
+}
+
+Uniform *ProgramBinary::createUniform(const D3DXCONSTANT_DESC &constantDescription, const std::string &_name)
+{
+    if (constantDescription.Rows == 1)   // Vectors and scalars
+    {
+        switch (constantDescription.Type)
+        {
+          case D3DXPT_SAMPLER2D:
+            switch (constantDescription.Columns)
+            {
+              case 1: return new Uniform(GL_SAMPLER_2D, _name, constantDescription.Elements);
+              default: UNREACHABLE();
+            }
+            break;
+          case D3DXPT_SAMPLERCUBE:
+            switch (constantDescription.Columns)
+            {
+              case 1: return new Uniform(GL_SAMPLER_CUBE, _name, constantDescription.Elements);
+              default: UNREACHABLE();
+            }
+            break;
+          case D3DXPT_BOOL:
+            switch (constantDescription.Columns)
+            {
+              case 1: return new Uniform(GL_BOOL, _name, constantDescription.Elements);
+              case 2: return new Uniform(GL_BOOL_VEC2, _name, constantDescription.Elements);
+              case 3: return new Uniform(GL_BOOL_VEC3, _name, constantDescription.Elements);
+              case 4: return new Uniform(GL_BOOL_VEC4, _name, constantDescription.Elements);
+              default: UNREACHABLE();
+            }
+            break;
+          case D3DXPT_INT:
+            switch (constantDescription.Columns)
+            {
+              case 1: return new Uniform(GL_INT, _name, constantDescription.Elements);
+              case 2: return new Uniform(GL_INT_VEC2, _name, constantDescription.Elements);
+              case 3: return new Uniform(GL_INT_VEC3, _name, constantDescription.Elements);
+              case 4: return new Uniform(GL_INT_VEC4, _name, constantDescription.Elements);
+              default: UNREACHABLE();
+            }
+            break;
+          case D3DXPT_FLOAT:
+            switch (constantDescription.Columns)
+            {
+              case 1: return new Uniform(GL_FLOAT, _name, constantDescription.Elements);
+              case 2: return new Uniform(GL_FLOAT_VEC2, _name, constantDescription.Elements);
+              case 3: return new Uniform(GL_FLOAT_VEC3, _name, constantDescription.Elements);
+              case 4: return new Uniform(GL_FLOAT_VEC4, _name, constantDescription.Elements);
+              default: UNREACHABLE();
+            }
+            break;
+          default:
+            UNREACHABLE();
+        }
+    }
+    else if (constantDescription.Rows == constantDescription.Columns)  // Square matrices
+    {
+        switch (constantDescription.Type)
+        {
+          case D3DXPT_FLOAT:
+            switch (constantDescription.Rows)
+            {
+              case 2: return new Uniform(GL_FLOAT_MAT2, _name, constantDescription.Elements);
+              case 3: return new Uniform(GL_FLOAT_MAT3, _name, constantDescription.Elements);
+              case 4: return new Uniform(GL_FLOAT_MAT4, _name, constantDescription.Elements);
+              default: UNREACHABLE();
+            }
+            break;
+          default: UNREACHABLE();
+        }
+    }
+    else UNREACHABLE();
+
+    return 0;
+}
+
+// This method needs to match OutputHLSL::decorate
+std::string ProgramBinary::decorateAttribute(const std::string &name)
+{
+    if (name.compare(0, 3, "gl_") != 0 && name.compare(0, 3, "dx_") != 0)
+    {
+        return "_" + name;
+    }
+    
+    return name;
+}
+
+std::string ProgramBinary::undecorateUniform(const std::string &_name)
+{
+    std::string name = _name;
+    
+    // Remove any structure field decoration
+    size_t pos = 0;
+    while ((pos = name.find("._", pos)) != std::string::npos)
+    {
+        name.replace(pos, 2, ".");
+    }
+
+    // Remove the leading decoration
+    if (name[0] == '_')
+    {
+        return name.substr(1);
+    }
+    else if (name.compare(0, 3, "ar_") == 0)
+    {
+        return name.substr(3);
+    }
+    
+    return name;
+}
+
+void ProgramBinary::applyUniformnbv(Uniform *targetUniform, GLsizei count, int width, const GLboolean *v)
+{
+    float vector[D3D9_MAX_FLOAT_CONSTANTS * 4];
+    BOOL boolVector[D3D9_MAX_BOOL_CONSTANTS];
+
+    if (targetUniform->ps.float4Index >= 0 || targetUniform->vs.float4Index >= 0)
+    {
+        ASSERT(count <= D3D9_MAX_FLOAT_CONSTANTS);
+        for (int i = 0; i < count; i++)
+        {
+            for (int j = 0; j < 4; j++)
+            {
+                if (j < width)
+                {
+                    vector[i * 4 + j] = (v[i * width + j] == GL_FALSE) ? 0.0f : 1.0f;
+                }
+                else
+                {
+                    vector[i * 4 + j] = 0.0f;
+                }
+            }
+        }
+    }
+
+    if (targetUniform->ps.boolIndex >= 0 || targetUniform->vs.boolIndex >= 0)
+    {
+        int psCount = targetUniform->ps.boolIndex >= 0 ? targetUniform->ps.registerCount : 0;
+        int vsCount = targetUniform->vs.boolIndex >= 0 ? targetUniform->vs.registerCount : 0;
+        int copyCount = std::min(count * width, std::max(psCount, vsCount));
+        ASSERT(copyCount <= D3D9_MAX_BOOL_CONSTANTS);
+        for (int i = 0; i < copyCount; i++)
+        {
+            boolVector[i] = v[i] != GL_FALSE;
+        }
+    }
+
+    if (targetUniform->ps.float4Index >= 0)
+    {
+        mDevice->SetPixelShaderConstantF(targetUniform->ps.float4Index, vector, targetUniform->ps.registerCount);
+    }
+        
+    if (targetUniform->ps.boolIndex >= 0)
+    {
+        mDevice->SetPixelShaderConstantB(targetUniform->ps.boolIndex, boolVector, targetUniform->ps.registerCount);
+    }
+    
+    if (targetUniform->vs.float4Index >= 0)
+    {
+        mDevice->SetVertexShaderConstantF(targetUniform->vs.float4Index, vector, targetUniform->vs.registerCount);
+    }
+        
+    if (targetUniform->vs.boolIndex >= 0)
+    {
+        mDevice->SetVertexShaderConstantB(targetUniform->vs.boolIndex, boolVector, targetUniform->vs.registerCount);
+    }
+}
+
+bool ProgramBinary::applyUniformnfv(Uniform *targetUniform, const GLfloat *v)
+{
+    if (targetUniform->ps.registerCount)
+    {
+        mDevice->SetPixelShaderConstantF(targetUniform->ps.float4Index, v, targetUniform->ps.registerCount);
+    }
+
+    if (targetUniform->vs.registerCount)
+    {
+        mDevice->SetVertexShaderConstantF(targetUniform->vs.float4Index, v, targetUniform->vs.registerCount);
+    }
+
+    return true;
+}
+
+bool ProgramBinary::applyUniform1iv(Uniform *targetUniform, GLsizei count, const GLint *v)
+{
+    ASSERT(count <= D3D9_MAX_FLOAT_CONSTANTS);
+    D3DXVECTOR4 vector[D3D9_MAX_FLOAT_CONSTANTS];
+
+    for (int i = 0; i < count; i++)
+    {
+        vector[i] = D3DXVECTOR4((float)v[i], 0, 0, 0);
+    }
+
+    if (targetUniform->ps.registerCount)
+    {
+        if (targetUniform->ps.samplerIndex >= 0)
+        {
+            unsigned int firstIndex = targetUniform->ps.samplerIndex;
+
+            for (int i = 0; i < count; i++)
+            {
+                unsigned int samplerIndex = firstIndex + i;
+
+                if (samplerIndex < MAX_TEXTURE_IMAGE_UNITS)
+                {
+                    ASSERT(mSamplersPS[samplerIndex].active);
+                    mSamplersPS[samplerIndex].logicalTextureUnit = v[i];
+                }
+            }
+        }
+        else
+        {
+            ASSERT(targetUniform->ps.float4Index >= 0);
+            mDevice->SetPixelShaderConstantF(targetUniform->ps.float4Index, (const float*)vector, targetUniform->ps.registerCount);
+        }
+    }
+
+    if (targetUniform->vs.registerCount)
+    {
+        if (targetUniform->vs.samplerIndex >= 0)
+        {
+            unsigned int firstIndex = targetUniform->vs.samplerIndex;
+
+            for (int i = 0; i < count; i++)
+            {
+                unsigned int samplerIndex = firstIndex + i;
+
+                if (samplerIndex < MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF)
+                {
+                    ASSERT(mSamplersVS[samplerIndex].active);
+                    mSamplersVS[samplerIndex].logicalTextureUnit = v[i];
+                }
+            }
+        }
+        else
+        {
+            ASSERT(targetUniform->vs.float4Index >= 0);
+            mDevice->SetVertexShaderConstantF(targetUniform->vs.float4Index, (const float *)vector, targetUniform->vs.registerCount);
+        }
+    }
+
+    return true;
+}
+
+bool ProgramBinary::applyUniform2iv(Uniform *targetUniform, GLsizei count, const GLint *v)
+{
+    ASSERT(count <= D3D9_MAX_FLOAT_CONSTANTS);
+    D3DXVECTOR4 vector[D3D9_MAX_FLOAT_CONSTANTS];
+
+    for (int i = 0; i < count; i++)
+    {
+        vector[i] = D3DXVECTOR4((float)v[0], (float)v[1], 0, 0);
+
+        v += 2;
+    }
+
+    applyUniformniv(targetUniform, count, vector);
+
+    return true;
+}
+
+bool ProgramBinary::applyUniform3iv(Uniform *targetUniform, GLsizei count, const GLint *v)
+{
+    ASSERT(count <= D3D9_MAX_FLOAT_CONSTANTS);
+    D3DXVECTOR4 vector[D3D9_MAX_FLOAT_CONSTANTS];
+
+    for (int i = 0; i < count; i++)
+    {
+        vector[i] = D3DXVECTOR4((float)v[0], (float)v[1], (float)v[2], 0);
+
+        v += 3;
+    }
+
+    applyUniformniv(targetUniform, count, vector);
+
+    return true;
+}
+
+bool ProgramBinary::applyUniform4iv(Uniform *targetUniform, GLsizei count, const GLint *v)
+{
+    ASSERT(count <= D3D9_MAX_FLOAT_CONSTANTS);
+    D3DXVECTOR4 vector[D3D9_MAX_FLOAT_CONSTANTS];
+
+    for (int i = 0; i < count; i++)
+    {
+        vector[i] = D3DXVECTOR4((float)v[0], (float)v[1], (float)v[2], (float)v[3]);
+
+        v += 4;
+    }
+
+    applyUniformniv(targetUniform, count, vector);
+
+    return true;
+}
+
+void ProgramBinary::applyUniformniv(Uniform *targetUniform, GLsizei count, const D3DXVECTOR4 *vector)
+{
+    if (targetUniform->ps.registerCount)
+    {
+        ASSERT(targetUniform->ps.float4Index >= 0);
+        mDevice->SetPixelShaderConstantF(targetUniform->ps.float4Index, (const float *)vector, targetUniform->ps.registerCount);
+    }
+
+    if (targetUniform->vs.registerCount)
+    {
+        ASSERT(targetUniform->vs.float4Index >= 0);
+        mDevice->SetVertexShaderConstantF(targetUniform->vs.float4Index, (const float *)vector, targetUniform->vs.registerCount);
+    }
+}
+
+// append a santized message to the program info log.
+// The D3D compiler includes a fake file path in some of the warning or error 
+// messages, so lets remove all occurrences of this fake file path from the log.
+void ProgramBinary::appendToInfoLogSanitized(const char *message)
+{
+    std::string msg(message);
+
+    size_t found;
+    do
+    {
+        found = msg.find(fakepath);
+        if (found != std::string::npos)
+        {
+            msg.erase(found, strlen(fakepath));
+        }
+    }
+    while (found != std::string::npos);
+
+    appendToInfoLog("%s\n", msg.c_str());
+}
+
+void ProgramBinary::appendToInfoLog(const char *format, ...)
+{
+    if (!format)
+    {
+        return;
+    }
+
+    char info[1024];
+
+    va_list vararg;
+    va_start(vararg, format);
+    vsnprintf(info, sizeof(info), format, vararg);
+    va_end(vararg);
+
+    size_t infoLength = strlen(info);
+
+    if (!mInfoLog)
+    {
+        mInfoLog = new char[infoLength + 1];
+        strcpy(mInfoLog, info);
+    }
+    else
+    {
+        size_t logLength = strlen(mInfoLog);
+        char *newLog = new char[logLength + infoLength + 1];
+        strcpy(newLog, mInfoLog);
+        strcpy(newLog + logLength, info);
+
+        delete[] mInfoLog;
+        mInfoLog = newLog;
+    }
+}
+
+void ProgramBinary::resetInfoLog()
+{
+    if (mInfoLog)
+    {
+        delete [] mInfoLog;
+        mInfoLog = NULL;
+    }
+}
+
+bool ProgramBinary::isValidated() const 
+{
+    return mValidated;
+}
+
+int ProgramBinary::getInfoLogLength() const
+{
+    if (!mInfoLog)
+    {
+        return 0;
+    }
+    else
+    {
+       return strlen(mInfoLog) + 1;
+    }
+}
+
+void ProgramBinary::getInfoLog(GLsizei bufSize, GLsizei *length, char *infoLog)
+{
+    int index = 0;
+
+    if (bufSize > 0)
+    {
+        if (mInfoLog)
+        {
+            index = std::min(bufSize - 1, (int)strlen(mInfoLog));
+            memcpy(infoLog, mInfoLog, index);
+        }
+
+        infoLog[index] = '\0';
+    }
+
+    if (length)
+    {
+        *length = index;
+    }
+}
+
+void ProgramBinary::getActiveAttribute(GLuint index, GLsizei bufsize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
+{
+    // Skip over inactive attributes
+    unsigned int activeAttribute = 0;
+    unsigned int attribute;
+    for (attribute = 0; attribute < MAX_VERTEX_ATTRIBS; attribute++)
+    {
+        if (mLinkedAttribute[attribute].name.empty())
+        {
+            continue;
+        }
+
+        if (activeAttribute == index)
+        {
+            break;
+        }
+
+        activeAttribute++;
+    }
+
+    if (bufsize > 0)
+    {
+        const char *string = mLinkedAttribute[attribute].name.c_str();
+
+        strncpy(name, string, bufsize);
+        name[bufsize - 1] = '\0';
+
+        if (length)
+        {
+            *length = strlen(name);
+        }
+    }
+
+    *size = 1;   // Always a single 'type' instance
+
+    *type = mLinkedAttribute[attribute].type;
+}
+
+GLint ProgramBinary::getActiveAttributeCount()
+{
+    int count = 0;
+
+    for (int attributeIndex = 0; attributeIndex < MAX_VERTEX_ATTRIBS; attributeIndex++)
+    {
+        if (!mLinkedAttribute[attributeIndex].name.empty())
+        {
+            count++;
+        }
+    }
+
+    return count;
+}
+
+GLint ProgramBinary::getActiveAttributeMaxLength()
+{
+    int maxLength = 0;
+
+    for (int attributeIndex = 0; attributeIndex < MAX_VERTEX_ATTRIBS; attributeIndex++)
+    {
+        if (!mLinkedAttribute[attributeIndex].name.empty())
+        {
+            maxLength = std::max((int)(mLinkedAttribute[attributeIndex].name.length() + 1), maxLength);
+        }
+    }
+
+    return maxLength;
+}
+
+void ProgramBinary::getActiveUniform(GLuint index, GLsizei bufsize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
+{
+    // Skip over internal uniforms
+    unsigned int activeUniform = 0;
+    unsigned int uniform;
+    for (uniform = 0; uniform < mUniforms.size(); uniform++)
+    {
+        if (mUniforms[uniform]->name.compare(0, 3, "dx_") == 0)
+        {
+            continue;
+        }
+
+        if (activeUniform == index)
+        {
+            break;
+        }
+
+        activeUniform++;
+    }
+
+    ASSERT(uniform < mUniforms.size());   // index must be smaller than getActiveUniformCount()
+
+    if (bufsize > 0)
+    {
+        std::string string = mUniforms[uniform]->name;
+
+        if (mUniforms[uniform]->isArray())
+        {
+            string += "[0]";
+        }
+
+        strncpy(name, string.c_str(), bufsize);
+        name[bufsize - 1] = '\0';
+
+        if (length)
+        {
+            *length = strlen(name);
+        }
+    }
+
+    *size = mUniforms[uniform]->arraySize;
+
+    *type = mUniforms[uniform]->type;
+}
+
+GLint ProgramBinary::getActiveUniformCount()
+{
+    int count = 0;
+
+    unsigned int numUniforms = mUniforms.size();
+    for (unsigned int uniformIndex = 0; uniformIndex < numUniforms; uniformIndex++)
+    {
+        if (mUniforms[uniformIndex]->name.compare(0, 3, "dx_") != 0)
+        {
+            count++;
+        }
+    }
+
+    return count;
+}
+
+GLint ProgramBinary::getActiveUniformMaxLength()
+{
+    int maxLength = 0;
+
+    unsigned int numUniforms = mUniforms.size();
+    for (unsigned int uniformIndex = 0; uniformIndex < numUniforms; uniformIndex++)
+    {
+        if (!mUniforms[uniformIndex]->name.empty() && mUniforms[uniformIndex]->name.compare(0, 3, "dx_") != 0)
+        {
+            int length = (int)(mUniforms[uniformIndex]->name.length() + 1);
+            if (mUniforms[uniformIndex]->isArray())
+            {
+                length += 3;  // Counting in "[0]".
+            }
+            maxLength = std::max(length, maxLength);
+        }
+    }
+
+    return maxLength;
+}
+
+void ProgramBinary::validate()
+{
+    resetInfoLog();
+
+    applyUniforms();
+    if (!validateSamplers(true))
+    {
+        mValidated = false;
+    }
+    else
+    {
+        mValidated = true;
+    }
+}
+
+bool ProgramBinary::validateSamplers(bool logErrors)
+{
+    // if any two active samplers in a program are of different types, but refer to the same
+    // texture image unit, and this is the current program, then ValidateProgram will fail, and
+    // DrawArrays and DrawElements will issue the INVALID_OPERATION error.
+
+    const unsigned int maxCombinedTextureImageUnits = getContext()->getMaximumCombinedTextureImageUnits();
+    TextureType textureUnitType[MAX_COMBINED_TEXTURE_IMAGE_UNITS_VTF];
+
+    for (unsigned int i = 0; i < MAX_COMBINED_TEXTURE_IMAGE_UNITS_VTF; ++i)
+    {
+        textureUnitType[i] = TEXTURE_UNKNOWN;
+    }
+
+    for (unsigned int i = 0; i < mUsedPixelSamplerRange; ++i)
+    {
+        if (mSamplersPS[i].active)
+        {
+            unsigned int unit = mSamplersPS[i].logicalTextureUnit;
+            
+            if (unit >= maxCombinedTextureImageUnits)
+            {
+                if (logErrors)
+                {
+                    appendToInfoLog("Sampler uniform (%d) exceeds MAX_COMBINED_TEXTURE_IMAGE_UNITS (%d)", unit, maxCombinedTextureImageUnits);
+                }
+
+                return false;
+            }
+
+            if (textureUnitType[unit] != TEXTURE_UNKNOWN)
+            {
+                if (mSamplersPS[i].textureType != textureUnitType[unit])
+                {
+                    if (logErrors)
+                    {
+                        appendToInfoLog("Samplers of conflicting types refer to the same texture image unit (%d).", unit);
+                    }
+
+                    return false;
+                }
+            }
+            else
+            {
+                textureUnitType[unit] = mSamplersPS[i].textureType;
+            }
+        }
+    }
+
+    for (unsigned int i = 0; i < mUsedVertexSamplerRange; ++i)
+    {
+        if (mSamplersVS[i].active)
+        {
+            unsigned int unit = mSamplersVS[i].logicalTextureUnit;
+            
+            if (unit >= maxCombinedTextureImageUnits)
+            {
+                if (logErrors)
+                {
+                    appendToInfoLog("Sampler uniform (%d) exceeds MAX_COMBINED_TEXTURE_IMAGE_UNITS (%d)", unit, maxCombinedTextureImageUnits);
+                }
+
+                return false;
+            }
+
+            if (textureUnitType[unit] != TEXTURE_UNKNOWN)
+            {
+                if (mSamplersVS[i].textureType != textureUnitType[unit])
+                {
+                    if (logErrors)
+                    {
+                        appendToInfoLog("Samplers of conflicting types refer to the same texture image unit (%d).", unit);
+                    }
+
+                    return false;
+                }
+            }
+            else
+            {
+                textureUnitType[unit] = mSamplersVS[i].textureType;
+            }
+        }
+    }
+
+    return true;
+}
+
+GLint ProgramBinary::getDxDepthRangeLocation() const
+{
+    return mDxDepthRangeLocation;
+}
+
+GLint ProgramBinary::getDxDepthLocation() const
+{
+    return mDxDepthLocation;
+}
+
+GLint ProgramBinary::getDxCoordLocation() const
+{
+    return mDxCoordLocation;
+}
+
+GLint ProgramBinary::getDxHalfPixelSizeLocation() const
+{
+    return mDxHalfPixelSizeLocation;
+}
+
+GLint ProgramBinary::getDxFrontCCWLocation() const
+{
+    return mDxFrontCCWLocation;
+}
+
+GLint ProgramBinary::getDxPointsOrLinesLocation() const
+{
+    return mDxPointsOrLinesLocation;
+}
+
+}
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/ProgramBinary.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/angle/src/libGLESv2/ProgramBinary.h	Sat Jun 09 12:08:28 2012 +0900
@@ -0,0 +1,220 @@
+//
+// Copyright (c) 2002-2012 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+// Program.h: Defines the gl::Program class. Implements GL program objects
+// and related functionality. [OpenGL ES 2.0.24] section 2.10.3 page 28.
+
+#ifndef LIBGLESV2_PROGRAM_BINARY_H_
+#define LIBGLESV2_PROGRAM_BINARY_H_
+
+#include <d3dx9.h>
+#include <d3dcompiler.h>
+#include <string>
+#include <vector>
+
+#include "libGLESv2/Shader.h"
+#include "libGLESv2/Context.h"
+
+namespace gl
+{
+class FragmentShader;
+class VertexShader;
+
+// Helper struct representing a single shader uniform
+struct Uniform
+{
+    Uniform(GLenum type, const std::string &_name, unsigned int arraySize);
+
+    ~Uniform();
+
+    bool isArray();
+
+    const GLenum type;
+    const std::string _name;   // Decorated name
+    const std::string name;    // Undecorated name
+    const unsigned int arraySize;
+
+    unsigned char *data;
+    bool dirty;
+
+    struct RegisterInfo
+    {
+        RegisterInfo()
+        {
+            float4Index = -1;
+            samplerIndex = -1;
+            boolIndex = -1;
+            registerCount = 0;
+        }
+
+        void set(const D3DXCONSTANT_DESC &constantDescription)
+        {
+            switch(constantDescription.RegisterSet)
+            {
+              case D3DXRS_BOOL:    boolIndex = constantDescription.RegisterIndex;    break;
+              case D3DXRS_FLOAT4:  float4Index = constantDescription.RegisterIndex;  break;
+              case D3DXRS_SAMPLER: samplerIndex = constantDescription.RegisterIndex; break;
+              default: UNREACHABLE();
+            }
+            
+            ASSERT(registerCount == 0 || registerCount == (int)constantDescription.RegisterCount);
+            registerCount = constantDescription.RegisterCount;
+        }
+
+        int float4Index;
+        int samplerIndex;
+        int boolIndex;
+
+        int registerCount;
+    };
+
+    RegisterInfo ps;
+    RegisterInfo vs;
+};
+
+// Struct used for correlating uniforms/elements of uniform arrays to handles
+struct UniformLocation
+{
+    UniformLocation(const std::string &_name, unsigned int element, unsigned int index);
+
+    std::string name;
+    unsigned int element;
+    unsigned int index;
+};
+
+// This is the result of linking a program. It is the state that would be passed to ProgramBinary.
+class ProgramBinary
+{
+  public:
+    ProgramBinary();
+    ~ProgramBinary();
+
+    IDirect3DPixelShader9 *getPixelShader();
+    IDirect3DVertexShader9 *getVertexShader();
+
+    GLuint getAttributeLocation(const char *name);
+    int getSemanticIndex(int attributeIndex);
+
+    GLint getSamplerMapping(SamplerType type, unsigned int samplerIndex);
+    TextureType getSamplerTextureType(SamplerType type, unsigned int samplerIndex);
+    GLint getUsedSamplerRange(SamplerType type);
+
+    GLint getUniformLocation(std::string name);
+    bool setUniform1fv(GLint location, GLsizei count, const GLfloat *v);
+    bool setUniform2fv(GLint location, GLsizei count, const GLfloat *v);
+    bool setUniform3fv(GLint location, GLsizei count, const GLfloat *v);
+    bool setUniform4fv(GLint location, GLsizei count, const GLfloat *v);
+    bool setUniformMatrix2fv(GLint location, GLsizei count, const GLfloat *value);
+    bool setUniformMatrix3fv(GLint location, GLsizei count, const GLfloat *value);
+    bool setUniformMatrix4fv(GLint location, GLsizei count, const GLfloat *value);
+    bool setUniform1iv(GLint location, GLsizei count, const GLint *v);
+    bool setUniform2iv(GLint location, GLsizei count, const GLint *v);
+    bool setUniform3iv(GLint location, GLsizei count, const GLint *v);
+    bool setUniform4iv(GLint location, GLsizei count, const GLint *v);
+
+    bool getUniformfv(GLint location, GLsizei *bufSize, GLfloat *params);
+    bool getUniformiv(GLint location, GLsizei *bufSize, GLint *params);
+
+    GLint getDxDepthRangeLocation() const;
+    GLint getDxDepthLocation() const;
+    GLint getDxCoordLocation() const;
+    GLint getDxHalfPixelSizeLocation() const;
+    GLint getDxFrontCCWLocation() const;
+    GLint getDxPointsOrLinesLocation() const;
+
+    void dirtyAllUniforms();
+    void applyUniforms();
+
+    bool link(const AttributeBindings &attributeBindings, FragmentShader *fragmentShader, VertexShader *vertexShader);
+    int getInfoLogLength() const;
+    void getInfoLog(GLsizei bufSize, GLsizei *length, char *infoLog);
+    void getAttachedShaders(GLsizei maxCount, GLsizei *count, GLuint *shaders);
+
+    void getActiveAttribute(GLuint index, GLsizei bufsize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
+    GLint getActiveAttributeCount();
+    GLint getActiveAttributeMaxLength();
+
+    void getActiveUniform(GLuint index, GLsizei bufsize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
+    GLint getActiveUniformCount();
+    GLint getActiveUniformMaxLength();
+
+    void validate();
+    bool validateSamplers(bool logErrors);
+    bool isValidated() const;
+
+    static std::string decorateAttribute(const std::string &name);    // Prepend an underscore
+    static std::string undecorateUniform(const std::string &_name);   // Remove leading underscore
+
+  private:
+    DISALLOW_COPY_AND_ASSIGN(ProgramBinary);
+
+    ID3D10Blob *compileToBinary(const char *hlsl, const char *profile, ID3DXConstantTable **constantTable);
+
+    int packVaryings(const Varying *packing[][4], FragmentShader *fragmentShader);
+    bool linkVaryings(std::string& pixelHLSL, std::string& vertexHLSL, FragmentShader *fragmentShader, VertexShader *vertexShader);
+
+    bool linkAttributes(const AttributeBindings &attributeBindings, FragmentShader *fragmentShader, VertexShader *vertexShader);
+
+    bool linkUniforms(GLenum shader, ID3DXConstantTable *constantTable);
+    bool defineUniform(GLenum shader, const D3DXHANDLE &constantHandle, const D3DXCONSTANT_DESC &constantDescription, std::string name = "");
+    bool defineUniform(GLenum shader, const D3DXCONSTANT_DESC &constantDescription, const std::string &name);
+    Uniform *createUniform(const D3DXCONSTANT_DESC &constantDescription, const std::string &name);
+    bool applyUniformnfv(Uniform *targetUniform, const GLfloat *v);
+    bool applyUniform1iv(Uniform *targetUniform, GLsizei count, const GLint *v);
+    bool applyUniform2iv(Uniform *targetUniform, GLsizei count, const GLint *v);
+    bool applyUniform3iv(Uniform *targetUniform, GLsizei count, const GLint *v);
+    bool applyUniform4iv(Uniform *targetUniform, GLsizei count, const GLint *v);
+    void applyUniformniv(Uniform *targetUniform, GLsizei count, const D3DXVECTOR4 *vector);
+    void applyUniformnbv(Uniform *targetUniform, GLsizei count, int width, const GLboolean *v);
+
+    void appendToInfoLogSanitized(const char *message);
+    void appendToInfoLog(const char *info, ...);
+    void resetInfoLog();
+
+    static unsigned int issueSerial();
+
+    IDirect3DDevice9 *mDevice;
+
+    IDirect3DPixelShader9 *mPixelExecutable;
+    IDirect3DVertexShader9 *mVertexExecutable;
+
+    // These are only used during linking.
+    ID3DXConstantTable *mConstantTablePS;
+    ID3DXConstantTable *mConstantTableVS;
+
+    Attribute mLinkedAttribute[MAX_VERTEX_ATTRIBS];
+    int mSemanticIndex[MAX_VERTEX_ATTRIBS];
+
+    struct Sampler
+    {
+        bool active;
+        GLint logicalTextureUnit;
+        TextureType textureType;
+    };
+
+    Sampler mSamplersPS[MAX_TEXTURE_IMAGE_UNITS];
+    Sampler mSamplersVS[MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF];
+    GLuint mUsedVertexSamplerRange;
+    GLuint mUsedPixelSamplerRange;
+
+    typedef std::vector<Uniform*> UniformArray;
+    UniformArray mUniforms;
+    typedef std::vector<UniformLocation> UniformIndex;
+    UniformIndex mUniformIndex;
+
+    GLint mDxDepthRangeLocation;
+    GLint mDxDepthLocation;
+    GLint mDxCoordLocation;
+    GLint mDxHalfPixelSizeLocation;
+    GLint mDxFrontCCWLocation;
+    GLint mDxPointsOrLinesLocation;
+
+    char *mInfoLog;
+    bool mValidated;
+};
+}
+
+#endif   // LIBGLESV2_PROGRAM_BINARY_H_
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/Renderbuffer.cpp
--- a/gfx/angle/src/libGLESv2/Renderbuffer.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/Renderbuffer.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -63,68 +63,144 @@
     return dx2es::GetStencilSize(getD3DFormat());
 }
 
-RenderbufferTexture::RenderbufferTexture(Texture *texture, GLenum target) : mTarget(target)
+///// RenderbufferTexture2D Implementation ////////
+
+RenderbufferTexture2D::RenderbufferTexture2D(Texture2D *texture, GLenum target) : mTarget(target)
 {
-    mTexture.set(texture);
+    mTexture2D.set(texture);
 }
 
-RenderbufferTexture::~RenderbufferTexture()
+RenderbufferTexture2D::~RenderbufferTexture2D()
 {
-    mTexture.set(NULL);
+    mTexture2D.set(NULL);
 }
 
 // Textures need to maintain their own reference count for references via
 // Renderbuffers acting as proxies. Here, we notify the texture of a reference.
-void RenderbufferTexture::addProxyRef(const Renderbuffer *proxy)
+void RenderbufferTexture2D::addProxyRef(const Renderbuffer *proxy)
 {
-    mTexture->addProxyRef(proxy);
+    mTexture2D->addProxyRef(proxy);
 }
 
-void RenderbufferTexture::releaseProxy(const Renderbuffer *proxy)
+void RenderbufferTexture2D::releaseProxy(const Renderbuffer *proxy)
 {
-    mTexture->releaseProxy(proxy);
+    mTexture2D->releaseProxy(proxy);
 }
 
-IDirect3DSurface9 *RenderbufferTexture::getRenderTarget()
+// Increments refcount on surface.
+// caller must Release() the returned surface
+IDirect3DSurface9 *RenderbufferTexture2D::getRenderTarget()
 {
-    return mTexture->getRenderTarget(mTarget);
+    return mTexture2D->getRenderTarget(mTarget);
 }
 
-IDirect3DSurface9 *RenderbufferTexture::getDepthStencil()
+// Increments refcount on surface.
+// caller must Release() the returned surface
+IDirect3DSurface9 *RenderbufferTexture2D::getDepthStencil()
+{
+    return mTexture2D->getDepthStencil(mTarget);
+}
+
+GLsizei RenderbufferTexture2D::getWidth() const
+{
+    return mTexture2D->getWidth(0);
+}
+
+GLsizei RenderbufferTexture2D::getHeight() const
+{
+    return mTexture2D->getHeight(0);
+}
+
+GLenum RenderbufferTexture2D::getInternalFormat() const
+{
+    return mTexture2D->getInternalFormat(0);
+}
+
+D3DFORMAT RenderbufferTexture2D::getD3DFormat() const
+{
+    return mTexture2D->getD3DFormat(0);
+}
+
+GLsizei RenderbufferTexture2D::getSamples() const
+{
+    return 0;
+}
+
+unsigned int RenderbufferTexture2D::getSerial() const
+{
+    return mTexture2D->getRenderTargetSerial(mTarget);
+}
+
+///// RenderbufferTextureCubeMap Implementation ////////
+
+RenderbufferTextureCubeMap::RenderbufferTextureCubeMap(TextureCubeMap *texture, GLenum target) : mTarget(target)
+{
+    mTextureCubeMap.set(texture);
+}
+
+RenderbufferTextureCubeMap::~RenderbufferTextureCubeMap()
+{
+    mTextureCubeMap.set(NULL);
+}
+
+// Textures need to maintain their own reference count for references via
+// Renderbuffers acting as proxies. Here, we notify the texture of a reference.
+void RenderbufferTextureCubeMap::addProxyRef(const Renderbuffer *proxy)
+{
+    mTextureCubeMap->addProxyRef(proxy);
+}
+
+void RenderbufferTextureCubeMap::releaseProxy(const Renderbuffer *proxy)
+{
+    mTextureCubeMap->releaseProxy(proxy);
+}
+
+// Increments refcount on surface.
+// caller must Release() the returned surface
+IDirect3DSurface9 *RenderbufferTextureCubeMap::getRenderTarget()
+{
+    return mTextureCubeMap->getRenderTarget(mTarget);
+}
+
+// Increments refcount on surface.
+// caller must Release() the returned surface
+IDirect3DSurface9 *RenderbufferTextureCubeMap::getDepthStencil()
 {
     return NULL;
 }
 
-GLsizei RenderbufferTexture::getWidth() const
+GLsizei RenderbufferTextureCubeMap::getWidth() const
 {
-    return mTexture->getWidth(0);
-}
- 
-GLsizei RenderbufferTexture::getHeight() const
-{
-    return mTexture->getHeight(0);
-}
- 
-GLenum RenderbufferTexture::getInternalFormat() const
-{
-    return mTexture->getInternalFormat();
+    return mTextureCubeMap->getWidth(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0);
 }
 
-D3DFORMAT RenderbufferTexture::getD3DFormat() const
+GLsizei RenderbufferTextureCubeMap::getHeight() const
 {
-    return mTexture->getD3DFormat();
+    return mTextureCubeMap->getHeight(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0);
 }
 
-GLsizei RenderbufferTexture::getSamples() const
+GLenum RenderbufferTextureCubeMap::getInternalFormat() const
+{
+    return mTextureCubeMap->getInternalFormat(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0);
+}
+
+D3DFORMAT RenderbufferTextureCubeMap::getD3DFormat() const
+{
+    return mTextureCubeMap->getD3DFormat(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0);
+}
+
+GLsizei RenderbufferTextureCubeMap::getSamples() const
 {
     return 0;
 }
 
-unsigned int RenderbufferTexture::getSerial() const
+unsigned int RenderbufferTextureCubeMap::getSerial() const
 {
-    return mTexture->getRenderTargetSerial(mTarget);
+    return mTextureCubeMap->getRenderTargetSerial(mTarget);
 }
 
+////// Renderbuffer Implementation //////
+
 Renderbuffer::Renderbuffer(GLuint id, RenderbufferInterface *instance) : RefCountObject(id)
 {
     ASSERT(instance != NULL);
@@ -152,11 +228,15 @@
     RefCountObject::release();
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *Renderbuffer::getRenderTarget()
 {
     return mInstance->getRenderTarget();
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *Renderbuffer::getDepthStencil()
 {
     return mInstance->getDepthStencil();
@@ -243,11 +323,15 @@
 {
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *RenderbufferStorage::getRenderTarget()
 {
     return NULL;
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *RenderbufferStorage::getDepthStencil()
 {
     return NULL;
@@ -356,6 +440,8 @@
     }
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *Colorbuffer::getRenderTarget()
 {
     if (mRenderTarget)
@@ -428,8 +514,15 @@
     }
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *DepthStencilbuffer::getDepthStencil()
 {
+    if (mDepthStencil)
+    {
+        mDepthStencil->AddRef();
+    }
+
     return mDepthStencil;
 }
 
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/Renderbuffer.h
--- a/gfx/angle/src/libGLESv2/Renderbuffer.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/Renderbuffer.h	Sat Jun 09 12:08:28 2012 +0900
@@ -21,7 +21,8 @@
 
 namespace gl
 {
-class Texture;
+class Texture2D;
+class TextureCubeMap;
 class Renderbuffer;
 class Colorbuffer;
 class DepthStencilbuffer;
@@ -58,12 +59,12 @@
     DISALLOW_COPY_AND_ASSIGN(RenderbufferInterface);
 };
 
-class RenderbufferTexture : public RenderbufferInterface
+class RenderbufferTexture2D : public RenderbufferInterface
 {
   public:
-    RenderbufferTexture(Texture *texture, GLenum target);
+    RenderbufferTexture2D(Texture2D *texture, GLenum target);
 
-    virtual ~RenderbufferTexture();
+    virtual ~RenderbufferTexture2D();
 
     void addProxyRef(const Renderbuffer *proxy);
     void releaseProxy(const Renderbuffer *proxy);
@@ -80,9 +81,37 @@
     virtual unsigned int getSerial() const;
 
   private:
-    DISALLOW_COPY_AND_ASSIGN(RenderbufferTexture);
+    DISALLOW_COPY_AND_ASSIGN(RenderbufferTexture2D);
 
-    BindingPointer <Texture> mTexture;
+    BindingPointer <Texture2D> mTexture2D;
+    GLenum mTarget;
+};
+
+class RenderbufferTextureCubeMap : public RenderbufferInterface
+{
+  public:
+    RenderbufferTextureCubeMap(TextureCubeMap *texture, GLenum target);
+
+    virtual ~RenderbufferTextureCubeMap();
+
+    void addProxyRef(const Renderbuffer *proxy);
+    void releaseProxy(const Renderbuffer *proxy);
+
+    IDirect3DSurface9 *getRenderTarget();
+    IDirect3DSurface9 *getDepthStencil();
+
+    virtual GLsizei getWidth() const;
+    virtual GLsizei getHeight() const;
+    virtual GLenum getInternalFormat() const;
+    virtual D3DFORMAT getD3DFormat() const;
+    virtual GLsizei getSamples() const;
+
+    virtual unsigned int getSerial() const;
+
+  private:
+    DISALLOW_COPY_AND_ASSIGN(RenderbufferTextureCubeMap);
+
+    BindingPointer <TextureCubeMap> mTextureCubeMap;
     GLenum mTarget;
 };
 
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/Shader.h
--- a/gfx/angle/src/libGLESv2/Shader.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/Shader.h	Sat Jun 09 12:08:28 2012 +0900
@@ -42,7 +42,7 @@
 
 class Shader
 {
-    friend Program;
+    friend class ProgramBinary;
 
   public:
     Shader(ResourceManager *manager, GLuint handle);
@@ -128,7 +128,7 @@
 
 class VertexShader : public Shader
 {
-    friend Program;
+    friend class ProgramBinary;
 
   public:
     VertexShader(ResourceManager *manager, GLuint handle);
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/Texture.cpp
--- a/gfx/angle/src/libGLESv2/Texture.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/Texture.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -13,12 +13,6 @@
 #include <d3dx9tex.h>
 
 #include <algorithm>
-
-#if _MSC_VER <= 1400
-#define _interlockedbittestandreset _interlockedbittestandreset_NAME_CHANGED_TO_AVOID_MSVS2005_ERROR
-#define _interlockedbittestandset _interlockedbittestandset_NAME_CHANGED_TO_AVOID_MSVS2005_ERROR
-#endif
-
 #include <intrin.h>
 
 #include "common/debug.h"
@@ -37,8 +31,12 @@
 
 static D3DFORMAT ConvertTextureFormatType(GLenum format, GLenum type)
 {
-    if (format == GL_COMPRESSED_RGB_S3TC_DXT1_EXT ||
-        format == GL_COMPRESSED_RGBA_S3TC_DXT1_EXT)
+    if (IsDepthTexture(format))
+    {
+        return D3DFMT_INTZ;
+    }
+    else if (format == GL_COMPRESSED_RGB_S3TC_DXT1_EXT ||
+             format == GL_COMPRESSED_RGBA_S3TC_DXT1_EXT)
     {
         return D3DFMT_DXT1;
     }
@@ -81,6 +79,10 @@
 
 static bool IsTextureFormatRenderable(D3DFORMAT format)
 {
+    if (format == D3DFMT_INTZ)
+    {
+        return true;
+    }
     switch(format)
     {
       case D3DFMT_L8:
@@ -101,6 +103,21 @@
     return false;
 }
 
+static inline DWORD GetTextureUsage(D3DFORMAT d3dfmt, GLenum glusage, bool forceRenderable)
+{
+    DWORD d3dusage = 0;
+
+    if (d3dfmt == D3DFMT_INTZ)
+    {
+        d3dusage |= D3DUSAGE_DEPTHSTENCIL;
+    }
+    else if(forceRenderable || (IsTextureFormatRenderable(d3dfmt) && (glusage == GL_FRAMEBUFFER_ATTACHMENT_ANGLE)))
+    {
+        d3dusage |= D3DUSAGE_RENDERTARGET;
+    }
+    return d3dusage;
+}
+
 Image::Image()
 {
     mWidth = 0; 
@@ -161,6 +178,8 @@
     IDirect3DTexture9 *newTexture = NULL;
     IDirect3DSurface9 *newSurface = NULL;
     const D3DPOOL poolToUse = D3DPOOL_SYSTEMMEM;
+    const D3DFORMAT d3dFormat = getD3DFormat();
+    ASSERT(d3dFormat != D3DFMT_INTZ); // We should never get here for depth textures
 
     if (mWidth != 0 && mHeight != 0)
     {
@@ -184,7 +203,7 @@
             levelToFetch = upsampleCount;
         }
 
-        HRESULT result = getDevice()->CreateTexture(requestWidth, requestHeight, levelToFetch + 1, NULL, getD3DFormat(),
+        HRESULT result = getDevice()->CreateTexture(requestWidth, requestHeight, levelToFetch + 1, NULL, d3dFormat,
                                                     poolToUse, &newTexture, NULL);
 
         if (FAILED(result))
@@ -312,7 +331,14 @@
         switch (mFormat)
         {
           case GL_ALPHA:
-            loadAlphaData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
+            if (supportsSSE2())
+            {
+                loadAlphaDataSSE2(width, height, inputPitch, input, locked.Pitch, locked.pBits);
+            }
+            else
+            {
+                loadAlphaData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
+            }
             break;
           case GL_LUMINANCE:
             loadLuminanceData(width, height, inputPitch, input, locked.Pitch, locked.pBits, getD3DFormat() == D3DFMT_L8);
@@ -436,6 +462,46 @@
     }
 }
 
+void Image::loadAlphaDataSSE2(GLsizei width, GLsizei height,
+                              int inputPitch, const void *input, size_t outputPitch, void *output) const
+{
+    const unsigned char *source = NULL;
+    unsigned int *dest = NULL;
+    __m128i zeroWide = _mm_setzero_si128();
+
+    for (int y = 0; y < height; y++)
+    {
+        source = static_cast<const unsigned char*>(input) + y * inputPitch;
+        dest = reinterpret_cast<unsigned int*>(static_cast<unsigned char*>(output) + y * outputPitch);
+
+        int x;
+        // Make output writes aligned
+        for (x = 0; ((reinterpret_cast<intptr_t>(&dest[x]) & 0xF) != 0 && x < width); x++)
+        {
+            dest[x] = static_cast<unsigned int>(source[x]) << 24;
+        }
+
+        for (; x + 7 < width; x += 8)
+        {
+            __m128i sourceData = _mm_loadl_epi64(reinterpret_cast<const __m128i*>(&source[x]));
+            // Interleave each byte to 16bit, make the lower byte to zero
+            sourceData = _mm_unpacklo_epi8(zeroWide, sourceData);
+            // Interleave each 16bit to 32bit, make the lower 16bit to zero
+            __m128i lo = _mm_unpacklo_epi16(zeroWide, sourceData);
+            __m128i hi = _mm_unpackhi_epi16(zeroWide, sourceData);
+
+            _mm_store_si128(reinterpret_cast<__m128i*>(&dest[x]), lo);
+            _mm_store_si128(reinterpret_cast<__m128i*>(&dest[x + 4]), hi);
+        }
+
+        // Handle the remainder
+        for (; x < width; x++)
+        {
+            dest[x] = static_cast<unsigned int>(source[x]) << 24;
+        }
+    }
+}
+
 void Image::loadAlphaFloatData(GLsizei width, GLsizei height,
                                int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
@@ -1294,9 +1360,9 @@
     mDirty = true;
 }
 
-TextureStorage::TextureStorage(bool renderTarget)
-    : mRenderTarget(renderTarget),
-      mD3DPool(getDisplay()->getTexturePool(mRenderTarget)),
+TextureStorage::TextureStorage(DWORD usage)
+    : mD3DUsage(usage),
+      mD3DPool(getDisplay()->getTexturePool(usage)),
       mTextureSerial(issueTextureSerial())
 {
 }
@@ -1307,7 +1373,7 @@
 
 bool TextureStorage::isRenderTarget() const
 {
-    return mRenderTarget;
+    return (mD3DUsage & (D3DUSAGE_RENDERTARGET | D3DUSAGE_DEPTHSTENCIL)) != 0;
 }
 
 bool TextureStorage::isManaged() const
@@ -1320,6 +1386,11 @@
     return mD3DPool;
 }
 
+DWORD TextureStorage::getUsage() const
+{
+    return mD3DUsage;
+}
+
 unsigned int TextureStorage::getTextureSerial() const
 {
     return mTextureSerial;
@@ -1493,24 +1564,6 @@
 
 bool Texture::subImage(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels, Image *image)
 {
-    if (width + xoffset > image->getWidth() || height + yoffset > image->getHeight())
-    {
-        error(GL_INVALID_VALUE);
-        return false;
-    }
-
-    if (IsCompressed(image->getFormat()))
-    {
-        error(GL_INVALID_OPERATION);
-        return false;
-    }
-
-    if (format != image->getFormat())
-    {
-        error(GL_INVALID_OPERATION);
-        return false;
-    }
-
     if (pixels != NULL)
     {
         image->loadData(xoffset, yoffset, width, height, type, unpackAlignment, pixels);
@@ -1522,18 +1575,6 @@
 
 bool Texture::subImageCompressed(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *pixels, Image *image)
 {
-    if (width + xoffset > image->getWidth() || height + yoffset > image->getHeight())
-    {
-        error(GL_INVALID_VALUE);
-        return false;
-    }
-
-    if (format != getInternalFormat())
-    {
-        error(GL_INVALID_OPERATION);
-        return false;
-    }
-
     if (pixels != NULL)
     {
         image->loadCompressedData(xoffset, yoffset, width, height, pixels);
@@ -1652,23 +1693,27 @@
     return true;
 }
 
-TextureStorage2D::TextureStorage2D(IDirect3DTexture9 *surfaceTexture) : TextureStorage(true), mRenderTargetSerial(RenderbufferStorage::issueSerial())
+TextureStorage2D::TextureStorage2D(IDirect3DTexture9 *surfaceTexture) : TextureStorage(D3DUSAGE_RENDERTARGET), mRenderTargetSerial(RenderbufferStorage::issueSerial())
 {
     mTexture = surfaceTexture;
 }
 
-TextureStorage2D::TextureStorage2D(int levels, D3DFORMAT format, int width, int height, bool renderTarget)
-    : TextureStorage(renderTarget), mRenderTargetSerial(RenderbufferStorage::issueSerial())
+TextureStorage2D::TextureStorage2D(int levels, D3DFORMAT format, DWORD usage, int width, int height)
+    : TextureStorage(usage), mRenderTargetSerial(RenderbufferStorage::issueSerial())
 {
-    IDirect3DDevice9 *device = getDevice();
-
     mTexture = NULL;
-    HRESULT result = device->CreateTexture(width, height, levels, isRenderTarget() ? D3DUSAGE_RENDERTARGET : 0, format, getPool(), &mTexture, NULL);
-
-    if (FAILED(result))
+    // if the width or height is not positive this should be treated as an incomplete texture
+    // we handle that here by skipping the d3d texture creation
+    if (width > 0 && height > 0)
     {
-        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-        error(GL_OUT_OF_MEMORY);
+        IDirect3DDevice9 *device = getDevice();
+        HRESULT result = device->CreateTexture(width, height, levels, getUsage(), format, getPool(), &mTexture, NULL);
+
+        if (FAILED(result))
+        {
+            ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
+            error(GL_OUT_OF_MEMORY);
+        }
     }
 }
 
@@ -1680,6 +1725,8 @@
     }
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *TextureStorage2D::getSurfaceLevel(int level)
 {
     IDirect3DSurface9 *surface = NULL;
@@ -1763,19 +1810,20 @@
         return 0;
 }
 
-GLenum Texture2D::getInternalFormat() const
+GLenum Texture2D::getInternalFormat(GLint level) const
 {
-    return mImageArray[0].getFormat();
+    if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
+        return mImageArray[level].getFormat();
+    else
+        return GL_NONE;
 }
 
-GLenum Texture2D::getType() const
+D3DFORMAT Texture2D::getD3DFormat(GLint level) const
 {
-    return mImageArray[0].getType();
-}
-
-D3DFORMAT Texture2D::getD3DFormat() const
-{
-    return mImageArray[0].getD3DFormat();
+    if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
+        return mImageArray[level].getD3DFormat();
+    else
+        return D3DFMT_UNKNOWN;
 }
 
 void Texture2D::redefineImage(GLint level, GLenum format, GLsizei width, GLsizei height, GLenum type)
@@ -2001,10 +2049,10 @@
     GLenum format = gl::ExtractFormat(internalformat);
     GLenum type = gl::ExtractType(internalformat);
     D3DFORMAT d3dfmt = ConvertTextureFormatType(format, type);
-    const bool renderTarget = IsTextureFormatRenderable(d3dfmt) && (mUsage == GL_FRAMEBUFFER_ATTACHMENT_ANGLE);
+    DWORD d3dusage = GetTextureUsage(d3dfmt, mUsage, false);
 
     delete mTexStorage;
-    mTexStorage = new TextureStorage2D(levels, d3dfmt, width, height, renderTarget);
+    mTexStorage = new TextureStorage2D(levels, d3dfmt, d3dusage, width, height);
     mImmutable = true;
 
     for (int level = 0; level < levels; level++)
@@ -2059,8 +2107,8 @@
       default: UNREACHABLE();
     }
 
-    if ((getInternalFormat() == GL_FLOAT && !getContext()->supportsFloat32LinearFilter()) ||
-        (getInternalFormat() == GL_HALF_FLOAT_OES && !getContext()->supportsFloat16LinearFilter()))
+    if ((getInternalFormat(0) == GL_FLOAT && !getContext()->supportsFloat32LinearFilter()) ||
+        (getInternalFormat(0) == GL_HALF_FLOAT_OES && !getContext()->supportsFloat16LinearFilter()))
     {
         if (mMagFilter != GL_NEAREST || (mMinFilter != GL_NEAREST && mMinFilter != GL_NEAREST_MIPMAP_NEAREST))
         {
@@ -2142,9 +2190,14 @@
     return true;
 }
 
-bool Texture2D::isCompressed() const
+bool Texture2D::isCompressed(GLint level) const
 {
-    return IsCompressed(getInternalFormat());
+    return IsCompressed(getInternalFormat(level));
+}
+
+bool Texture2D::isDepth(GLint level) const
+{
+    return IsDepthTexture(getInternalFormat(level));
 }
 
 IDirect3DBaseTexture9 *Texture2D::getBaseTexture() const
@@ -2158,11 +2211,11 @@
     GLsizei width = mImageArray[0].getWidth();
     GLsizei height = mImageArray[0].getHeight();
     GLint levels = creationLevels(width, height);
-    D3DFORMAT format = mImageArray[0].getD3DFormat();
-    const bool renderTarget = IsTextureFormatRenderable(format) && (mUsage == GL_FRAMEBUFFER_ATTACHMENT_ANGLE);
+    D3DFORMAT d3dfmt = mImageArray[0].getD3DFormat();
+    DWORD d3dusage = GetTextureUsage(d3dfmt, mUsage, false);
 
     delete mTexStorage;
-    mTexStorage = new TextureStorage2D(levels, format, width, height, renderTarget);
+    mTexStorage = new TextureStorage2D(levels, d3dfmt, d3dusage, width, height);
     
     if (mTexStorage->isManaged())
     {
@@ -2202,9 +2255,10 @@
         GLsizei width = mImageArray[0].getWidth();
         GLsizei height = mImageArray[0].getHeight();
         GLint levels = creationLevels(width, height);
-        D3DFORMAT format = mImageArray[0].getD3DFormat();
-
-        newTexStorage = new TextureStorage2D(levels, format, width, height, true);
+        D3DFORMAT d3dfmt = mImageArray[0].getD3DFormat();
+        DWORD d3dusage = GetTextureUsage(d3dfmt, GL_FRAMEBUFFER_ATTACHMENT_ANGLE, true);
+
+        newTexStorage = new TextureStorage2D(levels, d3dfmt, d3dusage, width, height);
 
         if (mTexStorage != NULL)
         {
@@ -2217,8 +2271,8 @@
                 if (!copyToRenderTarget(dest, source, mTexStorage->isManaged()))
                 {   
                    delete newTexStorage;
-                   source->Release();
-                   dest->Release();
+                   if (source) source->Release();
+                   if (dest) dest->Release();
                    return error(GL_OUT_OF_MEMORY);
                 }
 
@@ -2300,12 +2354,14 @@
 
     if (mColorbufferProxy == NULL)
     {
-        mColorbufferProxy = new Renderbuffer(id(), new RenderbufferTexture(this, target));
+        mColorbufferProxy = new Renderbuffer(id(), new RenderbufferTexture2D(this, target));
     }
 
     return mColorbufferProxy;
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *Texture2D::getRenderTarget(GLenum target)
 {
     ASSERT(target == GL_TEXTURE_2D);
@@ -2318,6 +2374,33 @@
 
     updateTexture();
     
+    // ensure this is NOT a depth texture
+    if (isDepth(0))
+    {
+        return NULL;
+    }
+    return mTexStorage->getSurfaceLevel(0);
+}
+
+// Increments refcount on surface.
+// caller must Release() the returned surface
+IDirect3DSurface9 *Texture2D::getDepthStencil(GLenum target)
+{
+    ASSERT(target == GL_TEXTURE_2D);
+
+    // ensure the underlying texture is created
+    if (getStorage(true) == NULL)
+    {
+        return NULL;
+    }
+
+    updateTexture();
+
+    // ensure this is actually a depth texture
+    if (!isDepth(0))
+    {
+        return NULL;
+    }
     return mTexStorage->getSurfaceLevel(0);
 }
 
@@ -2338,18 +2421,22 @@
     return mTexStorage;
 }
 
-TextureStorageCubeMap::TextureStorageCubeMap(int levels, D3DFORMAT format, int size, bool renderTarget)
-    : TextureStorage(renderTarget), mFirstRenderTargetSerial(RenderbufferStorage::issueCubeSerials())
+TextureStorageCubeMap::TextureStorageCubeMap(int levels, D3DFORMAT format, DWORD usage, int size)
+    : TextureStorage(usage), mFirstRenderTargetSerial(RenderbufferStorage::issueCubeSerials())
 {
-    IDirect3DDevice9 *device = getDevice();
-
     mTexture = NULL;
-    HRESULT result = device->CreateCubeTexture(size, levels, isRenderTarget() ? D3DUSAGE_RENDERTARGET : 0, format, getPool(), &mTexture, NULL);
-
-    if (FAILED(result))
+    // if the size is not positive this should be treated as an incomplete texture
+    // we handle that here by skipping the d3d texture creation
+    if (size > 0)
     {
-        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-        error(GL_OUT_OF_MEMORY);
+        IDirect3DDevice9 *device = getDevice();
+        HRESULT result = device->CreateCubeTexture(size, levels, getUsage(), format, getPool(), &mTexture, NULL);
+
+        if (FAILED(result))
+        {
+            ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
+            error(GL_OUT_OF_MEMORY);
+        }
     }
 }
 
@@ -2361,6 +2448,8 @@
     }
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *TextureStorageCubeMap::getCubeMapSurface(GLenum faceTarget, int level)
 {
     IDirect3DSurface9 *surface = NULL;
@@ -2439,35 +2528,36 @@
     return GL_TEXTURE_CUBE_MAP;
 }
 
-GLsizei TextureCubeMap::getWidth(GLint level) const
+GLsizei TextureCubeMap::getWidth(GLenum target, GLint level) const
 {
     if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
-        return mImageArray[0][level].getWidth();
+        return mImageArray[faceIndex(target)][level].getWidth();
     else
         return 0;
 }
 
-GLsizei TextureCubeMap::getHeight(GLint level) const
+GLsizei TextureCubeMap::getHeight(GLenum target, GLint level) const
 {
     if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
-        return mImageArray[0][level].getHeight();
+        return mImageArray[faceIndex(target)][level].getHeight();
     else
         return 0;
 }
 
-GLenum TextureCubeMap::getInternalFormat() const
+GLenum TextureCubeMap::getInternalFormat(GLenum target, GLint level) const
 {
-    return mImageArray[0][0].getFormat();
+    if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
+        return mImageArray[faceIndex(target)][level].getFormat();
+    else
+        return GL_NONE;
 }
 
-GLenum TextureCubeMap::getType() const
+D3DFORMAT TextureCubeMap::getD3DFormat(GLenum target, GLint level) const
 {
-    return mImageArray[0][0].getType();
-}
-
-D3DFORMAT TextureCubeMap::getD3DFormat() const
-{
-    return mImageArray[0][0].getD3DFormat();
+    if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
+        return mImageArray[faceIndex(target)][level].getD3DFormat();
+    else
+        return D3DFMT_UNKNOWN;
 }
 
 void TextureCubeMap::setImagePosX(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
@@ -2567,8 +2657,8 @@
         return false;
     }
 
-    if ((getInternalFormat() == GL_FLOAT && !getContext()->supportsFloat32LinearFilter()) ||
-        (getInternalFormat() == GL_HALF_FLOAT_OES && !getContext()->supportsFloat16LinearFilter()))
+    if ((getInternalFormat(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0) == GL_FLOAT && !getContext()->supportsFloat32LinearFilter()) ||
+        (getInternalFormat(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0) == GL_HALF_FLOAT_OES && !getContext()->supportsFloat16LinearFilter()))
     {
         if (mMagFilter != GL_NEAREST || (mMinFilter != GL_NEAREST && mMinFilter != GL_NEAREST_MIPMAP_NEAREST))
         {
@@ -2664,9 +2754,9 @@
     return true;
 }
 
-bool TextureCubeMap::isCompressed() const
+bool TextureCubeMap::isCompressed(GLenum target, GLint level) const
 {
-    return IsCompressed(getInternalFormat());
+    return IsCompressed(getInternalFormat(target, level));
 }
 
 IDirect3DBaseTexture9 *TextureCubeMap::getBaseTexture() const
@@ -2679,11 +2769,11 @@
 {
     GLsizei size = mImageArray[0][0].getWidth();
     GLint levels = creationLevels(size, 0);
-    D3DFORMAT format = mImageArray[0][0].getD3DFormat();
-    const bool renderTarget = IsTextureFormatRenderable(format) && (mUsage == GL_FRAMEBUFFER_ATTACHMENT_ANGLE);
+    D3DFORMAT d3dfmt = mImageArray[0][0].getD3DFormat();
+    DWORD d3dusage = GetTextureUsage(d3dfmt, mUsage, false);
 
     delete mTexStorage;
-    mTexStorage = new TextureStorageCubeMap(levels, format, size, renderTarget);
+    mTexStorage = new TextureStorageCubeMap(levels, d3dfmt, d3dusage, size);
 
     if (mTexStorage->isManaged())
     {
@@ -2727,9 +2817,10 @@
     {
         GLsizei size = mImageArray[0][0].getWidth();
         GLint levels = creationLevels(size, 0);
-        D3DFORMAT format = mImageArray[0][0].getD3DFormat();
-
-        newTexStorage = new TextureStorageCubeMap(levels, format, size, true);
+        D3DFORMAT d3dfmt = mImageArray[0][0].getD3DFormat();
+        DWORD d3dusage = GetTextureUsage(d3dfmt, GL_FRAMEBUFFER_ATTACHMENT_ANGLE, true);
+
+        newTexStorage = new TextureStorageCubeMap(levels, d3dfmt, d3dusage, size);
 
         if (mTexStorage != NULL)
         {
@@ -2744,8 +2835,8 @@
                     if (!copyToRenderTarget(dest, source, mTexStorage->isManaged()))
                     {
                        delete newTexStorage;
-                       source->Release();
-                       dest->Release();
+                       if (source) source->Release();
+                       if (dest) dest->Release();
                        return error(GL_OUT_OF_MEMORY);
                     }
 
@@ -2914,10 +3005,10 @@
     GLenum format = gl::ExtractFormat(internalformat);
     GLenum type = gl::ExtractType(internalformat);
     D3DFORMAT d3dfmt = ConvertTextureFormatType(format, type);
-    const bool renderTarget = IsTextureFormatRenderable(d3dfmt) && (mUsage == GL_FRAMEBUFFER_ATTACHMENT_ANGLE);
+    DWORD d3dusage = GetTextureUsage(d3dfmt, mUsage, false);
 
     delete mTexStorage;
-    mTexStorage = new TextureStorageCubeMap(levels, d3dfmt, size, renderTarget);
+    mTexStorage = new TextureStorageCubeMap(levels, d3dfmt, d3dusage, size);
     mImmutable = true;
 
     for (int level = 0; level < levels; level++)
@@ -3034,12 +3125,14 @@
 
     if (mFaceProxies[face] == NULL)
     {
-        mFaceProxies[face] = new Renderbuffer(id(), new RenderbufferTexture(this, target));
+        mFaceProxies[face] = new Renderbuffer(id(), new RenderbufferTextureCubeMap(this, target));
     }
 
     return mFaceProxies[face];
 }
 
+// Increments refcount on surface.
+// caller must Release() the returned surface
 IDirect3DSurface9 *TextureCubeMap::getRenderTarget(GLenum target)
 {
     ASSERT(IsCubemapTextureTarget(target));
@@ -3072,4 +3165,4 @@
     return mTexStorage;
 }
 
-}
\ No newline at end of file
+}
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/Texture.h
--- a/gfx/angle/src/libGLESv2/Texture.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/Texture.h	Sat Jun 09 12:08:28 2012 +0900
@@ -71,6 +71,8 @@
 
     void loadAlphaData(GLsizei width, GLsizei height,
                        int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadAlphaDataSSE2(GLsizei width, GLsizei height,
+                           int inputPitch, const void *input, size_t outputPitch, void *output) const;
     void loadAlphaFloatData(GLsizei width, GLsizei height,
                             int inputPitch, const void *input, size_t outputPitch, void *output) const;
     void loadAlphaHalfFloatData(GLsizei width, GLsizei height,
@@ -144,20 +146,21 @@
 class TextureStorage
 {
   public:
-    explicit TextureStorage(bool renderTarget);
+    explicit TextureStorage(DWORD usage);
 
     virtual ~TextureStorage();
 
     bool isRenderTarget() const;
     bool isManaged() const;
     D3DPOOL getPool() const;
+    DWORD getUsage() const;
     unsigned int getTextureSerial() const;
     virtual unsigned int getRenderTargetSerial(GLenum target) const = 0;
 
   private:
     DISALLOW_COPY_AND_ASSIGN(TextureStorage);
 
-    const bool mRenderTarget;
+    const DWORD mD3DUsage;
     const D3DPOOL mD3DPool;
 
     const unsigned int mTextureSerial;
@@ -190,14 +193,7 @@
     GLenum getWrapT() const;
     GLenum getUsage() const;
 
-    virtual GLsizei getWidth(GLint level) const = 0;
-    virtual GLsizei getHeight(GLint level) const = 0;
-    virtual GLenum getInternalFormat() const = 0;
-    virtual GLenum getType() const = 0;
-    virtual D3DFORMAT getD3DFormat() const = 0;
-
     virtual bool isSamplerComplete() const = 0;
-    virtual bool isCompressed() const = 0;
 
     IDirect3DBaseTexture9 *getTexture();
     virtual Renderbuffer *getRenderbuffer(GLenum target) = 0;
@@ -216,8 +212,6 @@
     static const GLuint INCOMPLETE_TEXTURE_ID = static_cast<GLuint>(-1);   // Every texture takes an id at creation time. The value is arbitrary because it is never registered with the resource manager.
 
   protected:
-    friend class RenderbufferTexture;
-
     void setImage(GLint unpackAlignment, const void *pixels, Image *image);
     bool subImage(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels, Image *image);
     void setCompressedImage(GLsizei imageSize, const void *pixels, Image *image);
@@ -258,7 +252,7 @@
 {
   public:
     explicit TextureStorage2D(IDirect3DTexture9 *surfaceTexture);
-    TextureStorage2D(int levels, D3DFORMAT format, int width, int height, bool renderTarget);
+    TextureStorage2D(int levels, D3DFORMAT format, DWORD usage, int width, int height);
 
     virtual ~TextureStorage2D();
 
@@ -286,11 +280,12 @@
 
     virtual GLenum getTarget() const;
 
-    virtual GLsizei getWidth(GLint level) const;
-    virtual GLsizei getHeight(GLint level) const;
-    virtual GLenum getInternalFormat() const;
-    virtual GLenum getType() const;
-    virtual D3DFORMAT getD3DFormat() const;
+    GLsizei getWidth(GLint level) const;
+    GLsizei getHeight(GLint level) const;
+    GLenum getInternalFormat(GLint level) const;
+    D3DFORMAT getD3DFormat(GLint level) const;
+    bool isCompressed(GLint level) const;
+    bool isDepth(GLint level) const;
 
     void setImage(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels);
     void setCompressedImage(GLint level, GLenum format, GLsizei width, GLsizei height, GLsizei imageSize, const void *pixels);
@@ -301,7 +296,6 @@
     void storage(GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
 
     virtual bool isSamplerComplete() const;
-    virtual bool isCompressed() const;
     virtual void bindTexImage(egl::Surface *surface);
     virtual void releaseTexImage();
 
@@ -309,6 +303,11 @@
 
     virtual Renderbuffer *getRenderbuffer(GLenum target);
 
+  protected:
+    friend class RenderbufferTexture2D;
+    virtual IDirect3DSurface9 *getRenderTarget(GLenum target);
+    virtual IDirect3DSurface9 *getDepthStencil(GLenum target);
+
   private:
     DISALLOW_COPY_AND_ASSIGN(Texture2D);
 
@@ -316,7 +315,6 @@
     virtual void createTexture();
     virtual void updateTexture();
     virtual void convertToRenderTarget();
-    virtual IDirect3DSurface9 *getRenderTarget(GLenum target);
     virtual TextureStorage *getStorage(bool renderTarget);
 
     bool isMipmapComplete() const;
@@ -341,7 +339,7 @@
 class TextureStorageCubeMap : public TextureStorage
 {
   public:
-    TextureStorageCubeMap(int levels, D3DFORMAT format, int size, bool renderTarget);
+    TextureStorageCubeMap(int levels, D3DFORMAT format, DWORD usage, int size);
 
     virtual ~TextureStorageCubeMap();
 
@@ -369,11 +367,11 @@
 
     virtual GLenum getTarget() const;
     
-    virtual GLsizei getWidth(GLint level) const;
-    virtual GLsizei getHeight(GLint level) const;
-    virtual GLenum getInternalFormat() const;
-    virtual GLenum getType() const;
-    virtual D3DFORMAT getD3DFormat() const;
+    GLsizei getWidth(GLenum target, GLint level) const;
+    GLsizei getHeight(GLenum target, GLint level) const;
+    GLenum getInternalFormat(GLenum target, GLint level) const;
+    D3DFORMAT getD3DFormat(GLenum target, GLint level) const;
+    bool isCompressed(GLenum target, GLint level) const;
 
     void setImagePosX(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels);
     void setImageNegX(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels);
@@ -391,7 +389,6 @@
     void storage(GLsizei levels, GLenum internalformat, GLsizei size);
 
     virtual bool isSamplerComplete() const;
-    virtual bool isCompressed() const;
 
     virtual void generateMipmaps();
 
@@ -399,6 +396,10 @@
 
     static unsigned int faceIndex(GLenum face);
 
+  protected:
+    friend class RenderbufferTextureCubeMap;
+    virtual IDirect3DSurface9 *getRenderTarget(GLenum target);
+
   private:
     DISALLOW_COPY_AND_ASSIGN(TextureCubeMap);
 
@@ -406,7 +407,6 @@
     virtual void createTexture();
     virtual void updateTexture();
     virtual void convertToRenderTarget();
-    virtual IDirect3DSurface9 *getRenderTarget(GLenum target);
     virtual TextureStorage *getStorage(bool renderTarget);
 
     bool isCubeComplete() const;
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/VertexDataManager.cpp
--- a/gfx/angle/src/libGLESv2/VertexDataManager.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/VertexDataManager.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -13,6 +13,7 @@
 
 #include "libGLESv2/Buffer.h"
 #include "libGLESv2/Program.h"
+#include "libGLESv2/ProgramBinary.h"
 #include "libGLESv2/main.h"
 
 #include "libGLESv2/vertexconversion.h"
@@ -128,10 +129,11 @@
 
     const VertexAttributeArray &attribs = mContext->getVertexAttributes();
     Program *program = mContext->getCurrentProgram();
+    ProgramBinary *programBinary = program->getProgramBinary();
 
     for (int attributeIndex = 0; attributeIndex < MAX_VERTEX_ATTRIBS; attributeIndex++)
     {
-        translated[attributeIndex].active = (program->getSemanticIndex(attributeIndex) != -1);
+        translated[attributeIndex].active = (programBinary->getSemanticIndex(attributeIndex) != -1);
     }
 
     // Determine the required storage size per used buffer, and invalidate static buffers that don't contain matching attributes
@@ -448,8 +450,8 @@
 template <GLenum fromType> struct ConversionRule<fromType, true, D3DVT_FLOAT> : gl::Normalize<typename GLToCType<fromType>::type> { };
 
 // Use a full specialisation for this so that it preferentially matches ahead of the generic normalize-to-float rules.
-template <> struct ConversionRule<GL_FIXED, true, D3DVT_FLOAT> : gl::FixedToFloat<GLuint, 16> { };
-template <> struct ConversionRule<GL_FIXED, false, D3DVT_FLOAT> : gl::FixedToFloat<GLuint, 16> { };
+template <> struct ConversionRule<GL_FIXED, true, D3DVT_FLOAT> : gl::FixedToFloat<GLint, 16> { };
+template <> struct ConversionRule<GL_FIXED, false, D3DVT_FLOAT> : gl::FixedToFloat<GLint, 16> { };
 
 // A 2-stage construction is used for DefaultVertexValues because float must use SimpleDefaultValues (i.e. 0/1)
 // whether it is normalized or not.
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/libGLESv2.cpp
--- a/gfx/angle/src/libGLESv2/libGLESv2.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/libGLESv2.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -24,6 +24,7 @@
 #include "libGLESv2/Fence.h"
 #include "libGLESv2/Framebuffer.h"
 #include "libGLESv2/Program.h"
+#include "libGLESv2/ProgramBinary.h"
 #include "libGLESv2/Renderbuffer.h"
 #include "libGLESv2/Shader.h"
 #include "libGLESv2/Texture.h"
@@ -54,26 +55,121 @@
     return false;
 }
 
-bool validateSubImageParams(bool compressed, GLsizei width, GLsizei height, GLint xoffset, GLint yoffset, GLint level, GLenum format, gl::Texture *texture)
+// Verify that format/type are one of the combinations from table 3.4.
+bool checkTextureFormatType(GLenum format, GLenum type)
+{
+    // validate <format> by itself (used as secondary key below)
+    switch (format)
+    {
+      case GL_RGBA:
+      case GL_BGRA_EXT:
+      case GL_RGB:
+      case GL_ALPHA:
+      case GL_LUMINANCE:
+      case GL_LUMINANCE_ALPHA:
+      case GL_DEPTH_COMPONENT:
+      case GL_DEPTH_STENCIL_OES:
+        break;
+      default:
+        return error(GL_INVALID_ENUM, false);
+    }
+
+    // invalid <type> -> sets INVALID_ENUM
+    // invalid <format>+<type> combination -> sets INVALID_OPERATION
+    switch (type)
+    {
+      case GL_UNSIGNED_BYTE:
+        switch (format)
+        {
+          case GL_RGBA:
+          case GL_BGRA_EXT:
+          case GL_RGB:
+          case GL_ALPHA:
+          case GL_LUMINANCE:
+          case GL_LUMINANCE_ALPHA:
+            return true;
+          default:
+            return error(GL_INVALID_OPERATION, false);
+        }
+
+      case GL_FLOAT:
+      case GL_HALF_FLOAT_OES:
+        switch (format)
+        {
+          case GL_RGBA:
+          case GL_RGB:
+          case GL_ALPHA:
+          case GL_LUMINANCE:
+          case GL_LUMINANCE_ALPHA:
+            return true;
+          default:
+            return error(GL_INVALID_OPERATION, false);
+        }
+
+      case GL_UNSIGNED_SHORT_4_4_4_4:
+      case GL_UNSIGNED_SHORT_5_5_5_1:
+        switch (format)
+        {
+          case GL_RGBA:
+            return true;
+          default:
+            return error(GL_INVALID_OPERATION, false);
+        }
+
+      case GL_UNSIGNED_SHORT_5_6_5:
+        switch (format)
+        {
+          case GL_RGB:
+            return true;
+          default:
+            return error(GL_INVALID_OPERATION, false);
+        }
+
+      case GL_UNSIGNED_SHORT:
+      case GL_UNSIGNED_INT:
+        switch (format)
+        {
+          case GL_DEPTH_COMPONENT:
+            return true;
+          default:
+            return error(GL_INVALID_OPERATION, false);
+        }
+
+      case GL_UNSIGNED_INT_24_8_OES:
+        switch (format)
+        {
+          case GL_DEPTH_STENCIL_OES:
+            return true;
+          default:
+            return error(GL_INVALID_OPERATION, false);
+        }
+
+      default:
+        return error(GL_INVALID_ENUM, false);
+    }
+}
+bool validateSubImageParams2D(bool compressed, GLsizei width, GLsizei height,
+                              GLint xoffset, GLint yoffset, GLint level, GLenum format,
+                              gl::Texture2D *texture)
 {
     if (!texture)
     {
         return error(GL_INVALID_OPERATION, false);
     }
 
-    if (compressed != texture->isCompressed())
+    if (compressed != texture->isCompressed(level))
     {
         return error(GL_INVALID_OPERATION, false);
     }
 
-    if (format != GL_NONE && format != texture->getInternalFormat())
+    if (format != GL_NONE && format != texture->getInternalFormat(level))
     {
         return error(GL_INVALID_OPERATION, false);
     }
 
     if (compressed)
     {
-        if ((width % 4 != 0 && width != texture->getWidth(0)) || 
+        if ((width % 4 != 0 && width != texture->getWidth(0)) ||
             (height % 4 != 0 && height != texture->getHeight(0)))
         {
             return error(GL_INVALID_OPERATION, false);
@@ -89,6 +185,43 @@
     return true;
 }
 
+bool validateSubImageParamsCube(bool compressed, GLsizei width, GLsizei height,
+                                GLint xoffset, GLint yoffset, GLenum target, GLint level, GLenum format,
+                                gl::TextureCubeMap *texture)
+{
+    if (!texture)
+    {
+        return error(GL_INVALID_OPERATION, false);
+    }
+
+    if (compressed != texture->isCompressed(target, level))
+    {
+        return error(GL_INVALID_OPERATION, false);
+    }
+
+    if (format != GL_NONE && format != texture->getInternalFormat(target, level))
+    {
+        return error(GL_INVALID_OPERATION, false);
+    }
+
+    if (compressed)
+    {
+        if ((width % 4 != 0 && width != texture->getWidth(target, 0)) ||
+            (height % 4 != 0 && height != texture->getHeight(target, 0)))
+        {
+            return error(GL_INVALID_OPERATION, false);
+        }
+    }
+
+    if (xoffset + width > texture->getWidth(target, level) ||
+        yoffset + height > texture->getHeight(target, level))
+    {
+        return error(GL_INVALID_VALUE, false);
+    }
+
+    return true;
+}
+
 // check for combinations of format and type that are valid for ReadPixels
 bool validReadFormatType(GLenum format, GLenum type)
 {
@@ -103,6 +236,17 @@
             return false;
         }
         break;
+      case GL_BGRA_EXT:
+        switch (type)
+        {
+          case GL_UNSIGNED_BYTE:
+          case GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT:
+          case GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT:
+            break;
+          default:
+            return false;
+        }
+        break;
       case gl::IMPLEMENTATION_COLOR_READ_FORMAT:
         switch (type)
         {
@@ -1083,7 +1227,7 @@
             if (target == GL_TEXTURE_2D)
             {
                 gl::Texture2D *texture = context->getTexture2D();
-                if (validateSubImageParams(true, width, height, xoffset, yoffset, level, GL_NONE, texture))
+                if (validateSubImageParams2D(true, width, height, xoffset, yoffset, level, format, texture))
                 {
                     texture->subImageCompressed(level, xoffset, yoffset, width, height, format, imageSize, data);
                 }
@@ -1091,7 +1235,7 @@
             else if (gl::IsCubemapTextureTarget(target))
             {
                 gl::TextureCubeMap *texture = context->getTextureCubeMap();
-                if (validateSubImageParams(true, width, height, xoffset, yoffset, level, GL_NONE, texture))
+                if (validateSubImageParamsCube(true, width, height, xoffset, yoffset, target, level, format, texture))
                 {
                     texture->subImageCompressed(target, level, xoffset, yoffset, width, height, format, imageSize, data);
                 }
@@ -1247,6 +1391,19 @@
                     return error(GL_INVALID_ENUM);
                 }
                 break;
+              case GL_DEPTH_COMPONENT:
+              case GL_DEPTH_COMPONENT16:
+              case GL_DEPTH_COMPONENT32_OES:
+              case GL_DEPTH_STENCIL_OES:
+              case GL_DEPTH24_STENCIL8_OES:
+                  if (context->supportsDepthTextures())
+                  {
+                      return error(GL_INVALID_OPERATION);
+                  }
+                  else
+                  {
+                      return error(GL_INVALID_ENUM);
+                  }
               default:
                 return error(GL_INVALID_ENUM);
             }
@@ -1344,24 +1501,32 @@
             gl::Renderbuffer *source = framebuffer->getColorbuffer();
             GLenum colorbufferFormat = source->getInternalFormat();
             gl::Texture *texture = NULL;
+            GLenum textureFormat = GL_RGBA;
 
             if (target == GL_TEXTURE_2D)
             {
-                texture = context->getTexture2D();
+                gl::Texture2D *tex2d = context->getTexture2D();
+
+                if (!validateSubImageParams2D(false, width, height, xoffset, yoffset, level, GL_NONE, tex2d))
+                {
+                    return; // error already registered by validateSubImageParams
+                }
+                textureFormat = tex2d->getInternalFormat(level);
+                texture = tex2d;
             }
             else if (gl::IsCubemapTextureTarget(target))
             {
-                texture = context->getTextureCubeMap();
+                gl::TextureCubeMap *texcube = context->getTextureCubeMap();
+
+                if (!validateSubImageParamsCube(false, width, height, xoffset, yoffset, target, level, GL_NONE, texcube))
+                {
+                    return; // error already registered by validateSubImageParams
+                }
+                textureFormat = texcube->getInternalFormat(target, level);
+                texture = texcube;
             }
             else UNREACHABLE();
 
-            if (!validateSubImageParams(false, width, height, xoffset, yoffset, level, GL_NONE, texture))
-            {
-                return; // error already registered by validateSubImageParams
-            }
-
-            GLenum textureFormat = texture->getInternalFormat();
-
             // [OpenGL ES 2.0.24] table 3.9
             switch (textureFormat)
             {
@@ -1403,6 +1568,9 @@
               case GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE:
               case GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE:
                 return error(GL_INVALID_OPERATION);
+              case GL_DEPTH_COMPONENT:
+              case GL_DEPTH_STENCIL_OES:
+                return error(GL_INVALID_OPERATION);
               default:
                 return error(GL_INVALID_OPERATION);
             }
@@ -2295,19 +2463,21 @@
                     return error(GL_INVALID_OPERATION);
                 }
 
-                if (tex->isCompressed())
-                {
-                    return error(GL_INVALID_OPERATION);
-                }
-
                 switch (textarget)
                 {
                   case GL_TEXTURE_2D:
-                    if (tex->getTarget() != GL_TEXTURE_2D)
                     {
-                        return error(GL_INVALID_OPERATION);
+                        if (tex->getTarget() != GL_TEXTURE_2D)
+                        {
+                            return error(GL_INVALID_OPERATION);
+                        }
+                        gl::Texture2D *tex2d = static_cast<gl::Texture2D *>(tex);
+                        if (tex2d->isCompressed(0))
+                        {
+                            return error(GL_INVALID_OPERATION);
+                        }
+                        break;
                     }
-                    break;
 
                   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
                   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
@@ -2315,142 +2485,162 @@
                   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
                   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
                   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
-                    if (tex->getTarget() != GL_TEXTURE_CUBE_MAP)
+                    {
+                        if (tex->getTarget() != GL_TEXTURE_CUBE_MAP)
+                        {
+                            return error(GL_INVALID_OPERATION);
+                        }
+                        gl::TextureCubeMap *texcube = static_cast<gl::TextureCubeMap *>(tex);
+                        if (texcube->isCompressed(textarget, level))
+                        {
+                            return error(GL_INVALID_OPERATION);
+                        }
+                        break;
+                    }
+
+                  default:
+                    return error(GL_INVALID_ENUM);
+                }
+
+                if (level != 0)
+                {
+                    return error(GL_INVALID_VALUE);
+                }
+            }
+
+            gl::Framebuffer *framebuffer = NULL;
+            GLuint framebufferHandle = 0;
+            if (target == GL_READ_FRAMEBUFFER_ANGLE)
+            {
+                framebuffer = context->getReadFramebuffer();
+                framebufferHandle = context->getReadFramebufferHandle();
+            }
+            else
+            {
+                framebuffer = context->getDrawFramebuffer();
+                framebufferHandle = context->getDrawFramebufferHandle();
+            }
+
+            if (framebufferHandle == 0 || !framebuffer)
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            switch (attachment)
+            {
+              case GL_COLOR_ATTACHMENT0:  framebuffer->setColorbuffer(textarget, texture);   break;
+              case GL_DEPTH_ATTACHMENT:   framebuffer->setDepthbuffer(textarget, texture);   break;
+              case GL_STENCIL_ATTACHMENT: framebuffer->setStencilbuffer(textarget, texture); break;
+            }
+        }
+    }
+    catch(std::bad_alloc&)
+    {
+        return error(GL_OUT_OF_MEMORY);
+    }
+}
+
+void __stdcall glFrontFace(GLenum mode)
+{
+    EVENT("(GLenum mode = 0x%X)", mode);
+
+    try
+    {
+        switch (mode)
+        {
+          case GL_CW:
+          case GL_CCW:
+            {
+                gl::Context *context = gl::getNonLostContext();
+
+                if (context)
+                {
+                    context->setFrontFace(mode);
+                }
+            }
+            break;
+          default:
+            return error(GL_INVALID_ENUM);
+        }
+    }
+    catch(std::bad_alloc&)
+    {
+        return error(GL_OUT_OF_MEMORY);
+    }
+}
+
+void __stdcall glGenBuffers(GLsizei n, GLuint* buffers)
+{
+    EVENT("(GLsizei n = %d, GLuint* buffers = 0x%0.8p)", n, buffers);
+
+    try
+    {
+        if (n < 0)
+        {
+            return error(GL_INVALID_VALUE);
+        }
+
+        gl::Context *context = gl::getNonLostContext();
+
+        if (context)
+        {
+            for (int i = 0; i < n; i++)
+            {
+                buffers[i] = context->createBuffer();
+            }
+        }
+    }
+    catch(std::bad_alloc&)
+    {
+        return error(GL_OUT_OF_MEMORY);
+    }
+}
+
+void __stdcall glGenerateMipmap(GLenum target)
+{
+    EVENT("(GLenum target = 0x%X)", target);
+
+    try
+    {
+        gl::Context *context = gl::getNonLostContext();
+
+        if (context)
+        {
+            switch (target)
+            {
+              case GL_TEXTURE_2D:
+                {
+                    gl::Texture2D *tex2d = context->getTexture2D();
+
+                    if (tex2d->isCompressed(0))
                     {
                         return error(GL_INVALID_OPERATION);
                     }
+                    if (tex2d->isDepth(0))
+                    {
+                        return error(GL_INVALID_OPERATION);
+                    }
+
+                    tex2d->generateMipmaps();
                     break;
-
-                  default:
-                    return error(GL_INVALID_ENUM);
-                }
-
-                if (level != 0)
-                {
-                    return error(GL_INVALID_VALUE);
-                }
-            }
-
-            gl::Framebuffer *framebuffer = NULL;
-            GLuint framebufferHandle = 0;
-            if (target == GL_READ_FRAMEBUFFER_ANGLE)
-            {
-                framebuffer = context->getReadFramebuffer();
-                framebufferHandle = context->getReadFramebufferHandle();
-            }
-            else
-            {
-                framebuffer = context->getDrawFramebuffer();
-                framebufferHandle = context->getDrawFramebufferHandle();
-            }
-
-            if (framebufferHandle == 0 || !framebuffer)
-            {
-                return error(GL_INVALID_OPERATION);
-            }
-
-            switch (attachment)
-            {
-              case GL_COLOR_ATTACHMENT0:  framebuffer->setColorbuffer(textarget, texture);   break;
-              case GL_DEPTH_ATTACHMENT:   framebuffer->setDepthbuffer(textarget, texture);   break;
-              case GL_STENCIL_ATTACHMENT: framebuffer->setStencilbuffer(textarget, texture); break;
-            }
-        }
-    }
-    catch(std::bad_alloc&)
-    {
-        return error(GL_OUT_OF_MEMORY);
-    }
-}
-
-void __stdcall glFrontFace(GLenum mode)
-{
-    EVENT("(GLenum mode = 0x%X)", mode);
-
-    try
-    {
-        switch (mode)
-        {
-          case GL_CW:
-          case GL_CCW:
-            {
-                gl::Context *context = gl::getNonLostContext();
-
-                if (context)
-                {
-                    context->setFrontFace(mode);
-                }
-            }
-            break;
-          default:
-            return error(GL_INVALID_ENUM);
-        }
-    }
-    catch(std::bad_alloc&)
-    {
-        return error(GL_OUT_OF_MEMORY);
-    }
-}
-
-void __stdcall glGenBuffers(GLsizei n, GLuint* buffers)
-{
-    EVENT("(GLsizei n = %d, GLuint* buffers = 0x%0.8p)", n, buffers);
-
-    try
-    {
-        if (n < 0)
-        {
-            return error(GL_INVALID_VALUE);
-        }
-
-        gl::Context *context = gl::getNonLostContext();
-
-        if (context)
-        {
-            for (int i = 0; i < n; i++)
-            {
-                buffers[i] = context->createBuffer();
-            }
-        }
-    }
-    catch(std::bad_alloc&)
-    {
-        return error(GL_OUT_OF_MEMORY);
-    }
-}
-
-void __stdcall glGenerateMipmap(GLenum target)
-{
-    EVENT("(GLenum target = 0x%X)", target);
-
-    try
-    {
-        gl::Context *context = gl::getNonLostContext();
-
-        if (context)
-        {
-            gl::Texture *texture;
-
-            switch (target)
-            {
-              case GL_TEXTURE_2D:
-                texture = context->getTexture2D();
-                break;
+                }
 
               case GL_TEXTURE_CUBE_MAP:
-                texture = context->getTextureCubeMap();
-                break;
+                {
+                    gl::TextureCubeMap *texcube = context->getTextureCubeMap();
+
+                    if (texcube->isCompressed(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0))
+                    {
+                        return error(GL_INVALID_OPERATION);
+                    }
+
+                    texcube->generateMipmaps();
+                    break;
+                }
 
               default:
                 return error(GL_INVALID_ENUM);
             }
-
-            if (texture->isCompressed())
-            {
-                return error(GL_INVALID_OPERATION);
-            }
-
-            texture->generateMipmaps();
         }
     }
     catch(std::bad_alloc&)
@@ -2748,12 +2938,13 @@
                 }
             }
 
-            if (!programObject->isLinked())
+            gl::ProgramBinary *programBinary = programObject->getProgramBinary();
+            if (!programBinary)
             {
                 return error(GL_INVALID_OPERATION, -1);
             }
 
-            return programObject->getAttributeLocation(name);
+            return programBinary->getAttributeLocation(name);
         }
     }
     catch(std::bad_alloc&)
@@ -3207,7 +3398,7 @@
                 *params = programObject->isFlaggedForDeletion();
                 return;
               case GL_LINK_STATUS:
-                *params = programObject->isLinked();
+                *params = programObject->getProgramBinary() != NULL;
                 return;
               case GL_VALIDATE_STATUS:
                 *params = programObject->isValidated();
@@ -3230,6 +3421,9 @@
               case GL_ACTIVE_UNIFORM_MAX_LENGTH:
                 *params = programObject->getActiveUniformMaxLength();
                 return;
+              case GL_PROGRAM_BINARY_LENGTH_OES:
+                *params = 0;
+                return;
               default:
                 return error(GL_INVALID_ENUM);
             }
@@ -3755,15 +3949,21 @@
 
             gl::Program *programObject = context->getProgram(program);
 
-            if (!programObject || !programObject->isLinked())
+            if (!programObject)
             {
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!programObject->getUniformfv(location, &bufSize, params))
+            gl::ProgramBinary *programBinary = programObject->getProgramBinary();
+            if (!programBinary)
             {
                 return error(GL_INVALID_OPERATION);
             }
+
+            if (!programBinary->getUniformfv(location, &bufSize, params))
+            {
+                return error(GL_INVALID_OPERATION);
+            }
         }
     }
     catch(std::bad_alloc&)
@@ -3789,12 +3989,18 @@
 
             gl::Program *programObject = context->getProgram(program);
 
-            if (!programObject || !programObject->isLinked())
+            if (!programObject)
             {
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!programObject->getUniformfv(location, NULL, params))
+            gl::ProgramBinary *programBinary = programObject->getProgramBinary();
+            if (!programBinary)
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            if (!programBinary->getUniformfv(location, NULL, params))
             {
                 return error(GL_INVALID_OPERATION);
             }
@@ -3829,20 +4035,61 @@
 
             gl::Program *programObject = context->getProgram(program);
 
-            if (!programObject || !programObject->isLinked())
+            if (!programObject)
             {
                 return error(GL_INVALID_OPERATION);
             }
 
+            gl::ProgramBinary *programBinary = programObject->getProgramBinary();
+            if (!programBinary)
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            if (!programBinary->getUniformiv(location, &bufSize, params))
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+        }
+    }
+    catch(std::bad_alloc&)
+    {
+        return error(GL_OUT_OF_MEMORY);
+    }
+}
+
+void __stdcall glGetUniformiv(GLuint program, GLint location, GLint* params)
+{
+    EVENT("(GLuint program = %d, GLint location = %d, GLint* params = 0x%0.8p)", program, location, params);
+
+    try
+    {
+        gl::Context *context = gl::getNonLostContext();
+
+        if (context)
+        {
+            if (program == 0)
+            {
+                return error(GL_INVALID_VALUE);
+            }
+
+            gl::Program *programObject = context->getProgram(program);
+
             if (!programObject)
             {
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!programObject->getUniformiv(location, &bufSize, params))
+            gl::ProgramBinary *programBinary = programObject->getProgramBinary();
+            if (!programBinary)
             {
                 return error(GL_INVALID_OPERATION);
             }
+
+            if (!programBinary->getUniformiv(location, NULL, params))
+            {
+                return error(GL_INVALID_OPERATION);
+            }
         }
     }
     catch(std::bad_alloc&)
@@ -3851,64 +4098,25 @@
     }
 }
 
-void __stdcall glGetUniformiv(GLuint program, GLint location, GLint* params)
-{
-    EVENT("(GLuint program = %d, GLint location = %d, GLint* params = 0x%0.8p)", program, location, params);
+int __stdcall glGetUniformLocation(GLuint program, const GLchar* name)
+{
+    EVENT("(GLuint program = %d, const GLchar* name = 0x%0.8p)", program, name);
 
     try
     {
         gl::Context *context = gl::getNonLostContext();
 
+        if (strstr(name, "gl_") == name)
+        {
+            return -1;
+        }
+
         if (context)
         {
-            if (program == 0)
-            {
-                return error(GL_INVALID_VALUE);
-            }
-
             gl::Program *programObject = context->getProgram(program);
 
-            if (!programObject || !programObject->isLinked())
-            {
-                return error(GL_INVALID_OPERATION);
-            }
-
             if (!programObject)
             {
-                return error(GL_INVALID_OPERATION);
-            }
-
-            if (!programObject->getUniformiv(location, NULL, params))
-            {
-                return error(GL_INVALID_OPERATION);
-            }
-        }
-    }
-    catch(std::bad_alloc&)
-    {
-        return error(GL_OUT_OF_MEMORY);
-    }
-}
-
-int __stdcall glGetUniformLocation(GLuint program, const GLchar* name)
-{
-    EVENT("(GLuint program = %d, const GLchar* name = 0x%0.8p)", program, name);
-
-    try
-    {
-        gl::Context *context = gl::getNonLostContext();
-
-        if (strstr(name, "gl_") == name)
-        {
-            return -1;
-        }
-
-        if (context)
-        {
-            gl::Program *programObject = context->getProgram(program);
-
-            if (!programObject)
-            {
                 if (context->getShader(program))
                 {
                     return error(GL_INVALID_OPERATION, -1);
@@ -3919,12 +4127,13 @@
                 }
             }
 
-            if (!programObject->isLinked())
+            gl::ProgramBinary *programBinary = programObject->getProgramBinary();
+            if (!programBinary)
             {
                 return error(GL_INVALID_OPERATION, -1);
             }
 
-            return programObject->getUniformLocation(name);
+            return programBinary->getUniformLocation(name);
         }
     }
     catch(std::bad_alloc&)
@@ -5001,6 +5210,26 @@
             return error(GL_INVALID_OPERATION);
         }
 
+        // validate <type> by itself (used as secondary key below)
+        switch (type)
+        {
+          case GL_UNSIGNED_BYTE:
+          case GL_UNSIGNED_SHORT_5_6_5:
+          case GL_UNSIGNED_SHORT_4_4_4_4:
+          case GL_UNSIGNED_SHORT_5_5_5_1:
+          case GL_UNSIGNED_SHORT:
+          case GL_UNSIGNED_INT:
+          case GL_UNSIGNED_INT_24_8_OES:
+          case GL_HALF_FLOAT_OES:
+          case GL_FLOAT:
+            break;
+          default:
+            return error(GL_INVALID_ENUM);
+        }
+
+        // validate <format> + <type> combinations
+        // - invalid <format> -> sets INVALID_ENUM
+        // - invalid <format>+<type> combination -> sets INVALID_OPERATION
         switch (format)
         {
           case GL_ALPHA:
@@ -5013,7 +5242,7 @@
               case GL_HALF_FLOAT_OES:
                 break;
               default:
-                return error(GL_INVALID_ENUM);
+                return error(GL_INVALID_OPERATION);
             }
             break;
           case GL_RGB:
@@ -5025,7 +5254,7 @@
               case GL_HALF_FLOAT_OES:
                 break;
               default:
-                return error(GL_INVALID_ENUM);
+                return error(GL_INVALID_OPERATION);
             }
             break;
           case GL_RGBA:
@@ -5038,7 +5267,7 @@
               case GL_HALF_FLOAT_OES:
                 break;
               default:
-                return error(GL_INVALID_ENUM);
+                return error(GL_INVALID_OPERATION);
             }
             break;
           case GL_BGRA_EXT:
@@ -5047,7 +5276,7 @@
               case GL_UNSIGNED_BYTE:
                 break;
               default:
-                return error(GL_INVALID_ENUM);
+                return error(GL_INVALID_OPERATION);
             }
             break;
           case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:  // error cases for compressed textures are handled below
@@ -5055,8 +5284,27 @@
           case GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE:
           case GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE:
             break; 
+          case GL_DEPTH_COMPONENT:
+            switch (type)
+            {
+              case GL_UNSIGNED_SHORT:
+              case GL_UNSIGNED_INT:
+                break;
+              default:
+                return error(GL_INVALID_OPERATION);
+            }
+            break;
+          case GL_DEPTH_STENCIL_OES:
+            switch (type)
+            {
+              case GL_UNSIGNED_INT_24_8_OES:
+                break;
+              default:
+                return error(GL_INVALID_OPERATION);
+            }
+            break;
           default:
-            return error(GL_INVALID_VALUE);
+            return error(GL_INVALID_ENUM);
         }
 
         if (border != 0)
@@ -5135,6 +5383,23 @@
                     return error(GL_INVALID_ENUM);
                 }
                 break;
+              case GL_DEPTH_COMPONENT:
+              case GL_DEPTH_STENCIL_OES:
+                if (!context->supportsDepthTextures())
+                {
+                    return error(GL_INVALID_VALUE);
+                }
+                if (target != GL_TEXTURE_2D)
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+                // OES_depth_texture supports loading depth data and multiple levels,
+                // but ANGLE_depth_texture does not
+                if (pixels != NULL || level != 0)
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+                break;
               default:
                 break;
             }
@@ -5405,6 +5670,25 @@
                     return error(GL_INVALID_ENUM);
                 }
                 break;
+              case GL_DEPTH_COMPONENT16:
+              case GL_DEPTH_COMPONENT32_OES:
+              case GL_DEPTH24_STENCIL8_OES:
+                if (!context->supportsDepthTextures())
+                {
+                    return error(GL_INVALID_ENUM);
+                }
+                if (target != GL_TEXTURE_2D)
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+                // ANGLE_depth_texture only supports 1-level textures
+                if (levels != 1)
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+                break;
+              default:
+                break;
             }
 
             if (target == GL_TEXTURE_2D)
@@ -5473,12 +5757,98 @@
             return error(GL_INVALID_VALUE);
         }
 
-        if (!gl::CheckTextureFormatType(format, type))
-        {
-            return error(GL_INVALID_ENUM);
-        }
-
-        if (width == 0 || height == 0 || pixels == NULL)
+        if (!checkTextureFormatType(format, type))
+        {
+            return; // error is set by helper function
+        }
+
+        gl::Context *context = gl::getNonLostContext();
+
+        if (context)
+        {
+            if (level > context->getMaximumTextureLevel())
+            {
+                return error(GL_INVALID_VALUE);
+            }
+
+            if (format == GL_FLOAT)
+            {
+                if (!context->supportsFloat32Textures())
+                {
+                    return error(GL_INVALID_ENUM);
+                }
+            }
+            else if (format == GL_HALF_FLOAT_OES)
+            {
+                if (!context->supportsFloat16Textures())
+                {
+                    return error(GL_INVALID_ENUM);
+                }
+            }
+            else if (gl::IsDepthTexture(format))
+            {
+                if (!context->supportsDepthTextures())
+                {
+                    return error(GL_INVALID_ENUM);
+                }
+                if (target != GL_TEXTURE_2D)
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+                // OES_depth_texture supports loading depth data, but ANGLE_depth_texture does not
+                return error(GL_INVALID_OPERATION);
+            }
+
+            if (width == 0 || height == 0 || pixels == NULL)
+            {
+                return;
+            }
+
+            if (target == GL_TEXTURE_2D)
+            {
+                gl::Texture2D *texture = context->getTexture2D();
+                if (validateSubImageParams2D(false, width, height, xoffset, yoffset, level, format, texture))
+                {
+                    texture->subImage(level, xoffset, yoffset, width, height, format, type, context->getUnpackAlignment(), pixels);
+                }
+            }
+            else if (gl::IsCubemapTextureTarget(target))
+            {
+                gl::TextureCubeMap *texture = context->getTextureCubeMap();
+                if (validateSubImageParamsCube(false, width, height, xoffset, yoffset, target, level, format, texture))
+                {
+                    texture->subImage(target, level, xoffset, yoffset, width, height, format, type, context->getUnpackAlignment(), pixels);
+                }
+            }
+            else
+            {
+                UNREACHABLE();
+            }
+        }
+    }
+    catch(std::bad_alloc&)
+    {
+        return error(GL_OUT_OF_MEMORY);
+    }
+}
+
+void __stdcall glUniform1f(GLint location, GLfloat x)
+{
+    glUniform1fv(location, 1, &x);
+}
+
+void __stdcall glUniform1fv(GLint location, GLsizei count, const GLfloat* v)
+{
+    EVENT("(GLint location = %d, GLsizei count = %d, const GLfloat* v = 0x%0.8p)", location, count, v);
+
+    try
+    {
+        if (count < 0)
+        {
+            return error(GL_INVALID_VALUE);
+        }
+
+        if (location == -1)
         {
             return;
         }
@@ -5487,45 +5857,22 @@
 
         if (context)
         {
-            if (level > context->getMaximumTextureLevel())
-            {
-                return error(GL_INVALID_VALUE);
-            }
-
-            if (format == GL_FLOAT)
-            {
-                if (!context->supportsFloat32Textures())
-                {
-                    return error(GL_INVALID_ENUM);
-                }
-            }
-            else if (format == GL_HALF_FLOAT_OES)
-            {
-                if (!context->supportsFloat16Textures())
-                {
-                    return error(GL_INVALID_ENUM);
-                }
-            }
-
-            if (target == GL_TEXTURE_2D)
-            {
-                gl::Texture2D *texture = context->getTexture2D();
-                if (validateSubImageParams(false, width, height, xoffset, yoffset, level, format, texture))
-                {
-                    texture->subImage(level, xoffset, yoffset, width, height, format, type, context->getUnpackAlignment(), pixels);
-                }
-            }
-            else if (gl::IsCubemapTextureTarget(target))
-            {
-                gl::TextureCubeMap *texture = context->getTextureCubeMap();
-                if (validateSubImageParams(false, width, height, xoffset, yoffset, level, format, texture))
-                {
-                    texture->subImage(target, level, xoffset, yoffset, width, height, format, type, context->getUnpackAlignment(), pixels);
-                }
-            }
-            else
-            {
-                UNREACHABLE();
+            gl::Program *program = context->getCurrentProgram();
+
+            if (!program)
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            gl::ProgramBinary *programBinary = program->getProgramBinary();
+            if (!programBinary)
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            if (!programBinary->setUniform1fv(location, count, v))
+            {
+                return error(GL_INVALID_OPERATION);
             }
         }
     }
@@ -5535,14 +5882,14 @@
     }
 }
 
-void __stdcall glUniform1f(GLint location, GLfloat x)
-{
-    glUniform1fv(location, 1, &x);
-}
-
-void __stdcall glUniform1fv(GLint location, GLsizei count, const GLfloat* v)
-{
-    EVENT("(GLint location = %d, GLsizei count = %d, const GLfloat* v = 0x%0.8p)", location, count, v);
+void __stdcall glUniform1i(GLint location, GLint x)
+{
+    glUniform1iv(location, 1, &x);
+}
+
+void __stdcall glUniform1iv(GLint location, GLsizei count, const GLint* v)
+{
+    EVENT("(GLint location = %d, GLsizei count = %d, const GLint* v = 0x%0.8p)", location, count, v);
 
     try
     {
@@ -5567,51 +5914,13 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!program->setUniform1fv(location, count, v))
+            gl::ProgramBinary *programBinary = program->getProgramBinary();
+            if (!programBinary)
             {
                 return error(GL_INVALID_OPERATION);
             }
-        }
-    }
-    catch(std::bad_alloc&)
-    {
-        return error(GL_OUT_OF_MEMORY);
-    }
-}
-
-void __stdcall glUniform1i(GLint location, GLint x)
-{
-    glUniform1iv(location, 1, &x);
-}
-
-void __stdcall glUniform1iv(GLint location, GLsizei count, const GLint* v)
-{
-    EVENT("(GLint location = %d, GLsizei count = %d, const GLint* v = 0x%0.8p)", location, count, v);
-
-    try
-    {
-        if (count < 0)
-        {
-            return error(GL_INVALID_VALUE);
-        }
-
-        if (location == -1)
-        {
-            return;
-        }
-
-        gl::Context *context = gl::getNonLostContext();
-
-        if (context)
-        {
-            gl::Program *program = context->getCurrentProgram();
-
-            if (!program)
-            {
-                return error(GL_INVALID_OPERATION);
-            }
-
-            if (!program->setUniform1iv(location, count, v))
+
+            if (!programBinary->setUniform1iv(location, count, v))
             {
                 return error(GL_INVALID_OPERATION);
             }
@@ -5657,10 +5966,16 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!program->setUniform2fv(location, count, v))
+            gl::ProgramBinary *programBinary = program->getProgramBinary();
+            if (!programBinary)
             {
                 return error(GL_INVALID_OPERATION);
             }
+
+            if (!programBinary->setUniform2fv(location, count, v))
+            {
+                return error(GL_INVALID_OPERATION);
+            }
         }
     }
     catch(std::bad_alloc&)
@@ -5703,10 +6018,16 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!program->setUniform2iv(location, count, v))
+            gl::ProgramBinary *programBinary = program->getProgramBinary();
+            if (!programBinary)
             {
                 return error(GL_INVALID_OPERATION);
             }
+
+            if (!programBinary->setUniform2iv(location, count, v))
+            {
+                return error(GL_INVALID_OPERATION);
+            }
         }
     }
     catch(std::bad_alloc&)
@@ -5749,10 +6070,16 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!program->setUniform3fv(location, count, v))
+            gl::ProgramBinary *programBinary = program->getProgramBinary();
+            if (!programBinary)
             {
                 return error(GL_INVALID_OPERATION);
             }
+
+            if (!programBinary->setUniform3fv(location, count, v))
+            {
+                return error(GL_INVALID_OPERATION);
+            }
         }
     }
     catch(std::bad_alloc&)
@@ -5795,10 +6122,16 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!program->setUniform3iv(location, count, v))
+            gl::ProgramBinary *programBinary = program->getProgramBinary();
+            if (!programBinary)
             {
                 return error(GL_INVALID_OPERATION);
             }
+
+            if (!programBinary->setUniform3iv(location, count, v))
+            {
+                return error(GL_INVALID_OPERATION);
+            }
         }
     }
     catch(std::bad_alloc&)
@@ -5841,10 +6174,16 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!program->setUniform4fv(location, count, v))
+            gl::ProgramBinary *programBinary = program->getProgramBinary();
+            if (!programBinary)
             {
                 return error(GL_INVALID_OPERATION);
             }
+
+            if (!programBinary->setUniform4fv(location, count, v))
+            {
+                return error(GL_INVALID_OPERATION);
+            }
         }
     }
     catch(std::bad_alloc&)
@@ -5887,7 +6226,13 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!program->setUniform4iv(location, count, v))
+            gl::ProgramBinary *programBinary = program->getProgramBinary();
+            if (!programBinary)
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            if (!programBinary->setUniform4iv(location, count, v))
             {
                 return error(GL_INVALID_OPERATION);
             }
@@ -5927,7 +6272,13 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!program->setUniformMatrix2fv(location, count, value))
+            gl::ProgramBinary *programBinary = program->getProgramBinary();
+            if (!programBinary)
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            if (!programBinary->setUniformMatrix2fv(location, count, value))
             {
                 return error(GL_INVALID_OPERATION);
             }
@@ -5967,7 +6318,13 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!program->setUniformMatrix3fv(location, count, value))
+            gl::ProgramBinary *programBinary = program->getProgramBinary();
+            if (!programBinary)
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            if (!programBinary->setUniformMatrix3fv(location, count, value))
             {
                 return error(GL_INVALID_OPERATION);
             }
@@ -6007,10 +6364,16 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!program->setUniformMatrix4fv(location, count, value))
+            gl::ProgramBinary *programBinary = program->getProgramBinary();
+            if (!programBinary)
             {
                 return error(GL_INVALID_OPERATION);
             }
+
+            if (!programBinary->setUniformMatrix4fv(location, count, value))
+            {
+                return error(GL_INVALID_OPERATION);
+            }
         }
     }
     catch(std::bad_alloc&)
@@ -6043,7 +6406,7 @@
                 }
             }
 
-            if (program != 0 && !programObject->isLinked())
+            if (program != 0 && !programObject->getProgramBinary())
             {
                 return error(GL_INVALID_OPERATION);
             }
@@ -6081,7 +6444,13 @@
                 }
             }
 
-            programObject->validate();
+            gl::ProgramBinary *programBinary = programObject->getProgramBinary();
+            if (!programBinary)
+            {
+                return;
+            }
+
+            programBinary->validate();
         }
     }
     catch(std::bad_alloc&)
@@ -6452,6 +6821,79 @@
     }
 }
 
+void __stdcall glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei *length, 
+                                     GLenum *binaryFormat, void *binary)
+{
+    EVENT("(GLenum program = 0x%X, bufSize = %s, length = 0x%0.8p, binaryFormat = 0x%0.8p, binary = 0x%0.8p)",
+          program, bufSize, length, binaryFormat, binary);
+
+    try
+    {
+        gl::Context *context = gl::getNonLostContext();
+
+        if (context)
+        {
+            gl::Program *programObject = context->getProgram(program);
+
+            if (!programObject)
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            gl::ProgramBinary *programBinary = programObject->getProgramBinary();
+
+            if (!programBinary)
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            *binaryFormat = GL_PROGRAM_BINARY_ANGLE;
+
+            if (length)
+            {
+                *length = 0;
+            }
+        }
+    }
+    catch(std::bad_alloc&)
+    {
+        return error(GL_OUT_OF_MEMORY);
+    }
+}
+
+void __stdcall glProgramBinaryOES(GLuint program, GLenum binaryFormat,
+                                  const void *binary, GLint length)
+{
+    EVENT("(GLenum program = 0x%X, binaryFormat = 0x%x, binary = 0x%0.8p, length = %d)",
+          program, binaryFormat, binary, length);
+
+    try
+    {
+        gl::Context *context = gl::getNonLostContext();
+
+        if (context)
+        {
+            if (binaryFormat != GL_PROGRAM_BINARY_ANGLE)
+            {
+                return error(GL_INVALID_ENUM);
+            }
+
+            gl::Program *programObject = context->getProgram(program);
+
+            if (!programObject)
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            programObject->setProgramBinary(NULL);
+        }
+    }
+    catch(std::bad_alloc&)
+    {
+        return error(GL_OUT_OF_MEMORY);
+    }
+}
+
 __eglMustCastToProperFunctionPointerType __stdcall glGetProcAddress(const char *procname)
 {
     struct Extension
@@ -6488,7 +6930,8 @@
         {"glVertexAttribDivisorANGLE", (__eglMustCastToProperFunctionPointerType)glVertexAttribDivisorANGLE},
         {"glDrawArraysInstancedANGLE", (__eglMustCastToProperFunctionPointerType)glDrawArraysInstancedANGLE},
         {"glDrawElementsInstancedANGLE", (__eglMustCastToProperFunctionPointerType)glDrawElementsInstancedANGLE},
-    };
+        {"glGetProgramBinaryOES", (__eglMustCastToProperFunctionPointerType)glGetProgramBinaryOES},
+        {"glProgramBinaryOES", (__eglMustCastToProperFunctionPointerType)glProgramBinaryOES},    };
 
     for (int ext = 0; ext < sizeof(glExtensions) / sizeof(Extension); ext++)
     {
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/libGLESv2.vcproj
--- a/gfx/angle/src/libGLESv2/libGLESv2.vcproj	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/libGLESv2.vcproj	Sat Jun 09 12:08:28 2012 +0900
@@ -1,144 +1,557 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject ProjectType="Visual C++" Version="8.00" Name="libGLESv2" ProjectGUID="{B5871A7A-968C-42E3-A33B-981E6F448E78}" RootNamespace="libGLESv2" Keyword="Win32Proj" TargetFrameworkVersion="131072">
-  <Platforms>
-    <Platform Name="Win32" />
-  </Platforms>
-  <ToolFiles>
-  </ToolFiles>
-  <Configurations>
-    <Configuration Name="Debug|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="2" CharacterSet="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="0" AdditionalIncludeDirectories="$(ProjectDir)/..; $(ProjectDir)/../../include" PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGLESV2_EXPORTS;_CRT_SECURE_NO_DEPRECATE;NOMINMAX" MinimalRebuild="true" BasicRuntimeChecks="3" RuntimeLibrary="1" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="4" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" AdditionalDependencies="d3d9.lib D3dx9.lib" LinkIncremental="2" ModuleDefinitionFile="libGLESv2.def" GenerateDebugInformation="true" SubSystem="2" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" CommandLine="@echo on&#xD;&#xA;mkdir &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#xD;&#xA;copy &quot;$(OutDir)\libGLESv2.dll&quot; &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#xD;&#xA;copy &quot;$(OutDir)\libGLESv2.lib&quot; &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#xD;&#xA;@echo off&#xD;&#xA;" />
-    </Configuration>
-    <Configuration Name="Release|Win32" OutputDirectory="$(SolutionDir)$(ConfigurationName)" IntermediateDirectory="$(ConfigurationName)" ConfigurationType="2" CharacterSet="1" WholeProgramOptimization="1">
-      <Tool Name="VCPreBuildEventTool" />
-      <Tool Name="VCCustomBuildTool" />
-      <Tool Name="VCXMLDataGeneratorTool" />
-      <Tool Name="VCWebServiceProxyGeneratorTool" />
-      <Tool Name="VCMIDLTool" />
-      <Tool Name="VCCLCompilerTool" Optimization="2" InlineFunctionExpansion="2" AdditionalIncludeDirectories="$(ProjectDir)/..; $(ProjectDir)/../../include" PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGLESV2_EXPORTS;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;_SECURE_SCL=0" RuntimeLibrary="0" UsePrecompiledHeader="0" WarningLevel="3" Detect64BitPortabilityProblems="false" DebugInformationFormat="3" />
-      <Tool Name="VCManagedResourceCompilerTool" />
-      <Tool Name="VCResourceCompilerTool" />
-      <Tool Name="VCPreLinkEventTool" />
-      <Tool Name="VCLinkerTool" AdditionalDependencies="d3d9.lib D3dx9.lib" LinkIncremental="1" IgnoreAllDefaultLibraries="false" ModuleDefinitionFile="libGLESv2.def" GenerateDebugInformation="true" SubSystem="2" OptimizeReferences="2" EnableCOMDATFolding="2" RandomizedBaseAddress="1" DataExecutionPrevention="0" TargetMachine="1" />
-      <Tool Name="VCALinkTool" />
-      <Tool Name="VCManifestTool" />
-      <Tool Name="VCXDCMakeTool" />
-      <Tool Name="VCBscMakeTool" />
-      <Tool Name="VCFxCopTool" />
-      <Tool Name="VCAppVerifierTool" />
-      <Tool Name="VCPostBuildEventTool" CommandLine="@echo on&#xD;&#xA;mkdir &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#xD;&#xA;copy &quot;$(OutDir)\libGLESv2.dll&quot; &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#xD;&#xA;copy &quot;$(OutDir)\libGLESv2.lib&quot; &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#xD;&#xA;@echo off&#xD;&#xA;" />
-    </Configuration>
-  </Configurations>
-  <References>
-  </References>
-  <Files>
-    <Filter Name="Source Files" Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx" UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
-      <File RelativePath=".\Blit.cpp">
-      </File>
-      <File RelativePath=".\Buffer.cpp">
-      </File>
-      <File RelativePath=".\Context.cpp">
-      </File>
-      <File RelativePath="..\common\debug.cpp">
-      </File>
-      <File RelativePath=".\Fence.cpp">
-      </File>
-      <File RelativePath=".\Framebuffer.cpp">
-      </File>
-      <File RelativePath=".\libGLESv2.cpp">
-      </File>
-      <File RelativePath=".\main.cpp">
-      </File>
-      <File RelativePath=".\Program.cpp">
-      </File>
-      <File RelativePath=".\RefCountObject.cpp">
-      </File>
-      <File RelativePath=".\Renderbuffer.cpp">
-      </File>
-      <File RelativePath=".\ResourceManager.cpp">
-      </File>
-      <File RelativePath=".\Shader.cpp">
-      </File>
-      <File RelativePath=".\Texture.cpp">
-      </File>
-      <File RelativePath=".\utilities.cpp">
-      </File>
-      <Filter Name="Geometry">
-        <File RelativePath=".\geometry\IndexDataManager.cpp">
-        </File>
-        <File RelativePath=".\geometry\VertexDataManager.cpp">
-        </File>
-      </Filter>
-    </Filter>
-    <Filter Name="Header Files" Filter="h;hpp;hxx;hm;inl;inc;xsd" UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
-      <File RelativePath=".\Blit.h">
-      </File>
-      <File RelativePath=".\Buffer.h">
-      </File>
-      <File RelativePath=".\Context.h">
-      </File>
-      <File RelativePath=".\Fence.h">
-      </File>
-      <File RelativePath=".\Framebuffer.h">
-      </File>
-      <File RelativePath="..\..\include\GLES2\gl2.h">
-      </File>
-      <File RelativePath="..\..\include\GLES2\gl2ext.h">
-      </File>
-      <File RelativePath="..\..\include\GLES2\gl2platform.h">
-      </File>
-      <File RelativePath=".\main.h">
-      </File>
-      <File RelativePath=".\mathutil.h">
-      </File>
-      <File RelativePath=".\Program.h">
-      </File>
-      <File RelativePath=".\RefCountObject.h">
-      </File>
-      <File RelativePath=".\Renderbuffer.h">
-      </File>
-      <File RelativePath=".\resource.h">
-      </File>
-      <File RelativePath=".\ResourceManager.h">
-      </File>
-      <File RelativePath=".\Shader.h">
-      </File>
-      <File RelativePath=".\Texture.h">
-      </File>
-      <File RelativePath=".\utilities.h">
-      </File>
-      <File RelativePath="..\common\version.h">
-      </File>
-      <Filter Name="Geometry">
-        <File RelativePath=".\geometry\IndexDataManager.h">
-        </File>
-        <File RelativePath=".\geometry\vertexconversion.h">
-        </File>
-        <File RelativePath=".\geometry\VertexDataManager.h">
-        </File>
-      </Filter>
-    </Filter>
-    <File RelativePath=".\libGLESv2.def">
-    </File>
-    <File RelativePath=".\libGLESv2.rc">
-    </File>
-  </Files>
-  <Globals>
-  </Globals>
-</VisualStudioProject>
\ No newline at end of file
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="libGLESv2"
+	ProjectGUID="{B5871A7A-968C-42E3-A33B-981E6F448E78}"
+	RootNamespace="libGLESv2"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="$(ProjectDir)/..; $(ProjectDir)/../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGLESV2_EXPORTS;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				DisableSpecificWarnings="4100;4127;4189;4239;4244;4245;4512;4702"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+				WarnAsError="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="d3d9.lib D3dx9.lib d3dcompiler.lib"
+				LinkIncremental="2"
+				ModuleDefinitionFile="libGLESv2.def"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="@echo on&#x0D;&#x0A;mkdir &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#x0D;&#x0A;copy &quot;$(OutDir)\libGLESv2.dll&quot; &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#x0D;&#x0A;copy &quot;$(OutDir)\libGLESv2.lib&quot; &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#x0D;&#x0A;@echo off&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				AdditionalIncludeDirectories="$(ProjectDir)/..; $(ProjectDir)/../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGLESV2_EXPORTS;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;_SECURE_SCL=0"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				DisableSpecificWarnings="4100;4127;4189;4239;4244;4245;4512;4702;4718"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				WarnAsError="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="d3d9.lib D3dx9.lib d3dcompiler.lib"
+				LinkIncremental="1"
+				IgnoreAllDefaultLibraries="false"
+				ModuleDefinitionFile="libGLESv2.def"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="@echo on&#x0D;&#x0A;mkdir &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#x0D;&#x0A;copy &quot;$(OutDir)\libGLESv2.dll&quot; &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#x0D;&#x0A;copy &quot;$(OutDir)\libGLESv2.lib&quot; &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#x0D;&#x0A;@echo off&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="$(ProjectDir)/..; $(ProjectDir)/../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGLESV2_EXPORTS;_CRT_SECURE_NO_DEPRECATE;NOMINMAX"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				DisableSpecificWarnings="4100;4127;4189;4239;4244;4245;4512;4702;4718"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				WarnAsError="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="d3d9.lib D3dx9.lib d3dcompiler.lib"
+				LinkIncremental="2"
+				ModuleDefinitionFile="libGLESv2.def"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="@echo on&#x0D;&#x0A;mkdir &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#x0D;&#x0A;copy &quot;$(OutDir)\libGLESv2.dll&quot; &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#x0D;&#x0A;copy &quot;$(OutDir)\libGLESv2.lib&quot; &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#x0D;&#x0A;@echo off&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				AdditionalIncludeDirectories="$(ProjectDir)/..; $(ProjectDir)/../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGLESV2_EXPORTS;_CRT_SECURE_NO_DEPRECATE;NOMINMAX;_SECURE_SCL=0"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				DisableSpecificWarnings="4100;4127;4189;4239;4244;4245;4512;4702;4718"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				WarnAsError="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="d3d9.lib D3dx9.lib d3dcompiler.lib"
+				LinkIncremental="1"
+				IgnoreAllDefaultLibraries="false"
+				ModuleDefinitionFile="libGLESv2.def"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="@echo on&#x0D;&#x0A;mkdir &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#x0D;&#x0A;copy &quot;$(OutDir)\libGLESv2.dll&quot; &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#x0D;&#x0A;copy &quot;$(OutDir)\libGLESv2.lib&quot; &quot;$(ProjectDir)..\..\lib\$(ConfigurationName)\&quot;&#x0D;&#x0A;@echo off&#x0D;&#x0A;"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath=".\Blit.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\Buffer.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\Context.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\common\debug.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\Fence.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\Framebuffer.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\HandleAllocator.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\IndexDataManager.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\libGLESv2.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\main.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\Program.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\ProgramBinary.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\Query.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\common\RefCountObject.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\Renderbuffer.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\ResourceManager.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\Shader.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\Texture.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\utilities.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\VertexDataManager.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath=".\Blit.h"
+				>
+			</File>
+			<File
+				RelativePath=".\Buffer.h"
+				>
+			</File>
+			<File
+				RelativePath=".\Context.h"
+				>
+			</File>
+			<File
+				RelativePath=".\Fence.h"
+				>
+			</File>
+			<File
+				RelativePath=".\Framebuffer.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\GLES2\gl2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\GLES2\gl2ext.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\include\GLES2\gl2platform.h"
+				>
+			</File>
+			<File
+				RelativePath=".\HandleAllocator.h"
+				>
+			</File>
+			<File
+				RelativePath=".\IndexDataManager.h"
+				>
+			</File>
+			<File
+				RelativePath=".\main.h"
+				>
+			</File>
+			<File
+				RelativePath=".\mathutil.h"
+				>
+			</File>
+			<File
+				RelativePath=".\Program.h"
+				>
+			</File>
+			<File
+				RelativePath=".\ProgramBinary.h"
+				>
+			</File>
+			<File
+				RelativePath=".\Query.h"
+				>
+			</File>
+			<File
+				RelativePath="..\common\RefCountObject.h"
+				>
+			</File>
+			<File
+				RelativePath=".\Renderbuffer.h"
+				>
+			</File>
+			<File
+				RelativePath=".\resource.h"
+				>
+			</File>
+			<File
+				RelativePath=".\ResourceManager.h"
+				>
+			</File>
+			<File
+				RelativePath=".\Shader.h"
+				>
+			</File>
+			<File
+				RelativePath=".\Texture.h"
+				>
+			</File>
+			<File
+				RelativePath=".\utilities.h"
+				>
+			</File>
+			<File
+				RelativePath="..\common\version.h"
+				>
+			</File>
+			<File
+				RelativePath=".\vertexconversion.h"
+				>
+			</File>
+			<File
+				RelativePath=".\VertexDataManager.h"
+				>
+			</File>
+		</Filter>
+		<File
+			RelativePath=".\libGLESv2.def"
+			>
+		</File>
+		<File
+			RelativePath=".\libGLESv2.rc"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/mathutil.h
--- a/gfx/angle/src/libGLESv2/mathutil.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/mathutil.h	Sat Jun 09 12:08:28 2012 +0900
@@ -8,11 +8,6 @@
 
 #ifndef LIBGLESV2_MATHUTIL_H_
 #define LIBGLESV2_MATHUTIL_H_
-
-#if _MSC_VER <= 1400
-#define _interlockedbittestandreset _interlockedbittestandreset_NAME_CHANGED_TO_AVOID_MSVS2005_ERROR
-#define _interlockedbittestandset _interlockedbittestandset_NAME_CHANGED_TO_AVOID_MSVS2005_ERROR
-#endif
 
 #include <intrin.h>
 #include <math.h>
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/utilities.cpp
--- a/gfx/angle/src/libGLESv2/utilities.cpp	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/utilities.cpp	Sat Jun 09 12:08:28 2012 +0900
@@ -274,6 +274,17 @@
     }
 }
 
+bool IsDepthTexture(GLenum format)
+{
+    if (format == GL_DEPTH_COMPONENT ||
+        format == GL_DEPTH_STENCIL_OES)
+    {
+        return true;
+    }
+
+    return false;
+}
+
 // Returns the size, in bytes, of a single texel in an Image
 int ComputePixelSize(GLenum format, GLenum type)
 {
@@ -294,7 +305,11 @@
       case GL_UNSIGNED_SHORT_4_4_4_4:
       case GL_UNSIGNED_SHORT_5_5_5_1:
       case GL_UNSIGNED_SHORT_5_6_5:
+      case GL_UNSIGNED_SHORT:
         return sizeof(unsigned short);
+      case GL_UNSIGNED_INT:
+      case GL_UNSIGNED_INT_24_8_OES:
+        return sizeof(unsigned int);
       case GL_FLOAT:
         switch (format)
         {
@@ -333,53 +348,6 @@
     return target == GL_TEXTURE_2D || IsCubemapTextureTarget(target);
 }
 
-// Verify that format/type are one of the combinations from table 3.4.
-bool CheckTextureFormatType(GLenum format, GLenum type)
-{
-    switch (type)
-    {
-      case GL_UNSIGNED_BYTE:
-        switch (format)
-        {
-          case GL_RGBA:
-          case GL_BGRA_EXT:
-          case GL_RGB:
-          case GL_ALPHA:
-          case GL_LUMINANCE:
-          case GL_LUMINANCE_ALPHA:
-            return true;
-
-          default:
-            return false;
-        }
-
-      case GL_FLOAT:
-      case GL_HALF_FLOAT_OES:
-        switch (format)
-        {
-          case GL_RGBA:
-          case GL_RGB:
-          case GL_ALPHA:
-          case GL_LUMINANCE:
-          case GL_LUMINANCE_ALPHA:
-            return true;
-
-          default:
-            return false;
-        }
-
-      case GL_UNSIGNED_SHORT_4_4_4_4:
-      case GL_UNSIGNED_SHORT_5_5_5_1:
-        return (format == GL_RGBA);
-
-      case GL_UNSIGNED_SHORT_5_6_5:
-        return (format == GL_RGB);
-
-      default:
-        return false;
-    }
-}
-
 GLenum ExtractFormat(GLenum internalformat)
 {
     switch (internalformat)
@@ -407,6 +375,9 @@
       case GL_LUMINANCE16F_EXT:                return GL_LUMINANCE;
       case GL_LUMINANCE_ALPHA16F_EXT:          return GL_LUMINANCE_ALPHA;
       case GL_BGRA8_EXT:                       return GL_BGRA_EXT;
+      case GL_DEPTH_COMPONENT16:               return GL_DEPTH_COMPONENT;
+      case GL_DEPTH_COMPONENT32_OES:           return GL_DEPTH_COMPONENT;
+      case GL_DEPTH24_STENCIL8_OES:            return GL_DEPTH_STENCIL_OES;
       default:                                 return GL_NONE;   // Unsupported
     }
 }
@@ -438,6 +409,9 @@
       case GL_LUMINANCE16F_EXT:                return GL_HALF_FLOAT_OES;
       case GL_LUMINANCE_ALPHA16F_EXT:          return GL_HALF_FLOAT_OES;
       case GL_BGRA8_EXT:                       return GL_UNSIGNED_BYTE;
+      case GL_DEPTH_COMPONENT16:               return GL_UNSIGNED_SHORT;
+      case GL_DEPTH_COMPONENT32_OES:           return GL_UNSIGNED_INT;
+      case GL_DEPTH24_STENCIL8_OES:            return GL_UNSIGNED_INT_24_8_OES;
       default:                                 return GL_NONE;   // Unsupported
     }
 }
@@ -767,6 +741,7 @@
 {
     switch (format)
     {
+      case GL_NONE:                 return D3DFMT_NULL;
       case GL_RGBA4:
       case GL_RGB5_A1:
       case GL_RGBA8_OES:            return D3DFMT_A8R8G8B8;
@@ -965,6 +940,16 @@
     return false;
 }
 
+bool IsDepthFormat(D3DFORMAT surfaceFormat)
+{
+    return (surfaceFormat == D3DFMT_INTZ);
+}
+
+bool IsStencilFormat(D3DFORMAT surfaceFormat)
+{
+    return (surfaceFormat == D3DFMT_INTZ);
+}
+
 GLsizei GetSamplesFromMultisampleType(D3DMULTISAMPLE_TYPE type)
 {
     if (type == D3DMULTISAMPLE_NONMASKABLE)
diff -r 91d3e124dee2 gfx/angle/src/libGLESv2/utilities.h
--- a/gfx/angle/src/libGLESv2/utilities.h	Tue Apr 24 18:02:41 2012 -0700
+++ b/gfx/angle/src/libGLESv2/utilities.h	Sat Jun 09 12:08:28 2012 +0900
@@ -16,6 +16,9 @@
 
 #include <string>
 
+const D3DFORMAT D3DFMT_INTZ = ((D3DFORMAT)(MAKEFOURCC('I','N','T','Z')));
+const D3DFORMAT D3DFMT_NULL = ((D3DFORMAT)(MAKEFOURCC('N','U','L','L')));
+
 namespace gl
 {
 
@@ -36,9 +39,9 @@
 GLsizei ComputeCompressedPitch(GLsizei width, GLenum format);
 GLsizei ComputeCompressedSize(GLsizei width, GLsizei height, GLenum format);
 bool IsCompressed(GLenum format);
+bool IsDepthTexture(GLenum format);
 bool IsCubemapTextureTarget(GLenum target);
 bool IsInternalTextureTarget(GLenum target);
-bool CheckTextureFormatType(GLenum format, GLenum type);
 GLenum ExtractFormat(GLenum internalformat);
 GLenum ExtractType(GLenum internalformat);
 
@@ -79,6 +82,8 @@
 GLuint GetStencilSize(D3DFORMAT stencilFormat);
 bool IsFloat32Format(D3DFORMAT surfaceFormat);
 bool IsFloat16Format(D3DFORMAT surfaceFormat);
+bool IsDepthFormat(D3DFORMAT surfaceFormat);
+bool IsStencilFormat(D3DFORMAT surfaceFormat);
 
 GLsizei GetSamplesFromMultisampleType(D3DMULTISAMPLE_TYPE type);
 

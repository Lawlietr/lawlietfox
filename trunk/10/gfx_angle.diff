diff -r d713478624d8 gfx/angle/README.mozilla
--- a/gfx/angle/README.mozilla	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/README.mozilla	Thu Jan 05 10:52:20 2012 +0900
@@ -1,6 +1,6 @@
 This is the ANGLE project, from http://code.google.com/p/angleproject/
 
-Current revision: r809
+Current revision: r924
 
 == Applied local patches ==
 
@@ -9,7 +9,6 @@
   angle-intrinsic-msvc2005.patch - work around a MSVC 2005 compile error
   angle-limit-identifiers-to-250-chars.patch - see bug 675625
   angle-use-xmalloc.patch - see bug 680840. Can drop this patch whenever the new preprocessor lands.
-  angle-r885.patch - this is ANGLE r885, fixes bug 695076
 
 In addition to these patches, the Makefile.in files are ours, they're not present in upsteam ANGLE.
 
diff -r d713478624d8 gfx/angle/include/EGL/eglext.h
--- a/gfx/angle/include/EGL/eglext.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/include/EGL/eglext.h	Thu Jan 05 10:52:20 2012 +0900
@@ -318,6 +318,14 @@
 #define EGL_COVERAGE_SAMPLE_RESOLVE_NONE_NV	0x3133
 #endif
 
+#ifndef EGL_EXT_create_context_robustness
+#define EGL_EXT_create_context_robustness 1
+#define EGL_CONTEXT_OPENGL_ROBUST_ACCESS_EXT                0x30BF
+#define EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT  0x3138
+#define EGL_NO_RESET_NOTIFICATION_EXT                       0x31BE
+#define EGL_LOSE_CONTEXT_ON_RESET_EXT                       0x31BF
+#endif
+
 #if KHRONOS_SUPPORT_INT64   /* EGLTimeKHR requires 64-bit uint support */
 #ifndef EGL_NV_system_time
 #define EGL_NV_system_time 1
diff -r d713478624d8 gfx/angle/include/EGL/eglplatform.h
--- a/gfx/angle/include/EGL/eglplatform.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/include/EGL/eglplatform.h	Thu Jan 05 10:52:20 2012 +0900
@@ -89,7 +89,7 @@
 typedef struct wl_egl_pixmap  *EGLNativePixmapType;
 typedef struct wl_egl_window  *EGLNativeWindowType;
 
-#elif defined(__unix__)
+#elif defined(__unix__) && !defined(ANDROID)
 
 /* X11 (tentative)  */
 #include <X11/Xlib.h>
@@ -99,6 +99,14 @@
 typedef Pixmap   EGLNativePixmapType;
 typedef Window   EGLNativeWindowType;
 
+#elif defined(ANDROID)
+
+struct egl_native_pixmap_t;
+
+typedef struct ANativeWindow*           EGLNativeWindowType;
+typedef struct egl_native_pixmap_t*     EGLNativePixmapType;
+typedef void*                           EGLNativeDisplayType;
+
 #else
 #error "Platform not recognized"
 #endif
diff -r d713478624d8 gfx/angle/include/GLES2/gl2ext.h
--- a/gfx/angle/include/GLES2/gl2ext.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/include/GLES2/gl2ext.h	Thu Jan 05 10:52:20 2012 +0900
@@ -207,6 +207,11 @@
 #define GL_MAX_SAMPLES_ANGLE                                    0x8D57
 #endif
 
+/* GL_ANGLE_pack_reverse_row_order */
+#ifndef GL_ANGLE_pack_reverse_row_order
+#define GL_PACK_REVERSE_ROW_ORDER_ANGLE                         0x93A4
+#endif
+
 /* GL_ANGLE_texture_compression_dxt3 */
 #ifndef GL_ANGLE_texture_compression_dxt3
 #define GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE                      0x83F2
@@ -222,6 +227,12 @@
 #define GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE                0x93A0
 #endif
 
+/* GL_ANGLE_texture_usage */
+#ifndef GL_ANGLE_texture_usage
+#define GL_TEXTURE_USAGE_ANGLE                                  0x93A2
+#define GL_FRAMEBUFFER_ATTACHMENT_ANGLE                         0x93A3
+#endif
+
 /*------------------------------------------------------------------------*
  * APPLE extension tokens
  *------------------------------------------------------------------------*/
@@ -325,6 +336,42 @@
 #define GL_UNPACK_SKIP_PIXELS                                   0x0CF4
 #endif
 
+/* GL_EXT_robustness */
+#ifndef GL_EXT_robustness
+#define GL_GUILTY_CONTEXT_RESET_EXT                             0x8253
+#define GL_INNOCENT_CONTEXT_RESET_EXT                           0x8254
+#define GL_UNKNOWN_CONTEXT_RESET_EXT                            0x8255
+#define GL_CONTEXT_ROBUST_ACCESS_EXT                            0x90F3
+#define GL_RESET_NOTIFICATION_STRATEGY_EXT                      0x8256
+#define GL_LOSE_CONTEXT_ON_RESET_EXT                            0x8252
+#define GL_NO_RESET_NOTIFICATION_EXT                            0x8261
+#endif
+
+/* GL_EXT_texture_storage */
+#ifndef GL_EXT_texture_storage
+#define GL_TEXTURE_IMMUTABLE_FORMAT_EXT                         0x912F
+#define GL_ALPHA8_EXT                                           0x803C
+#define GL_LUMINANCE8_EXT                                       0x8040
+#define GL_LUMINANCE8_ALPHA8_EXT                                0x8045
+/* OES_texture_float dependent internal formats */
+#define GL_RGBA32F_EXT                                          0x8814  /* reuse tokens from ARB_texture_float */
+#define GL_RGB32F_EXT                                           0x8815
+#define GL_ALPHA32F_EXT                                         0x8816
+#define GL_LUMINANCE32F_EXT                                     0x8818
+#define GL_LUMINANCE_ALPHA32F_EXT                               0x8819
+/* OES_texture_half_float dependent internal formats */
+#define GL_RGBA16F_EXT                                          0x881A /* reuse tokens from ARB_texture_float */
+#define GL_RGB16F_EXT                                           0x881B
+#define GL_ALPHA16F_EXT                                         0x881C
+#define GL_LUMINANCE16F_EXT                                     0x881E
+#define GL_LUMINANCE_ALPHA16F_EXT                               0x881F
+/* EXT_texture_type_2_10_10_10_REV dependent internal formats */
+#define GL_RGB10_A2_EXT                                         0x8059  /* reuse tokens from EXT_texture */
+#define GL_RGB10_EXT                                            0x8052
+/* EXT_texture_format_BGRA8888 dependent internal formats */
+#define GL_BGRA8_EXT                                            0x93A1
+#endif
+
 /*------------------------------------------------------------------------*
  * DMP extension tokens
  *------------------------------------------------------------------------*/
@@ -805,6 +852,11 @@
 typedef void (GL_APIENTRYP PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
 #endif
 
+/* GL_ANGLE_pack_reverse_row_order */
+#ifndef GL_ANGLE_pack_reverse_row_order
+#define GL_ANGLE_pack_reverse_row_order 1
+#endif
+
 /* GL_ANGLE_texture_compression_dxt3 */
 #ifndef GL_ANGLE_texture_compression_dxt3
 #define GL_ANGLE_texture_compression_dxt3 1
@@ -824,6 +876,11 @@
 typedef void (GL_APIENTRYP PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC) (GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source);
 #endif
 
+/* GL_ANGLE_texture_usage */
+#ifndef GL_ANGLE_texture_usage
+#define GL_ANGLE_texture_usage 1
+#endif
+
 /*------------------------------------------------------------------------*
  * APPLE extension functions
  *------------------------------------------------------------------------*/
@@ -931,6 +988,30 @@
 #define GL_EXT_unpack_subimage 1
 #endif
 
+/* GL_EXT_robustness */
+#ifndef GL_EXT_robustness
+#define GL_EXT_robustness 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_APICALL GLenum GL_APIENTRY glGetGraphicsResetStatusEXT (void);
+GL_APICALL void   GL_APIENTRY glReadnPixelsEXT (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data);
+GL_APICALL void   GL_APIENTRY glGetnUniformfvEXT (GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
+GL_APICALL void   GL_APIENTRY glGetnUniformivEXT (GLuint program, GLint location, GLsizei bufSize, GLint *params);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef GLenum (GL_APIENTRYP PFNGLGETGRAPHICSRESETSTATUSEXTPROC) (void);
+typedef void   (GL_APIENTRYP PFNGLREADNPIXELSEXTPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data);
+typedef void   (GL_APIENTRYP PFNGLGETNUNIFORMFVEXTPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
+typedef void   (GL_APIENTRYP PFNGLGETNUNIFORMIVEXTPROC) (GLuint program, GLint location, GLsizei bufSize, GLint *params);
+#endif
+
+/* GL_EXT_texture_storage */
+#ifndef GL_EXT_texture_storage
+#define GL_EXT_texture_storage 1
+#ifdef GL_GLEXT_PROTOTYPES
+GL_APICALL void GL_APIENTRY TexStorage2DEXT (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (GL_APIENTRYP PFNGLTEXSTORAGE2DEXT) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
+#endif
+
 /*------------------------------------------------------------------------*
  * DMP extension functions
  *------------------------------------------------------------------------*/
diff -r d713478624d8 gfx/angle/include/GLSLANG/ShaderLang.h
--- a/gfx/angle/include/GLSLANG/ShaderLang.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/include/GLSLANG/ShaderLang.h	Thu Jan 05 10:52:20 2012 +0900
@@ -76,7 +76,8 @@
   SH_FLOAT_MAT3     = 0x8B5B,
   SH_FLOAT_MAT4     = 0x8B5C,
   SH_SAMPLER_2D     = 0x8B5E,
-  SH_SAMPLER_CUBE   = 0x8B60
+  SH_SAMPLER_CUBE   = 0x8B60,
+  SH_SAMPLER_2D_RECT_ARB = 0x8B63
 } ShDataType;
 
 typedef enum {
@@ -137,6 +138,7 @@
     // Set to 1 to enable the extension, else 0.
     int OES_standard_derivatives;
     int OES_EGL_image_external;
+    int ARB_texture_rectangle;
 } ShBuiltInResources;
 
 //
diff -r d713478624d8 gfx/angle/samples/build_samples.gyp
--- a/gfx/angle/samples/build_samples.gyp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/samples/build_samples.gyp	Thu Jan 05 10:52:20 2012 +0900
@@ -159,6 +159,14 @@
             'gles2_book/TextureWrap/TextureWrap.c',
           ],
         },
+        {
+          'target_name': 'post_sub_buffer',
+          'type': 'executable',
+          'dependencies': ['es_util'],
+          'sources': [
+            'gles2_book/PostSubBuffer/PostSubBuffer.c',
+          ],
+        },
       ],
     }],
   ],
diff -r d713478624d8 gfx/angle/samples/gles2_book/Common/esUtil.c
--- a/gfx/angle/samples/gles2_book/Common/esUtil.c	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/samples/gles2_book/Common/esUtil.c	Thu Jan 05 10:52:20 2012 +0900
@@ -22,10 +22,16 @@
 #include <stdlib.h>
 #include <GLES2/gl2.h>
 #include <EGL/egl.h>
+#include <EGL/eglext.h>
 #include "esUtil.h"
 #include "esUtil_win.h"
 
 
+///
+//  Extensions
+//
+
+PFNEGLPOSTSUBBUFFERNVPROC eglPostSubBufferNV;
 
 
 ///
@@ -35,7 +41,7 @@
 //
 EGLBoolean CreateEGLContext ( EGLNativeWindowType hWnd, EGLDisplay* eglDisplay,
                               EGLContext* eglContext, EGLSurface* eglSurface,
-                              EGLint attribList[])
+                              EGLint* configAttribList, EGLint* surfaceAttribList)
 {
    EGLint numConfigs;
    EGLint majorVersion;
@@ -45,7 +51,7 @@
    EGLSurface surface;
    EGLConfig config;
    EGLint contextAttribs[] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE, EGL_NONE };
-
+   
    // Get Display
    display = eglGetDisplay(GetDC(hWnd));
    if ( display == EGL_NO_DISPLAY )
@@ -59,6 +65,9 @@
       return EGL_FALSE;
    }
 
+   // Bind to extensions
+   eglPostSubBufferNV = (PFNEGLPOSTSUBBUFFERNVPROC) eglGetProcAddress("eglPostSubBufferNV");
+
    // Get configs
    if ( !eglGetConfigs(display, NULL, 0, &numConfigs) )
    {
@@ -66,13 +75,13 @@
    }
 
    // Choose config
-   if ( !eglChooseConfig(display, attribList, &config, 1, &numConfigs) )
+   if ( !eglChooseConfig(display, configAttribList, &config, 1, &numConfigs) )
    {
       return EGL_FALSE;
    }
 
    // Create a surface
-   surface = eglCreateWindowSurface(display, config, (EGLNativeWindowType)hWnd, NULL);
+   surface = eglCreateWindowSurface(display, config, (EGLNativeWindowType)hWnd, surfaceAttribList);
    if ( surface == EGL_NO_SURFACE )
    {
       return EGL_FALSE;
@@ -128,10 +137,11 @@
 //          ES_WINDOW_DEPTH       - specifies that a depth buffer should be created
 //          ES_WINDOW_STENCIL     - specifies that a stencil buffer should be created
 //          ES_WINDOW_MULTISAMPLE - specifies that a multi-sample buffer should be created
+//          ES_WINDOW_POST_SUB_BUFFER_SUPPORTED - specifies that EGL_POST_SUB_BUFFER_NV is supported.
 //
 GLboolean ESUTIL_API esCreateWindow ( ESContext *esContext, LPCTSTR title, GLint width, GLint height, GLuint flags )
 {
-   EGLint attribList[] =
+   EGLint configAttribList[] =
    {
        EGL_RED_SIZE,       5,
        EGL_GREEN_SIZE,     6,
@@ -142,6 +152,11 @@
        EGL_SAMPLE_BUFFERS, (flags & ES_WINDOW_MULTISAMPLE) ? 1 : 0,
        EGL_NONE
    };
+   EGLint surfaceAttribList[] =
+   {
+       EGL_POST_SUB_BUFFER_SUPPORTED_NV, flags & (ES_WINDOW_POST_SUB_BUFFER_SUPPORTED) ? EGL_TRUE : EGL_FALSE,
+       EGL_NONE, EGL_NONE
+   };
    
    if ( esContext == NULL )
    {
@@ -161,7 +176,8 @@
                             &esContext->eglDisplay,
                             &esContext->eglContext,
                             &esContext->eglSurface,
-                            attribList) )
+                            configAttribList,
+                            surfaceAttribList ) )
    {
       return GL_FALSE;
    }
diff -r d713478624d8 gfx/angle/samples/gles2_book/Common/esUtil.h
--- a/gfx/angle/samples/gles2_book/Common/esUtil.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/samples/gles2_book/Common/esUtil.h	Thu Jan 05 10:52:20 2012 +0900
@@ -22,6 +22,7 @@
 //
 #include <GLES2/gl2.h>
 #include <EGL/egl.h>
+#include <EGL/eglext.h>
 
 #ifdef __cplusplus
 
@@ -44,9 +45,10 @@
 #define ES_WINDOW_DEPTH         2 
 /// esCreateWindow flag - stencil buffer
 #define ES_WINDOW_STENCIL       4
-/// esCreateWindow flat - multi-sample buffer
+/// esCreateWindow flag - multi-sample buffer
 #define ES_WINDOW_MULTISAMPLE   8
-
+/// esCreateWindow flag - EGL_POST_SUB_BUFFER_NV supported.
+#define ES_WINDOW_POST_SUB_BUFFER_SUPPORTED 16
 
 ///
 // Types
@@ -88,6 +90,13 @@
 
 
 ///
+//  Extensions
+//
+
+extern PFNEGLPOSTSUBBUFFERNVPROC eglPostSubBufferNV;
+
+
+///
 //  Public Functions
 //
 
@@ -110,6 +119,7 @@
 ///         ES_WINDOW_DEPTH   - specifies that a depth buffer should be created
 ///         ES_WINDOW_STENCIL - specifies that a stencil buffer should be created
 ///         ES_WINDOW_MULTISAMPLE - specifies that a multi-sample buffer should be created
+///         ES_WINDOW_POST_SUB_BUFFER_SUPPORTED - specifies that EGL_POST_SUB_BUFFER_NV is supported.
 /// \return GL_TRUE if window creation is succesful, GL_FALSE otherwise
 GLboolean ESUTIL_API esCreateWindow ( ESContext *esContext, LPCTSTR title, GLint width, GLint height, GLuint flags );
 
diff -r d713478624d8 gfx/angle/src/common/version.h
--- a/gfx/angle/src/common/version.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/common/version.h	Thu Jan 05 10:52:20 2012 +0900
@@ -1,7 +1,7 @@
-#define MAJOR_VERSION 0
+#define MAJOR_VERSION 1
 #define MINOR_VERSION 0
 #define BUILD_VERSION 0
-#define BUILD_REVISION 809
+#define BUILD_REVISION 930
 
 #define STRINGIFY(x) #x
 #define MACRO_STRINGIFY(x) STRINGIFY(x)
diff -r d713478624d8 gfx/angle/src/compiler/BaseTypes.h
--- a/gfx/angle/src/compiler/BaseTypes.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/compiler/BaseTypes.h	Thu Jan 05 10:52:20 2012 +0900
@@ -43,6 +43,7 @@
     EbtSampler2D,
     EbtSamplerCube,
     EbtSamplerExternalOES,  // Only valid if OES_EGL_image_external exists.
+    EbtSampler2DRect,       // Only valid if GL_ARB_texture_rectangle exists.
     EbtGuardSamplerEnd,    // non type:  see implementation of IsSampler()
     EbtStruct,
     EbtAddress,            // should be deprecated??
@@ -59,6 +60,7 @@
     case EbtSampler2D:         return "sampler2D";         break;
     case EbtSamplerCube:       return "samplerCube";       break;
     case EbtSamplerExternalOES: return "samplerExternalOES"; break;
+    case EbtSampler2DRect:     return "sampler2DRect";     break;
     case EbtStruct:            return "structure";         break;
     default:                   return "unknown type";
     }
diff -r d713478624d8 gfx/angle/src/compiler/BuiltInFunctionEmulator.cpp
--- a/gfx/angle/src/compiler/BuiltInFunctionEmulator.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/compiler/BuiltInFunctionEmulator.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -333,12 +333,12 @@
     out << "// BEGIN: Generated code for built-in function emulation\n\n";
     if (withPrecision) {
         out << "#if defined(GL_FRAGMENT_PRECISION_HIGH)\n"
-            << "#define webgl_emulation_precision highp\n"
+            << "#define webgl_emu_precision highp\n"
             << "#else\n"
-            << "#define webgl_emulation_precision mediump\n"
+            << "#define webgl_emu_precision mediump\n"
             << "#endif\n\n";
     } else {
-        out << "#define webgl_emulation_precision\n\n";
+        out << "#define webgl_emu_precision\n\n";
     }
     for (size_t i = 0; i < mFunctions.size(); ++i) {
         out << mFunctionSource[mFunctions[i]] << "\n\n";
diff -r d713478624d8 gfx/angle/src/compiler/Initialize.cpp
--- a/gfx/angle/src/compiler/Initialize.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/compiler/Initialize.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -19,7 +19,7 @@
 // Prototypes for built-in functions seen by both vertex and fragment shaders.
 //
 //============================================================================
-static TString BuiltInFunctionsCommon()
+static TString BuiltInFunctionsCommon(const ShBuiltInResources& resources)
 {
     TString s;
 
@@ -311,6 +311,26 @@
     s.append(TString("bvec4 not(bvec4 x);"));
 
     //
+    // Texture Functions.
+    //
+    s.append(TString("vec4 texture2D(sampler2D sampler, vec2 coord);"));
+    s.append(TString("vec4 texture2DProj(sampler2D sampler, vec3 coord);"));
+    s.append(TString("vec4 texture2DProj(sampler2D sampler, vec4 coord);"));
+    s.append(TString("vec4 textureCube(samplerCube sampler, vec3 coord);"));
+
+    if (resources.OES_EGL_image_external) {
+        s.append(TString("vec4 texture2D(samplerExternalOES sampler, vec2 coord);"));
+        s.append(TString("vec4 texture2DProj(samplerExternalOES sampler, vec3 coord);"));
+        s.append(TString("vec4 texture2DProj(samplerExternalOES sampler, vec4 coord);"));
+    }
+
+    if (resources.ARB_texture_rectangle) {
+        s.append(TString("vec4 texture2DRect(sampler2DRect sampler, vec2 coord);"));
+        s.append(TString("vec4 texture2DRectProj(sampler2DRect sampler, vec3 coord);"));
+        s.append(TString("vec4 texture2DRectProj(sampler2DRect sampler, vec4 coord);"));
+    }
+
+    //
     // Noise functions.
     //
     //s.append(TString("float noise1(float x);"));
@@ -353,22 +373,11 @@
     //
     // Texture Functions.
     //
-    s.append(TString("vec4 texture2D(sampler2D sampler, vec2 coord);"));
-    s.append(TString("vec4 texture2DProj(sampler2D sampler, vec3 coord);"));
-    s.append(TString("vec4 texture2DProj(sampler2D sampler, vec4 coord);"));
-    s.append(TString("vec4 textureCube(samplerCube sampler, vec3 coord);"));
-
     s.append(TString("vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod);"));
     s.append(TString("vec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod);"));
     s.append(TString("vec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod);"));
     s.append(TString("vec4 textureCubeLod(samplerCube sampler, vec3 coord, float lod);"));
 
-    if (resources.OES_EGL_image_external) {
-        s.append(TString("vec4 texture2D(samplerExternalOES sampler, vec2 coord);"));
-        s.append(TString("vec4 texture2DProj(samplerExternalOES sampler, vec3 coord);"));
-        s.append(TString("vec4 texture2DProj(samplerExternalOES sampler, vec4 coord);"));
-    }
-
     return s;
 }
 
@@ -384,22 +393,11 @@
     //
     // Texture Functions.
     //
-    s.append(TString("vec4 texture2D(sampler2D sampler, vec2 coord);"));
-    s.append(TString("vec4 texture2DProj(sampler2D sampler, vec3 coord);"));
-    s.append(TString("vec4 texture2DProj(sampler2D sampler, vec4 coord);"));
-    s.append(TString("vec4 textureCube(samplerCube sampler, vec3 coord);"));
-
     s.append(TString("vec4 texture2D(sampler2D sampler, vec2 coord, float bias);"));
     s.append(TString("vec4 texture2DProj(sampler2D sampler, vec3 coord, float bias);"));
     s.append(TString("vec4 texture2DProj(sampler2D sampler, vec4 coord, float bias);"));
     s.append(TString("vec4 textureCube(samplerCube sampler, vec3 coord, float bias);"));
 
-    if (resources.OES_EGL_image_external) {
-        s.append(TString("vec4 texture2D(samplerExternalOES sampler, vec2 coord);"));
-        s.append(TString("vec4 texture2DProj(samplerExternalOES sampler, vec3 coord);"));
-        s.append(TString("vec4 texture2DProj(samplerExternalOES sampler, vec4 coord);"));
-    }
-
     if (resources.OES_standard_derivatives) {
         s.append(TString("float dFdx(float p);"));
         s.append(TString("vec2  dFdx(vec2  p);"));
@@ -500,14 +498,14 @@
     switch (type) {
     case SH_FRAGMENT_SHADER:
         builtInStrings.push_back(DefaultPrecisionFragment());
-        builtInStrings.push_back(BuiltInFunctionsCommon());
+        builtInStrings.push_back(BuiltInFunctionsCommon(resources));
         builtInStrings.push_back(BuiltInFunctionsFragment(resources));
         builtInStrings.push_back(StandardUniforms());
         break;
 
     case SH_VERTEX_SHADER:
         builtInStrings.push_back(DefaultPrecisionVertex());
-        builtInStrings.push_back(BuiltInFunctionsCommon());
+        builtInStrings.push_back(BuiltInFunctionsCommon(resources));
         builtInStrings.push_back(BuiltInFunctionsVertex(resources));
         builtInStrings.push_back(StandardUniforms());
         break;
@@ -624,7 +622,7 @@
     switch(type) {
     case SH_FRAGMENT_SHADER: {
             // Set up gl_FragData.  The array size.
-            TType fragData(EbtFloat, EbpMedium, EvqFragColor,   4, false, true);
+            TType fragData(EbtFloat, EbpMedium, EvqFragData, 4, false, true);
             fragData.setArraySize(resources.MaxDrawBuffers);
             symbolTable.insert(*new TVariable(NewPoolTString("gl_FragData"),    fragData));
         }
@@ -640,4 +638,6 @@
         extBehavior["GL_OES_standard_derivatives"] = EBhUndefined;
     if (resources.OES_EGL_image_external)
         extBehavior["GL_OES_EGL_image_external"] = EBhUndefined;
+    if (resources.ARB_texture_rectangle)
+        extBehavior["GL_ARB_texture_rectangle"] = EBhUndefined;
 }
diff -r d713478624d8 gfx/angle/src/compiler/OutputHLSL.cpp
--- a/gfx/angle/src/compiler/OutputHLSL.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/compiler/OutputHLSL.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -45,9 +45,12 @@
     mUsesPointSize = false;
     mUsesXor = false;
     mUsesMod1 = false;
-    mUsesMod2 = false;
-    mUsesMod3 = false;
-    mUsesMod4 = false;
+    mUsesMod2v = false;
+    mUsesMod2f = false;
+    mUsesMod3v = false;
+    mUsesMod3f = false;
+    mUsesMod4v = false;
+    mUsesMod4f = false;
     mUsesFaceforward1 = false;
     mUsesFaceforward2 = false;
     mUsesFaceforward3 = false;
@@ -185,7 +188,7 @@
 
         if (mUsesFragCoord)
         {
-            out << "uniform float4 dx_Viewport;\n"
+            out << "uniform float4 dx_Coord;\n"
                    "uniform float2 dx_Depth;\n";
         }
 
@@ -479,8 +482,17 @@
                "}\n"
                "\n";
     }
-    
-    if (mUsesMod2)
+
+    if (mUsesMod2v)
+    {
+        out << "float2 mod(float2 x, float2 y)\n"
+               "{\n"
+               "    return x - y * floor(x / y);\n"
+               "}\n"
+               "\n";
+    }
+
+    if (mUsesMod2f)
     {
         out << "float2 mod(float2 x, float y)\n"
                "{\n"
@@ -489,7 +501,16 @@
                "\n";
     }
     
-    if (mUsesMod3)
+    if (mUsesMod3v)
+    {
+        out << "float3 mod(float3 x, float3 y)\n"
+               "{\n"
+               "    return x - y * floor(x / y);\n"
+               "}\n"
+               "\n";
+    }
+
+    if (mUsesMod3f)
     {
         out << "float3 mod(float3 x, float y)\n"
                "{\n"
@@ -498,7 +519,16 @@
                "\n";
     }
 
-    if (mUsesMod4)
+    if (mUsesMod4v)
+    {
+        out << "float4 mod(float4 x, float4 y)\n"
+               "{\n"
+               "    return x - y * floor(x / y);\n"
+               "}\n"
+               "\n";
+    }
+
+    if (mUsesMod4f)
     {
         out << "float4 mod(float4 x, float y)\n"
                "{\n"
@@ -1447,12 +1477,17 @@
       case EOpVectorNotEqual:   outputTriplet(visit, "(", " != ", ")");                break;
       case EOpMod:
         {
-            switch (node->getSequence()[0]->getAsTyped()->getNominalSize())   // Number of components in the first argument
+            // We need to look at the number of components in both arguments
+            switch (node->getSequence()[0]->getAsTyped()->getNominalSize() * 10
+                     + node->getSequence()[1]->getAsTyped()->getNominalSize())
             {
-              case 1: mUsesMod1 = true; break;
-              case 2: mUsesMod2 = true; break;
-              case 3: mUsesMod3 = true; break;
-              case 4: mUsesMod4 = true; break;
+              case 11: mUsesMod1 = true; break;
+              case 22: mUsesMod2v = true; break;
+              case 21: mUsesMod2f = true; break;
+              case 33: mUsesMod3v = true; break;
+              case 31: mUsesMod3f = true; break;
+              case 44: mUsesMod4v = true; break;
+              case 41: mUsesMod4f = true; break;
               default: UNREACHABLE();
             }
 
diff -r d713478624d8 gfx/angle/src/compiler/OutputHLSL.h
--- a/gfx/angle/src/compiler/OutputHLSL.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/compiler/OutputHLSL.h	Thu Jan 05 10:52:20 2012 +0900
@@ -91,9 +91,12 @@
     bool mUsesPointSize;
     bool mUsesXor;
     bool mUsesMod1;
-    bool mUsesMod2;
-    bool mUsesMod3;
-    bool mUsesMod4;
+    bool mUsesMod2v;
+    bool mUsesMod2f;
+    bool mUsesMod3v;
+    bool mUsesMod3f;
+    bool mUsesMod4v;
+    bool mUsesMod4f;
     bool mUsesFaceforward1;
     bool mUsesFaceforward2;
     bool mUsesFaceforward3;
diff -r d713478624d8 gfx/angle/src/compiler/ParseHelper.cpp
--- a/gfx/angle/src/compiler/ParseHelper.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/compiler/ParseHelper.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -553,7 +553,7 @@
         return true;
     }
 
-    if (!type->isMatrix()) {
+    if (!type->isMatrix() || !matrixInMatrix) {
         if ((op != EOpConstructStruct && size != 1 && size < type->getObjectSize()) ||
             (op == EOpConstructStruct && size < type->getObjectSize())) {
             error(line, "not enough data provided for construction", "constructor", "");
diff -r d713478624d8 gfx/angle/src/compiler/ShaderLang.cpp
--- a/gfx/angle/src/compiler/ShaderLang.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/compiler/ShaderLang.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -122,6 +122,7 @@
     // Extensions.
     resources->OES_standard_derivatives = 0;
     resources->OES_EGL_image_external = 0;
+    resources->ARB_texture_rectangle = 0;
 }
 
 //
diff -r d713478624d8 gfx/angle/src/compiler/VariableInfo.cpp
--- a/gfx/angle/src/compiler/VariableInfo.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/compiler/VariableInfo.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -63,6 +63,7 @@
           }
       case EbtSampler2D: return SH_SAMPLER_2D;
       case EbtSamplerCube: return SH_SAMPLER_CUBE;
+      case EbtSampler2DRect: return SH_SAMPLER_2D_RECT_ARB;
       default: UNREACHABLE();
     }
     return SH_NONE;
diff -r d713478624d8 gfx/angle/src/compiler/glslang.l
--- a/gfx/angle/src/compiler/glslang.l	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/compiler/glslang.l	Thu Jan 05 10:52:20 2012 +0900
@@ -121,6 +121,7 @@
 "sampler2D"       { context->lexAfterType = true; return SAMPLER2D; }
 "samplerCube"     { context->lexAfterType = true; return SAMPLERCUBE; }
 "samplerExternalOES" { context->lexAfterType = true; return SAMPLER_EXTERNAL_OES; }
+"sampler2DRect" { context->lexAfterType = true; return SAMPLER2DRECT; }
 
 "struct"       { context->lexAfterType = true; return(STRUCT); }
 
diff -r d713478624d8 gfx/angle/src/compiler/glslang.y
--- a/gfx/angle/src/compiler/glslang.y	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/compiler/glslang.y	Thu Jan 05 10:52:20 2012 +0900
@@ -98,7 +98,7 @@
 %token <lex> BVEC2 BVEC3 BVEC4 IVEC2 IVEC3 IVEC4 VEC2 VEC3 VEC4
 %token <lex> MATRIX2 MATRIX3 MATRIX4 IN_QUAL OUT_QUAL INOUT_QUAL UNIFORM VARYING
 %token <lex> STRUCT VOID_TYPE WHILE
-%token <lex> SAMPLER2D SAMPLERCUBE SAMPLER_EXTERNAL_OES
+%token <lex> SAMPLER2D SAMPLERCUBE SAMPLER_EXTERNAL_OES SAMPLER2DRECT
 
 %token <lex> IDENTIFIER TYPE_NAME FLOATCONSTANT INTCONSTANT BOOLCONSTANT
 %token <lex> FIELD_SELECTION
@@ -1624,6 +1624,15 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         $$.setBasic(EbtSamplerExternalOES, qual, $1.line);
     }
+    | SAMPLER2DRECT {
+        if (!context->supportsExtension("GL_ARB_texture_rectangle")) {
+            context->error($1.line, "unsupported type", "sampler2DRect", "");
+            context->recover();
+        }
+        FRAG_VERT_ONLY("sampler2DRect", $1.line);
+        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
+        $$.setBasic(EbtSampler2DRect, qual, $1.line);
+    }
     | struct_specifier {
         FRAG_VERT_ONLY("struct", $1.line);
         $$ = $1;
diff -r d713478624d8 gfx/angle/src/compiler/glslang_lex.cpp
--- a/gfx/angle/src/compiler/glslang_lex.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/compiler/glslang_lex.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -63,7 +63,6 @@
 typedef unsigned char flex_uint8_t; 
 typedef unsigned short int flex_uint16_t;
 typedef unsigned int flex_uint32_t;
-#endif /* ! C99 */
 
 /* Limits of integral types. */
 #ifndef INT8_MIN
@@ -94,6 +93,8 @@
 #define UINT32_MAX             (4294967295U)
 #endif
 
+#endif /* ! C99 */
+
 #endif /* ! FLEXINT_H */
 
 #ifdef __cplusplus
@@ -167,7 +168,15 @@
 
 /* Size of default input buffer. */
 #ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
 #define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
 #endif
 
 /* The state buf must be large enough to hold one state per character in the main buffer.
@@ -371,8 +380,8 @@
 	*yy_cp = '\0'; \
 	yyg->yy_c_buf_p = yy_cp;
 
-#define YY_NUM_RULES 146
-#define YY_END_OF_BUFFER 147
+#define YY_NUM_RULES 147
+#define YY_END_OF_BUFFER 148
 /* This struct is not used in this scanner,
    but its presence is necessary. */
 struct yy_trans_info
@@ -380,55 +389,55 @@
 	flex_int32_t yy_verify;
 	flex_int32_t yy_nxt;
 	};
-static yyconst flex_int16_t yy_accept[422] =
+static yyconst flex_int16_t yy_accept[426] =
     {   0,
-        0,    0,    0,    0,    0,    0,  147,  145,  144,  144,
-      129,  135,  140,  124,  125,  133,  132,  121,  130,  128,
-      134,   93,   93,  122,  118,  136,  123,  137,  141,   89,
-      126,  127,  139,   89,   89,   89,   89,   89,   89,   89,
-       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
-       89,   89,   89,  119,  138,  120,  131,    3,    4,    3,
-      143,  146,  142,  115,  101,  120,  109,  104,   99,  107,
-       97,  108,   98,   96,    2,    1,  100,   95,   91,   92,
-        0,    0,   93,  127,  119,  126,  116,  112,  114,  113,
-      117,   89,  105,  111,   89,   89,   89,   89,   89,   89,
-
-       89,   89,   89,   89,   17,   89,   89,   89,   89,   89,
-       89,   89,   89,   89,   89,   89,   89,   89,   20,   22,
-       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
-       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
-       89,   89,   89,   89,   89,   89,  106,  110,    5,  142,
-        0,    1,   95,    0,    0,   94,   90,  102,  103,   49,
-       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
-       89,   89,   89,   89,   89,   89,   89,   18,   89,   89,
-       89,   89,   89,   89,   89,   89,   26,   89,   89,   89,
-       89,   89,   89,   89,   89,   23,   89,   89,   89,   89,
-
-       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
-       89,   89,   89,   89,   89,   89,   89,   89,    0,   96,
-        0,   95,   89,   28,   89,   89,   86,   89,   89,   89,
-       89,   89,   89,   89,   21,   52,   89,   89,   89,   89,
-       89,   57,   71,   89,   89,   89,   89,   89,   89,   89,
-       89,   68,    9,   33,   34,   35,   89,   89,   89,   89,
-       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
-       89,   55,   29,   89,   89,   89,   89,   89,   89,   36,
-       37,   38,   27,   89,   89,   89,   15,   42,   43,   44,
-       50,   12,   89,   89,   89,   89,   82,   83,   84,   89,
-
-       30,   72,   25,   79,   80,   81,    7,   76,   77,   78,
-       89,   24,   74,   89,   89,   39,   40,   41,   89,   89,
-       89,   89,   89,   89,   89,   89,   89,   69,   89,   89,
-       89,   89,   89,   89,   89,   51,   89,   88,   89,   89,
-       19,   89,   89,   89,   89,   70,   65,   60,   89,   89,
-       89,   89,   89,   75,   56,   89,   63,   32,   89,   85,
-       64,   48,   58,   89,   89,   89,   89,   89,   89,   89,
-       89,   59,   31,   89,   89,   89,    8,   89,   89,   89,
-       89,   89,   53,   13,   89,   14,   89,   89,   16,   66,
-       89,   89,   89,   61,   89,   89,   89,   89,   54,   73,
-
-       62,   11,   67,    6,   87,   10,   45,   89,   89,   89,
-       89,   46,   89,   89,   89,   89,   89,   89,   89,   47,
-        0
+        0,    0,    0,    0,    0,    0,  148,  146,  145,  145,
+      130,  136,  141,  125,  126,  134,  133,  122,  131,  129,
+      135,   94,   94,  123,  119,  137,  124,  138,  142,   90,
+      127,  128,  140,   90,   90,   90,   90,   90,   90,   90,
+       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
+       90,   90,   90,  120,  139,  121,  132,    3,    4,    3,
+      144,  147,  143,  116,  102,  121,  110,  105,  100,  108,
+       98,  109,   99,   97,    2,    1,  101,   96,   92,   93,
+        0,    0,   94,  128,  120,  127,  117,  113,  115,  114,
+      118,   90,  106,  112,   90,   90,   90,   90,   90,   90,
+
+       90,   90,   90,   90,   17,   90,   90,   90,   90,   90,
+       90,   90,   90,   90,   90,   90,   90,   90,   20,   22,
+       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
+       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
+       90,   90,   90,   90,   90,   90,  107,  111,    5,  143,
+        0,    1,   96,    0,    0,   95,   91,  103,  104,   50,
+       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
+       90,   90,   90,   90,   90,   90,   90,   18,   90,   90,
+       90,   90,   90,   90,   90,   90,   26,   90,   90,   90,
+       90,   90,   90,   90,   90,   23,   90,   90,   90,   90,
+
+       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
+       90,   90,   90,   90,   90,   90,   90,   90,    0,   97,
+        0,   96,   90,   28,   90,   90,   87,   90,   90,   90,
+       90,   90,   90,   90,   21,   53,   90,   90,   90,   90,
+       90,   58,   72,   90,   90,   90,   90,   90,   90,   90,
+       90,   69,    9,   33,   34,   35,   90,   90,   90,   90,
+       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
+       90,   56,   29,   90,   90,   90,   90,   90,   90,   36,
+       37,   38,   27,   90,   90,   90,   15,   42,   43,   44,
+       51,   12,   90,   90,   90,   90,   83,   84,   85,   90,
+
+       30,   73,   25,   80,   81,   82,    7,   77,   78,   79,
+       90,   24,   75,   90,   90,   39,   40,   41,   90,   90,
+       90,   90,   90,   90,   90,   90,   90,   70,   90,   90,
+       90,   90,   90,   90,   90,   52,   90,   89,   90,   90,
+       19,   90,   90,   90,   90,   71,   66,   61,   90,   90,
+       90,   90,   90,   76,   57,   90,   64,   32,   90,   86,
+       65,   49,   59,   90,   90,   90,   90,   90,   90,   90,
+       90,   60,   31,   90,   90,   90,    8,   90,   90,   90,
+       90,   90,   54,   13,   90,   14,   90,   90,   16,   67,
+       90,   90,   90,   62,   90,   90,   90,   90,   55,   74,
+
+       63,   11,   68,    6,   88,   10,   45,   90,   90,   90,
+       90,   90,   90,   46,   90,   90,   90,   48,   90,   90,
+       90,   90,   90,   47,    0
     } ;
 
 static yyconst flex_int32_t yy_ec[256] =
@@ -441,12 +450,12 @@
        18,   19,   16,   16,   16,   20,   20,   21,   22,   23,
        24,   25,   26,    1,   27,   27,   28,   29,   30,   27,
        31,   31,   31,   31,   31,   31,   31,   31,   32,   31,
-       31,   31,   33,   31,   31,   31,   31,   34,   31,   31,
-       35,    1,   36,   37,   31,    1,   38,   39,   40,   41,
-
-       42,   43,   44,   45,   46,   31,   47,   48,   49,   50,
-       51,   52,   31,   53,   54,   55,   56,   57,   58,   59,
-       60,   61,   62,   63,   64,   65,    1,    1,    1,    1,
+       31,   33,   34,   31,   31,   31,   31,   35,   31,   31,
+       36,    1,   37,   38,   31,    1,   39,   40,   41,   42,
+
+       43,   44,   45,   46,   47,   31,   48,   49,   50,   51,
+       52,   53,   31,   54,   55,   56,   57,   58,   59,   60,
+       61,   62,   63,   64,   65,   66,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -463,199 +472,201 @@
         1,    1,    1,    1,    1
     } ;
 
-static yyconst flex_int32_t yy_meta[66] =
+static yyconst flex_int32_t yy_meta[67] =
     {   0,
         1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    3,    3,    3,    3,    3,    3,
         1,    1,    1,    1,    1,    1,    3,    3,    3,    3,
-        4,    4,    4,    4,    1,    1,    1,    3,    3,    3,
-        3,    3,    3,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    1,    1,    1,    3,    3,
+        3,    3,    3,    3,    4,    4,    4,    4,    4,    4,
         4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
-        4,    1,    1,    1,    1
+        4,    4,    1,    1,    1,    1
     } ;
 
-static yyconst flex_int16_t yy_base[427] =
+static yyconst flex_int16_t yy_base[431] =
     {   0,
-        0,    0,   63,   64,   73,    0,  621,  622,  622,  622,
-      596,   44,  133,  622,  622,  595,  130,  622,  129,  127,
-      141,  153,  161,  593,  622,  177,  593,   46,  622,    0,
-      622,  622,  124,   97,  105,  137,  148,  154,  168,  565,
-      151,  167,  564,  121,  158,  558,  111,  571,  177,  176,
-      157,  188,  567,  622,  168,  622,  622,  622,  622,  597,
-      622,  622,    0,  622,  622,  622,  622,  622,  622,  622,
-      622,  622,  622,  225,  622,    0,  622,  231,  259,  267,
-      288,    0,  297,  622,  622,  622,  586,  622,  622,  622,
-      585,    0,  622,  622,  559,  552,  555,  563,  562,  549,
-
-      564,  551,  557,  545,  542,  555,  542,  539,  539,  545,
-      533,  540,  537,  547,  533,  539,  542,  543,    0,  205,
-      542,  170,  528,  541,  532,  534,  524,  538,  535,  537,
-      520,  525,  522,  511,  199,  525,  521,  523,  512,  515,
-      212,  520,  512,  524,  138,  517,  622,  622,  622,    0,
-      313,    0,  325,  341,  275,  353,    0,  622,  622,    0,
-      509,  513,  522,  519,  503,  503,  179,  518,  515,  515,
-      513,  510,  502,  508,  495,  506,  509,    0,  506,  494,
-      501,  498,  502,  495,  484,  483,  496,  499,  496,  491,
-      482,  246,  487,  490,  481,  478,  482,  488,  479,  470,
-
-      473,  471,  481,  467,  465,  465,  467,  464,  475,  474,
-      245,  469,  464,  453,  251,  471,  473,  462,  359,  365,
-      371,  377,  463,    0,  461,  301,    0,  453,  451,  459,
-      448,  465,  454,  317,    0,    0,  448,  458,  458,  443,
-      329,    0,    0,  445,  345,  446,  440,  439,  440,  439,
-      381,    0,    0,    0,    0,    0,  435,  436,  441,  432,
-      445,  440,  439,  431,  435,  427,  430,  434,  439,  438,
-      429,    0,    0,  435,  424,  424,  429,  428,  425,    0,
-        0,    0,    0,  415,  427,  429,    0,    0,    0,    0,
-        0,    0,  417,  418,  412,  422,    0,    0,    0,  413,
+        0,    0,   64,   65,   74,    0,  627,  628,  628,  628,
+      602,   45,  135,  628,  628,  601,  132,  628,  131,  129,
+      143,  155,  163,  599,  628,  179,  599,   47,  628,    0,
+      628,  628,  126,   98,  108,  147,  158,  158,  165,  570,
+      130,  107,  569,  148,  156,  563,  172,  576,  174,  181,
+      177,  195,  572,  628,  173,  628,  628,  628,  628,  603,
+      628,  628,    0,  628,  628,  628,  628,  628,  628,  628,
+      628,  628,  628,  233,  628,    0,  628,  239,  255,  271,
+      287,    0,  300,  628,  628,  628,  592,  628,  628,  628,
+      591,    0,  628,  628,  564,  557,  560,  568,  567,  554,
+
+      569,  556,  562,  550,  547,  560,  547,  544,  544,  550,
+      538,  545,  542,  552,  538,  544,  547,  548,    0,  187,
+      547,  241,  533,  546,  537,  539,  529,  543,  540,  542,
+      525,  530,  527,  516,  192,  530,  526,  528,  517,  520,
+      274,  525,  517,  529,  114,  522,  628,  628,  628,    0,
+      316,    0,  322,  338,  344,  351,    0,  628,  628,    0,
+      514,  518,  527,  524,  508,  508,  205,  523,  520,  520,
+      518,  515,  507,  513,  500,  511,  514,    0,  511,  499,
+      506,  503,  507,  500,  489,  488,  501,  504,  501,  496,
+      487,  247,  492,  495,  486,  483,  487,  493,  484,  475,
+
+      478,  476,  486,  472,  470,  470,  472,  469,  480,  479,
+      328,  474,  469,  458,  260,  476,  478,  467,  358,  366,
+      372,  378,  468,    0,  466,  276,    0,  458,  456,  464,
+      453,  470,  459,  291,    0,    0,  453,  463,  463,  448,
+      305,    0,    0,  450,  327,  451,  445,  444,  445,  444,
+      382,    0,    0,    0,    0,    0,  440,  441,  446,  437,
+      450,  445,  444,  436,  440,  432,  435,  439,  444,  443,
+      434,    0,    0,  440,  429,  429,  434,  433,  430,    0,
+        0,    0,    0,  420,  432,  434,    0,    0,    0,    0,
+        0,    0,  422,  423,  417,  427,    0,    0,    0,  418,
 
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-      420,    0,    0,  418,  414,    0,    0,    0,  410,  406,
-      411,  401,  414,  400,  413,  402,  409,    0,  407,  409,
-      393,  402,  408,  403,  391,    0,  393,    0,  392,  395,
-        0,  384,  383,  383,  396,    0,  398,    0,  397,  396,
-      381,  394,  381,    0,    0,  384,    0,    0,  376,    0,
-        0,    0,    0,  373,  384,  377,  383,  380,  375,  367,
-      379,    0,    0,  372,  379,  368,    0,  377,  374,  364,
-      294,  372,    0,    0,  372,    0,  368,  324,    0,    0,
-      323,  299,  310,    0,  300,  320,  282,  278,    0,    0,
-
-        0,    0,    0,    0,    0,    0,    0,  287,  266,  260,
-      257,    0,  228,  221,  221,  206,  206,  197,  160,    0,
-      622,  400,  402,  404,  408,  157
+      425,    0,    0,  423,  419,    0,    0,    0,  415,  411,
+      416,  406,  419,  405,  418,  407,  414,    0,  412,  414,
+      398,  407,  413,  408,  396,    0,  398,    0,  397,  400,
+        0,  389,  388,  388,  401,    0,  403,    0,  402,  401,
+      386,  399,  386,    0,    0,  389,    0,    0,  381,    0,
+        0,    0,    0,  378,  389,  382,  388,  385,  380,  372,
+      382,    0,    0,  365,  371,  360,    0,  369,  366,  356,
+      385,  364,    0,    0,  364,    0,  362,  361,    0,    0,
+      360,  323,  308,    0,  298,  318,  270,  265,    0,    0,
+
+        0,    0,    0,    0,    0,    0,  279,  271,  240,  240,
+      238,  237,  226,    0,  208,  188,  190,    0,  186,  173,
+      187,  164,  158,    0,  628,  415,  417,  419,  423,  186
     } ;
 
-static yyconst flex_int16_t yy_def[427] =
+static yyconst flex_int16_t yy_def[431] =
     {   0,
-      421,    1,  422,  422,  421,    5,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421,  421,  421,  423,
-      421,  421,  421,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  424,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  425,  421,  421,  421,  421,
-      421,  426,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  423,  421,  421,  423,  423,  423,  423,  423,  423,
-
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  421,  421,  421,  424,
-      421,  425,  421,  421,  421,  421,  426,  421,  421,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  421,  421,
-      421,  421,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-      423,  423,  423,  423,  423,  423,  423,  423,  423,  423,
-        0,  421,  421,  421,  421,  421
+      425,    1,  426,  426,  425,    5,  425,  425,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  427,
+      425,  425,  425,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  428,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425,  425,  429,  425,  425,  425,  425,
+      425,  430,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  427,  425,  425,  427,  427,  427,  427,  427,  427,
+
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  425,  425,  425,  428,
+      425,  429,  425,  425,  425,  425,  430,  425,  425,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  425,  425,
+      425,  425,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,  427,  427,  427,  427,  427,  427,
+      427,  427,  427,  427,    0,  425,  425,  425,  425,  425
     } ;
 
-static yyconst flex_int16_t yy_nxt[688] =
+static yyconst flex_int16_t yy_nxt[695] =
     {   0,
         8,    9,   10,   11,   12,   13,   14,   15,   16,   17,
        18,   19,   20,   21,   22,   23,   23,   23,   23,   23,
        24,   25,   26,   27,   28,   29,   30,   30,   30,   30,
-       30,   30,   30,   30,   31,   32,   33,   34,   35,   36,
-       37,   38,   39,   40,   41,   42,   30,   43,   44,   45,
-       46,   47,   48,   49,   50,   51,   52,   53,   30,   30,
-       30,   54,   55,   56,   57,   59,   59,   65,   66,   90,
-       91,   60,   60,    8,   61,   62,    8,    8,    8,    8,
+       30,   30,   30,   30,   30,   31,   32,   33,   34,   35,
+       36,   37,   38,   39,   40,   41,   42,   30,   43,   44,
+       45,   46,   47,   48,   49,   50,   51,   52,   53,   30,
+       30,   30,   54,   55,   56,   57,   59,   59,   65,   66,
+       90,   91,   60,   60,    8,   61,   62,    8,    8,    8,
         8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
-        8,    8,    8,    8,    8,    8,    8,    8,    8,   63,
-
-       63,   63,   63,   63,   63,   63,   63,    8,    8,    8,
+        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
+
+       63,   63,   63,   63,   63,   63,   63,   63,   63,    8,
+        8,    8,   63,   63,   63,   63,   63,   63,   63,   63,
        63,   63,   63,   63,   63,   63,   63,   63,   63,   63,
-       63,   63,   63,   63,   63,   63,   63,   63,   63,   63,
-       63,   63,   63,   63,    8,    8,    8,    8,   67,   70,
-       72,   74,   74,   74,   74,   74,   74,   93,  128,   75,
-       95,   96,   73,   71,   76,   97,   68,   98,  123,  157,
-       94,   99,  124,  129,   77,   78,  130,   79,   79,   79,
-       79,   79,   80,   78,  100,   83,   83,   83,   83,   83,
-       83,   85,   81,  216,  101,  217,   82,  102,  116,  103,
-       81,  147,  420,  104,   81,  125,  117,   86,  105,   87,
-
-       88,  107,   81,  108,  106,  110,  141,  118,  126,  119,
-      142,   82,  109,  111,  132,  112,  120,  137,  113,  190,
-      138,  133,  134,  121,  114,  143,  419,  191,  139,  144,
-      148,  135,  229,  230,  136,  140,  204,  418,  145,   74,
-       74,   74,   74,   74,   74,  153,  153,  153,  153,  153,
-      153,  205,  184,  417,  151,  185,  186,  211,  416,  187,
-      154,  188,  254,  255,  256,  212,  151,  280,  281,  282,
-      415,   78,  154,   79,   79,   79,   79,   79,   80,   78,
-      414,   80,   80,   80,   80,   80,   80,  275,   81,  156,
-      156,  156,  156,  156,  156,  276,   81,  155,  413,  155,
-
-       81,  412,  156,  156,  156,  156,  156,  156,   81,   78,
-      396,   83,   83,   83,   83,   83,   83,  288,  289,  290,
-      411,  397,  219,  398,  219,  410,   81,  220,  220,  220,
-      220,  220,  220,  297,  298,  299,  409,  408,   81,  153,
-      153,  153,  153,  153,  153,  304,  305,  306,  407,  406,
-      221,  405,  221,  404,  154,  222,  222,  222,  222,  222,
-      222,  308,  309,  310,  403,  402,  154,  156,  156,  156,
-      156,  156,  156,  220,  220,  220,  220,  220,  220,  220,
-      220,  220,  220,  220,  220,  222,  222,  222,  222,  222,
-      222,  222,  222,  222,  222,  222,  222,  316,  317,  318,
-
-       58,   58,   58,   58,   92,   92,  150,  150,  152,  401,
-      152,  152,  400,  399,  395,  394,  393,  392,  391,  390,
-      389,  388,  387,  386,  385,  384,  383,  382,  381,  380,
-      379,  378,  377,  376,  375,  374,  373,  372,  371,  370,
-      369,  368,  367,  366,  365,  364,  363,  362,  361,  360,
-      359,  358,  357,  356,  355,  354,  353,  352,  351,  350,
-      349,  348,  347,  346,  345,  344,  343,  342,  341,  340,
-      339,  338,  337,  336,  335,  334,  333,  332,  331,  330,
-      329,  328,  327,  326,  325,  324,  323,  322,  321,  320,
-      319,  315,  314,  313,  312,  311,  307,  303,  302,  301,
-
-      300,  296,  295,  294,  293,  292,  291,  287,  286,  285,
-      284,  283,  279,  278,  277,  274,  273,  272,  271,  270,
-      269,  268,  267,  266,  265,  264,  263,  262,  261,  260,
-      259,  258,  257,  253,  252,  251,  250,  249,  248,  247,
-      246,  245,  244,  243,  242,  241,  240,  239,  238,  237,
-      236,  235,  234,  233,  232,  231,  228,  227,  226,  225,
-      224,  223,  218,  215,  214,  213,  210,  209,  208,  207,
-      206,  203,  202,  201,  200,  199,  198,  197,  196,  195,
-      194,  193,  192,  189,  183,  182,  181,  180,  179,  178,
-      177,  176,  175,  174,  173,  172,  171,  170,  169,  168,
-
-      167,  166,  165,  164,  163,  162,  161,  160,  159,  158,
-      149,  146,  131,  127,  122,  115,   89,   84,   69,   64,
-      421,    7,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421
+       63,   63,   63,   63,   63,   63,    8,    8,    8,    8,
+       67,   70,   72,   74,   74,   74,   74,   74,   74,   93,
+      119,   75,   95,   96,   73,   71,   76,  120,   68,   97,
+      216,   98,  217,   94,  121,   99,   77,   78,  116,   79,
+       79,   79,   79,   79,   80,   78,  117,   83,   83,   83,
+       83,   83,   83,   85,   81,  100,  123,  118,  157,   82,
+      124,  424,   81,  423,  125,  101,  147,   81,  102,   86,
+
+      103,   87,   88,  110,  104,   81,  107,  126,  108,  105,
+      128,  111,  132,  112,   82,  106,  113,  109,  422,  133,
+      134,  421,  114,  137,  420,  129,  138,  141,  130,  135,
+      204,  142,  136,  143,  139,  184,  148,  144,  185,  186,
+      419,  140,  187,  418,  188,  205,  145,   74,   74,   74,
+       74,   74,   74,  153,  153,  153,  153,  153,  153,  229,
+      230,  417,  151,  254,  255,  256,  416,   78,  154,   79,
+       79,   79,   79,   79,   80,  151,  280,  281,  282,  415,
+      414,  154,  413,   78,   81,   80,   80,   80,   80,   80,
+       80,  190,  288,  289,  290,  412,  155,   81,  155,  191,
+
+       81,  156,  156,  156,  156,  156,  156,  297,  298,  299,
+      411,  410,   78,   81,   83,   83,   83,   83,   83,   83,
+      211,  304,  305,  306,  409,  219,  408,  219,  212,   81,
+      220,  220,  220,  220,  220,  220,  153,  153,  153,  153,
+      153,  153,   81,  308,  309,  310,  407,  221,  406,  221,
+      405,  154,  222,  222,  222,  222,  222,  222,  156,  156,
+      156,  156,  156,  156,  154,  156,  156,  156,  156,  156,
+      156,  275,  220,  220,  220,  220,  220,  220,  404,  276,
+      220,  220,  220,  220,  220,  220,  222,  222,  222,  222,
+      222,  222,  222,  222,  222,  222,  222,  222,  316,  317,
+
+      318,  396,  403,  402,  401,  400,  399,  395,  394,  393,
+      392,  391,  397,  390,  398,   58,   58,   58,   58,   92,
+       92,  150,  150,  152,  389,  152,  152,  388,  387,  386,
+      385,  384,  383,  382,  381,  380,  379,  378,  377,  376,
+      375,  374,  373,  372,  371,  370,  369,  368,  367,  366,
+      365,  364,  363,  362,  361,  360,  359,  358,  357,  356,
+      355,  354,  353,  352,  351,  350,  349,  348,  347,  346,
+      345,  344,  343,  342,  341,  340,  339,  338,  337,  336,
+      335,  334,  333,  332,  331,  330,  329,  328,  327,  326,
+      325,  324,  323,  322,  321,  320,  319,  315,  314,  313,
+
+      312,  311,  307,  303,  302,  301,  300,  296,  295,  294,
+      293,  292,  291,  287,  286,  285,  284,  283,  279,  278,
+      277,  274,  273,  272,  271,  270,  269,  268,  267,  266,
+      265,  264,  263,  262,  261,  260,  259,  258,  257,  253,
+      252,  251,  250,  249,  248,  247,  246,  245,  244,  243,
+      242,  241,  240,  239,  238,  237,  236,  235,  234,  233,
+      232,  231,  228,  227,  226,  225,  224,  223,  218,  215,
+      214,  213,  210,  209,  208,  207,  206,  203,  202,  201,
+      200,  199,  198,  197,  196,  195,  194,  193,  192,  189,
+      183,  182,  181,  180,  179,  178,  177,  176,  175,  174,
+
+      173,  172,  171,  170,  169,  168,  167,  166,  165,  164,
+      163,  162,  161,  160,  159,  158,  149,  146,  131,  127,
+      122,  115,   89,   84,   69,   64,  425,    7,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425
+
     } ;
 
-static yyconst flex_int16_t yy_chk[688] =
+static yyconst flex_int16_t yy_chk[695] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -663,79 +674,81 @@
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    3,    4,   12,   12,   28,
-       28,    3,    4,    5,    5,    5,    5,    5,    5,    5,
+        1,    1,    1,    1,    1,    1,    3,    4,   12,   12,
+       28,   28,    3,    4,    5,    5,    5,    5,    5,    5,
         5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
         5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
 
         5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
         5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
         5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    5,    5,    5,    5,    5,    5,   13,   17,
-       19,   20,   20,   20,   20,   20,   20,   33,   47,   21,
-       34,   34,   19,   17,   21,   35,   13,   35,   44,  426,
-       33,   35,   44,   47,   21,   22,   47,   22,   22,   22,
-       22,   22,   22,   23,   36,   23,   23,   23,   23,   23,
-       23,   26,   22,  145,   36,  145,   22,   36,   41,   37,
-       23,   55,  419,   37,   22,   45,   41,   26,   37,   26,
-
-       26,   38,   23,   38,   37,   39,   51,   41,   45,   42,
-       51,   22,   38,   39,   49,   39,   42,   50,   39,  122,
-       50,   49,   49,   42,   39,   52,  418,  122,   50,   52,
-       55,   49,  167,  167,   49,   50,  135,  417,   52,   74,
-       74,   74,   74,   74,   74,   78,   78,   78,   78,   78,
-       78,  135,  120,  416,   74,  120,  120,  141,  415,  120,
-       78,  120,  192,  192,  192,  141,   74,  215,  215,  215,
-      414,   79,   78,   79,   79,   79,   79,   79,   79,   80,
-      413,   80,   80,   80,   80,   80,   80,  211,   79,  155,
-      155,  155,  155,  155,  155,  211,   80,   81,  411,   81,
-
-       79,  410,   81,   81,   81,   81,   81,   81,   80,   83,
-      381,   83,   83,   83,   83,   83,   83,  226,  226,  226,
-      409,  381,  151,  381,  151,  408,   83,  151,  151,  151,
-      151,  151,  151,  234,  234,  234,  398,  397,   83,  153,
-      153,  153,  153,  153,  153,  241,  241,  241,  396,  395,
-      154,  393,  154,  392,  153,  154,  154,  154,  154,  154,
-      154,  245,  245,  245,  391,  388,  153,  156,  156,  156,
-      156,  156,  156,  219,  219,  219,  219,  219,  219,  220,
-      220,  220,  220,  220,  220,  221,  221,  221,  221,  221,
-      221,  222,  222,  222,  222,  222,  222,  251,  251,  251,
-
-      422,  422,  422,  422,  423,  423,  424,  424,  425,  387,
-      425,  425,  385,  382,  380,  379,  378,  376,  375,  374,
-      371,  370,  369,  368,  367,  366,  365,  364,  359,  356,
-      353,  352,  351,  350,  349,  347,  345,  344,  343,  342,
-      340,  339,  337,  335,  334,  333,  332,  331,  330,  329,
-      327,  326,  325,  324,  323,  322,  321,  320,  319,  315,
-      314,  311,  300,  296,  295,  294,  293,  286,  285,  284,
-      279,  278,  277,  276,  275,  274,  271,  270,  269,  268,
-      267,  266,  265,  264,  263,  262,  261,  260,  259,  258,
-      257,  250,  249,  248,  247,  246,  244,  240,  239,  238,
-
-      237,  233,  232,  231,  230,  229,  228,  225,  223,  218,
-      217,  216,  214,  213,  212,  210,  209,  208,  207,  206,
-      205,  204,  203,  202,  201,  200,  199,  198,  197,  196,
-      195,  194,  193,  191,  190,  189,  188,  187,  186,  185,
-      184,  183,  182,  181,  180,  179,  177,  176,  175,  174,
-      173,  172,  171,  170,  169,  168,  166,  165,  164,  163,
-      162,  161,  146,  144,  143,  142,  140,  139,  138,  137,
-      136,  134,  133,  132,  131,  130,  129,  128,  127,  126,
-      125,  124,  123,  121,  118,  117,  116,  115,  114,  113,
-      112,  111,  110,  109,  108,  107,  106,  105,  104,  103,
-
-      102,  101,  100,   99,   98,   97,   96,   95,   91,   87,
-       60,   53,   48,   46,   43,   40,   27,   24,   16,   11,
-        7,  421,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421,  421,  421,  421,
-      421,  421,  421,  421,  421,  421,  421
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+       13,   17,   19,   20,   20,   20,   20,   20,   20,   33,
+       42,   21,   34,   34,   19,   17,   21,   42,   13,   35,
+      145,   35,  145,   33,   42,   35,   21,   22,   41,   22,
+       22,   22,   22,   22,   22,   23,   41,   23,   23,   23,
+       23,   23,   23,   26,   22,   36,   44,   41,  430,   22,
+       44,  423,   23,  422,   45,   36,   55,   22,   36,   26,
+
+       37,   26,   26,   39,   37,   23,   38,   45,   38,   37,
+       47,   39,   49,   39,   22,   37,   39,   38,  421,   49,
+       49,  420,   39,   50,  419,   47,   50,   51,   47,   49,
+      135,   51,   49,   52,   50,  120,   55,   52,  120,  120,
+      417,   50,  120,  416,  120,  135,   52,   74,   74,   74,
+       74,   74,   74,   78,   78,   78,   78,   78,   78,  167,
+      167,  415,   74,  192,  192,  192,  413,   79,   78,   79,
+       79,   79,   79,   79,   79,   74,  215,  215,  215,  412,
+      411,   78,  410,   80,   79,   80,   80,   80,   80,   80,
+       80,  122,  226,  226,  226,  409,   81,   79,   81,  122,
+
+       80,   81,   81,   81,   81,   81,   81,  234,  234,  234,
+      408,  407,   83,   80,   83,   83,   83,   83,   83,   83,
+      141,  241,  241,  241,  398,  151,  397,  151,  141,   83,
+      151,  151,  151,  151,  151,  151,  153,  153,  153,  153,
+      153,  153,   83,  245,  245,  245,  396,  154,  395,  154,
+      393,  153,  154,  154,  154,  154,  154,  154,  155,  155,
+      155,  155,  155,  155,  153,  156,  156,  156,  156,  156,
+      156,  211,  219,  219,  219,  219,  219,  219,  392,  211,
+      220,  220,  220,  220,  220,  220,  221,  221,  221,  221,
+      221,  221,  222,  222,  222,  222,  222,  222,  251,  251,
+
+      251,  381,  391,  388,  387,  385,  382,  380,  379,  378,
+      376,  375,  381,  374,  381,  426,  426,  426,  426,  427,
+      427,  428,  428,  429,  371,  429,  429,  370,  369,  368,
+      367,  366,  365,  364,  359,  356,  353,  352,  351,  350,
+      349,  347,  345,  344,  343,  342,  340,  339,  337,  335,
+      334,  333,  332,  331,  330,  329,  327,  326,  325,  324,
+      323,  322,  321,  320,  319,  315,  314,  311,  300,  296,
+      295,  294,  293,  286,  285,  284,  279,  278,  277,  276,
+      275,  274,  271,  270,  269,  268,  267,  266,  265,  264,
+      263,  262,  261,  260,  259,  258,  257,  250,  249,  248,
+
+      247,  246,  244,  240,  239,  238,  237,  233,  232,  231,
+      230,  229,  228,  225,  223,  218,  217,  216,  214,  213,
+      212,  210,  209,  208,  207,  206,  205,  204,  203,  202,
+      201,  200,  199,  198,  197,  196,  195,  194,  193,  191,
+      190,  189,  188,  187,  186,  185,  184,  183,  182,  181,
+      180,  179,  177,  176,  175,  174,  173,  172,  171,  170,
+      169,  168,  166,  165,  164,  163,  162,  161,  146,  144,
+      143,  142,  140,  139,  138,  137,  136,  134,  133,  132,
+      131,  130,  129,  128,  127,  126,  125,  124,  123,  121,
+      118,  117,  116,  115,  114,  113,  112,  111,  110,  109,
+
+      108,  107,  106,  105,  104,  103,  102,  101,  100,   99,
+       98,   97,   96,   95,   91,   87,   60,   53,   48,   46,
+       43,   40,   27,   24,   16,   11,    7,  425,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425,  425,  425,  425,  425,  425,  425,
+      425,  425,  425,  425
+
     } ;
 
 /* Table of booleans, true if rule could match eol. */
-static yyconst flex_int32_t yy_rule_can_match_eol[147] =
+static yyconst flex_int32_t yy_rule_can_match_eol[148] =
     {   0,
 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
@@ -744,7 +757,7 @@
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
-    0, 0, 0, 0, 1, 0, 0,     };
+    0, 0, 0, 0, 0, 1, 0, 0,     };
 
 /* The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
@@ -909,7 +922,12 @@
     
 /* Amount of stuff to slurp up with each read. */
 #ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
 #define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
@@ -917,7 +935,7 @@
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO fwrite( yytext, yyleng, 1, yyout )
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -928,7 +946,7 @@
 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
 		{ \
 		int c = '*'; \
-		int n; \
+		size_t n; \
 		for ( n = 0; n < max_size && \
 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
@@ -1070,13 +1088,13 @@
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 422 )
+				if ( yy_current_state >= 426 )
 					yy_c = yy_meta[(unsigned int) yy_c];
 				}
 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 			++yy_cp;
 			}
-		while ( yy_current_state != 421 );
+		while ( yy_current_state != 425 );
 		yy_cp = yyg->yy_last_accepting_cpos;
 		yy_current_state = yyg->yy_last_accepting_state;
 
@@ -1297,11 +1315,11 @@
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-{ context->lexAfterType = true; return(STRUCT); }
+{ context->lexAfterType = true; return SAMPLER2DRECT; }
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-{ return reserved_word(yyscanner); }
+{ context->lexAfterType = true; return(STRUCT); }
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
@@ -1461,30 +1479,30 @@
 	YY_BREAK
 case 89:
 YY_RULE_SETUP
+{ return reserved_word(yyscanner); }
+	YY_BREAK
+case 90:
+YY_RULE_SETUP
 {
    yylval->lex.string = NewPoolTString(yytext); 
    return check_type(yyscanner);
 }
 	YY_BREAK
-case 90:
-YY_RULE_SETUP
-{ yylval->lex.i = strtol(yytext, 0, 0); return(INTCONSTANT); }
-	YY_BREAK
 case 91:
 YY_RULE_SETUP
 { yylval->lex.i = strtol(yytext, 0, 0); return(INTCONSTANT); }
 	YY_BREAK
 case 92:
 YY_RULE_SETUP
-{ context->error(yylineno, "Invalid Octal number.", yytext, "", ""); context->recover(); return 0;}
+{ yylval->lex.i = strtol(yytext, 0, 0); return(INTCONSTANT); }
 	YY_BREAK
 case 93:
 YY_RULE_SETUP
-{ yylval->lex.i = strtol(yytext, 0, 0); return(INTCONSTANT); }
+{ context->error(yylineno, "Invalid Octal number.", yytext, "", ""); context->recover(); return 0;}
 	YY_BREAK
 case 94:
 YY_RULE_SETUP
-{ yylval->lex.f = static_cast<float>(atof_dot(yytext)); return(FLOATCONSTANT); }
+{ yylval->lex.i = strtol(yytext, 0, 0); return(INTCONSTANT); }
 	YY_BREAK
 case 95:
 YY_RULE_SETUP
@@ -1496,185 +1514,189 @@
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
-{  return(ADD_ASSIGN); }
+{ yylval->lex.f = static_cast<float>(atof_dot(yytext)); return(FLOATCONSTANT); }
 	YY_BREAK
 case 98:
 YY_RULE_SETUP
-{  return(SUB_ASSIGN); }
+{  return(ADD_ASSIGN); }
 	YY_BREAK
 case 99:
 YY_RULE_SETUP
-{  return(MUL_ASSIGN); }
+{  return(SUB_ASSIGN); }
 	YY_BREAK
 case 100:
 YY_RULE_SETUP
-{  return(DIV_ASSIGN); }
+{  return(MUL_ASSIGN); }
 	YY_BREAK
 case 101:
 YY_RULE_SETUP
-{  return(MOD_ASSIGN); }
+{  return(DIV_ASSIGN); }
 	YY_BREAK
 case 102:
 YY_RULE_SETUP
-{  return(LEFT_ASSIGN); }
+{  return(MOD_ASSIGN); }
 	YY_BREAK
 case 103:
 YY_RULE_SETUP
-{  return(RIGHT_ASSIGN); }
+{  return(LEFT_ASSIGN); }
 	YY_BREAK
 case 104:
 YY_RULE_SETUP
-{  return(AND_ASSIGN); }
+{  return(RIGHT_ASSIGN); }
 	YY_BREAK
 case 105:
 YY_RULE_SETUP
-{  return(XOR_ASSIGN); }
+{  return(AND_ASSIGN); }
 	YY_BREAK
 case 106:
 YY_RULE_SETUP
-{  return(OR_ASSIGN); }
+{  return(XOR_ASSIGN); }
 	YY_BREAK
 case 107:
 YY_RULE_SETUP
-{  return(INC_OP); }
+{  return(OR_ASSIGN); }
 	YY_BREAK
 case 108:
 YY_RULE_SETUP
-{  return(DEC_OP); }
+{  return(INC_OP); }
 	YY_BREAK
 case 109:
 YY_RULE_SETUP
-{  return(AND_OP); }
+{  return(DEC_OP); }
 	YY_BREAK
 case 110:
 YY_RULE_SETUP
-{  return(OR_OP); }
+{  return(AND_OP); }
 	YY_BREAK
 case 111:
 YY_RULE_SETUP
-{  return(XOR_OP); }
+{  return(OR_OP); }
 	YY_BREAK
 case 112:
 YY_RULE_SETUP
-{  return(LE_OP); }
+{  return(XOR_OP); }
 	YY_BREAK
 case 113:
 YY_RULE_SETUP
-{  return(GE_OP); }
+{  return(LE_OP); }
 	YY_BREAK
 case 114:
 YY_RULE_SETUP
-{  return(EQ_OP); }
+{  return(GE_OP); }
 	YY_BREAK
 case 115:
 YY_RULE_SETUP
-{  return(NE_OP); }
+{  return(EQ_OP); }
 	YY_BREAK
 case 116:
 YY_RULE_SETUP
-{  return(LEFT_OP); }
+{  return(NE_OP); }
 	YY_BREAK
 case 117:
 YY_RULE_SETUP
-{  return(RIGHT_OP); }
+{  return(LEFT_OP); }
 	YY_BREAK
 case 118:
 YY_RULE_SETUP
-{ context->lexAfterType = false; return(SEMICOLON); }
+{  return(RIGHT_OP); }
 	YY_BREAK
 case 119:
 YY_RULE_SETUP
-{ context->lexAfterType = false; return(LEFT_BRACE); }
+{ context->lexAfterType = false; return(SEMICOLON); }
 	YY_BREAK
 case 120:
 YY_RULE_SETUP
-{ return(RIGHT_BRACE); }
+{ context->lexAfterType = false; return(LEFT_BRACE); }
 	YY_BREAK
 case 121:
 YY_RULE_SETUP
-{ if (context->inTypeParen) context->lexAfterType = false; return(COMMA); }
+{ return(RIGHT_BRACE); }
 	YY_BREAK
 case 122:
 YY_RULE_SETUP
-{ return(COLON); }
+{ if (context->inTypeParen) context->lexAfterType = false; return(COMMA); }
 	YY_BREAK
 case 123:
 YY_RULE_SETUP
-{ context->lexAfterType = false; return(EQUAL); }
+{ return(COLON); }
 	YY_BREAK
 case 124:
 YY_RULE_SETUP
-{ context->lexAfterType = false; context->inTypeParen = true; return(LEFT_PAREN); }
+{ context->lexAfterType = false; return(EQUAL); }
 	YY_BREAK
 case 125:
 YY_RULE_SETUP
-{ context->inTypeParen = false; return(RIGHT_PAREN); }
+{ context->lexAfterType = false; context->inTypeParen = true; return(LEFT_PAREN); }
 	YY_BREAK
 case 126:
 YY_RULE_SETUP
-{ return(LEFT_BRACKET); }
+{ context->inTypeParen = false; return(RIGHT_PAREN); }
 	YY_BREAK
 case 127:
 YY_RULE_SETUP
-{ return(RIGHT_BRACKET); }
+{ return(LEFT_BRACKET); }
 	YY_BREAK
 case 128:
 YY_RULE_SETUP
-{ BEGIN(FIELDS);  return(DOT); }
+{ return(RIGHT_BRACKET); }
 	YY_BREAK
 case 129:
 YY_RULE_SETUP
-{ return(BANG); }
+{ BEGIN(FIELDS);  return(DOT); }
 	YY_BREAK
 case 130:
 YY_RULE_SETUP
-{ return(DASH); }
+{ return(BANG); }
 	YY_BREAK
 case 131:
 YY_RULE_SETUP
-{ return(TILDE); }
+{ return(DASH); }
 	YY_BREAK
 case 132:
 YY_RULE_SETUP
-{ return(PLUS); }
+{ return(TILDE); }
 	YY_BREAK
 case 133:
 YY_RULE_SETUP
-{ return(STAR); }
+{ return(PLUS); }
 	YY_BREAK
 case 134:
 YY_RULE_SETUP
-{ return(SLASH); }
+{ return(STAR); }
 	YY_BREAK
 case 135:
 YY_RULE_SETUP
-{ return(PERCENT); }
+{ return(SLASH); }
 	YY_BREAK
 case 136:
 YY_RULE_SETUP
-{ return(LEFT_ANGLE); }
+{ return(PERCENT); }
 	YY_BREAK
 case 137:
 YY_RULE_SETUP
-{ return(RIGHT_ANGLE); }
+{ return(LEFT_ANGLE); }
 	YY_BREAK
 case 138:
 YY_RULE_SETUP
-{ return(VERTICAL_BAR); }
+{ return(RIGHT_ANGLE); }
 	YY_BREAK
 case 139:
 YY_RULE_SETUP
-{ return(CARET); }
+{ return(VERTICAL_BAR); }
 	YY_BREAK
 case 140:
 YY_RULE_SETUP
-{ return(AMPERSAND); }
+{ return(CARET); }
 	YY_BREAK
 case 141:
 YY_RULE_SETUP
+{ return(AMPERSAND); }
+	YY_BREAK
+case 142:
+YY_RULE_SETUP
 { return(QUESTION); }
 	YY_BREAK
-case 142:
+case 143:
 YY_RULE_SETUP
 { 
     BEGIN(INITIAL);
@@ -1682,12 +1704,12 @@
     return FIELD_SELECTION;
 }
 	YY_BREAK
-case 143:
+case 144:
 YY_RULE_SETUP
 {}
 	YY_BREAK
-case 144:
-/* rule 144 can match eol */
+case 145:
+/* rule 145 can match eol */
 YY_RULE_SETUP
 {  }
 	YY_BREAK
@@ -1696,11 +1718,11 @@
 case YY_STATE_EOF(FIELDS):
 { context->AfterEOF = true; yyterminate(); }
 	YY_BREAK
-case 145:
+case 146:
 YY_RULE_SETUP
 { context->warning(yylineno, "Unknown char", yytext, ""); return 0; }
 	YY_BREAK
-case 146:
+case 147:
 YY_RULE_SETUP
 ECHO;
 	YY_BREAK
@@ -1996,7 +2018,7 @@
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 422 )
+			if ( yy_current_state >= 426 )
 				yy_c = yy_meta[(unsigned int) yy_c];
 			}
 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
@@ -2025,11 +2047,11 @@
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 422 )
+		if ( yy_current_state >= 426 )
 			yy_c = yy_meta[(unsigned int) yy_c];
 		}
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 421);
+	yy_is_jam = (yy_current_state == 425);
 
 	return yy_is_jam ? 0 : yy_current_state;
 }
@@ -2439,8 +2461,8 @@
 
 /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
  * scan from a @e copy of @a bytes.
- * @param bytes the byte buffer to scan
- * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
  * @param yyscanner The scanner object.
  * @return the newly allocated buffer state object.
  */
diff -r d713478624d8 gfx/angle/src/compiler/glslang_tab.cpp
--- a/gfx/angle/src/compiler/glslang_tab.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/compiler/glslang_tab.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -1,24 +1,23 @@
-/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
 
 /* Skeleton implementation for Bison's Yacc-like parsers in C
-
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
    Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
+   
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -29,7 +28,7 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-
+   
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
@@ -47,7 +46,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.3"
+#define YYBISON_VERSION "2.4.1"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -55,11 +54,55 @@
 /* Pure parsers.  */
 #define YYPURE 1
 
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
 /* Using locations.  */
 #define YYLSP_NEEDED 0
 
 
 
+/* Copy the first part of user declarations.  */
+
+
+//
+// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+// This file is auto-generated by generate_parser.sh. DO NOT EDIT!
+
+#include "compiler/SymbolTable.h"
+#include "compiler/ParseHelper.h"
+#include "GLSLANG/ShaderLang.h"
+
+#define YYLEX_PARAM context->scanner
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -107,196 +150,68 @@
      SAMPLER2D = 296,
      SAMPLERCUBE = 297,
      SAMPLER_EXTERNAL_OES = 298,
-     IDENTIFIER = 299,
-     TYPE_NAME = 300,
-     FLOATCONSTANT = 301,
-     INTCONSTANT = 302,
-     BOOLCONSTANT = 303,
-     FIELD_SELECTION = 304,
-     LEFT_OP = 305,
-     RIGHT_OP = 306,
-     INC_OP = 307,
-     DEC_OP = 308,
-     LE_OP = 309,
-     GE_OP = 310,
-     EQ_OP = 311,
-     NE_OP = 312,
-     AND_OP = 313,
-     OR_OP = 314,
-     XOR_OP = 315,
-     MUL_ASSIGN = 316,
-     DIV_ASSIGN = 317,
-     ADD_ASSIGN = 318,
-     MOD_ASSIGN = 319,
-     LEFT_ASSIGN = 320,
-     RIGHT_ASSIGN = 321,
-     AND_ASSIGN = 322,
-     XOR_ASSIGN = 323,
-     OR_ASSIGN = 324,
-     SUB_ASSIGN = 325,
-     LEFT_PAREN = 326,
-     RIGHT_PAREN = 327,
-     LEFT_BRACKET = 328,
-     RIGHT_BRACKET = 329,
-     LEFT_BRACE = 330,
-     RIGHT_BRACE = 331,
-     DOT = 332,
-     COMMA = 333,
-     COLON = 334,
-     EQUAL = 335,
-     SEMICOLON = 336,
-     BANG = 337,
-     DASH = 338,
-     TILDE = 339,
-     PLUS = 340,
-     STAR = 341,
-     SLASH = 342,
-     PERCENT = 343,
-     LEFT_ANGLE = 344,
-     RIGHT_ANGLE = 345,
-     VERTICAL_BAR = 346,
-     CARET = 347,
-     AMPERSAND = 348,
-     QUESTION = 349
+     SAMPLER2DRECT = 299,
+     IDENTIFIER = 300,
+     TYPE_NAME = 301,
+     FLOATCONSTANT = 302,
+     INTCONSTANT = 303,
+     BOOLCONSTANT = 304,
+     FIELD_SELECTION = 305,
+     LEFT_OP = 306,
+     RIGHT_OP = 307,
+     INC_OP = 308,
+     DEC_OP = 309,
+     LE_OP = 310,
+     GE_OP = 311,
+     EQ_OP = 312,
+     NE_OP = 313,
+     AND_OP = 314,
+     OR_OP = 315,
+     XOR_OP = 316,
+     MUL_ASSIGN = 317,
+     DIV_ASSIGN = 318,
+     ADD_ASSIGN = 319,
+     MOD_ASSIGN = 320,
+     LEFT_ASSIGN = 321,
+     RIGHT_ASSIGN = 322,
+     AND_ASSIGN = 323,
+     XOR_ASSIGN = 324,
+     OR_ASSIGN = 325,
+     SUB_ASSIGN = 326,
+     LEFT_PAREN = 327,
+     RIGHT_PAREN = 328,
+     LEFT_BRACKET = 329,
+     RIGHT_BRACKET = 330,
+     LEFT_BRACE = 331,
+     RIGHT_BRACE = 332,
+     DOT = 333,
+     COMMA = 334,
+     COLON = 335,
+     EQUAL = 336,
+     SEMICOLON = 337,
+     BANG = 338,
+     DASH = 339,
+     TILDE = 340,
+     PLUS = 341,
+     STAR = 342,
+     SLASH = 343,
+     PERCENT = 344,
+     LEFT_ANGLE = 345,
+     RIGHT_ANGLE = 346,
+     VERTICAL_BAR = 347,
+     CARET = 348,
+     AMPERSAND = 349,
+     QUESTION = 350
    };
 #endif
-/* Tokens.  */
-#define INVARIANT 258
-#define HIGH_PRECISION 259
-#define MEDIUM_PRECISION 260
-#define LOW_PRECISION 261
-#define PRECISION 262
-#define ATTRIBUTE 263
-#define CONST_QUAL 264
-#define BOOL_TYPE 265
-#define FLOAT_TYPE 266
-#define INT_TYPE 267
-#define BREAK 268
-#define CONTINUE 269
-#define DO 270
-#define ELSE 271
-#define FOR 272
-#define IF 273
-#define DISCARD 274
-#define RETURN 275
-#define BVEC2 276
-#define BVEC3 277
-#define BVEC4 278
-#define IVEC2 279
-#define IVEC3 280
-#define IVEC4 281
-#define VEC2 282
-#define VEC3 283
-#define VEC4 284
-#define MATRIX2 285
-#define MATRIX3 286
-#define MATRIX4 287
-#define IN_QUAL 288
-#define OUT_QUAL 289
-#define INOUT_QUAL 290
-#define UNIFORM 291
-#define VARYING 292
-#define STRUCT 293
-#define VOID_TYPE 294
-#define WHILE 295
-#define SAMPLER2D 296
-#define SAMPLERCUBE 297
-#define SAMPLER_EXTERNAL_OES 298
-#define IDENTIFIER 299
-#define TYPE_NAME 300
-#define FLOATCONSTANT 301
-#define INTCONSTANT 302
-#define BOOLCONSTANT 303
-#define FIELD_SELECTION 304
-#define LEFT_OP 305
-#define RIGHT_OP 306
-#define INC_OP 307
-#define DEC_OP 308
-#define LE_OP 309
-#define GE_OP 310
-#define EQ_OP 311
-#define NE_OP 312
-#define AND_OP 313
-#define OR_OP 314
-#define XOR_OP 315
-#define MUL_ASSIGN 316
-#define DIV_ASSIGN 317
-#define ADD_ASSIGN 318
-#define MOD_ASSIGN 319
-#define LEFT_ASSIGN 320
-#define RIGHT_ASSIGN 321
-#define AND_ASSIGN 322
-#define XOR_ASSIGN 323
-#define OR_ASSIGN 324
-#define SUB_ASSIGN 325
-#define LEFT_PAREN 326
-#define RIGHT_PAREN 327
-#define LEFT_BRACKET 328
-#define RIGHT_BRACKET 329
-#define LEFT_BRACE 330
-#define RIGHT_BRACE 331
-#define DOT 332
-#define COMMA 333
-#define COLON 334
-#define EQUAL 335
-#define SEMICOLON 336
-#define BANG 337
-#define DASH 338
-#define TILDE 339
-#define PLUS 340
-#define STAR 341
-#define SLASH 342
-#define PERCENT 343
-#define LEFT_ANGLE 344
-#define RIGHT_ANGLE 345
-#define VERTICAL_BAR 346
-#define CARET 347
-#define AMPERSAND 348
-#define QUESTION 349
-
-
-
-
-/* Copy the first part of user declarations.  */
-
-
-//
-// Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-//
-
-// This file is auto-generated by generate_parser.sh. DO NOT EDIT!
-
-#include "compiler/SymbolTable.h"
-#include "compiler/ParseHelper.h"
-#include "GLSLANG/ShaderLang.h"
-
-#define YYLEX_PARAM context->scanner
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-/* Enabling the token table.  */
-#ifndef YYTOKEN_TABLE
-# define YYTOKEN_TABLE 0
-#endif
+
+
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-
 {
+
+
     struct {
         TSourceLoc line;
         union {
@@ -326,17 +241,16 @@
             TTypeList* typeList;
         };
     } interm;
-}
-/* Line 193 of yacc.c.  */
-
-	YYSTYPE;
+
+
+
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 
-
 /* Copy the second part of user declarations.  */
 
 
@@ -366,8 +280,6 @@
 }
 
 
-/* Line 216 of yacc.c.  */
-
 
 #ifdef short
 # undef short
@@ -417,7 +329,7 @@
 #define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
 
 #ifndef YY_
-# if defined YYENABLE_NLS && YYENABLE_NLS
+# if YYENABLE_NLS
 #  if ENABLE_NLS
 #   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
 #   define YY_(msgid) dgettext ("bison-runtime", msgid)
@@ -442,14 +354,14 @@
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static int
-YYID (int i)
+YYID (int yyi)
 #else
 static int
-YYID (i)
-    int i;
+YYID (yyi)
+    int yyi;
 #endif
 {
-  return i;
+  return yyi;
 }
 #endif
 
@@ -530,9 +442,9 @@
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  yytype_int16 yyss;
-  YYSTYPE yyvs;
-  };
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
 
 /* The size of the maximum gap between one aligned stack and the next.  */
 # define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
@@ -566,12 +478,12 @@
    elements in the stack, and YYPTR gives the new location of the
    stack.  Advance YYPTR to a properly aligned location for the next
    stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
     do									\
       {									\
 	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
@@ -580,22 +492,22 @@
 #endif
 
 /* YYFINAL -- State number of the termination state.  */
-#define YYFINAL  70
+#define YYFINAL  71
 /* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   1327
+#define YYLAST   1370
 
 /* YYNTOKENS -- Number of terminals.  */
-#define YYNTOKENS  95
+#define YYNTOKENS  96
 /* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  80
 /* YYNRULES -- Number of rules.  */
-#define YYNRULES  196
+#define YYNRULES  197
 /* YYNRULES -- Number of states.  */
-#define YYNSTATES  299
+#define YYNSTATES  300
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
-#define YYMAXUTOK   349
+#define YYMAXUTOK   350
 
 #define YYTRANSLATE(YYX)						\
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
@@ -637,7 +549,8 @@
       55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
       65,    66,    67,    68,    69,    70,    71,    72,    73,    74,
       75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
-      85,    86,    87,    88,    89,    90,    91,    92,    93,    94
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95
 };
 
 #if YYDEBUG
@@ -658,74 +571,75 @@
      298,   303,   306,   308,   311,   313,   315,   317,   320,   322,
      324,   327,   329,   331,   333,   335,   340,   342,   344,   346,
      348,   350,   352,   354,   356,   358,   360,   362,   364,   366,
-     368,   370,   372,   374,   376,   378,   380,   382,   383,   390,
-     391,   397,   399,   402,   406,   408,   412,   414,   419,   421,
-     423,   425,   427,   429,   431,   433,   435,   437,   440,   441,
-     442,   448,   450,   452,   455,   459,   461,   464,   466,   469,
-     475,   479,   481,   483,   488,   489,   496,   497,   506,   507,
-     515,   517,   519,   521,   522,   525,   529,   532,   535,   538,
-     542,   545,   547,   550,   552,   554,   555
+     368,   370,   372,   374,   376,   378,   380,   382,   384,   385,
+     392,   393,   399,   401,   404,   408,   410,   414,   416,   421,
+     423,   425,   427,   429,   431,   433,   435,   437,   439,   442,
+     443,   444,   450,   452,   454,   457,   461,   463,   466,   468,
+     471,   477,   481,   483,   485,   490,   491,   498,   499,   508,
+     509,   517,   519,   521,   523,   524,   527,   531,   534,   537,
+     540,   544,   547,   549,   552,   554,   556,   557
 };
 
 /* YYRHS -- A `-1'-separated list of the rules' RHS.  */
 static const yytype_int16 yyrhs[] =
 {
-     171,     0,    -1,    44,    -1,    96,    -1,    47,    -1,    46,
-      -1,    48,    -1,    71,   123,    72,    -1,    97,    -1,    98,
-      73,    99,    74,    -1,   100,    -1,    98,    77,    49,    -1,
-      98,    52,    -1,    98,    53,    -1,   123,    -1,   101,    -1,
-     102,    -1,    98,    77,   102,    -1,   104,    72,    -1,   103,
-      72,    -1,   105,    39,    -1,   105,    -1,   105,   121,    -1,
-     104,    78,   121,    -1,   106,    71,    -1,   141,    -1,    44,
-      -1,    49,    -1,    98,    -1,    52,   107,    -1,    53,   107,
-      -1,   108,   107,    -1,    85,    -1,    83,    -1,    82,    -1,
-     107,    -1,   109,    86,   107,    -1,   109,    87,   107,    -1,
-     109,    -1,   110,    85,   109,    -1,   110,    83,   109,    -1,
-     110,    -1,   111,    -1,   112,    89,   111,    -1,   112,    90,
-     111,    -1,   112,    54,   111,    -1,   112,    55,   111,    -1,
-     112,    -1,   113,    56,   112,    -1,   113,    57,   112,    -1,
-     113,    -1,   114,    -1,   115,    -1,   116,    -1,   117,    58,
-     116,    -1,   117,    -1,   118,    60,   117,    -1,   118,    -1,
-     119,    59,   118,    -1,   119,    -1,   119,    94,   123,    79,
-     121,    -1,   120,    -1,   107,   122,   121,    -1,    80,    -1,
-      61,    -1,    62,    -1,    63,    -1,    70,    -1,   121,    -1,
-     123,    78,   121,    -1,   120,    -1,   126,    81,    -1,   134,
-      81,    -1,     7,   139,   140,    81,    -1,   127,    72,    -1,
-     129,    -1,   128,    -1,   129,   131,    -1,   128,    78,   131,
-      -1,   136,    44,    71,    -1,   138,    44,    -1,   138,    44,
-      73,   124,    74,    -1,   137,   132,   130,    -1,   132,   130,
-      -1,   137,   132,   133,    -1,   132,   133,    -1,    -1,    33,
-      -1,    34,    -1,    35,    -1,   138,    -1,   135,    -1,   134,
-      78,    44,    -1,   134,    78,    44,    73,    74,    -1,   134,
-      78,    44,    73,   124,    74,    -1,   134,    78,    44,    80,
-     149,    -1,   136,    -1,   136,    44,    -1,   136,    44,    73,
-      74,    -1,   136,    44,    73,   124,    74,    -1,   136,    44,
-      80,   149,    -1,     3,    44,    -1,   138,    -1,   137,   138,
+     172,     0,    -1,    45,    -1,    97,    -1,    48,    -1,    47,
+      -1,    49,    -1,    72,   124,    73,    -1,    98,    -1,    99,
+      74,   100,    75,    -1,   101,    -1,    99,    78,    50,    -1,
+      99,    53,    -1,    99,    54,    -1,   124,    -1,   102,    -1,
+     103,    -1,    99,    78,   103,    -1,   105,    73,    -1,   104,
+      73,    -1,   106,    39,    -1,   106,    -1,   106,   122,    -1,
+     105,    79,   122,    -1,   107,    72,    -1,   142,    -1,    45,
+      -1,    50,    -1,    99,    -1,    53,   108,    -1,    54,   108,
+      -1,   109,   108,    -1,    86,    -1,    84,    -1,    83,    -1,
+     108,    -1,   110,    87,   108,    -1,   110,    88,   108,    -1,
+     110,    -1,   111,    86,   110,    -1,   111,    84,   110,    -1,
+     111,    -1,   112,    -1,   113,    90,   112,    -1,   113,    91,
+     112,    -1,   113,    55,   112,    -1,   113,    56,   112,    -1,
+     113,    -1,   114,    57,   113,    -1,   114,    58,   113,    -1,
+     114,    -1,   115,    -1,   116,    -1,   117,    -1,   118,    59,
+     117,    -1,   118,    -1,   119,    61,   118,    -1,   119,    -1,
+     120,    60,   119,    -1,   120,    -1,   120,    95,   124,    80,
+     122,    -1,   121,    -1,   108,   123,   122,    -1,    81,    -1,
+      62,    -1,    63,    -1,    64,    -1,    71,    -1,   122,    -1,
+     124,    79,   122,    -1,   121,    -1,   127,    82,    -1,   135,
+      82,    -1,     7,   140,   141,    82,    -1,   128,    73,    -1,
+     130,    -1,   129,    -1,   130,   132,    -1,   129,    79,   132,
+      -1,   137,    45,    72,    -1,   139,    45,    -1,   139,    45,
+      74,   125,    75,    -1,   138,   133,   131,    -1,   133,   131,
+      -1,   138,   133,   134,    -1,   133,   134,    -1,    -1,    33,
+      -1,    34,    -1,    35,    -1,   139,    -1,   136,    -1,   135,
+      79,    45,    -1,   135,    79,    45,    74,    75,    -1,   135,
+      79,    45,    74,   125,    75,    -1,   135,    79,    45,    81,
+     150,    -1,   137,    -1,   137,    45,    -1,   137,    45,    74,
+      75,    -1,   137,    45,    74,   125,    75,    -1,   137,    45,
+      81,   150,    -1,     3,    45,    -1,   139,    -1,   138,   139,
       -1,     9,    -1,     8,    -1,    37,    -1,     3,    37,    -1,
-      36,    -1,   140,    -1,   139,   140,    -1,     4,    -1,     5,
-      -1,     6,    -1,   141,    -1,   141,    73,   124,    74,    -1,
+      36,    -1,   141,    -1,   140,   141,    -1,     4,    -1,     5,
+      -1,     6,    -1,   142,    -1,   142,    74,   125,    75,    -1,
       39,    -1,    11,    -1,    12,    -1,    10,    -1,    27,    -1,
       28,    -1,    29,    -1,    21,    -1,    22,    -1,    23,    -1,
       24,    -1,    25,    -1,    26,    -1,    30,    -1,    31,    -1,
-      32,    -1,    41,    -1,    42,    -1,    43,    -1,   142,    -1,
-      45,    -1,    -1,    38,    44,    75,   143,   145,    76,    -1,
-      -1,    38,    75,   144,   145,    76,    -1,   146,    -1,   145,
-     146,    -1,   138,   147,    81,    -1,   148,    -1,   147,    78,
-     148,    -1,    44,    -1,    44,    73,   124,    74,    -1,   121,
-      -1,   125,    -1,   153,    -1,   152,    -1,   150,    -1,   159,
-      -1,   160,    -1,   163,    -1,   170,    -1,    75,    76,    -1,
-      -1,    -1,    75,   154,   158,   155,    76,    -1,   157,    -1,
-     152,    -1,    75,    76,    -1,    75,   158,    76,    -1,   151,
-      -1,   158,   151,    -1,    81,    -1,   123,    81,    -1,    18,
-      71,   123,    72,   161,    -1,   151,    16,   151,    -1,   151,
-      -1,   123,    -1,   136,    44,    80,   149,    -1,    -1,    40,
-      71,   164,   162,    72,   156,    -1,    -1,    15,   165,   151,
-      40,    71,   123,    72,    81,    -1,    -1,    17,    71,   166,
-     167,   169,    72,   156,    -1,   159,    -1,   150,    -1,   162,
-      -1,    -1,   168,    81,    -1,   168,    81,   123,    -1,    14,
-      81,    -1,    13,    81,    -1,    20,    81,    -1,    20,   123,
-      81,    -1,    19,    81,    -1,   172,    -1,   171,   172,    -1,
-     173,    -1,   125,    -1,    -1,   126,   174,   157,    -1
+      32,    -1,    41,    -1,    42,    -1,    43,    -1,    44,    -1,
+     143,    -1,    46,    -1,    -1,    38,    45,    76,   144,   146,
+      77,    -1,    -1,    38,    76,   145,   146,    77,    -1,   147,
+      -1,   146,   147,    -1,   139,   148,    82,    -1,   149,    -1,
+     148,    79,   149,    -1,    45,    -1,    45,    74,   125,    75,
+      -1,   122,    -1,   126,    -1,   154,    -1,   153,    -1,   151,
+      -1,   160,    -1,   161,    -1,   164,    -1,   171,    -1,    76,
+      77,    -1,    -1,    -1,    76,   155,   159,   156,    77,    -1,
+     158,    -1,   153,    -1,    76,    77,    -1,    76,   159,    77,
+      -1,   152,    -1,   159,   152,    -1,    82,    -1,   124,    82,
+      -1,    18,    72,   124,    73,   162,    -1,   152,    16,   152,
+      -1,   152,    -1,   124,    -1,   137,    45,    81,   150,    -1,
+      -1,    40,    72,   165,   163,    73,   157,    -1,    -1,    15,
+     166,   152,    40,    72,   124,    73,    82,    -1,    -1,    17,
+      72,   167,   168,   170,    73,   157,    -1,   160,    -1,   151,
+      -1,   163,    -1,    -1,   169,    82,    -1,   169,    82,   124,
+      -1,    14,    82,    -1,    13,    82,    -1,    20,    82,    -1,
+      20,   124,    82,    -1,    19,    82,    -1,   173,    -1,   172,
+     173,    -1,   174,    -1,   126,    -1,    -1,   127,   175,   158,
+      -1
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
@@ -744,13 +658,13 @@
     1316,  1336,  1412,  1421,  1444,  1447,  1453,  1461,  1469,  1477,
     1487,  1494,  1497,  1500,  1506,  1509,  1524,  1528,  1532,  1536,
     1545,  1550,  1555,  1560,  1565,  1570,  1575,  1580,  1585,  1590,
-    1596,  1602,  1608,  1613,  1618,  1627,  1632,  1645,  1645,  1659,
-    1659,  1668,  1671,  1686,  1722,  1726,  1732,  1740,  1756,  1760,
-    1764,  1765,  1771,  1772,  1773,  1774,  1775,  1779,  1780,  1780,
-    1780,  1790,  1791,  1796,  1799,  1809,  1812,  1818,  1819,  1823,
-    1831,  1835,  1845,  1850,  1867,  1867,  1872,  1872,  1879,  1879,
-    1887,  1890,  1896,  1899,  1905,  1909,  1916,  1923,  1930,  1937,
-    1948,  1957,  1961,  1968,  1971,  1977,  1977
+    1596,  1602,  1608,  1613,  1618,  1627,  1636,  1641,  1654,  1654,
+    1668,  1668,  1677,  1680,  1695,  1731,  1735,  1741,  1749,  1765,
+    1769,  1773,  1774,  1780,  1781,  1782,  1783,  1784,  1788,  1789,
+    1789,  1789,  1799,  1800,  1805,  1808,  1818,  1821,  1827,  1828,
+    1832,  1840,  1844,  1854,  1859,  1876,  1876,  1881,  1881,  1888,
+    1888,  1896,  1899,  1905,  1908,  1914,  1918,  1925,  1932,  1939,
+    1946,  1957,  1966,  1970,  1977,  1980,  1986,  1986
 };
 #endif
 
@@ -766,16 +680,16 @@
   "BVEC4", "IVEC2", "IVEC3", "IVEC4", "VEC2", "VEC3", "VEC4", "MATRIX2",
   "MATRIX3", "MATRIX4", "IN_QUAL", "OUT_QUAL", "INOUT_QUAL", "UNIFORM",
   "VARYING", "STRUCT", "VOID_TYPE", "WHILE", "SAMPLER2D", "SAMPLERCUBE",
-  "SAMPLER_EXTERNAL_OES", "IDENTIFIER", "TYPE_NAME", "FLOATCONSTANT",
-  "INTCONSTANT", "BOOLCONSTANT", "FIELD_SELECTION", "LEFT_OP", "RIGHT_OP",
-  "INC_OP", "DEC_OP", "LE_OP", "GE_OP", "EQ_OP", "NE_OP", "AND_OP",
-  "OR_OP", "XOR_OP", "MUL_ASSIGN", "DIV_ASSIGN", "ADD_ASSIGN",
-  "MOD_ASSIGN", "LEFT_ASSIGN", "RIGHT_ASSIGN", "AND_ASSIGN", "XOR_ASSIGN",
-  "OR_ASSIGN", "SUB_ASSIGN", "LEFT_PAREN", "RIGHT_PAREN", "LEFT_BRACKET",
-  "RIGHT_BRACKET", "LEFT_BRACE", "RIGHT_BRACE", "DOT", "COMMA", "COLON",
-  "EQUAL", "SEMICOLON", "BANG", "DASH", "TILDE", "PLUS", "STAR", "SLASH",
-  "PERCENT", "LEFT_ANGLE", "RIGHT_ANGLE", "VERTICAL_BAR", "CARET",
-  "AMPERSAND", "QUESTION", "$accept", "variable_identifier",
+  "SAMPLER_EXTERNAL_OES", "SAMPLER2DRECT", "IDENTIFIER", "TYPE_NAME",
+  "FLOATCONSTANT", "INTCONSTANT", "BOOLCONSTANT", "FIELD_SELECTION",
+  "LEFT_OP", "RIGHT_OP", "INC_OP", "DEC_OP", "LE_OP", "GE_OP", "EQ_OP",
+  "NE_OP", "AND_OP", "OR_OP", "XOR_OP", "MUL_ASSIGN", "DIV_ASSIGN",
+  "ADD_ASSIGN", "MOD_ASSIGN", "LEFT_ASSIGN", "RIGHT_ASSIGN", "AND_ASSIGN",
+  "XOR_ASSIGN", "OR_ASSIGN", "SUB_ASSIGN", "LEFT_PAREN", "RIGHT_PAREN",
+  "LEFT_BRACKET", "RIGHT_BRACKET", "LEFT_BRACE", "RIGHT_BRACE", "DOT",
+  "COMMA", "COLON", "EQUAL", "SEMICOLON", "BANG", "DASH", "TILDE", "PLUS",
+  "STAR", "SLASH", "PERCENT", "LEFT_ANGLE", "RIGHT_ANGLE", "VERTICAL_BAR",
+  "CARET", "AMPERSAND", "QUESTION", "$accept", "variable_identifier",
   "primary_expression", "postfix_expression", "integer_expression",
   "function_call", "function_call_or_method", "function_call_generic",
   "function_call_header_no_parameters",
@@ -794,16 +708,16 @@
   "init_declarator_list", "single_declaration", "fully_specified_type",
   "type_qualifier", "type_specifier", "precision_qualifier",
   "type_specifier_no_prec", "type_specifier_nonarray", "struct_specifier",
-  "@1", "@2", "struct_declaration_list", "struct_declaration",
+  "$@1", "$@2", "struct_declaration_list", "struct_declaration",
   "struct_declarator_list", "struct_declarator", "initializer",
   "declaration_statement", "statement", "simple_statement",
-  "compound_statement", "@3", "@4", "statement_no_new_scope",
+  "compound_statement", "$@3", "$@4", "statement_no_new_scope",
   "compound_statement_no_new_scope", "statement_list",
   "expression_statement", "selection_statement",
-  "selection_rest_statement", "condition", "iteration_statement", "@5",
-  "@6", "@7", "for_init_statement", "conditionopt", "for_rest_statement",
+  "selection_rest_statement", "condition", "iteration_statement", "$@5",
+  "$@6", "$@7", "for_init_statement", "conditionopt", "for_rest_statement",
   "jump_statement", "translation_unit", "external_declaration",
-  "function_definition", "@8", 0
+  "function_definition", "$@8", 0
 };
 #endif
 
@@ -821,33 +735,33 @@
      315,   316,   317,   318,   319,   320,   321,   322,   323,   324,
      325,   326,   327,   328,   329,   330,   331,   332,   333,   334,
      335,   336,   337,   338,   339,   340,   341,   342,   343,   344,
-     345,   346,   347,   348,   349
+     345,   346,   347,   348,   349,   350
 };
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
 static const yytype_uint8 yyr1[] =
 {
-       0,    95,    96,    97,    97,    97,    97,    97,    98,    98,
-      98,    98,    98,    98,    99,   100,   101,   101,   102,   102,
-     103,   103,   104,   104,   105,   106,   106,   106,   107,   107,
-     107,   107,   108,   108,   108,   109,   109,   109,   110,   110,
-     110,   111,   112,   112,   112,   112,   112,   113,   113,   113,
-     114,   115,   116,   117,   117,   118,   118,   119,   119,   120,
-     120,   121,   121,   122,   122,   122,   122,   122,   123,   123,
-     124,   125,   125,   125,   126,   127,   127,   128,   128,   129,
-     130,   130,   131,   131,   131,   131,   132,   132,   132,   132,
-     133,   134,   134,   134,   134,   134,   135,   135,   135,   135,
-     135,   135,   136,   136,   137,   137,   137,   137,   137,   138,
-     138,   139,   139,   139,   140,   140,   141,   141,   141,   141,
-     141,   141,   141,   141,   141,   141,   141,   141,   141,   141,
-     141,   141,   141,   141,   141,   141,   141,   143,   142,   144,
-     142,   145,   145,   146,   147,   147,   148,   148,   149,   150,
-     151,   151,   152,   152,   152,   152,   152,   153,   154,   155,
-     153,   156,   156,   157,   157,   158,   158,   159,   159,   160,
-     161,   161,   162,   162,   164,   163,   165,   163,   166,   163,
-     167,   167,   168,   168,   169,   169,   170,   170,   170,   170,
-     170,   171,   171,   172,   172,   174,   173
+       0,    96,    97,    98,    98,    98,    98,    98,    99,    99,
+      99,    99,    99,    99,   100,   101,   102,   102,   103,   103,
+     104,   104,   105,   105,   106,   107,   107,   107,   108,   108,
+     108,   108,   109,   109,   109,   110,   110,   110,   111,   111,
+     111,   112,   113,   113,   113,   113,   113,   114,   114,   114,
+     115,   116,   117,   118,   118,   119,   119,   120,   120,   121,
+     121,   122,   122,   123,   123,   123,   123,   123,   124,   124,
+     125,   126,   126,   126,   127,   128,   128,   129,   129,   130,
+     131,   131,   132,   132,   132,   132,   133,   133,   133,   133,
+     134,   135,   135,   135,   135,   135,   136,   136,   136,   136,
+     136,   136,   137,   137,   138,   138,   138,   138,   138,   139,
+     139,   140,   140,   140,   141,   141,   142,   142,   142,   142,
+     142,   142,   142,   142,   142,   142,   142,   142,   142,   142,
+     142,   142,   142,   142,   142,   142,   142,   142,   144,   143,
+     145,   143,   146,   146,   147,   148,   148,   149,   149,   150,
+     151,   152,   152,   153,   153,   153,   153,   153,   154,   155,
+     156,   154,   157,   157,   158,   158,   159,   159,   160,   160,
+     161,   162,   162,   163,   163,   165,   164,   166,   164,   167,
+     164,   168,   168,   169,   169,   170,   170,   171,   171,   171,
+     171,   171,   172,   172,   173,   173,   175,   174
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
@@ -866,13 +780,13 @@
        4,     2,     1,     2,     1,     1,     1,     2,     1,     1,
        2,     1,     1,     1,     1,     4,     1,     1,     1,     1,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       1,     1,     1,     1,     1,     1,     1,     0,     6,     0,
-       5,     1,     2,     3,     1,     3,     1,     4,     1,     1,
-       1,     1,     1,     1,     1,     1,     1,     2,     0,     0,
-       5,     1,     1,     2,     3,     1,     2,     1,     2,     5,
-       3,     1,     1,     4,     0,     6,     0,     8,     0,     7,
-       1,     1,     1,     0,     2,     3,     2,     2,     2,     3,
-       2,     1,     2,     1,     1,     0,     3
+       1,     1,     1,     1,     1,     1,     1,     1,     0,     6,
+       0,     5,     1,     2,     3,     1,     3,     1,     4,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     2,     0,
+       0,     5,     1,     1,     2,     3,     1,     2,     1,     2,
+       5,     3,     1,     1,     4,     0,     6,     0,     8,     0,
+       7,     1,     1,     1,     0,     2,     3,     2,     2,     2,
+       3,     2,     1,     2,     1,     1,     0,     3
 };
 
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
@@ -883,96 +797,96 @@
        0,     0,   111,   112,   113,     0,   105,   104,   119,   117,
      118,   123,   124,   125,   126,   127,   128,   120,   121,   122,
      129,   130,   131,   108,   106,     0,   116,   132,   133,   134,
-     136,   194,   195,     0,    76,    86,     0,    91,    96,     0,
-     102,     0,   109,   114,   135,     0,   191,   193,   107,   101,
-       0,     0,   139,    71,     0,    74,    86,     0,    87,    88,
-      89,    77,     0,    86,     0,    72,    97,   103,   110,     0,
-       1,   192,     0,   137,     0,     0,   196,    78,    83,    85,
-      90,     0,    92,    79,     0,     0,     2,     5,     4,     6,
-      27,     0,     0,     0,    34,    33,    32,     3,     8,    28,
-      10,    15,    16,     0,     0,    21,     0,    35,     0,    38,
-      41,    42,    47,    50,    51,    52,    53,    55,    57,    59,
-      70,     0,    25,    73,     0,     0,     0,   141,     0,     0,
-     176,     0,     0,     0,     0,     0,   158,   163,   167,    35,
-      61,    68,     0,   149,     0,   114,   152,   165,   151,   150,
-       0,   153,   154,   155,   156,    80,    82,    84,     0,     0,
-      98,     0,   148,   100,    29,    30,     0,    12,    13,     0,
-       0,    19,    18,     0,    20,    22,    24,    31,     0,     0,
+     135,   137,   195,   196,     0,    76,    86,     0,    91,    96,
+       0,   102,     0,   109,   114,   136,     0,   192,   194,   107,
+     101,     0,     0,   140,    71,     0,    74,    86,     0,    87,
+      88,    89,    77,     0,    86,     0,    72,    97,   103,   110,
+       0,     1,   193,     0,   138,     0,     0,   197,    78,    83,
+      85,    90,     0,    92,    79,     0,     0,     2,     5,     4,
+       6,    27,     0,     0,     0,    34,    33,    32,     3,     8,
+      28,    10,    15,    16,     0,     0,    21,     0,    35,     0,
+      38,    41,    42,    47,    50,    51,    52,    53,    55,    57,
+      59,    70,     0,    25,    73,     0,     0,     0,   142,     0,
+       0,   177,     0,     0,     0,     0,     0,   159,   164,   168,
+      35,    61,    68,     0,   150,     0,   114,   153,   166,   152,
+     151,     0,   154,   155,   156,   157,    80,    82,    84,     0,
+       0,    98,     0,   149,   100,    29,    30,     0,    12,    13,
+       0,     0,    19,    18,     0,    20,    22,    24,    31,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,   115,     0,   146,     0,   144,   140,   142,   187,
-     186,     0,   178,     0,   190,   188,     0,   174,   157,     0,
-      64,    65,    66,    67,    63,     0,     0,   168,   164,   166,
-       0,    93,     0,    95,    99,     7,     0,    14,    26,    11,
-      17,    23,    36,    37,    40,    39,    45,    46,    43,    44,
-      48,    49,    54,    56,    58,     0,   138,     0,     0,   143,
-       0,     0,     0,   189,     0,   159,    62,    69,     0,    94,
-       9,     0,     0,   145,     0,   181,   180,   183,     0,   172,
-       0,     0,     0,    81,    60,   147,     0,   182,     0,     0,
-     171,   169,     0,     0,   160,     0,   184,     0,     0,     0,
-     162,   175,   161,     0,   185,   179,   170,   173,   177
+       0,     0,     0,   115,     0,   147,     0,   145,   141,   143,
+     188,   187,     0,   179,     0,   191,   189,     0,   175,   158,
+       0,    64,    65,    66,    67,    63,     0,     0,   169,   165,
+     167,     0,    93,     0,    95,    99,     7,     0,    14,    26,
+      11,    17,    23,    36,    37,    40,    39,    45,    46,    43,
+      44,    48,    49,    54,    56,    58,     0,   139,     0,     0,
+     144,     0,     0,     0,   190,     0,   160,    62,    69,     0,
+      94,     9,     0,     0,   146,     0,   182,   181,   184,     0,
+     173,     0,     0,     0,    81,    60,   148,     0,   183,     0,
+       0,   172,   170,     0,     0,   161,     0,   185,     0,     0,
+       0,   163,   176,   162,     0,   186,   180,   171,   174,   178
 };
 
 /* YYDEFGOTO[NTERM-NUM].  */
 static const yytype_int16 yydefgoto[] =
 {
-      -1,    97,    98,    99,   226,   100,   101,   102,   103,   104,
-     105,   106,   139,   108,   109,   110,   111,   112,   113,   114,
-     115,   116,   117,   118,   119,   140,   141,   215,   142,   121,
-     143,   144,    33,    34,    35,    78,    61,    62,    79,    36,
-      37,    38,    39,    40,    41,    42,   122,    44,   124,    74,
-     126,   127,   195,   196,   163,   146,   147,   148,   149,   209,
-     272,   291,   292,   150,   151,   152,   281,   271,   153,   254,
-     201,   251,   267,   278,   279,   154,    45,    46,    47,    54
+      -1,    98,    99,   100,   227,   101,   102,   103,   104,   105,
+     106,   107,   140,   109,   110,   111,   112,   113,   114,   115,
+     116,   117,   118,   119,   120,   141,   142,   216,   143,   122,
+     144,   145,    34,    35,    36,    79,    62,    63,    80,    37,
+      38,    39,    40,    41,    42,    43,   123,    45,   125,    75,
+     127,   128,   196,   197,   164,   147,   148,   149,   150,   210,
+     273,   292,   293,   151,   152,   153,   282,   272,   154,   255,
+     202,   252,   268,   279,   280,   155,    46,    47,    48,    55
 };
 
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
-#define YYPACT_NINF -242
+#define YYPACT_NINF -251
 static const yytype_int16 yypact[] =
 {
-    1179,    -6,  -242,  -242,  -242,   151,  -242,  -242,  -242,  -242,
-    -242,  -242,  -242,  -242,  -242,  -242,  -242,  -242,  -242,  -242,
-    -242,  -242,  -242,  -242,  -242,   -39,  -242,  -242,  -242,  -242,
-    -242,  -242,   -69,   -37,   -32,    21,   -61,  -242,    26,  1221,
-    -242,  1282,  -242,   -58,  -242,   207,  -242,  -242,  -242,  -242,
-    1282,    22,  -242,  -242,    33,  -242,    70,    88,  -242,  -242,
-    -242,  -242,  1221,   125,    42,  -242,    -8,  -242,  -242,   961,
-    -242,  -242,    72,  -242,  1221,   286,  -242,  -242,  -242,  -242,
-     117,  1221,   -57,  -242,   766,   961,    94,  -242,  -242,  -242,
-    -242,   961,   961,   961,  -242,  -242,  -242,  -242,  -242,    14,
-    -242,  -242,  -242,    99,   -35,  1026,   101,  -242,   961,   -27,
-      46,  -242,   -21,    56,  -242,  -242,  -242,   115,   119,   -45,
-    -242,   103,  -242,  -242,  1221,   136,  1094,  -242,   102,   104,
-    -242,   111,   116,   105,   831,   118,   112,  -242,  -242,    39,
-    -242,  -242,    17,  -242,   -69,    93,  -242,  -242,  -242,  -242,
-     369,  -242,  -242,  -242,  -242,   122,  -242,  -242,   896,   961,
-    -242,   123,  -242,  -242,  -242,  -242,    10,  -242,  -242,   961,
-    1246,  -242,  -242,   961,   120,  -242,  -242,  -242,   961,   961,
-     961,   961,   961,   961,   961,   961,   961,   961,   961,   961,
-     961,   961,  -242,  1136,   126,    49,  -242,  -242,  -242,  -242,
-    -242,   452,  -242,   961,  -242,  -242,    71,  -242,  -242,   452,
-    -242,  -242,  -242,  -242,  -242,   961,   961,  -242,  -242,  -242,
-     961,  -242,   124,  -242,  -242,  -242,   128,   114,  -242,   129,
-    -242,  -242,  -242,  -242,   -27,   -27,  -242,  -242,  -242,  -242,
-     -21,   -21,  -242,   115,   119,    89,  -242,   961,   136,  -242,
-     150,   618,    11,  -242,   701,   452,  -242,  -242,   130,  -242,
-    -242,   961,   131,  -242,   137,  -242,  -242,   701,   452,   114,
-     152,   148,   145,  -242,  -242,  -242,   961,  -242,   141,   153,
-     208,  -242,   143,   535,  -242,    38,   961,   535,   452,   961,
-    -242,  -242,  -242,   146,   114,  -242,  -242,  -242,  -242
+    1250,   -17,  -251,  -251,  -251,   113,  -251,  -251,  -251,  -251,
+    -251,  -251,  -251,  -251,  -251,  -251,  -251,  -251,  -251,  -251,
+    -251,  -251,  -251,  -251,  -251,   -39,  -251,  -251,  -251,  -251,
+    -251,  -251,  -251,   -65,   -34,   -10,    21,   -32,  -251,    28,
+     207,  -251,  1324,  -251,    56,  -251,  1206,  -251,  -251,  -251,
+    -251,  1324,    74,  -251,  -251,    86,  -251,    71,    95,  -251,
+    -251,  -251,  -251,   207,   119,   120,  -251,   -56,  -251,  -251,
+     971,  -251,  -251,    84,  -251,   207,   287,  -251,  -251,  -251,
+    -251,   124,   207,   -59,  -251,   773,   971,    98,  -251,  -251,
+    -251,  -251,   971,   971,   971,  -251,  -251,  -251,  -251,  -251,
+      35,  -251,  -251,  -251,   100,    -9,  1037,   102,  -251,   971,
+     -27,    -1,  -251,   -24,    99,  -251,  -251,  -251,   112,   111,
+     -51,  -251,   103,  -251,  -251,   207,   135,  1106,  -251,   101,
+     104,  -251,   109,   115,   106,   839,   117,   107,  -251,  -251,
+      39,  -251,  -251,   -11,  -251,   -65,    54,  -251,  -251,  -251,
+    -251,   371,  -251,  -251,  -251,  -251,   116,  -251,  -251,   905,
+     971,  -251,   118,  -251,  -251,  -251,  -251,     8,  -251,  -251,
+     971,  1287,  -251,  -251,   971,   125,  -251,  -251,  -251,   971,
+     971,   971,   971,   971,   971,   971,   971,   971,   971,   971,
+     971,   971,   971,  -251,  1149,   122,    17,  -251,  -251,  -251,
+    -251,  -251,   455,  -251,   971,  -251,  -251,    32,  -251,  -251,
+     455,  -251,  -251,  -251,  -251,  -251,   971,   971,  -251,  -251,
+    -251,   971,  -251,   123,  -251,  -251,  -251,   126,   121,  -251,
+     127,  -251,  -251,  -251,  -251,   -27,   -27,  -251,  -251,  -251,
+    -251,   -24,   -24,  -251,   112,   111,    79,  -251,   971,   135,
+    -251,   151,   623,    11,  -251,   707,   455,  -251,  -251,   128,
+    -251,  -251,   971,   130,  -251,   134,  -251,  -251,   707,   455,
+     121,   147,   136,   131,  -251,  -251,  -251,   971,  -251,   132,
+     142,   200,  -251,   139,   539,  -251,    19,   971,   539,   455,
+     971,  -251,  -251,  -251,   140,   121,  -251,  -251,  -251,  -251
 };
 
 /* YYPGOTO[NTERM-NUM].  */
 static const yytype_int16 yypgoto[] =
 {
-    -242,  -242,  -242,  -242,  -242,  -242,  -242,    77,  -242,  -242,
-    -242,  -242,   -44,  -242,   -63,  -242,   -62,   -17,  -242,  -242,
-    -242,    52,    37,    51,  -242,   -66,   -83,  -242,   -92,   -73,
-       7,     8,  -242,  -242,  -242,   161,   197,   193,   176,  -242,
-    -242,  -241,   -29,   -30,   253,   -22,     0,  -242,  -242,  -242,
-     135,  -122,  -242,    12,  -138,    13,  -140,  -203,  -242,  -242,
-    -242,   -26,   209,    53,    15,  -242,  -242,    -2,  -242,  -242,
-    -242,  -242,  -242,  -242,  -242,  -242,  -242,   224,  -242,  -242
+    -251,  -251,  -251,  -251,  -251,  -251,  -251,    50,  -251,  -251,
+    -251,  -251,   -44,  -251,   -21,  -251,   -62,   -20,  -251,  -251,
+    -251,    34,    36,    33,  -251,   -66,   -83,  -251,   -92,   -73,
+       7,    13,  -251,  -251,  -251,   143,   170,   176,   159,  -251,
+    -251,  -247,   -22,   -30,   237,   -15,     0,  -251,  -251,  -251,
+     129,  -122,  -251,    -6,  -159,    -8,  -140,  -250,  -251,  -251,
+    -251,   -41,   202,    48,     9,  -251,  -251,    -5,  -251,  -251,
+    -251,  -251,  -251,  -251,  -251,  -251,  -251,   213,  -251,  -251
 };
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
@@ -982,276 +896,286 @@
 #define YYTABLE_NINF -117
 static const yytype_int16 yytable[] =
 {
-      43,   166,   162,   120,   198,    51,    63,    31,    32,    67,
-     219,   161,    53,   270,   190,    69,   158,    64,   120,    68,
-      65,   223,   175,   159,    57,   107,   270,    63,    72,     6,
-       7,    48,    80,   182,   183,    55,    52,   172,    49,    43,
-     107,    43,   206,   173,   125,    43,    56,   164,   165,   191,
-      43,    80,    31,    32,    58,    59,    60,    23,    24,   178,
-     179,   250,    43,    83,   177,    84,   167,   168,   184,   185,
-      66,   198,    85,    57,    43,   145,   162,   227,     6,     7,
-     290,    43,   225,   268,   290,   222,    82,   169,   216,   216,
-     231,   170,   120,   -75,   125,   216,   125,    73,   217,   245,
-     210,   211,   212,    58,    59,    60,    23,    24,    75,   213,
-     293,   252,   186,   187,   107,   219,   216,   234,   235,   214,
-     236,   237,   238,   239,    43,    48,    43,   248,   280,   180,
-     249,   181,   256,   257,   232,   233,   107,   107,   107,   107,
-     107,   107,   107,   107,   107,   107,   107,   258,   296,   216,
-     145,   297,   253,   123,   120,     2,     3,     4,    58,    59,
-      60,   155,   269,   125,   -25,   -26,    69,   216,   261,   240,
-     241,   171,   176,   188,   262,   269,   107,   192,   274,   189,
-     194,   120,   202,   199,   285,   200,   204,   203,   208,   207,
-     264,  -116,   216,    43,   294,   220,   282,   224,   259,   247,
-     -27,   145,   260,   107,   273,   275,   162,    70,   276,   145,
+      44,   224,   167,   163,   121,   199,    52,    32,   271,   191,
+      68,   220,   162,    33,    64,   159,    84,    54,    85,   121,
+      49,   271,   160,   176,    58,    86,   108,    69,    50,     6,
+       7,   183,   184,    81,   291,    64,    73,    53,   291,    56,
+      44,   108,    44,   207,   192,   126,    44,    65,   165,   166,
+      66,    44,    81,    32,    59,    60,    61,    23,    24,    33,
+     179,   180,   251,    44,   173,   178,   185,   186,   217,    57,
+     174,   218,   199,    67,    58,    44,   146,   163,   228,     6,
+       7,   226,    44,   181,   269,   182,   223,   217,   168,   169,
+     217,   232,   294,   121,   -75,   126,   249,   126,   217,   250,
+     246,   211,   212,   213,    59,    60,    61,    23,    24,   170,
+     214,   217,   253,   171,   254,   108,   220,     2,     3,     4,
+     215,   237,   238,   239,   240,    44,   -25,    44,    70,   281,
+      70,   298,    49,   257,   258,   233,   234,   108,   108,   108,
+     108,   108,   108,   108,   108,   108,   108,   108,   259,   297,
+      74,   146,    59,    60,    61,   121,   187,   188,   217,   262,
+     235,   236,    76,   270,   126,    83,   124,   241,   242,   156,
+     -26,   189,   190,   172,   177,   263,   270,   108,   193,   275,
+     195,   203,   121,   200,   209,   286,   201,   204,   205,   208,
+     221,   265,   283,   225,    44,   295,   248,  -116,   260,   -27,
+     217,   261,   146,   274,   108,   276,   277,   163,   285,   284,
+     146,     2,     3,     4,   287,   288,   289,     8,     9,    10,
+     290,   231,   299,   243,   245,   157,   244,    78,    11,    12,
+      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      82,   158,    51,   264,   266,    25,    26,   296,    27,    28,
+      29,    30,   146,    31,   194,   146,   146,    77,   256,    72,
+       0,   267,     0,   278,     0,     0,     0,     0,   146,   146,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,   146,     0,     0,     0,   146,   146,
        1,     2,     3,     4,     5,     6,     7,     8,     9,    10,
-     283,   284,   286,   289,   288,   287,   243,   298,    11,    12,
+     129,   130,   131,     0,   132,   133,   134,   135,    11,    12,
       13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
-     242,   244,   156,    23,    24,    25,    26,   230,    27,    28,
-      29,   145,    30,    77,   145,   145,    81,   157,    50,   193,
-     263,   295,   255,    76,   265,   277,   266,   145,   145,    71,
+       0,     0,     0,    23,    24,    25,    26,   136,    27,    28,
+      29,    30,    87,    31,    88,    89,    90,    91,     0,     0,
+      92,    93,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    94,
+       0,     0,     0,   137,   138,     0,     0,     0,     0,   139,
+      95,    96,     0,    97,     1,     2,     3,     4,     5,     6,
+       7,     8,     9,    10,   129,   130,   131,     0,   132,   133,
+     134,   135,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,     0,     0,     0,    23,    24,    25,
+      26,   136,    27,    28,    29,    30,    87,    31,    88,    89,
+      90,    91,     0,     0,    92,    93,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,   145,     0,     0,     0,   145,   145,     1,
-       2,     3,     4,     5,     6,     7,     8,     9,    10,   128,
-     129,   130,     0,   131,   132,   133,   134,    11,    12,    13,
-      14,    15,    16,    17,    18,    19,    20,    21,    22,     0,
-       0,     0,    23,    24,    25,    26,   135,    27,    28,    29,
-      86,    30,    87,    88,    89,    90,     0,     0,    91,    92,
+       0,     0,     0,    94,     0,     0,     0,   137,   219,     0,
+       0,     0,     0,   139,    95,    96,     0,    97,     1,     2,
+       3,     4,     5,     6,     7,     8,     9,    10,   129,   130,
+     131,     0,   132,   133,   134,   135,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,     0,     0,
+       0,    23,    24,    25,    26,   136,    27,    28,    29,    30,
+      87,    31,    88,    89,    90,    91,     0,     0,    92,    93,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,    93,     0,     0,
-       0,   136,   137,     0,     0,     0,     0,   138,    94,    95,
-       0,    96,     1,     2,     3,     4,     5,     6,     7,     8,
-       9,    10,   128,   129,   130,     0,   131,   132,   133,   134,
+       0,     0,     0,     0,     0,     0,     0,    94,     0,     0,
+       0,   137,     0,     0,     0,     0,     0,   139,    95,    96,
+       0,    97,     1,     2,     3,     4,     5,     6,     7,     8,
+       9,    10,   129,   130,   131,     0,   132,   133,   134,   135,
       11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
-      21,    22,     0,     0,     0,    23,    24,    25,    26,   135,
-      27,    28,    29,    86,    30,    87,    88,    89,    90,     0,
-       0,    91,    92,     0,     0,     0,     0,     0,     0,     0,
+      21,    22,     0,     0,     0,    23,    24,    25,    26,   136,
+      27,    28,    29,    30,    87,    31,    88,    89,    90,    91,
+       0,     0,    92,    93,     0,     0,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-      93,     0,     0,     0,   136,   218,     0,     0,     0,     0,
-     138,    94,    95,     0,    96,     1,     2,     3,     4,     5,
-       6,     7,     8,     9,    10,   128,   129,   130,     0,   131,
-     132,   133,   134,    11,    12,    13,    14,    15,    16,    17,
-      18,    19,    20,    21,    22,     0,     0,     0,    23,    24,
-      25,    26,   135,    27,    28,    29,    86,    30,    87,    88,
-      89,    90,     0,     0,    91,    92,     0,     0,     0,     0,
+       0,    94,     0,     0,     0,    76,     0,     0,     0,     0,
+       0,   139,    95,    96,     0,    97,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,     0,     0,     0,     0,
+       0,     0,     0,     0,    11,    12,    13,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,     0,     0,     0,    23,
+      24,    25,    26,     0,    27,    28,    29,    30,    87,    31,
+      88,    89,    90,    91,     0,     0,    92,    93,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,    93,     0,     0,     0,   136,     0,     0,
-       0,     0,     0,   138,    94,    95,     0,    96,     1,     2,
-       3,     4,     5,     6,     7,     8,     9,    10,   128,   129,
-     130,     0,   131,   132,   133,   134,    11,    12,    13,    14,
+       0,     0,     0,     0,     0,    94,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,   139,    95,    96,     0,    97,
+      58,     2,     3,     4,     0,     6,     7,     8,     9,    10,
+       0,     0,     0,     0,     0,     0,     0,     0,    11,    12,
+      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+       0,     0,     0,    23,    24,    25,    26,     0,    27,    28,
+      29,    30,    87,    31,    88,    89,    90,    91,     0,     0,
+      92,    93,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    94,
+       0,     0,     0,     8,     9,    10,     0,     0,     0,     0,
+      95,    96,     0,    97,    11,    12,    13,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,     0,     0,     0,     0,
+       0,    25,    26,     0,    27,    28,    29,    30,    87,    31,
+      88,    89,    90,    91,     0,     0,    92,    93,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    94,     0,     0,   161,     8,
+       9,    10,     0,     0,     0,     0,    95,    96,     0,    97,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,     0,     0,     0,     0,     0,    25,    26,     0,
+      27,    28,    29,    30,    87,    31,    88,    89,    90,    91,
+       0,     0,    92,    93,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    94,     0,     0,     0,     8,     9,    10,     0,     0,
+       0,   206,    95,    96,     0,    97,    11,    12,    13,    14,
       15,    16,    17,    18,    19,    20,    21,    22,     0,     0,
-       0,    23,    24,    25,    26,   135,    27,    28,    29,    86,
-      30,    87,    88,    89,    90,     0,     0,    91,    92,     0,
+       0,     0,     0,    25,    26,     0,    27,    28,    29,    30,
+      87,    31,    88,    89,    90,    91,     0,     0,    92,    93,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,    93,     0,     0,     0,
-      75,     0,     0,     0,     0,     0,   138,    94,    95,     0,
-      96,     1,     2,     3,     4,     5,     6,     7,     8,     9,
-      10,     0,     0,     0,     0,     0,     0,     0,     0,    11,
-      12,    13,    14,    15,    16,    17,    18,    19,    20,    21,
-      22,     0,     0,     0,    23,    24,    25,    26,     0,    27,
-      28,    29,    86,    30,    87,    88,    89,    90,     0,     0,
-      91,    92,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,    93,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,   138,
-      94,    95,     0,    96,    57,     2,     3,     4,     0,     6,
-       7,     8,     9,    10,     0,     0,     0,     0,     0,     0,
-       0,     0,    11,    12,    13,    14,    15,    16,    17,    18,
-      19,    20,    21,    22,     0,     0,     0,    23,    24,    25,
-      26,     0,    27,    28,    29,    86,    30,    87,    88,    89,
-      90,     0,     0,    91,    92,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,    94,     0,     0,
+     222,     8,     9,    10,     0,     0,     0,     0,    95,    96,
+       0,    97,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,     0,     0,     0,     0,     0,    25,
+      26,     0,    27,    28,    29,    30,    87,    31,    88,    89,
+      90,    91,     0,     0,    92,    93,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,    93,     0,     0,     0,     8,     9,    10,     0,
-       0,     0,     0,    94,    95,     0,    96,    11,    12,    13,
+       0,     0,     0,    94,     0,     0,     0,     8,     9,    10,
+       0,     0,     0,     0,    95,    96,     0,    97,    11,    12,
+      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+       0,     0,     0,     0,     0,    25,   175,     0,    27,    28,
+      29,    30,    87,    31,    88,    89,    90,    91,     0,     0,
+      92,    93,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    94,
+       2,     3,     4,     0,     0,     0,     8,     9,    10,     0,
+      95,    96,     0,    97,     0,     0,     0,    11,    12,    13,
       14,    15,    16,    17,    18,    19,    20,    21,    22,     0,
        0,     0,     0,     0,    25,    26,     0,    27,    28,    29,
-      86,    30,    87,    88,    89,    90,     0,     0,    91,    92,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,    93,     0,     0,
-     160,     8,     9,    10,     0,     0,     0,     0,    94,    95,
-       0,    96,    11,    12,    13,    14,    15,    16,    17,    18,
-      19,    20,    21,    22,     0,     0,     0,     0,     0,    25,
-      26,     0,    27,    28,    29,    86,    30,    87,    88,    89,
-      90,     0,     0,    91,    92,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,    93,     0,     0,     0,     8,     9,    10,     0,
-       0,     0,   205,    94,    95,     0,    96,    11,    12,    13,
-      14,    15,    16,    17,    18,    19,    20,    21,    22,     0,
-       0,     0,     0,     0,    25,    26,     0,    27,    28,    29,
-      86,    30,    87,    88,    89,    90,     0,     0,    91,    92,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,    93,     0,     0,
-     221,     8,     9,    10,     0,     0,     0,     0,    94,    95,
-       0,    96,    11,    12,    13,    14,    15,    16,    17,    18,
-      19,    20,    21,    22,     0,     0,     0,     0,     0,    25,
-      26,     0,    27,    28,    29,    86,    30,    87,    88,    89,
-      90,     0,     0,    91,    92,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,    93,     0,     0,     0,     8,     9,    10,     0,
-       0,     0,     0,    94,    95,     0,    96,    11,    12,    13,
-      14,    15,    16,    17,    18,    19,    20,    21,    22,     0,
-       0,     0,     0,     0,    25,   174,     0,    27,    28,    29,
-      86,    30,    87,    88,    89,    90,     0,     0,    91,    92,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,    93,     2,     3,
-       4,     0,     0,     0,     8,     9,    10,     0,    94,    95,
-       0,    96,     0,     0,     0,    11,    12,    13,    14,    15,
-      16,    17,    18,    19,    20,    21,    22,     0,     0,     0,
-       0,     0,    25,    26,     0,    27,    28,    29,     0,    30,
-       2,     3,     4,     0,     0,     0,     8,     9,    10,     0,
-       0,     0,     0,     0,     0,     0,     0,    11,    12,    13,
-      14,    15,    16,    17,    18,    19,    20,    21,    22,     0,
-     197,     0,     0,     0,    25,    26,     0,    27,    28,    29,
-       0,    30,     1,     2,     3,     4,     5,     6,     7,     8,
+      30,     0,    31,     2,     3,     4,     0,     0,     0,     8,
        9,    10,     0,     0,     0,     0,     0,     0,     0,     0,
       11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
-      21,    22,   246,     0,     0,    23,    24,    25,    26,     0,
-      27,    28,    29,     0,    30,     2,     3,     4,     0,     0,
-       0,     8,     9,    10,     0,     0,     0,     0,     0,     0,
-       0,     0,    11,    12,    13,    14,    15,    16,    17,    18,
-      19,    20,    21,    22,     0,     0,     8,     9,    10,    25,
-      26,     0,    27,    28,    29,     0,    30,    11,    12,    13,
+      21,    22,     0,   198,     0,     0,     0,    25,    26,     0,
+      27,    28,    29,    30,     0,    31,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    71,     0,     0,     1,
+       2,     3,     4,     5,     6,     7,     8,     9,    10,     0,
+       0,     0,     0,     0,     0,     0,   247,    11,    12,    13,
       14,    15,    16,    17,    18,    19,    20,    21,    22,     0,
-       0,     0,     0,     0,    25,    26,     0,    27,    28,    29,
-     228,    30,     8,     9,    10,   229,     0,     0,     0,     0,
-       0,     0,     0,    11,    12,    13,    14,    15,    16,    17,
-      18,    19,    20,    21,    22,     0,     0,     0,     0,     0,
-      25,    26,     0,    27,    28,    29,     0,    30
+       0,     0,    23,    24,    25,    26,     0,    27,    28,    29,
+      30,     0,    31,     1,     2,     3,     4,     5,     6,     7,
+       8,     9,    10,     0,     0,     0,     0,     0,     0,     0,
+       0,    11,    12,    13,    14,    15,    16,    17,    18,    19,
+      20,    21,    22,     0,     0,     0,    23,    24,    25,    26,
+       0,    27,    28,    29,    30,     0,    31,     8,     9,    10,
+       0,     0,     0,     0,     0,     0,     0,     0,    11,    12,
+      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+       0,     0,     0,     0,     0,    25,    26,     0,    27,    28,
+      29,    30,   229,    31,     8,     9,    10,   230,     0,     0,
+       0,     0,     0,     0,     0,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,    21,    22,     0,     0,     0,
+       0,     0,    25,    26,     0,    27,    28,    29,    30,     0,
+      31
 };
 
 static const yytype_int16 yycheck[] =
 {
-       0,    93,    85,    69,   126,    44,    35,     0,     0,    39,
-     150,    84,    81,   254,    59,    73,    73,    78,    84,    41,
-      81,   159,   105,    80,     3,    69,   267,    56,    50,     8,
-       9,    37,    62,    54,    55,    72,    75,    72,    44,    39,
-      84,    41,   134,    78,    74,    45,    78,    91,    92,    94,
-      50,    81,    45,    45,    33,    34,    35,    36,    37,    86,
-      87,   201,    62,    71,   108,    73,    52,    53,    89,    90,
-      44,   193,    80,     3,    74,    75,   159,   169,     8,     9,
-     283,    81,    72,    72,   287,   158,    44,    73,    78,    78,
-     173,    77,   158,    72,   124,    78,   126,    75,    81,   191,
-      61,    62,    63,    33,    34,    35,    36,    37,    75,    70,
-      72,   203,    56,    57,   158,   255,    78,   180,   181,    80,
-     182,   183,   184,   185,   124,    37,   126,    78,   268,    83,
-      81,    85,   215,   216,   178,   179,   180,   181,   182,   183,
-     184,   185,   186,   187,   188,   189,   190,   220,   288,    78,
-     150,   289,    81,    81,   220,     4,     5,     6,    33,    34,
-      35,    44,   254,   193,    71,    71,    73,    78,    79,   186,
-     187,    72,    71,    58,   247,   267,   220,    74,   261,    60,
-      44,   247,    71,    81,   276,    81,    81,    71,    76,    71,
-      40,    71,    78,   193,   286,    73,    44,    74,    74,    73,
-      71,   201,    74,   247,    74,    74,   289,     0,    71,   209,
+       0,   160,    94,    86,    70,   127,    45,     0,   255,    60,
+      40,   151,    85,     0,    36,    74,    72,    82,    74,    85,
+      37,   268,    81,   106,     3,    81,    70,    42,    45,     8,
+       9,    55,    56,    63,   284,    57,    51,    76,   288,    73,
+      40,    85,    42,   135,    95,    75,    46,    79,    92,    93,
+      82,    51,    82,    46,    33,    34,    35,    36,    37,    46,
+      87,    88,   202,    63,    73,   109,    90,    91,    79,    79,
+      79,    82,   194,    45,     3,    75,    76,   160,   170,     8,
+       9,    73,    82,    84,    73,    86,   159,    79,    53,    54,
+      79,   174,    73,   159,    73,   125,    79,   127,    79,    82,
+     192,    62,    63,    64,    33,    34,    35,    36,    37,    74,
+      71,    79,   204,    78,    82,   159,   256,     4,     5,     6,
+      81,   183,   184,   185,   186,   125,    72,   127,    74,   269,
+      74,   290,    37,   216,   217,   179,   180,   181,   182,   183,
+     184,   185,   186,   187,   188,   189,   190,   191,   221,   289,
+      76,   151,    33,    34,    35,   221,    57,    58,    79,    80,
+     181,   182,    76,   255,   194,    45,    82,   187,   188,    45,
+      72,    59,    61,    73,    72,   248,   268,   221,    75,   262,
+      45,    72,   248,    82,    77,   277,    82,    72,    82,    72,
+      74,    40,    45,    75,   194,   287,    74,    72,    75,    72,
+      79,    75,   202,    75,   248,    75,    72,   290,    77,    73,
+     210,     4,     5,     6,    82,    73,    16,    10,    11,    12,
+      81,   171,    82,   189,   191,    82,   190,    57,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      64,    82,     5,   249,   252,    38,    39,   288,    41,    42,
+      43,    44,   252,    46,   125,   255,   256,    55,   210,    46,
+      -1,   252,    -1,   268,    -1,    -1,    -1,    -1,   268,   269,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   284,    -1,    -1,    -1,   288,   289,
        3,     4,     5,     6,     7,     8,     9,    10,    11,    12,
-      72,    76,    81,    80,    16,    72,   189,    81,    21,    22,
+      13,    14,    15,    -1,    17,    18,    19,    20,    21,    22,
       23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-     188,   190,    81,    36,    37,    38,    39,   170,    41,    42,
-      43,   251,    45,    56,   254,   255,    63,    81,     5,   124,
-     248,   287,   209,    54,   251,   267,   251,   267,   268,    45,
+      -1,    -1,    -1,    36,    37,    38,    39,    40,    41,    42,
+      43,    44,    45,    46,    47,    48,    49,    50,    -1,    -1,
+      53,    54,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    72,
+      -1,    -1,    -1,    76,    77,    -1,    -1,    -1,    -1,    82,
+      83,    84,    -1,    86,     3,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,    13,    14,    15,    -1,    17,    18,
+      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    -1,    -1,    -1,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    46,    47,    48,
+      49,    50,    -1,    -1,    53,    54,    -1,    -1,    -1,    -1,
       -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,   283,    -1,    -1,    -1,   287,   288,     3,
-       4,     5,     6,     7,     8,     9,    10,    11,    12,    13,
-      14,    15,    -1,    17,    18,    19,    20,    21,    22,    23,
-      24,    25,    26,    27,    28,    29,    30,    31,    32,    -1,
-      -1,    -1,    36,    37,    38,    39,    40,    41,    42,    43,
-      44,    45,    46,    47,    48,    49,    -1,    -1,    52,    53,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,    -1,    -1,
-      -1,    75,    76,    -1,    -1,    -1,    -1,    81,    82,    83,
-      -1,    85,     3,     4,     5,     6,     7,     8,     9,    10,
-      11,    12,    13,    14,    15,    -1,    17,    18,    19,    20,
-      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    -1,    -1,    -1,    36,    37,    38,    39,    40,
-      41,    42,    43,    44,    45,    46,    47,    48,    49,    -1,
-      -1,    52,    53,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      71,    -1,    -1,    -1,    75,    76,    -1,    -1,    -1,    -1,
-      81,    82,    83,    -1,    85,     3,     4,     5,     6,     7,
-       8,     9,    10,    11,    12,    13,    14,    15,    -1,    17,
-      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    -1,    -1,    -1,    36,    37,
-      38,    39,    40,    41,    42,    43,    44,    45,    46,    47,
-      48,    49,    -1,    -1,    52,    53,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    71,    -1,    -1,    -1,    75,    -1,    -1,
-      -1,    -1,    -1,    81,    82,    83,    -1,    85,     3,     4,
+      -1,    -1,    -1,    72,    -1,    -1,    -1,    76,    77,    -1,
+      -1,    -1,    -1,    82,    83,    84,    -1,    86,     3,     4,
        5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
       15,    -1,    17,    18,    19,    20,    21,    22,    23,    24,
       25,    26,    27,    28,    29,    30,    31,    32,    -1,    -1,
       -1,    36,    37,    38,    39,    40,    41,    42,    43,    44,
-      45,    46,    47,    48,    49,    -1,    -1,    52,    53,    -1,
+      45,    46,    47,    48,    49,    50,    -1,    -1,    53,    54,
       -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    71,    -1,    -1,    -1,
-      75,    -1,    -1,    -1,    -1,    -1,    81,    82,    83,    -1,
-      85,     3,     4,     5,     6,     7,     8,     9,    10,    11,
-      12,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    21,
-      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
-      32,    -1,    -1,    -1,    36,    37,    38,    39,    -1,    41,
-      42,    43,    44,    45,    46,    47,    48,    49,    -1,    -1,
-      52,    53,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    81,
-      82,    83,    -1,    85,     3,     4,     5,     6,    -1,     8,
-       9,    10,    11,    12,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    -1,    -1,    -1,    36,    37,    38,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    72,    -1,    -1,
+      -1,    76,    -1,    -1,    -1,    -1,    -1,    82,    83,    84,
+      -1,    86,     3,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    -1,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    -1,    -1,    -1,    36,    37,    38,    39,    40,
+      41,    42,    43,    44,    45,    46,    47,    48,    49,    50,
+      -1,    -1,    53,    54,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    72,    -1,    -1,    -1,    76,    -1,    -1,    -1,    -1,
+      -1,    82,    83,    84,    -1,    86,     3,     4,     5,     6,
+       7,     8,     9,    10,    11,    12,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    -1,    -1,    -1,    36,
+      37,    38,    39,    -1,    41,    42,    43,    44,    45,    46,
+      47,    48,    49,    50,    -1,    -1,    53,    54,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    72,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    82,    83,    84,    -1,    86,
+       3,     4,     5,     6,    -1,     8,     9,    10,    11,    12,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      -1,    -1,    -1,    36,    37,    38,    39,    -1,    41,    42,
+      43,    44,    45,    46,    47,    48,    49,    50,    -1,    -1,
+      53,    54,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    72,
+      -1,    -1,    -1,    10,    11,    12,    -1,    -1,    -1,    -1,
+      83,    84,    -1,    86,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    -1,    -1,    -1,    -1,
+      -1,    38,    39,    -1,    41,    42,    43,    44,    45,    46,
+      47,    48,    49,    50,    -1,    -1,    53,    54,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    72,    -1,    -1,    75,    10,
+      11,    12,    -1,    -1,    -1,    -1,    83,    84,    -1,    86,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    -1,    -1,    -1,    -1,    -1,    38,    39,    -1,
+      41,    42,    43,    44,    45,    46,    47,    48,    49,    50,
+      -1,    -1,    53,    54,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    72,    -1,    -1,    -1,    10,    11,    12,    -1,    -1,
+      -1,    82,    83,    84,    -1,    86,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    -1,    -1,
+      -1,    -1,    -1,    38,    39,    -1,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    50,    -1,    -1,    53,    54,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    72,    -1,    -1,
+      75,    10,    11,    12,    -1,    -1,    -1,    -1,    83,    84,
+      -1,    86,    21,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    -1,    -1,    -1,    -1,    -1,    38,
       39,    -1,    41,    42,    43,    44,    45,    46,    47,    48,
-      49,    -1,    -1,    52,    53,    -1,    -1,    -1,    -1,    -1,
+      49,    50,    -1,    -1,    53,    54,    -1,    -1,    -1,    -1,
       -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    71,    -1,    -1,    -1,    10,    11,    12,    -1,
-      -1,    -1,    -1,    82,    83,    -1,    85,    21,    22,    23,
+      -1,    -1,    -1,    72,    -1,    -1,    -1,    10,    11,    12,
+      -1,    -1,    -1,    -1,    83,    84,    -1,    86,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      -1,    -1,    -1,    -1,    -1,    38,    39,    -1,    41,    42,
+      43,    44,    45,    46,    47,    48,    49,    50,    -1,    -1,
+      53,    54,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    72,
+       4,     5,     6,    -1,    -1,    -1,    10,    11,    12,    -1,
+      83,    84,    -1,    86,    -1,    -1,    -1,    21,    22,    23,
       24,    25,    26,    27,    28,    29,    30,    31,    32,    -1,
       -1,    -1,    -1,    -1,    38,    39,    -1,    41,    42,    43,
-      44,    45,    46,    47,    48,    49,    -1,    -1,    52,    53,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,    -1,    -1,
-      74,    10,    11,    12,    -1,    -1,    -1,    -1,    82,    83,
-      -1,    85,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    -1,    -1,    -1,    -1,    -1,    38,
-      39,    -1,    41,    42,    43,    44,    45,    46,    47,    48,
-      49,    -1,    -1,    52,    53,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    71,    -1,    -1,    -1,    10,    11,    12,    -1,
-      -1,    -1,    81,    82,    83,    -1,    85,    21,    22,    23,
-      24,    25,    26,    27,    28,    29,    30,    31,    32,    -1,
-      -1,    -1,    -1,    -1,    38,    39,    -1,    41,    42,    43,
-      44,    45,    46,    47,    48,    49,    -1,    -1,    52,    53,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,    -1,    -1,
-      74,    10,    11,    12,    -1,    -1,    -1,    -1,    82,    83,
-      -1,    85,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    -1,    -1,    -1,    -1,    -1,    38,
-      39,    -1,    41,    42,    43,    44,    45,    46,    47,    48,
-      49,    -1,    -1,    52,    53,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    71,    -1,    -1,    -1,    10,    11,    12,    -1,
-      -1,    -1,    -1,    82,    83,    -1,    85,    21,    22,    23,
-      24,    25,    26,    27,    28,    29,    30,    31,    32,    -1,
-      -1,    -1,    -1,    -1,    38,    39,    -1,    41,    42,    43,
-      44,    45,    46,    47,    48,    49,    -1,    -1,    52,    53,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,     4,     5,
-       6,    -1,    -1,    -1,    10,    11,    12,    -1,    82,    83,
-      -1,    85,    -1,    -1,    -1,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    -1,    -1,    -1,
-      -1,    -1,    38,    39,    -1,    41,    42,    43,    -1,    45,
-       4,     5,     6,    -1,    -1,    -1,    10,    11,    12,    -1,
-      -1,    -1,    -1,    -1,    -1,    -1,    -1,    21,    22,    23,
-      24,    25,    26,    27,    28,    29,    30,    31,    32,    -1,
-      76,    -1,    -1,    -1,    38,    39,    -1,    41,    42,    43,
-      -1,    45,     3,     4,     5,     6,     7,     8,     9,    10,
+      44,    -1,    46,     4,     5,     6,    -1,    -1,    -1,    10,
       11,    12,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
       21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
-      31,    32,    76,    -1,    -1,    36,    37,    38,    39,    -1,
-      41,    42,    43,    -1,    45,     4,     5,     6,    -1,    -1,
-      -1,    10,    11,    12,    -1,    -1,    -1,    -1,    -1,    -1,
-      -1,    -1,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    -1,    -1,    10,    11,    12,    38,
-      39,    -1,    41,    42,    43,    -1,    45,    21,    22,    23,
+      31,    32,    -1,    77,    -1,    -1,    -1,    38,    39,    -1,
+      41,    42,    43,    44,    -1,    46,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,     0,    -1,    -1,     3,
+       4,     5,     6,     7,     8,     9,    10,    11,    12,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    77,    21,    22,    23,
       24,    25,    26,    27,    28,    29,    30,    31,    32,    -1,
-      -1,    -1,    -1,    -1,    38,    39,    -1,    41,    42,    43,
-      44,    45,    10,    11,    12,    49,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    21,    22,    23,    24,    25,    26,    27,
-      28,    29,    30,    31,    32,    -1,    -1,    -1,    -1,    -1,
-      38,    39,    -1,    41,    42,    43,    -1,    45
+      -1,    -1,    36,    37,    38,    39,    -1,    41,    42,    43,
+      44,    -1,    46,     3,     4,     5,     6,     7,     8,     9,
+      10,    11,    12,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    21,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    -1,    -1,    -1,    36,    37,    38,    39,
+      -1,    41,    42,    43,    44,    -1,    46,    10,    11,    12,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    21,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      -1,    -1,    -1,    -1,    -1,    38,    39,    -1,    41,    42,
+      43,    44,    45,    46,    10,    11,    12,    50,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    -1,    -1,    -1,
+      -1,    -1,    38,    39,    -1,    41,    42,    43,    44,    -1,
+      46
 };
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
@@ -1261,33 +1185,33 @@
        0,     3,     4,     5,     6,     7,     8,     9,    10,    11,
       12,    21,    22,    23,    24,    25,    26,    27,    28,    29,
       30,    31,    32,    36,    37,    38,    39,    41,    42,    43,
-      45,   125,   126,   127,   128,   129,   134,   135,   136,   137,
-     138,   139,   140,   141,   142,   171,   172,   173,    37,    44,
-     139,    44,    75,    81,   174,    72,    78,     3,    33,    34,
-      35,   131,   132,   137,    78,    81,    44,   138,   140,    73,
-       0,   172,   140,    75,   144,    75,   157,   131,   130,   133,
-     138,   132,    44,    71,    73,    80,    44,    46,    47,    48,
-      49,    52,    53,    71,    82,    83,    85,    96,    97,    98,
-     100,   101,   102,   103,   104,   105,   106,   107,   108,   109,
+      44,    46,   126,   127,   128,   129,   130,   135,   136,   137,
+     138,   139,   140,   141,   142,   143,   172,   173,   174,    37,
+      45,   140,    45,    76,    82,   175,    73,    79,     3,    33,
+      34,    35,   132,   133,   138,    79,    82,    45,   139,   141,
+      74,     0,   173,   141,    76,   145,    76,   158,   132,   131,
+     134,   139,   133,    45,    72,    74,    81,    45,    47,    48,
+      49,    50,    53,    54,    72,    83,    84,    86,    97,    98,
+      99,   101,   102,   103,   104,   105,   106,   107,   108,   109,
      110,   111,   112,   113,   114,   115,   116,   117,   118,   119,
-     120,   124,   141,    81,   143,   138,   145,   146,    13,    14,
-      15,    17,    18,    19,    20,    40,    75,    76,    81,   107,
-     120,   121,   123,   125,   126,   141,   150,   151,   152,   153,
-     158,   159,   160,   163,   170,    44,   130,   133,    73,    80,
-      74,   124,   121,   149,   107,   107,   123,    52,    53,    73,
-      77,    72,    72,    78,    39,   121,    71,   107,    86,    87,
-      83,    85,    54,    55,    89,    90,    56,    57,    58,    60,
-      59,    94,    74,   145,    44,   147,   148,    76,   146,    81,
-      81,   165,    71,    71,    81,    81,   123,    71,    76,   154,
-      61,    62,    63,    70,    80,   122,    78,    81,    76,   151,
-      73,    74,   124,   149,    74,    72,    99,   123,    44,    49,
-     102,   121,   107,   107,   109,   109,   111,   111,   111,   111,
-     112,   112,   116,   117,   118,   123,    76,    73,    78,    81,
-     151,   166,   123,    81,   164,   158,   121,   121,   124,    74,
-      74,    79,   124,   148,    40,   150,   159,   167,    72,   123,
-     136,   162,   155,    74,   121,    74,    71,   162,   168,   169,
-     151,   161,    44,    72,    76,   123,    81,    72,    16,    80,
-     152,   156,   157,    72,   123,   156,   151,   149,    81
+     120,   121,   125,   142,    82,   144,   139,   146,   147,    13,
+      14,    15,    17,    18,    19,    20,    40,    76,    77,    82,
+     108,   121,   122,   124,   126,   127,   142,   151,   152,   153,
+     154,   159,   160,   161,   164,   171,    45,   131,   134,    74,
+      81,    75,   125,   122,   150,   108,   108,   124,    53,    54,
+      74,    78,    73,    73,    79,    39,   122,    72,   108,    87,
+      88,    84,    86,    55,    56,    90,    91,    57,    58,    59,
+      61,    60,    95,    75,   146,    45,   148,   149,    77,   147,
+      82,    82,   166,    72,    72,    82,    82,   124,    72,    77,
+     155,    62,    63,    64,    71,    81,   123,    79,    82,    77,
+     152,    74,    75,   125,   150,    75,    73,   100,   124,    45,
+      50,   103,   122,   108,   108,   110,   110,   112,   112,   112,
+     112,   113,   113,   117,   118,   119,   124,    77,    74,    79,
+      82,   152,   167,   124,    82,   165,   159,   122,   122,   125,
+      75,    75,    80,   125,   149,    40,   151,   160,   168,    73,
+     124,   137,   163,   156,    75,   122,    75,    72,   163,   169,
+     170,   152,   162,    45,    73,    77,   124,    82,    73,    16,
+      81,   153,   157,   158,    73,   124,   157,   152,   150,    82
 };
 
 #define yyerrok		(yyerrstatus = 0)
@@ -1361,7 +1285,7 @@
    we won't break user code: when these are the locations we know.  */
 
 #ifndef YY_LOCATION_PRINT
-# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+# if YYLTYPE_IS_TRIVIAL
 #  define YY_LOCATION_PRINT(File, Loc)			\
      fprintf (File, "%d.%d-%d.%d",			\
 	      (Loc).first_line, (Loc).first_column,	\
@@ -1475,17 +1399,20 @@
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
 #else
 static void
-yy_stack_print (bottom, top)
-    yytype_int16 *bottom;
-    yytype_int16 *top;
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
   YYFPRINTF (stderr, "\n");
 }
 
@@ -1520,11 +1447,11 @@
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
-      fprintf (stderr, "   $%d = ", yyi + 1);
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
       yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
 		       &(yyvsp[(yyi + 1) - (yynrhs)])
 		       		       , context);
-      fprintf (stderr, "\n");
+      YYFPRINTF (stderr, "\n");
     }
 }
 
@@ -1806,10 +1733,8 @@
 	break;
     }
 }
-
 
 /* Prevent warnings from -Wmissing-prototypes.  */
-
 #ifdef YYPARSE_PARAM
 #if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
@@ -1828,10 +1753,9 @@
 
 
 
-
-/*----------.
-| yyparse.  |
-`----------*/
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
 
 #ifdef YYPARSE_PARAM
 #if (defined __STDC__ || defined __C99__FUNC__ \
@@ -1855,22 +1779,46 @@
 #endif
 #endif
 {
-  /* The look-ahead symbol.  */
+/* The lookahead symbol.  */
 int yychar;
 
-/* The semantic value of the look-ahead symbol.  */
+/* The semantic value of the lookahead symbol.  */
 YYSTYPE yylval;
 
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-  int yystate;
+    /* Number of syntax errors so far.  */
+    int yynerrs;
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
   int yyn;
   int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Look-ahead token as an internal (translated) token number.  */
-  int yytoken = 0;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
 #if YYERROR_VERBOSE
   /* Buffer for error messages, and its allocated size.  */
   char yymsgbuf[128];
@@ -1878,51 +1826,28 @@
   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
 #endif
 
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  yytype_int16 yyssa[YYINITDEPTH];
-  yytype_int16 *yyss = yyssa;
-  yytype_int16 *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  YYSTYPE *yyvsp;
-
-
-
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
   /* The number of symbols on the RHS of the reduced rule.
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
   YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
+  yychar = YYEMPTY; /* Cause a token to be read.  */
 
   /* Initialize stack pointers.
      Waste one element of value and location stack
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
-
   yyssp = yyss;
   yyvsp = yyvs;
 
@@ -1952,7 +1877,6 @@
 	YYSTYPE *yyvs1 = yyvs;
 	yytype_int16 *yyss1 = yyss;
 
-
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
@@ -1960,7 +1884,6 @@
 	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
-
 		    &yystacksize);
 
 	yyss = yyss1;
@@ -1983,9 +1906,8 @@
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
 	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
 	if (yyss1 != yyssa)
 	  YYSTACK_FREE (yyss1);
@@ -1996,7 +1918,6 @@
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
 
-
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
 		  (unsigned long int) yystacksize));
 
@@ -2006,6 +1927,9 @@
 
   YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
   goto yybackup;
 
 /*-----------.
@@ -2014,16 +1938,16 @@
 yybackup:
 
   /* Do appropriate processing given the current state.  Read a
-     look-ahead token if we need one and don't already have one.  */
-
-  /* First try to decide what to do without reference to look-ahead token.  */
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
   yyn = yypact[yystate];
   if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a look-ahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -2055,20 +1979,16 @@
       goto yyreduce;
     }
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
-  /* Shift the look-ahead token.  */
+  /* Shift the lookahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
 
-  /* Discard the shifted token unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
 
   yystate = yyn;
   *++yyvsp = yylval;
@@ -2140,14 +2060,14 @@
             (yyval.interm.intermTypedNode) = context->intermediate.addSymbol(variable->getUniqueId(),
                                                      variable->getName(),
                                                      variable->getType(), (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 3:
 
     {
         (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode);
-    ;}
+    }
     break;
 
   case 4:
@@ -2164,7 +2084,7 @@
         ConstantUnion *unionArray = new ConstantUnion[1];
         unionArray->setIConst((yyvsp[(1) - (1)].lex).i);
         (yyval.interm.intermTypedNode) = context->intermediate.addConstantUnion(unionArray, TType(EbtInt, EbpUndefined, EvqConst), (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 5:
@@ -2173,7 +2093,7 @@
         ConstantUnion *unionArray = new ConstantUnion[1];
         unionArray->setFConst((yyvsp[(1) - (1)].lex).f);
         (yyval.interm.intermTypedNode) = context->intermediate.addConstantUnion(unionArray, TType(EbtFloat, EbpUndefined, EvqConst), (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 6:
@@ -2182,21 +2102,21 @@
         ConstantUnion *unionArray = new ConstantUnion[1];
         unionArray->setBConst((yyvsp[(1) - (1)].lex).b);
         (yyval.interm.intermTypedNode) = context->intermediate.addConstantUnion(unionArray, TType(EbtBool, EbpUndefined, EvqConst), (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 7:
 
     {
         (yyval.interm.intermTypedNode) = (yyvsp[(2) - (3)].interm.intermTypedNode);
-    ;}
+    }
     break;
 
   case 8:
 
     {
         (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode);
-    ;}
+    }
     break;
 
   case 9:
@@ -2273,14 +2193,14 @@
             (yyval.interm.intermTypedNode)->setType(TType((yyvsp[(1) - (4)].interm.intermTypedNode)->getBasicType(), (yyvsp[(1) - (4)].interm.intermTypedNode)->getPrecision(), EvqTemporary));
         else
             (yyval.interm.intermTypedNode)->setType((yyvsp[(1) - (4)].interm.intermTypedNode)->getType());
-    ;}
+    }
     break;
 
   case 10:
 
     {
         (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode);
-    ;}
+    }
     break;
 
   case 11:
@@ -2393,7 +2313,7 @@
             (yyval.interm.intermTypedNode) = (yyvsp[(1) - (3)].interm.intermTypedNode);
         }
         // don't delete $3.string, it's from the pool
-    ;}
+    }
     break;
 
   case 12:
@@ -2407,7 +2327,7 @@
             context->recover();
             (yyval.interm.intermTypedNode) = (yyvsp[(1) - (2)].interm.intermTypedNode);
         }
-    ;}
+    }
     break;
 
   case 13:
@@ -2421,7 +2341,7 @@
             context->recover();
             (yyval.interm.intermTypedNode) = (yyvsp[(1) - (2)].interm.intermTypedNode);
         }
-    ;}
+    }
     break;
 
   case 14:
@@ -2430,7 +2350,7 @@
         if (context->integerErrorCheck((yyvsp[(1) - (1)].interm.intermTypedNode), "[]"))
             context->recover();
         (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode);
-    ;}
+    }
     break;
 
   case 15:
@@ -2530,14 +2450,14 @@
             }
         }
         delete fnCall;
-    ;}
+    }
     break;
 
   case 16:
 
     {
         (yyval.interm) = (yyvsp[(1) - (1)].interm);
-    ;}
+    }
     break;
 
   case 17:
@@ -2546,7 +2466,7 @@
         context->error((yyvsp[(3) - (3)].interm).line, "methods are not supported", "", "");
         context->recover();
         (yyval.interm) = (yyvsp[(3) - (3)].interm);
-    ;}
+    }
     break;
 
   case 18:
@@ -2554,7 +2474,7 @@
     {
         (yyval.interm) = (yyvsp[(1) - (2)].interm);
         (yyval.interm).line = (yyvsp[(2) - (2)].lex).line;
-    ;}
+    }
     break;
 
   case 19:
@@ -2562,7 +2482,7 @@
     {
         (yyval.interm) = (yyvsp[(1) - (2)].interm);
         (yyval.interm).line = (yyvsp[(2) - (2)].lex).line;
-    ;}
+    }
     break;
 
   case 20:
@@ -2570,7 +2490,7 @@
     {
         (yyval.interm).function = (yyvsp[(1) - (2)].interm.function);
         (yyval.interm).intermNode = 0;
-    ;}
+    }
     break;
 
   case 21:
@@ -2578,7 +2498,7 @@
     {
         (yyval.interm).function = (yyvsp[(1) - (1)].interm.function);
         (yyval.interm).intermNode = 0;
-    ;}
+    }
     break;
 
   case 22:
@@ -2588,7 +2508,7 @@
         (yyvsp[(1) - (2)].interm.function)->addParameter(param);
         (yyval.interm).function = (yyvsp[(1) - (2)].interm.function);
         (yyval.interm).intermNode = (yyvsp[(2) - (2)].interm.intermTypedNode);
-    ;}
+    }
     break;
 
   case 23:
@@ -2598,14 +2518,14 @@
         (yyvsp[(1) - (3)].interm).function->addParameter(param);
         (yyval.interm).function = (yyvsp[(1) - (3)].interm).function;
         (yyval.interm).intermNode = context->intermediate.growAggregate((yyvsp[(1) - (3)].interm).intermNode, (yyvsp[(3) - (3)].interm.intermTypedNode), (yyvsp[(2) - (3)].lex).line);
-    ;}
+    }
     break;
 
   case 24:
 
     {
         (yyval.interm.function) = (yyvsp[(1) - (2)].interm.function);
-    ;}
+    }
     break;
 
   case 25:
@@ -2664,7 +2584,7 @@
         TType type((yyvsp[(1) - (1)].interm.type));
         TFunction *function = new TFunction(&tempString, type, op);
         (yyval.interm.function) = function;
-    ;}
+    }
     break;
 
   case 26:
@@ -2675,7 +2595,7 @@
         TType type(EbtVoid, EbpUndefined);
         TFunction *function = new TFunction((yyvsp[(1) - (1)].lex).string, type);
         (yyval.interm.function) = function;
-    ;}
+    }
     break;
 
   case 27:
@@ -2686,14 +2606,14 @@
         TType type(EbtVoid, EbpUndefined);
         TFunction *function = new TFunction((yyvsp[(1) - (1)].lex).string, type);
         (yyval.interm.function) = function;
-    ;}
+    }
     break;
 
   case 28:
 
     {
         (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode);
-    ;}
+    }
     break;
 
   case 29:
@@ -2707,7 +2627,7 @@
             context->recover();
             (yyval.interm.intermTypedNode) = (yyvsp[(2) - (2)].interm.intermTypedNode);
         }
-    ;}
+    }
     break;
 
   case 30:
@@ -2721,7 +2641,7 @@
             context->recover();
             (yyval.interm.intermTypedNode) = (yyvsp[(2) - (2)].interm.intermTypedNode);
         }
-    ;}
+    }
     break;
 
   case 31:
@@ -2742,27 +2662,27 @@
             }
         } else
             (yyval.interm.intermTypedNode) = (yyvsp[(2) - (2)].interm.intermTypedNode);
-    ;}
+    }
     break;
 
   case 32:
 
-    { (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpNull; ;}
+    { (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpNull; }
     break;
 
   case 33:
 
-    { (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpNegative; ;}
+    { (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpNegative; }
     break;
 
   case 34:
 
-    { (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpLogicalNot; ;}
+    { (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpLogicalNot; }
     break;
 
   case 35:
 
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
   case 36:
@@ -2775,7 +2695,7 @@
             context->recover();
             (yyval.interm.intermTypedNode) = (yyvsp[(1) - (3)].interm.intermTypedNode);
         }
-    ;}
+    }
     break;
 
   case 37:
@@ -2788,12 +2708,12 @@
             context->recover();
             (yyval.interm.intermTypedNode) = (yyvsp[(1) - (3)].interm.intermTypedNode);
         }
-    ;}
+    }
     break;
 
   case 38:
 
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
   case 39:
@@ -2805,7 +2725,7 @@
             context->recover();
             (yyval.interm.intermTypedNode) = (yyvsp[(1) - (3)].interm.intermTypedNode);
         }
-    ;}
+    }
     break;
 
   case 40:
@@ -2817,17 +2737,17 @@
             context->recover();
             (yyval.interm.intermTypedNode) = (yyvsp[(1) - (3)].interm.intermTypedNode);
         }
-    ;}
+    }
     break;
 
   case 41:
 
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
   case 42:
 
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
   case 43:
@@ -2841,7 +2761,7 @@
             unionArray->setBConst(false);
             (yyval.interm.intermTypedNode) = context->intermediate.addConstantUnion(unionArray, TType(EbtBool, EbpUndefined, EvqConst), (yyvsp[(2) - (3)].lex).line);
         }
-    ;}
+    }
     break;
 
   case 44:
@@ -2855,7 +2775,7 @@
             unionArray->setBConst(false);
             (yyval.interm.intermTypedNode) = context->intermediate.addConstantUnion(unionArray, TType(EbtBool, EbpUndefined, EvqConst), (yyvsp[(2) - (3)].lex).line);
         }
-    ;}
+    }
     break;
 
   case 45:
@@ -2869,7 +2789,7 @@
             unionArray->setBConst(false);
             (yyval.interm.intermTypedNode) = context->intermediate.addConstantUnion(unionArray, TType(EbtBool, EbpUndefined, EvqConst), (yyvsp[(2) - (3)].lex).line);
         }
-    ;}
+    }
     break;
 
   case 46:
@@ -2883,12 +2803,12 @@
             unionArray->setBConst(false);
             (yyval.interm.intermTypedNode) = context->intermediate.addConstantUnion(unionArray, TType(EbtBool, EbpUndefined, EvqConst), (yyvsp[(2) - (3)].lex).line);
         }
-    ;}
+    }
     break;
 
   case 47:
 
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
   case 48:
@@ -2902,7 +2822,7 @@
             unionArray->setBConst(false);
             (yyval.interm.intermTypedNode) = context->intermediate.addConstantUnion(unionArray, TType(EbtBool, EbpUndefined, EvqConst), (yyvsp[(2) - (3)].lex).line);
         }
-    ;}
+    }
     break;
 
   case 49:
@@ -2916,27 +2836,27 @@
             unionArray->setBConst(false);
             (yyval.interm.intermTypedNode) = context->intermediate.addConstantUnion(unionArray, TType(EbtBool, EbpUndefined, EvqConst), (yyvsp[(2) - (3)].lex).line);
         }
-    ;}
+    }
     break;
 
   case 50:
 
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
   case 51:
 
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
   case 52:
 
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
   case 53:
 
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
   case 54:
@@ -2950,12 +2870,12 @@
             unionArray->setBConst(false);
             (yyval.interm.intermTypedNode) = context->intermediate.addConstantUnion(unionArray, TType(EbtBool, EbpUndefined, EvqConst), (yyvsp[(2) - (3)].lex).line);
         }
-    ;}
+    }
     break;
 
   case 55:
 
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
   case 56:
@@ -2969,12 +2889,12 @@
             unionArray->setBConst(false);
             (yyval.interm.intermTypedNode) = context->intermediate.addConstantUnion(unionArray, TType(EbtBool, EbpUndefined, EvqConst), (yyvsp[(2) - (3)].lex).line);
         }
-    ;}
+    }
     break;
 
   case 57:
 
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
   case 58:
@@ -2988,12 +2908,12 @@
             unionArray->setBConst(false);
             (yyval.interm.intermTypedNode) = context->intermediate.addConstantUnion(unionArray, TType(EbtBool, EbpUndefined, EvqConst), (yyvsp[(2) - (3)].lex).line);
         }
-    ;}
+    }
     break;
 
   case 59:
 
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
   case 60:
@@ -3011,12 +2931,12 @@
             context->recover();
             (yyval.interm.intermTypedNode) = (yyvsp[(5) - (5)].interm.intermTypedNode);
         }
-    ;}
+    }
     break;
 
   case 61:
 
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
   case 62:
@@ -3030,39 +2950,39 @@
             context->recover();
             (yyval.interm.intermTypedNode) = (yyvsp[(1) - (3)].interm.intermTypedNode);
         }
-    ;}
+    }
     break;
 
   case 63:
 
-    {                                    (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpAssign; ;}
+    {                                    (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpAssign; }
     break;
 
   case 64:
 
-    { FRAG_VERT_ONLY("*=", (yyvsp[(1) - (1)].lex).line);     (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpMulAssign; ;}
+    { FRAG_VERT_ONLY("*=", (yyvsp[(1) - (1)].lex).line);     (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpMulAssign; }
     break;
 
   case 65:
 
-    { FRAG_VERT_ONLY("/=", (yyvsp[(1) - (1)].lex).line);     (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpDivAssign; ;}
+    { FRAG_VERT_ONLY("/=", (yyvsp[(1) - (1)].lex).line);     (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpDivAssign; }
     break;
 
   case 66:
 
-    {                                    (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpAddAssign; ;}
+    {                                    (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpAddAssign; }
     break;
 
   case 67:
 
-    {                                    (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpSubAssign; ;}
+    {                                    (yyval.interm).line = (yyvsp[(1) - (1)].lex).line; (yyval.interm).op = EOpSubAssign; }
     break;
 
   case 68:
 
     {
         (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode);
-    ;}
+    }
     break;
 
   case 69:
@@ -3074,7 +2994,7 @@
             context->recover();
             (yyval.interm.intermTypedNode) = (yyvsp[(3) - (3)].interm.intermTypedNode);
         }
-    ;}
+    }
     break;
 
   case 70:
@@ -3083,7 +3003,7 @@
         if (context->constErrorCheck((yyvsp[(1) - (1)].interm.intermTypedNode)))
             context->recover();
         (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode);
-    ;}
+    }
     break;
 
   case 71:
@@ -3112,7 +3032,7 @@
         
         prototype->setOp(EOpPrototype);
         (yyval.interm.intermNode) = prototype;
-    ;}
+    }
     break;
 
   case 72:
@@ -3121,7 +3041,7 @@
         if ((yyvsp[(1) - (2)].interm).intermAggregate)
             (yyvsp[(1) - (2)].interm).intermAggregate->setOp(EOpDeclaration);
         (yyval.interm.intermNode) = (yyvsp[(1) - (2)].interm).intermAggregate;
-    ;}
+    }
     break;
 
   case 73:
@@ -3129,7 +3049,7 @@
     {
         context->symbolTable.setDefaultPrecision( (yyvsp[(3) - (4)].interm.type).type, (yyvsp[(2) - (4)].interm.precision) );
         (yyval.interm.intermNode) = 0;
-    ;}
+    }
     break;
 
   case 74:
@@ -3166,21 +3086,21 @@
         (yyval.interm).line = (yyvsp[(2) - (2)].lex).line;
 
         context->symbolTable.insert(*(yyval.interm).function);
-    ;}
+    }
     break;
 
   case 75:
 
     {
         (yyval.interm.function) = (yyvsp[(1) - (1)].interm.function);
-    ;}
+    }
     break;
 
   case 76:
 
     {
         (yyval.interm.function) = (yyvsp[(1) - (1)].interm.function);
-    ;}
+    }
     break;
 
   case 77:
@@ -3192,7 +3112,7 @@
             (yyvsp[(1) - (2)].interm.function)->addParameter((yyvsp[(2) - (2)].interm).param);
         else
             delete (yyvsp[(2) - (2)].interm).param.type;
-    ;}
+    }
     break;
 
   case 78:
@@ -3214,7 +3134,7 @@
             (yyval.interm.function) = (yyvsp[(1) - (3)].interm.function);
             (yyvsp[(1) - (3)].interm.function)->addParameter((yyvsp[(3) - (3)].interm).param);
         }
-    ;}
+    }
     break;
 
   case 79:
@@ -3233,7 +3153,7 @@
         TType type((yyvsp[(1) - (3)].interm.type));
         function = new TFunction((yyvsp[(2) - (3)].lex).string, type);
         (yyval.interm.function) = function;
-    ;}
+    }
     break;
 
   case 80:
@@ -3248,7 +3168,7 @@
         TParameter param = {(yyvsp[(2) - (2)].lex).string, new TType((yyvsp[(1) - (2)].interm.type))};
         (yyval.interm).line = (yyvsp[(2) - (2)].lex).line;
         (yyval.interm).param = param;
-    ;}
+    }
     break;
 
   case 81:
@@ -3270,7 +3190,7 @@
         TParameter param = { (yyvsp[(2) - (5)].lex).string, type };
         (yyval.interm).line = (yyvsp[(2) - (5)].lex).line;
         (yyval.interm).param = param;
-    ;}
+    }
     break;
 
   case 82:
@@ -3279,7 +3199,7 @@
         (yyval.interm) = (yyvsp[(3) - (3)].interm);
         if (context->paramErrorCheck((yyvsp[(3) - (3)].interm).line, (yyvsp[(1) - (3)].interm.type).qualifier, (yyvsp[(2) - (3)].interm.qualifier), (yyval.interm).param.type))
             context->recover();
-    ;}
+    }
     break;
 
   case 83:
@@ -3290,7 +3210,7 @@
             context->recover();
         if (context->paramErrorCheck((yyvsp[(2) - (2)].interm).line, EvqTemporary, (yyvsp[(1) - (2)].interm.qualifier), (yyval.interm).param.type))
             context->recover();
-    ;}
+    }
     break;
 
   case 84:
@@ -3299,7 +3219,7 @@
         (yyval.interm) = (yyvsp[(3) - (3)].interm);
         if (context->paramErrorCheck((yyvsp[(3) - (3)].interm).line, (yyvsp[(1) - (3)].interm.type).qualifier, (yyvsp[(2) - (3)].interm.qualifier), (yyval.interm).param.type))
             context->recover();
-    ;}
+    }
     break;
 
   case 85:
@@ -3310,35 +3230,35 @@
             context->recover();
         if (context->paramErrorCheck((yyvsp[(2) - (2)].interm).line, EvqTemporary, (yyvsp[(1) - (2)].interm.qualifier), (yyval.interm).param.type))
             context->recover();
-    ;}
+    }
     break;
 
   case 86:
 
     {
         (yyval.interm.qualifier) = EvqIn;
-    ;}
+    }
     break;
 
   case 87:
 
     {
         (yyval.interm.qualifier) = EvqIn;
-    ;}
+    }
     break;
 
   case 88:
 
     {
         (yyval.interm.qualifier) = EvqOut;
-    ;}
+    }
     break;
 
   case 89:
 
     {
         (yyval.interm.qualifier) = EvqInOut;
-    ;}
+    }
     break;
 
   case 90:
@@ -3346,14 +3266,14 @@
     {
         TParameter param = { 0, new TType((yyvsp[(1) - (1)].interm.type)) };
         (yyval.interm).param = param;
-    ;}
+    }
     break;
 
   case 91:
 
     {
         (yyval.interm) = (yyvsp[(1) - (1)].interm);
-    ;}
+    }
     break;
 
   case 92:
@@ -3373,7 +3293,7 @@
             context->recover();
         if (symbol && variable)
             symbol->setId(variable->getUniqueId());
-    ;}
+    }
     break;
 
   case 93:
@@ -3395,7 +3315,7 @@
             if (context->arrayErrorCheck((yyvsp[(4) - (5)].lex).line, *(yyvsp[(3) - (5)].lex).string, (yyvsp[(1) - (5)].interm).type, variable))
                 context->recover();
         }
-    ;}
+    }
     break;
 
   case 94:
@@ -3423,7 +3343,7 @@
             type.setArraySize(size);
             (yyval.interm).intermAggregate = context->intermediate.growAggregate((yyvsp[(1) - (6)].interm).intermNode, context->intermediate.addSymbol(variable ? variable->getUniqueId() : 0, *(yyvsp[(3) - (6)].lex).string, type, (yyvsp[(3) - (6)].lex).line), (yyvsp[(3) - (6)].lex).line);
         }
-    ;}
+    }
     break;
 
   case 95:
@@ -3447,7 +3367,7 @@
             context->recover();
             (yyval.interm).intermAggregate = 0;
         }
-    ;}
+    }
     break;
 
   case 96:
@@ -3455,7 +3375,7 @@
     {
         (yyval.interm).type = (yyvsp[(1) - (1)].interm.type);
         (yyval.interm).intermAggregate = context->intermediate.makeAggregate(context->intermediate.addSymbol(0, "", TType((yyvsp[(1) - (1)].interm.type)), (yyvsp[(1) - (1)].interm.type).line), (yyvsp[(1) - (1)].interm.type).line);
-    ;}
+    }
     break;
 
   case 97:
@@ -3477,7 +3397,7 @@
             context->recover();
         if (variable && symbol)
             symbol->setId(variable->getUniqueId());
-    ;}
+    }
     break;
 
   case 98:
@@ -3489,7 +3409,7 @@
         TIntermSymbol* symbol = context->intermediate.addSymbol(0, *(yyvsp[(2) - (4)].lex).string, TType((yyvsp[(1) - (4)].interm.type)), (yyvsp[(2) - (4)].lex).line);
         (yyval.interm).intermAggregate = context->intermediate.makeAggregate(symbol, (yyvsp[(2) - (4)].lex).line);
         (yyval.interm).type = (yyvsp[(1) - (4)].interm.type);
-    ;}
+    }
     break;
 
   case 99:
@@ -3525,7 +3445,7 @@
             if (variable && symbol)
                 symbol->setId(variable->getUniqueId());
         }
-    ;}
+    }
     break;
 
   case 100:
@@ -3549,7 +3469,7 @@
             context->recover();
             (yyval.interm).intermAggregate = 0;
         }
-    ;}
+    }
     break;
 
   case 101:
@@ -3558,7 +3478,7 @@
         VERTEX_ONLY("invariant declaration", (yyvsp[(1) - (2)].lex).line);
         (yyval.interm).qualifier = EvqInvariantVaryingOut;
         (yyval.interm).intermAggregate = 0;
-    ;}
+    }
     break;
 
   case 102:
@@ -3571,7 +3491,7 @@
             context->recover();
             (yyvsp[(1) - (1)].interm.type).setArray(false);
         }
-    ;}
+    }
     break;
 
   case 103:
@@ -3595,14 +3515,14 @@
         }
         (yyval.interm.type) = (yyvsp[(2) - (2)].interm.type);
         (yyval.interm.type).qualifier = (yyvsp[(1) - (2)].interm.type).qualifier;
-    ;}
+    }
     break;
 
   case 104:
 
     {
         (yyval.interm.type).setBasic(EbtVoid, EvqConst, (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 105:
@@ -3612,7 +3532,7 @@
         if (context->globalErrorCheck((yyvsp[(1) - (1)].lex).line, context->symbolTable.atGlobalLevel(), "attribute"))
             context->recover();
         (yyval.interm.type).setBasic(EbtVoid, EvqAttribute, (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 106:
@@ -3624,7 +3544,7 @@
             (yyval.interm.type).setBasic(EbtVoid, EvqVaryingOut, (yyvsp[(1) - (1)].lex).line);
         else
             (yyval.interm.type).setBasic(EbtVoid, EvqVaryingIn, (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 107:
@@ -3636,7 +3556,7 @@
             (yyval.interm.type).setBasic(EbtVoid, EvqInvariantVaryingOut, (yyvsp[(1) - (2)].lex).line);
         else
             (yyval.interm.type).setBasic(EbtVoid, EvqInvariantVaryingIn, (yyvsp[(1) - (2)].lex).line);
-    ;}
+    }
     break;
 
   case 108:
@@ -3645,7 +3565,7 @@
         if (context->globalErrorCheck((yyvsp[(1) - (1)].lex).line, context->symbolTable.atGlobalLevel(), "uniform"))
             context->recover();
         (yyval.interm.type).setBasic(EbtVoid, EvqUniform, (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 109:
@@ -3659,7 +3579,7 @@
                 context->recover();
             }
         }
-    ;}
+    }
     break;
 
   case 110:
@@ -3667,35 +3587,35 @@
     {
         (yyval.interm.type) = (yyvsp[(2) - (2)].interm.type);
         (yyval.interm.type).precision = (yyvsp[(1) - (2)].interm.precision);
-    ;}
+    }
     break;
 
   case 111:
 
     {
         (yyval.interm.precision) = EbpHigh;
-    ;}
+    }
     break;
 
   case 112:
 
     {
         (yyval.interm.precision) = EbpMedium;
-    ;}
+    }
     break;
 
   case 113:
 
     {
         (yyval.interm.precision) = EbpLow;
-    ;}
+    }
     break;
 
   case 114:
 
     {
         (yyval.interm.type) = (yyvsp[(1) - (1)].interm.type);
-    ;}
+    }
     break;
 
   case 115:
@@ -3711,7 +3631,7 @@
                 context->recover();
             (yyval.interm.type).setArray(true, size);
         }
-    ;}
+    }
     break;
 
   case 116:
@@ -3719,7 +3639,7 @@
     {
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtVoid, qual, (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 117:
@@ -3727,7 +3647,7 @@
     {
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtFloat, qual, (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 118:
@@ -3735,7 +3655,7 @@
     {
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtInt, qual, (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 119:
@@ -3743,7 +3663,7 @@
     {
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtBool, qual, (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 120:
@@ -3752,7 +3672,7 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtFloat, qual, (yyvsp[(1) - (1)].lex).line);
         (yyval.interm.type).setAggregate(2);
-    ;}
+    }
     break;
 
   case 121:
@@ -3761,7 +3681,7 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtFloat, qual, (yyvsp[(1) - (1)].lex).line);
         (yyval.interm.type).setAggregate(3);
-    ;}
+    }
     break;
 
   case 122:
@@ -3770,7 +3690,7 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtFloat, qual, (yyvsp[(1) - (1)].lex).line);
         (yyval.interm.type).setAggregate(4);
-    ;}
+    }
     break;
 
   case 123:
@@ -3779,7 +3699,7 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtBool, qual, (yyvsp[(1) - (1)].lex).line);
         (yyval.interm.type).setAggregate(2);
-    ;}
+    }
     break;
 
   case 124:
@@ -3788,7 +3708,7 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtBool, qual, (yyvsp[(1) - (1)].lex).line);
         (yyval.interm.type).setAggregate(3);
-    ;}
+    }
     break;
 
   case 125:
@@ -3797,7 +3717,7 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtBool, qual, (yyvsp[(1) - (1)].lex).line);
         (yyval.interm.type).setAggregate(4);
-    ;}
+    }
     break;
 
   case 126:
@@ -3806,7 +3726,7 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtInt, qual, (yyvsp[(1) - (1)].lex).line);
         (yyval.interm.type).setAggregate(2);
-    ;}
+    }
     break;
 
   case 127:
@@ -3815,7 +3735,7 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtInt, qual, (yyvsp[(1) - (1)].lex).line);
         (yyval.interm.type).setAggregate(3);
-    ;}
+    }
     break;
 
   case 128:
@@ -3824,7 +3744,7 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtInt, qual, (yyvsp[(1) - (1)].lex).line);
         (yyval.interm.type).setAggregate(4);
-    ;}
+    }
     break;
 
   case 129:
@@ -3834,7 +3754,7 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtFloat, qual, (yyvsp[(1) - (1)].lex).line);
         (yyval.interm.type).setAggregate(2, true);
-    ;}
+    }
     break;
 
   case 130:
@@ -3844,7 +3764,7 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtFloat, qual, (yyvsp[(1) - (1)].lex).line);
         (yyval.interm.type).setAggregate(3, true);
-    ;}
+    }
     break;
 
   case 131:
@@ -3854,7 +3774,7 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtFloat, qual, (yyvsp[(1) - (1)].lex).line);
         (yyval.interm.type).setAggregate(4, true);
-    ;}
+    }
     break;
 
   case 132:
@@ -3863,7 +3783,7 @@
         FRAG_VERT_ONLY("sampler2D", (yyvsp[(1) - (1)].lex).line);
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtSampler2D, qual, (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 133:
@@ -3872,7 +3792,7 @@
         FRAG_VERT_ONLY("samplerCube", (yyvsp[(1) - (1)].lex).line);
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtSamplerCube, qual, (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 134:
@@ -3885,19 +3805,32 @@
         FRAG_VERT_ONLY("samplerExternalOES", (yyvsp[(1) - (1)].lex).line);
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtSamplerExternalOES, qual, (yyvsp[(1) - (1)].lex).line);
-    ;}
+    }
     break;
 
   case 135:
 
     {
+        if (!context->supportsExtension("GL_ARB_texture_rectangle")) {
+            context->error((yyvsp[(1) - (1)].lex).line, "unsupported type", "sampler2DRect", "");
+            context->recover();
+        }
+        FRAG_VERT_ONLY("sampler2DRect", (yyvsp[(1) - (1)].lex).line);
+        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
+        (yyval.interm.type).setBasic(EbtSampler2DRect, qual, (yyvsp[(1) - (1)].lex).line);
+    }
+    break;
+
+  case 136:
+
+    {
         FRAG_VERT_ONLY("struct", (yyvsp[(1) - (1)].interm.type).line);
         (yyval.interm.type) = (yyvsp[(1) - (1)].interm.type);
         (yyval.interm.type).qualifier = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
-    ;}
+    }
     break;
 
-  case 136:
+  case 137:
 
     {
         //
@@ -3908,15 +3841,15 @@
         TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
         (yyval.interm.type).setBasic(EbtStruct, qual, (yyvsp[(1) - (1)].lex).line);
         (yyval.interm.type).userDef = &structure;
-    ;}
+    }
     break;
 
-  case 137:
-
-    { if (context->enterStructDeclaration((yyvsp[(2) - (3)].lex).line, *(yyvsp[(2) - (3)].lex).string)) context->recover(); ;}
+  case 138:
+
+    { if (context->enterStructDeclaration((yyvsp[(2) - (3)].lex).line, *(yyvsp[(2) - (3)].lex).string)) context->recover(); }
     break;
 
-  case 138:
+  case 139:
 
     {
         if (context->reservedErrorCheck((yyvsp[(2) - (6)].lex).line, *(yyvsp[(2) - (6)].lex).string))
@@ -3931,32 +3864,32 @@
         (yyval.interm.type).setBasic(EbtStruct, EvqTemporary, (yyvsp[(1) - (6)].lex).line);
         (yyval.interm.type).userDef = structure;
         context->exitStructDeclaration();
-    ;}
+    }
     break;
 
-  case 139:
-
-    { if (context->enterStructDeclaration((yyvsp[(2) - (2)].lex).line, *(yyvsp[(2) - (2)].lex).string)) context->recover(); ;}
+  case 140:
+
+    { if (context->enterStructDeclaration((yyvsp[(2) - (2)].lex).line, *(yyvsp[(2) - (2)].lex).string)) context->recover(); }
     break;
 
-  case 140:
+  case 141:
 
     {
         TType* structure = new TType((yyvsp[(4) - (5)].interm.typeList), TString(""));
         (yyval.interm.type).setBasic(EbtStruct, EvqTemporary, (yyvsp[(1) - (5)].lex).line);
         (yyval.interm.type).userDef = structure;
         context->exitStructDeclaration();
-    ;}
+    }
     break;
 
-  case 141:
+  case 142:
 
     {
         (yyval.interm.typeList) = (yyvsp[(1) - (1)].interm.typeList);
-    ;}
+    }
     break;
 
-  case 142:
+  case 143:
 
     {
         (yyval.interm.typeList) = (yyvsp[(1) - (2)].interm.typeList);
@@ -3969,10 +3902,10 @@
             }
             (yyval.interm.typeList)->push_back((*(yyvsp[(2) - (2)].interm.typeList))[i]);
         }
-    ;}
+    }
     break;
 
-  case 143:
+  case 144:
 
     {
         (yyval.interm.typeList) = (yyvsp[(2) - (3)].interm.typeList);
@@ -4006,25 +3939,25 @@
                 context->recover();
             }
         }
-    ;}
+    }
     break;
 
-  case 144:
+  case 145:
 
     {
         (yyval.interm.typeList) = NewPoolTTypeList();
         (yyval.interm.typeList)->push_back((yyvsp[(1) - (1)].interm.typeLine));
-    ;}
+    }
     break;
 
-  case 145:
+  case 146:
 
     {
         (yyval.interm.typeList)->push_back((yyvsp[(3) - (3)].interm.typeLine));
-    ;}
+    }
     break;
 
-  case 146:
+  case 147:
 
     {
         if (context->reservedErrorCheck((yyvsp[(1) - (1)].lex).line, *(yyvsp[(1) - (1)].lex).string))
@@ -4033,10 +3966,10 @@
         (yyval.interm.typeLine).type = new TType(EbtVoid, EbpUndefined);
         (yyval.interm.typeLine).line = (yyvsp[(1) - (1)].lex).line;
         (yyval.interm.typeLine).type->setFieldName(*(yyvsp[(1) - (1)].lex).string);
-    ;}
+    }
     break;
 
-  case 147:
+  case 148:
 
     {
         if (context->reservedErrorCheck((yyvsp[(1) - (4)].lex).line, *(yyvsp[(1) - (4)].lex).string))
@@ -4050,70 +3983,70 @@
         if (context->arraySizeErrorCheck((yyvsp[(2) - (4)].lex).line, (yyvsp[(3) - (4)].interm.intermTypedNode), size))
             context->recover();
         (yyval.interm.typeLine).type->setArraySize(size);
-    ;}
+    }
     break;
 
-  case 148:
-
-    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); ;}
+  case 149:
+
+    { (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode); }
     break;
 
-  case 149:
-
-    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); ;}
+  case 150:
+
+    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); }
     break;
 
-  case 150:
-
-    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermAggregate); ;}
+  case 151:
+
+    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermAggregate); }
     break;
 
-  case 151:
-
-    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); ;}
+  case 152:
+
+    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); }
     break;
 
-  case 152:
-
-    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); ;}
+  case 153:
+
+    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); }
     break;
 
-  case 153:
-
-    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); ;}
+  case 154:
+
+    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); }
     break;
 
-  case 154:
-
-    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); ;}
+  case 155:
+
+    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); }
     break;
 
-  case 155:
-
-    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); ;}
+  case 156:
+
+    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); }
     break;
 
-  case 156:
-
-    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); ;}
+  case 157:
+
+    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); }
     break;
 
-  case 157:
-
-    { (yyval.interm.intermAggregate) = 0; ;}
+  case 158:
+
+    { (yyval.interm.intermAggregate) = 0; }
     break;
 
-  case 158:
-
-    { context->symbolTable.push(); ;}
+  case 159:
+
+    { context->symbolTable.push(); }
     break;
 
-  case 159:
-
-    { context->symbolTable.pop(); ;}
+  case 160:
+
+    { context->symbolTable.pop(); }
     break;
 
-  case 160:
+  case 161:
 
     {
         if ((yyvsp[(3) - (5)].interm.intermAggregate) != 0) {
@@ -4121,27 +4054,27 @@
             (yyvsp[(3) - (5)].interm.intermAggregate)->setEndLine((yyvsp[(5) - (5)].lex).line);
         }
         (yyval.interm.intermAggregate) = (yyvsp[(3) - (5)].interm.intermAggregate);
-    ;}
+    }
     break;
 
-  case 161:
-
-    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); ;}
+  case 162:
+
+    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); }
     break;
 
-  case 162:
-
-    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); ;}
+  case 163:
+
+    { (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode); }
     break;
 
-  case 163:
+  case 164:
 
     {
         (yyval.interm.intermNode) = 0;
-    ;}
+    }
     break;
 
-  case 164:
+  case 165:
 
     {
         if ((yyvsp[(2) - (3)].interm.intermAggregate)) {
@@ -4149,68 +4082,68 @@
             (yyvsp[(2) - (3)].interm.intermAggregate)->setEndLine((yyvsp[(3) - (3)].lex).line);
         }
         (yyval.interm.intermNode) = (yyvsp[(2) - (3)].interm.intermAggregate);
-    ;}
+    }
     break;
 
-  case 165:
+  case 166:
 
     {
         (yyval.interm.intermAggregate) = context->intermediate.makeAggregate((yyvsp[(1) - (1)].interm.intermNode), 0);
-    ;}
+    }
     break;
 
-  case 166:
+  case 167:
 
     {
         (yyval.interm.intermAggregate) = context->intermediate.growAggregate((yyvsp[(1) - (2)].interm.intermAggregate), (yyvsp[(2) - (2)].interm.intermNode), 0);
-    ;}
+    }
     break;
 
-  case 167:
-
-    { (yyval.interm.intermNode) = 0; ;}
+  case 168:
+
+    { (yyval.interm.intermNode) = 0; }
     break;
 
-  case 168:
-
-    { (yyval.interm.intermNode) = static_cast<TIntermNode*>((yyvsp[(1) - (2)].interm.intermTypedNode)); ;}
+  case 169:
+
+    { (yyval.interm.intermNode) = static_cast<TIntermNode*>((yyvsp[(1) - (2)].interm.intermTypedNode)); }
     break;
 
-  case 169:
+  case 170:
 
     {
         if (context->boolErrorCheck((yyvsp[(1) - (5)].lex).line, (yyvsp[(3) - (5)].interm.intermTypedNode)))
             context->recover();
         (yyval.interm.intermNode) = context->intermediate.addSelection((yyvsp[(3) - (5)].interm.intermTypedNode), (yyvsp[(5) - (5)].interm.nodePair), (yyvsp[(1) - (5)].lex).line);
-    ;}
+    }
     break;
 
-  case 170:
+  case 171:
 
     {
         (yyval.interm.nodePair).node1 = (yyvsp[(1) - (3)].interm.intermNode);
         (yyval.interm.nodePair).node2 = (yyvsp[(3) - (3)].interm.intermNode);
-    ;}
+    }
     break;
 
-  case 171:
+  case 172:
 
     {
         (yyval.interm.nodePair).node1 = (yyvsp[(1) - (1)].interm.intermNode);
         (yyval.interm.nodePair).node2 = 0;
-    ;}
+    }
     break;
 
-  case 172:
+  case 173:
 
     {
         (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode);
         if (context->boolErrorCheck((yyvsp[(1) - (1)].interm.intermTypedNode)->getLine(), (yyvsp[(1) - (1)].interm.intermTypedNode)))
             context->recover();
-    ;}
+    }
     break;
 
-  case 173:
+  case 174:
 
     {
         TIntermNode* intermNode;
@@ -4225,29 +4158,29 @@
             context->recover();
             (yyval.interm.intermTypedNode) = 0;
         }
-    ;}
+    }
     break;
 
-  case 174:
-
-    { context->symbolTable.push(); ++context->loopNestingLevel; ;}
+  case 175:
+
+    { context->symbolTable.push(); ++context->loopNestingLevel; }
     break;
 
-  case 175:
+  case 176:
 
     {
         context->symbolTable.pop();
         (yyval.interm.intermNode) = context->intermediate.addLoop(ELoopWhile, 0, (yyvsp[(4) - (6)].interm.intermTypedNode), 0, (yyvsp[(6) - (6)].interm.intermNode), (yyvsp[(1) - (6)].lex).line);
         --context->loopNestingLevel;
-    ;}
+    }
     break;
 
-  case 176:
-
-    { ++context->loopNestingLevel; ;}
+  case 177:
+
+    { ++context->loopNestingLevel; }
     break;
 
-  case 177:
+  case 178:
 
     {
         if (context->boolErrorCheck((yyvsp[(8) - (8)].lex).line, (yyvsp[(6) - (8)].interm.intermTypedNode)))
@@ -4255,68 +4188,68 @@
 
         (yyval.interm.intermNode) = context->intermediate.addLoop(ELoopDoWhile, 0, (yyvsp[(6) - (8)].interm.intermTypedNode), 0, (yyvsp[(3) - (8)].interm.intermNode), (yyvsp[(4) - (8)].lex).line);
         --context->loopNestingLevel;
-    ;}
+    }
     break;
 
-  case 178:
-
-    { context->symbolTable.push(); ++context->loopNestingLevel; ;}
+  case 179:
+
+    { context->symbolTable.push(); ++context->loopNestingLevel; }
     break;
 
-  case 179:
+  case 180:
 
     {
         context->symbolTable.pop();
         (yyval.interm.intermNode) = context->intermediate.addLoop(ELoopFor, (yyvsp[(4) - (7)].interm.intermNode), reinterpret_cast<TIntermTyped*>((yyvsp[(5) - (7)].interm.nodePair).node1), reinterpret_cast<TIntermTyped*>((yyvsp[(5) - (7)].interm.nodePair).node2), (yyvsp[(7) - (7)].interm.intermNode), (yyvsp[(1) - (7)].lex).line);
         --context->loopNestingLevel;
-    ;}
+    }
     break;
 
-  case 180:
+  case 181:
 
     {
         (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode);
-    ;}
+    }
     break;
 
-  case 181:
+  case 182:
 
     {
         (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode);
-    ;}
+    }
     break;
 
-  case 182:
+  case 183:
 
     {
         (yyval.interm.intermTypedNode) = (yyvsp[(1) - (1)].interm.intermTypedNode);
-    ;}
+    }
     break;
 
-  case 183:
+  case 184:
 
     {
         (yyval.interm.intermTypedNode) = 0;
-    ;}
+    }
     break;
 
-  case 184:
+  case 185:
 
     {
         (yyval.interm.nodePair).node1 = (yyvsp[(1) - (2)].interm.intermTypedNode);
         (yyval.interm.nodePair).node2 = 0;
-    ;}
+    }
     break;
 
-  case 185:
+  case 186:
 
     {
         (yyval.interm.nodePair).node1 = (yyvsp[(1) - (3)].interm.intermTypedNode);
         (yyval.interm.nodePair).node2 = (yyvsp[(3) - (3)].interm.intermTypedNode);
-    ;}
+    }
     break;
 
-  case 186:
+  case 187:
 
     {
         if (context->loopNestingLevel <= 0) {
@@ -4324,10 +4257,10 @@
             context->recover();
         }
         (yyval.interm.intermNode) = context->intermediate.addBranch(EOpContinue, (yyvsp[(1) - (2)].lex).line);
-    ;}
+    }
     break;
 
-  case 187:
+  case 188:
 
     {
         if (context->loopNestingLevel <= 0) {
@@ -4335,10 +4268,10 @@
             context->recover();
         }
         (yyval.interm.intermNode) = context->intermediate.addBranch(EOpBreak, (yyvsp[(1) - (2)].lex).line);
-    ;}
+    }
     break;
 
-  case 188:
+  case 189:
 
     {
         (yyval.interm.intermNode) = context->intermediate.addBranch(EOpReturn, (yyvsp[(1) - (2)].lex).line);
@@ -4346,10 +4279,10 @@
             context->error((yyvsp[(1) - (2)].lex).line, "non-void function must return a value", "return", "");
             context->recover();
         }
-    ;}
+    }
     break;
 
-  case 189:
+  case 190:
 
     {
         (yyval.interm.intermNode) = context->intermediate.addBranch(EOpReturn, (yyvsp[(2) - (3)].interm.intermTypedNode), (yyvsp[(1) - (3)].lex).line);
@@ -4361,48 +4294,48 @@
             context->error((yyvsp[(1) - (3)].lex).line, "function return is not matching type:", "return", "");
             context->recover();
         }
-    ;}
+    }
     break;
 
-  case 190:
+  case 191:
 
     {
         FRAG_ONLY("discard", (yyvsp[(1) - (2)].lex).line);
         (yyval.interm.intermNode) = context->intermediate.addBranch(EOpKill, (yyvsp[(1) - (2)].lex).line);
-    ;}
+    }
     break;
 
-  case 191:
+  case 192:
 
     {
         (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode);
         context->treeRoot = (yyval.interm.intermNode);
-    ;}
+    }
     break;
 
-  case 192:
+  case 193:
 
     {
         (yyval.interm.intermNode) = context->intermediate.growAggregate((yyvsp[(1) - (2)].interm.intermNode), (yyvsp[(2) - (2)].interm.intermNode), 0);
         context->treeRoot = (yyval.interm.intermNode);
-    ;}
+    }
     break;
 
-  case 193:
+  case 194:
 
     {
         (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode);
-    ;}
+    }
     break;
 
-  case 194:
+  case 195:
 
     {
         (yyval.interm.intermNode) = (yyvsp[(1) - (1)].interm.intermNode);
-    ;}
+    }
     break;
 
-  case 195:
+  case 196:
 
     {
         TFunction* function = (yyvsp[(1) - (1)].interm).function;
@@ -4484,10 +4417,10 @@
         context->intermediate.setAggregateOperator(paramNodes, EOpParameters, (yyvsp[(1) - (1)].interm).line);
         (yyvsp[(1) - (1)].interm).intermAggregate = paramNodes;
         context->loopNestingLevel = 0;
-    ;}
+    }
     break;
 
-  case 196:
+  case 197:
 
     {
         //?? Check that all paths return a value if return type != void ?
@@ -4510,11 +4443,10 @@
 
         if ((yyvsp[(3) - (3)].interm.intermNode) && (yyvsp[(3) - (3)].interm.intermNode)->getAsAggregate())
             (yyval.interm.intermNode)->getAsAggregate()->setEndLine((yyvsp[(3) - (3)].interm.intermNode)->getAsAggregate()->getEndLine());
-    ;}
+    }
     break;
 
 
-/* Line 1267 of yacc.c.  */
 
       default: break;
     }
@@ -4526,7 +4458,6 @@
 
   *++yyvsp = yyval;
 
-
   /* Now `shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
@@ -4591,7 +4522,7 @@
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse look-ahead token after an
+      /* If just tried and failed to reuse lookahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
@@ -4608,7 +4539,7 @@
 	}
     }
 
-  /* Else will try to reuse look-ahead token after shifting the error
+  /* Else will try to reuse lookahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -4665,9 +4596,6 @@
       YY_STACK_PRINT (yyss, yyssp);
     }
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
   *++yyvsp = yylval;
 
 
@@ -4692,7 +4620,7 @@
   yyresult = 1;
   goto yyreturn;
 
-#ifndef yyoverflow
+#if !defined(yyoverflow) || YYERROR_VERBOSE
 /*-------------------------------------------------.
 | yyexhaustedlab -- memory exhaustion comes here.  |
 `-------------------------------------------------*/
@@ -4703,7 +4631,7 @@
 #endif
 
 yyreturn:
-  if (yychar != YYEOF && yychar != YYEMPTY)
+  if (yychar != YYEMPTY)
      yydestruct ("Cleanup: discarding lookahead",
 		 yytoken, &yylval, context);
   /* Do not reclaim the symbols of the rule which action triggered
diff -r d713478624d8 gfx/angle/src/compiler/glslang_tab.h
--- a/gfx/angle/src/compiler/glslang_tab.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/compiler/glslang_tab.h	Thu Jan 05 10:52:20 2012 +0900
@@ -1,24 +1,23 @@
-/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
 
 /* Skeleton interface for Bison's Yacc-like parsers in C
-
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
    Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
+   
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -29,10 +28,11 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-
+   
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
+
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -80,160 +80,68 @@
      SAMPLER2D = 296,
      SAMPLERCUBE = 297,
      SAMPLER_EXTERNAL_OES = 298,
-     IDENTIFIER = 299,
-     TYPE_NAME = 300,
-     FLOATCONSTANT = 301,
-     INTCONSTANT = 302,
-     BOOLCONSTANT = 303,
-     FIELD_SELECTION = 304,
-     LEFT_OP = 305,
-     RIGHT_OP = 306,
-     INC_OP = 307,
-     DEC_OP = 308,
-     LE_OP = 309,
-     GE_OP = 310,
-     EQ_OP = 311,
-     NE_OP = 312,
-     AND_OP = 313,
-     OR_OP = 314,
-     XOR_OP = 315,
-     MUL_ASSIGN = 316,
-     DIV_ASSIGN = 317,
-     ADD_ASSIGN = 318,
-     MOD_ASSIGN = 319,
-     LEFT_ASSIGN = 320,
-     RIGHT_ASSIGN = 321,
-     AND_ASSIGN = 322,
-     XOR_ASSIGN = 323,
-     OR_ASSIGN = 324,
-     SUB_ASSIGN = 325,
-     LEFT_PAREN = 326,
-     RIGHT_PAREN = 327,
-     LEFT_BRACKET = 328,
-     RIGHT_BRACKET = 329,
-     LEFT_BRACE = 330,
-     RIGHT_BRACE = 331,
-     DOT = 332,
-     COMMA = 333,
-     COLON = 334,
-     EQUAL = 335,
-     SEMICOLON = 336,
-     BANG = 337,
-     DASH = 338,
-     TILDE = 339,
-     PLUS = 340,
-     STAR = 341,
-     SLASH = 342,
-     PERCENT = 343,
-     LEFT_ANGLE = 344,
-     RIGHT_ANGLE = 345,
-     VERTICAL_BAR = 346,
-     CARET = 347,
-     AMPERSAND = 348,
-     QUESTION = 349
+     SAMPLER2DRECT = 299,
+     IDENTIFIER = 300,
+     TYPE_NAME = 301,
+     FLOATCONSTANT = 302,
+     INTCONSTANT = 303,
+     BOOLCONSTANT = 304,
+     FIELD_SELECTION = 305,
+     LEFT_OP = 306,
+     RIGHT_OP = 307,
+     INC_OP = 308,
+     DEC_OP = 309,
+     LE_OP = 310,
+     GE_OP = 311,
+     EQ_OP = 312,
+     NE_OP = 313,
+     AND_OP = 314,
+     OR_OP = 315,
+     XOR_OP = 316,
+     MUL_ASSIGN = 317,
+     DIV_ASSIGN = 318,
+     ADD_ASSIGN = 319,
+     MOD_ASSIGN = 320,
+     LEFT_ASSIGN = 321,
+     RIGHT_ASSIGN = 322,
+     AND_ASSIGN = 323,
+     XOR_ASSIGN = 324,
+     OR_ASSIGN = 325,
+     SUB_ASSIGN = 326,
+     LEFT_PAREN = 327,
+     RIGHT_PAREN = 328,
+     LEFT_BRACKET = 329,
+     RIGHT_BRACKET = 330,
+     LEFT_BRACE = 331,
+     RIGHT_BRACE = 332,
+     DOT = 333,
+     COMMA = 334,
+     COLON = 335,
+     EQUAL = 336,
+     SEMICOLON = 337,
+     BANG = 338,
+     DASH = 339,
+     TILDE = 340,
+     PLUS = 341,
+     STAR = 342,
+     SLASH = 343,
+     PERCENT = 344,
+     LEFT_ANGLE = 345,
+     RIGHT_ANGLE = 346,
+     VERTICAL_BAR = 347,
+     CARET = 348,
+     AMPERSAND = 349,
+     QUESTION = 350
    };
 #endif
-/* Tokens.  */
-#define INVARIANT 258
-#define HIGH_PRECISION 259
-#define MEDIUM_PRECISION 260
-#define LOW_PRECISION 261
-#define PRECISION 262
-#define ATTRIBUTE 263
-#define CONST_QUAL 264
-#define BOOL_TYPE 265
-#define FLOAT_TYPE 266
-#define INT_TYPE 267
-#define BREAK 268
-#define CONTINUE 269
-#define DO 270
-#define ELSE 271
-#define FOR 272
-#define IF 273
-#define DISCARD 274
-#define RETURN 275
-#define BVEC2 276
-#define BVEC3 277
-#define BVEC4 278
-#define IVEC2 279
-#define IVEC3 280
-#define IVEC4 281
-#define VEC2 282
-#define VEC3 283
-#define VEC4 284
-#define MATRIX2 285
-#define MATRIX3 286
-#define MATRIX4 287
-#define IN_QUAL 288
-#define OUT_QUAL 289
-#define INOUT_QUAL 290
-#define UNIFORM 291
-#define VARYING 292
-#define STRUCT 293
-#define VOID_TYPE 294
-#define WHILE 295
-#define SAMPLER2D 296
-#define SAMPLERCUBE 297
-#define SAMPLER_EXTERNAL_OES 298
-#define IDENTIFIER 299
-#define TYPE_NAME 300
-#define FLOATCONSTANT 301
-#define INTCONSTANT 302
-#define BOOLCONSTANT 303
-#define FIELD_SELECTION 304
-#define LEFT_OP 305
-#define RIGHT_OP 306
-#define INC_OP 307
-#define DEC_OP 308
-#define LE_OP 309
-#define GE_OP 310
-#define EQ_OP 311
-#define NE_OP 312
-#define AND_OP 313
-#define OR_OP 314
-#define XOR_OP 315
-#define MUL_ASSIGN 316
-#define DIV_ASSIGN 317
-#define ADD_ASSIGN 318
-#define MOD_ASSIGN 319
-#define LEFT_ASSIGN 320
-#define RIGHT_ASSIGN 321
-#define AND_ASSIGN 322
-#define XOR_ASSIGN 323
-#define OR_ASSIGN 324
-#define SUB_ASSIGN 325
-#define LEFT_PAREN 326
-#define RIGHT_PAREN 327
-#define LEFT_BRACKET 328
-#define RIGHT_BRACKET 329
-#define LEFT_BRACE 330
-#define RIGHT_BRACE 331
-#define DOT 332
-#define COMMA 333
-#define COLON 334
-#define EQUAL 335
-#define SEMICOLON 336
-#define BANG 337
-#define DASH 338
-#define TILDE 339
-#define PLUS 340
-#define STAR 341
-#define SLASH 342
-#define PERCENT 343
-#define LEFT_ANGLE 344
-#define RIGHT_ANGLE 345
-#define VERTICAL_BAR 346
-#define CARET 347
-#define AMPERSAND 348
-#define QUESTION 349
-
 
 
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
+{
 
-{
+
     struct {
         TSourceLoc line;
         union {
@@ -263,14 +171,15 @@
             TTypeList* typeList;
         };
     } interm;
-}
-/* Line 1489 of yacc.c.  */
 
-	YYSTYPE;
+
+
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 
 
+
diff -r d713478624d8 gfx/angle/src/libEGL/Display.cpp
--- a/gfx/angle/src/libEGL/Display.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libEGL/Display.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -88,6 +88,7 @@
     mMaxSwapInterval = 1;
     mSoftwareDevice = software;
     mDisplayId = displayId;
+    mDeviceLost = false;
 }
 
 Display::~Display()
@@ -304,7 +305,7 @@
     if (mDevice)
     {
         // If the device is lost, reset it first to prevent leaving the driver in an unstable state
-        if (isDeviceLost())
+        if (testDeviceLost())
         {
             resetDevice();
         }
@@ -446,33 +447,66 @@
         ASSERT(SUCCEEDED(result));
     }
 
+    initializeDevice();
+
+    return true;
+}
+
+// do any one-time device initialization
+// NOTE: this is also needed after a device lost/reset
+// to reset the scene status and ensure the default states are reset.
+void Display::initializeDevice()
+{
     // Permanent non-default states
     mDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);
+    mDevice->SetRenderState(D3DRS_LASTPIXEL, FALSE);
 
     mSceneStarted = false;
-
-    return true;
 }
 
 bool Display::resetDevice()
 {
     D3DPRESENT_PARAMETERS presentParameters = getDefaultPresentParameters();
-    HRESULT result;
-    
-    do
+
+    HRESULT result = D3D_OK;
+    bool lost = testDeviceLost();
+    int attempts = 3;    
+
+    while (lost && attempts > 0)
     {
-        Sleep(0);   // Give the graphics driver some CPU time
+        if (mDeviceEx)
+        {
+            Sleep(500);   // Give the graphics driver some CPU time
+            result = mDeviceEx->ResetEx(&presentParameters, NULL);
+        }
+        else
+        {
+            result = mDevice->TestCooperativeLevel();
+            
+            while (result == D3DERR_DEVICELOST)
+            {
+                Sleep(100);   // Give the graphics driver some CPU time
+                result = mDevice->TestCooperativeLevel();
+            }
 
-        result = mDevice->Reset(&presentParameters);
+            if (result == D3DERR_DEVICENOTRESET)
+            {
+                result = mDevice->Reset(&presentParameters);
+            }
+        }
+
+        lost = testDeviceLost();
+        attempts --;
     }
-    while (result == D3DERR_DEVICELOST);
 
     if (FAILED(result))
     {
+        ERR("Reset/ResetEx failed multiple times: 0x%08X", result);
         return error(EGL_BAD_ALLOC, false);
     }
 
-    ASSERT(SUCCEEDED(result));
+    // reset device defaults
+    initializeDevice();
 
     return true;
 }
@@ -480,6 +514,7 @@
 EGLSurface Display::createWindowSurface(HWND window, EGLConfig config, const EGLint *attribList)
 {
     const Config *configuration = mConfigSet.get(config);
+    EGLint postSubBufferSupported = EGL_FALSE;
 
     if (attribList)
     {
@@ -498,6 +533,9 @@
                     return error(EGL_BAD_ATTRIBUTE, EGL_NO_SURFACE);
                 }
                 break;
+              case EGL_POST_SUB_BUFFER_SUPPORTED_NV:
+                postSubBufferSupported = attribList[1];
+                break;
               case EGL_VG_COLORSPACE:
                 return error(EGL_BAD_MATCH, EGL_NO_SURFACE);
               case EGL_VG_ALPHA_FORMAT:
@@ -515,12 +553,13 @@
         return error(EGL_BAD_ALLOC, EGL_NO_SURFACE);
     }
 
-    if (isDeviceLost()) {
+    if (testDeviceLost()) 
+    {
         if (!restoreLostDevice())
             return EGL_NO_SURFACE;
     }
 
-    Surface *surface = new Surface(this, configuration, window);
+    Surface *surface = new Surface(this, configuration, window, postSubBufferSupported);
 
     if (!surface->initialize())
     {
@@ -627,7 +666,8 @@
         return error(EGL_BAD_ATTRIBUTE, EGL_NO_SURFACE);
     }
 
-    if (isDeviceLost()) {
+    if (testDeviceLost()) 
+    {
         if (!restoreLostDevice())
             return EGL_NO_SURFACE;
     }
@@ -645,7 +685,7 @@
     return success(surface);
 }
 
-EGLContext Display::createContext(EGLConfig configHandle, const gl::Context *shareContext)
+EGLContext Display::createContext(EGLConfig configHandle, const gl::Context *shareContext, bool notifyResets, bool robustAccess)
 {
     if (!mDevice)
     {
@@ -654,7 +694,7 @@
             return NULL;
         }
     }
-    else if (isDeviceLost())   // Lost device
+    else if (testDeviceLost())   // Lost device
     {
         if (!restoreLostDevice())
             return NULL;
@@ -662,14 +702,21 @@
 
     const egl::Config *config = mConfigSet.get(configHandle);
 
-    gl::Context *context = glCreateContext(config, shareContext);
+    gl::Context *context = glCreateContext(config, shareContext, notifyResets, robustAccess);
     mContextSet.insert(context);
+    mDeviceLost = false;
 
     return context;
 }
 
 bool Display::restoreLostDevice()
 {
+    for (ContextSet::iterator ctx = mContextSet.begin(); ctx != mContextSet.end(); ctx++)
+    {
+        if ((*ctx)->isResetNotificationEnabled())
+            return false;   // If reset notifications have been requested, application must delete all contexts first
+    }
+ 
     // Release surface resources to make the Reset() succeed
     for (SurfaceSet::iterator surface = mSurfaceSet.begin(); surface != mSurfaceSet.end(); surface++)
     {
@@ -703,6 +750,21 @@
     mContextSet.erase(context);
 }
 
+void Display::notifyDeviceLost()
+{
+    for (ContextSet::iterator context = mContextSet.begin(); context != mContextSet.end(); context++)
+    {
+        (*context)->markContextLost();
+    }
+    mDeviceLost = true;
+    error(EGL_CONTEXT_LOST);
+}
+
+bool Display::isDeviceLost()
+{
+    return mDeviceLost;
+}
+
 bool Display::isInitialized() const
 {
     return mD3d9 != NULL && mConfigSet.size() > 0;
@@ -769,13 +831,13 @@
     return &mAdapterIdentifier;
 }
 
-bool Display::isDeviceLost()
+bool Display::testDeviceLost()
 {
     if (mDeviceEx)
     {
         return FAILED(mDeviceEx->CheckDeviceState(NULL));
     }
-    else if(mDevice)
+    else if (mDevice)
     {
         return FAILED(mDevice->TestCooperativeLevel());
     }
@@ -783,6 +845,29 @@
     return false;   // No device yet, so no reset required
 }
 
+bool Display::testDeviceResettable()
+{
+    HRESULT status = D3D_OK;
+
+    if (mDeviceEx)
+    {
+        status = mDeviceEx->CheckDeviceState(NULL);
+    }
+    else if (mDevice)
+    {
+        status = mDevice->TestCooperativeLevel();
+    }
+
+    switch (status)
+    {
+      case D3DERR_DEVICENOTRESET:
+      case D3DERR_DEVICEHUNG:
+        return true;
+      default:
+        return false;
+    }
+}
+
 void Display::getMultiSampleSupport(D3DFORMAT format, bool *multiSampleArray)
 {
     for (int multiSampleIndex = 0; multiSampleIndex <= D3DMULTISAMPLE_16_SAMPLES; multiSampleIndex++)
@@ -818,7 +903,7 @@
     return SUCCEEDED(mD3d9->CheckDeviceFormat(mAdapter, mDeviceType, currentDisplayMode.Format, 0, D3DRTYPE_TEXTURE, D3DFMT_DXT5));
 }
 
-bool Display::getFloatTextureSupport(bool *filtering, bool *renderable)
+bool Display::getFloat32TextureSupport(bool *filtering, bool *renderable)
 {
     D3DDISPLAYMODE currentDisplayMode;
     mD3d9->GetAdapterDisplayMode(mAdapter, &currentDisplayMode);
@@ -846,7 +931,7 @@
     }
 }
 
-bool Display::getHalfFloatTextureSupport(bool *filtering, bool *renderable)
+bool Display::getFloat16TextureSupport(bool *filtering, bool *renderable)
 {
     D3DDISPLAYMODE currentDisplayMode;
     mD3d9->GetAdapterDisplayMode(mAdapter, &currentDisplayMode);
@@ -907,6 +992,23 @@
     return D3DPOOL_DEFAULT;
 }
 
+D3DPOOL Display::getTexturePool(bool renderable) const
+{
+    if (mD3d9Ex != NULL)
+    {
+        return D3DPOOL_DEFAULT;
+    }
+    else
+    {
+        if (!renderable)
+        {
+            return D3DPOOL_MANAGED;
+        }
+    }
+
+    return D3DPOOL_DEFAULT;
+}
+
 bool Display::getEventQuerySupport()
 {
     IDirect3DQuery9 *query;
@@ -948,7 +1050,12 @@
 
     mExtensionString = "";
 
-    if (isd3d9ex) {
+    // Multi-vendor (EXT) extensions
+    mExtensionString += "EGL_EXT_create_context_robustness ";
+
+    // ANGLE-specific extensions
+    if (isd3d9ex)
+    {
         mExtensionString += "EGL_ANGLE_d3d_share_handle_client_buffer ";
     }
 
@@ -956,13 +1063,16 @@
 
     if (swiftShader)
     {
-      mExtensionString += "EGL_ANGLE_software_display ";
+        mExtensionString += "EGL_ANGLE_software_display ";
     }
 
-    if (isd3d9ex) {
+    if (isd3d9ex)
+    {
         mExtensionString += "EGL_ANGLE_surface_d3d_texture_2d_share_handle ";
     }
 
+    mExtensionString += "EGL_NV_post_sub_buffer";
+
     std::string::size_type end = mExtensionString.find_last_not_of(' ');
     if (end != std::string::npos)
     {
diff -r d713478624d8 gfx/angle/src/libEGL/Display.h
--- a/gfx/angle/src/libEGL/Display.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libEGL/Display.h	Thu Jan 05 10:52:20 2012 +0900
@@ -44,7 +44,7 @@
 
     EGLSurface createWindowSurface(HWND window, EGLConfig config, const EGLint *attribList);
     EGLSurface createOffscreenSurface(EGLConfig config, HANDLE shareHandle, const EGLint *attribList);
-    EGLContext createContext(EGLConfig configHandle, const gl::Context *shareContext);
+    EGLContext createContext(EGLConfig configHandle, const gl::Context *shareContext, bool notifyResets, bool robustAccess);
 
     void destroySurface(egl::Surface *surface);
     void destroyContext(gl::Context *context);
@@ -61,19 +61,24 @@
     virtual IDirect3DDevice9 *getDevice();
     virtual D3DCAPS9 getDeviceCaps();
     virtual D3DADAPTER_IDENTIFIER9 *getAdapterIdentifier();
-    bool isDeviceLost();
+    virtual bool testDeviceLost();
+    virtual bool testDeviceResettable();
     virtual void getMultiSampleSupport(D3DFORMAT format, bool *multiSampleArray);
     virtual bool getDXT1TextureSupport();
     virtual bool getDXT3TextureSupport();
     virtual bool getDXT5TextureSupport();
     virtual bool getEventQuerySupport();
-    virtual bool getFloatTextureSupport(bool *filtering, bool *renderable);
-    virtual bool getHalfFloatTextureSupport(bool *filtering, bool *renderable);
+    virtual bool getFloat32TextureSupport(bool *filtering, bool *renderable);
+    virtual bool getFloat16TextureSupport(bool *filtering, bool *renderable);
     virtual bool getLuminanceTextureSupport();
     virtual bool getLuminanceAlphaTextureSupport();
     virtual bool getVertexTextureSupport() const;
     virtual bool getNonPower2TextureSupport() const;
     virtual D3DPOOL getBufferPool(DWORD usage) const;
+    virtual D3DPOOL getTexturePool(bool renderable) const;
+
+    virtual void notifyDeviceLost();
+    bool isDeviceLost();
 
     bool isD3d9ExDevice() { return mD3d9Ex != NULL; }
     const char *getExtensionString() const;
@@ -114,8 +119,10 @@
 
     typedef std::set<gl::Context*> ContextSet;
     ContextSet mContextSet;
+    bool mDeviceLost;
 
     bool createDevice();
+    void initializeDevice();
     bool resetDevice();
 
     void initExtensionString();
diff -r d713478624d8 gfx/angle/src/libEGL/Surface.cpp
--- a/gfx/angle/src/libEGL/Surface.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libEGL/Surface.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -39,8 +39,8 @@
 }
 }
 
-Surface::Surface(Display *display, const Config *config, HWND window) 
-    : mDisplay(display), mConfig(config), mWindow(window)
+Surface::Surface(Display *display, const Config *config, HWND window, EGLint postSubBufferSupported) 
+    : mDisplay(display), mConfig(config), mWindow(window), mPostSubBufferSupported(postSubBufferSupported)
 {
     mSwapChain = NULL;
     mDepthStencil = NULL;
@@ -61,7 +61,7 @@
 }
 
 Surface::Surface(Display *display, const Config *config, HANDLE shareHandle, EGLint width, EGLint height, EGLenum textureFormat, EGLenum textureType)
-    : mDisplay(display), mWindow(NULL), mConfig(config), mShareHandle(shareHandle), mWidth(width), mHeight(height)
+    : mDisplay(display), mWindow(NULL), mConfig(config), mShareHandle(shareHandle), mWidth(width), mHeight(height), mPostSubBufferSupported(EGL_FALSE)
 {
     mSwapChain = NULL;
     mDepthStencil = NULL;
@@ -106,7 +106,7 @@
 
         result = DwmSetPresentParameters(mWindow, &presentParams);
         if (FAILED(result))
-          ERR("Unable to set present parameters: %081X", result);
+          ERR("Unable to set present parameters: 0x%08X", result);
       }
     }
 
@@ -174,6 +174,13 @@
         return false;
     }
 
+    IDirect3DSurface9* preservedRenderTarget = NULL;
+    if (mPostSubBufferSupported && mRenderTarget)
+    {
+        preservedRenderTarget = mRenderTarget;
+        preservedRenderTarget->AddRef();
+    }
+
     // Evict all non-render target textures to system memory and release all resources
     // before reallocating them to free up as much video memory as possible.
     device->EvictManagedResources();
@@ -212,6 +219,12 @@
         useFlipEx = false;
     }
 
+    // D3DSWAPEFFECT_FLIPEX does not preserve the back buffer.
+    if (mPostSubBufferSupported)
+    {
+        useFlipEx = false;
+    }
+
     presentParameters.AutoDepthStencilFormat = mConfig->mDepthStencilFormat;
     // We set BackBufferCount = 1 even when we use D3DSWAPEFFECT_FLIPEX.
     // We do this because DirectX docs are a bit vague whether to set this to 1
@@ -230,7 +243,7 @@
     if(useFlipEx)
       presentParameters.SwapEffect = D3DSWAPEFFECT_FLIPEX;
     else
-      presentParameters.SwapEffect = D3DSWAPEFFECT_DISCARD;
+      presentParameters.SwapEffect = mPostSubBufferSupported ? D3DSWAPEFFECT_COPY : D3DSWAPEFFECT_DISCARD;
     presentParameters.Windowed = TRUE;
     presentParameters.BackBufferWidth = backbufferWidth;
     presentParameters.BackBufferHeight = backbufferHeight;
@@ -250,11 +263,65 @@
 
     if (FAILED(result))
     {
-        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY || result == D3DERR_INVALIDCALL);
+        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY || result == D3DERR_INVALIDCALL || result == D3DERR_DEVICELOST);
 
         ERR("Could not create additional swap chains or offscreen surfaces: %08lX", result);
         release();
-        return error(EGL_BAD_ALLOC, false);
+
+        
+        if (preservedRenderTarget)
+        {
+            preservedRenderTarget->Release();
+            preservedRenderTarget = NULL;
+        }
+
+        if(isDeviceLostError(result))
+        {
+            mDisplay->notifyDeviceLost();
+            return false;
+        }
+        else
+        {
+            return error(EGL_BAD_ALLOC, false);
+        }
+    }
+
+    if (mWindow)
+    {
+        mSwapChain->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &mRenderTarget);
+        if (!preservedRenderTarget)
+        {
+            InvalidateRect(mWindow, NULL, FALSE);
+        }
+    }
+    else
+    {
+        mOffscreenTexture->GetSurfaceLevel(0, &mRenderTarget);
+    }
+
+    if (preservedRenderTarget)
+    {
+        RECT rect =
+        {
+            0, 0,
+            mWidth, mHeight
+        };
+
+        if (rect.right > static_cast<LONG>(presentParameters.BackBufferWidth))
+        {
+            rect.right = presentParameters.BackBufferWidth;
+        }
+
+        if (rect.bottom > static_cast<LONG>(presentParameters.BackBufferHeight))
+        {
+            rect.bottom = presentParameters.BackBufferHeight;
+        }
+
+        mDisplay->endScene();
+        device->StretchRect(preservedRenderTarget, &rect, mRenderTarget, &rect, D3DTEXF_NONE);
+
+        preservedRenderTarget->Release();
+        preservedRenderTarget = NULL;
     }
 
     if (mConfig->mDepthStencilFormat != D3DFMT_UNKNOWN)
@@ -268,18 +335,11 @@
     {
         ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY || result == D3DERR_INVALIDCALL);
 
-        ERR("Could not create depthstencil surface for new swap chain: %08lX", result);
+        ERR("Could not create depthstencil surface for new swap chain: 0x%08X", result);
         release();
         return error(EGL_BAD_ALLOC, false);
     }
 
-    if (mWindow) {
-        mSwapChain->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &mRenderTarget);
-        InvalidateRect(mWindow, NULL, FALSE);
-    } else {
-        mOffscreenTexture->GetSurfaceLevel(0, &mRenderTarget);
-    }
-
     mWidth = presentParameters.BackBufferWidth;
     mHeight = presentParameters.BackBufferHeight;
 
@@ -413,6 +473,65 @@
 
         HRESULT result = mSwapChain->Present(NULL, NULL, NULL, NULL, 0);
 
+        if (result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY)
+        {
+            return error(EGL_BAD_ALLOC, false);
+        }
+
+        if (isDeviceLostError(result))
+        {
+            mDisplay->notifyDeviceLost();
+            return false;
+        }
+
+        ASSERT(SUCCEEDED(result));
+
+        checkForOutOfDateSwapChain();
+    }
+
+    return true;
+}
+
+bool Surface::postSubBuffer(EGLint x, EGLint y, EGLint width, EGLint height)
+{
+    if (x < 0 || y < 0 || width < 0 || height < 0)
+    {
+        return error(EGL_BAD_PARAMETER, false);
+    }
+
+    if (!mPostSubBufferSupported)
+    {
+        // Spec is not clear about how this should be handled.
+        return true;
+    }
+
+    if (mSwapChain)
+    {
+        mDisplay->endScene();
+
+        RECT rect =
+        {
+            x, mHeight - y - height,
+            x + width, mHeight - y
+        };
+
+        if (rect.right > mWidth)
+        {
+            rect.right = mWidth;
+        }
+
+        if (rect.bottom > mHeight)
+        {
+            rect.bottom = mHeight;
+        }
+
+        if (rect.left == rect.right || rect.top == rect.bottom)
+        {
+            return true;
+        }
+
+        HRESULT result = mSwapChain->Present(&rect, &rect, NULL, NULL, 0);
+
         if (result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY || result == D3DERR_DRIVERINTERNALERROR)
         {
             return error(EGL_BAD_ALLOC, false);
@@ -441,6 +560,11 @@
     return mHeight;
 }
 
+EGLint Surface::isPostSubBufferSupported() const
+{
+    return mPostSubBufferSupported;
+}
+
 IDirect3DSurface9 *Surface::getRenderTarget()
 {
     if (mRenderTarget)
diff -r d713478624d8 gfx/angle/src/libEGL/Surface.h
--- a/gfx/angle/src/libEGL/Surface.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libEGL/Surface.h	Thu Jan 05 10:52:20 2012 +0900
@@ -30,7 +30,7 @@
 class Surface
 {
   public:
-    Surface(Display *display, const egl::Config *config, HWND window);
+    Surface(Display *display, const egl::Config *config, HWND window, EGLint postSubBufferSupported);
     Surface(Display *display, const egl::Config *config, HANDLE shareHandle, EGLint width, EGLint height, EGLenum textureFormat, EGLenum textureTarget);
 
     ~Surface();
@@ -41,10 +41,13 @@
 
     HWND getWindowHandle();
     bool swap();
+    bool postSubBuffer(EGLint x, EGLint y, EGLint width, EGLint height);
 
     virtual EGLint getWidth() const;
     virtual EGLint getHeight() const;
 
+    virtual EGLint isPostSubBufferSupported() const;
+
     virtual IDirect3DSurface9 *getRenderTarget();
     virtual IDirect3DSurface9 *getDepthStencil();
     virtual IDirect3DTexture9 *getOffscreenTexture();
@@ -96,6 +99,8 @@
 //  EGLenum vgAlphaFormat;         // Alpha format for OpenVG
 //  EGLenum vgColorSpace;          // Color space for OpenVG
     EGLint mSwapInterval;
+    EGLint mPostSubBufferSupported;
+    
     DWORD mPresentInterval;
     bool mPresentIntervalDirty;
     gl::Texture2D *mTexture;
diff -r d713478624d8 gfx/angle/src/libEGL/libEGL.cpp
--- a/gfx/angle/src/libEGL/libEGL.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libEGL/libEGL.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -488,6 +488,9 @@
           case EGL_WIDTH:
             *value = eglSurface->getWidth();
             break;
+          case EGL_POST_SUB_BUFFER_SUPPORTED_NV:
+            *value = eglSurface->isPostSubBufferSupported();
+            break;
           default:
             return error(EGL_BAD_ATTRIBUTE, EGL_FALSE);
         }
@@ -715,7 +718,10 @@
             return error(EGL_BAD_MATCH, EGL_FALSE);
         }
 
-        glBindTexImage(eglSurface);
+        if (!glBindTexImage(eglSurface))
+        {
+            return error(EGL_BAD_MATCH, EGL_FALSE);
+        }
 
         return success(EGL_TRUE);
     }
@@ -814,16 +820,34 @@
     {
         // Get the requested client version (default is 1) and check it is two.
         EGLint client_version = 1;
+        bool reset_notification = false;
+        bool robust_access = false;
+
         if (attrib_list)
         {
             for (const EGLint* attribute = attrib_list; attribute[0] != EGL_NONE; attribute += 2)
             {
-                if (attribute[0] == EGL_CONTEXT_CLIENT_VERSION)
+                switch (attribute[0])
                 {
+                  case EGL_CONTEXT_CLIENT_VERSION:
                     client_version = attribute[1];
-                }
-                else
-                {
+                    break;
+                  case EGL_CONTEXT_OPENGL_ROBUST_ACCESS_EXT:
+                    if (attribute[1] == EGL_TRUE)
+                    {
+                        return error(EGL_BAD_CONFIG, EGL_NO_CONTEXT);   // Unimplemented
+                        robust_access = true;
+                    }
+                    else if (attribute[1] != EGL_FALSE)
+                        return error(EGL_BAD_ATTRIBUTE, EGL_NO_CONTEXT);
+                    break;
+                  case EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT:
+                    if (attribute[1] == EGL_LOSE_CONTEXT_ON_RESET_EXT)
+                        reset_notification = true;
+                    else if (attribute[1] != EGL_NO_RESET_NOTIFICATION_EXT)
+                        return error(EGL_BAD_ATTRIBUTE, EGL_NO_CONTEXT);
+                    break;
+                  default:
                     return error(EGL_BAD_ATTRIBUTE, EGL_NO_CONTEXT);
                 }
             }
@@ -834,6 +858,11 @@
             return error(EGL_BAD_CONFIG, EGL_NO_CONTEXT);
         }
 
+        if (share_context && static_cast<gl::Context*>(share_context)->isResetNotificationEnabled() != reset_notification)
+        {
+            return error(EGL_BAD_MATCH, EGL_NO_CONTEXT);
+        }
+
         egl::Display *display = static_cast<egl::Display*>(dpy);
 
         if (!validateConfig(display, config))
@@ -841,9 +870,12 @@
             return EGL_NO_CONTEXT;
         }
 
-        EGLContext context = display->createContext(config, static_cast<gl::Context*>(share_context));
+        EGLContext context = display->createContext(config, static_cast<gl::Context*>(share_context), reset_notification, robust_access);
 
-        return success(context);
+        if (context)
+            return success(context);
+        else
+            return error(EGL_CONTEXT_LOST, EGL_NO_CONTEXT);
     }
     catch(std::bad_alloc&)
     {
@@ -895,7 +927,13 @@
         gl::Context *context = static_cast<gl::Context*>(ctx);
         IDirect3DDevice9 *device = display->getDevice();
 
-        if (!device || display->isDeviceLost())
+        if (!device || display->testDeviceLost())
+        {
+            display->notifyDeviceLost();
+            return EGL_FALSE;
+        }
+
+        if (display->isDeviceLost())
         {
             return error(EGL_CONTEXT_LOST, EGL_FALSE);
         }
@@ -1077,6 +1115,11 @@
             return EGL_FALSE;
         }
 
+        if (display->isDeviceLost())
+        {
+            return error(EGL_CONTEXT_LOST, EGL_FALSE);
+        }
+
         if (surface == EGL_NO_SURFACE)
         {
             return error(EGL_BAD_SURFACE, EGL_FALSE);
@@ -1109,6 +1152,11 @@
             return EGL_FALSE;
         }
 
+        if (display->isDeviceLost())
+        {
+            return error(EGL_CONTEXT_LOST, EGL_FALSE);
+        }
+
         UNIMPLEMENTED();   // FIXME
 
         return success(0);
@@ -1121,6 +1169,43 @@
     return EGL_FALSE;
 }
 
+EGLBoolean __stdcall eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height)
+{
+    EVENT("(EGLDisplay dpy = 0x%0.8p, EGLSurface surface = 0x%0.8p, EGLint x = %d, EGLint y = %d, EGLint width = %d, EGLint height = %d)", dpy, surface, x, y, width, height);
+
+    try
+    {
+        egl::Display *display = static_cast<egl::Display*>(dpy);
+        egl::Surface *eglSurface = static_cast<egl::Surface*>(surface);
+
+        if (!validateSurface(display, eglSurface))
+        {
+            return EGL_FALSE;
+        }
+
+        if (display->isDeviceLost())
+        {
+            return error(EGL_CONTEXT_LOST, EGL_FALSE);
+        }
+
+        if (surface == EGL_NO_SURFACE)
+        {
+            return error(EGL_BAD_SURFACE, EGL_FALSE);
+        }
+
+        if (eglSurface->postSubBuffer(x, y, width, height))
+        {
+            return success(EGL_TRUE);
+        }
+    }
+    catch(std::bad_alloc&)
+    {
+        return error(EGL_BAD_ALLOC, EGL_FALSE);
+    }
+
+    return EGL_FALSE;
+}
+
 __eglMustCastToProperFunctionPointerType __stdcall eglGetProcAddress(const char *procname)
 {
     EVENT("(const char *procname = \"%s\")", procname);
@@ -1136,6 +1221,7 @@
         static const Extension eglExtensions[] =
         {
             {"eglQuerySurfacePointerANGLE", (__eglMustCastToProperFunctionPointerType)eglQuerySurfacePointerANGLE},
+            {"eglPostSubBufferNV", (__eglMustCastToProperFunctionPointerType)eglPostSubBufferNV},
             {"", NULL},
         };
 
diff -r d713478624d8 gfx/angle/src/libGLESv2/Context.cpp
--- a/gfx/angle/src/libGLESv2/Context.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/Context.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -38,8 +38,10 @@
 
 namespace gl
 {
-Context::Context(const egl::Config *config, const gl::Context *shareContext) : mConfig(config)
+Context::Context(const egl::Config *config, const gl::Context *shareContext, bool notifyResets, bool robustAccess) : mConfig(config)
 {
+    ASSERT(robustAccess == false);   // Unimplemented
+
     mDisplay = NULL;
     mDevice = NULL;
 
@@ -145,6 +147,7 @@
 
     mState.packAlignment = 4;
     mState.unpackAlignment = 4;
+    mState.packReverseRowOrder = false;
 
     mVertexDataManager = NULL;
     mIndexDataManager = NULL;
@@ -158,6 +161,10 @@
     mInvalidFramebufferOperation = false;
 
     mHasBeenCurrent = false;
+    mContextLost = false;
+    mResetStatus = GL_NO_ERROR;
+    mResetStrategy = (notifyResets ? GL_LOSE_CONTEXT_ON_RESET_EXT : GL_NO_RESET_NOTIFICATION_EXT);
+    mRobustAccess = robustAccess;
 
     mSupportsDXT1Textures = false;
     mSupportsDXT3Textures = false;
@@ -290,8 +297,8 @@
         mSupportsDXT1Textures = mDisplay->getDXT1TextureSupport();
         mSupportsDXT3Textures = mDisplay->getDXT3TextureSupport();
         mSupportsDXT5Textures = mDisplay->getDXT5TextureSupport();
-        mSupportsFloatTextures = mDisplay->getFloatTextureSupport(&mSupportsFloatLinearFilter, &mSupportsFloatRenderableTextures);
-        mSupportsHalfFloatTextures = mDisplay->getHalfFloatTextureSupport(&mSupportsHalfFloatLinearFilter, &mSupportsHalfFloatRenderableTextures);
+        mSupportsFloat32Textures = mDisplay->getFloat32TextureSupport(&mSupportsFloat32LinearFilter, &mSupportsFloat32RenderableTextures);
+        mSupportsFloat16Textures = mDisplay->getFloat16TextureSupport(&mSupportsFloat16LinearFilter, &mSupportsFloat16RenderableTextures);
         mSupportsLuminanceTextures = mDisplay->getLuminanceTextureSupport();
         mSupportsLuminanceAlphaTextures = mDisplay->getLuminanceAlphaTextureSupport();
 
@@ -389,6 +396,18 @@
     mCachedCurrentProgram = NULL;
 }
 
+void Context::markContextLost()
+{
+    if (mResetStrategy == GL_LOSE_CONTEXT_ON_RESET_EXT)
+        mResetStatus = GL_UNKNOWN_CONTEXT_RESET_EXT;
+    mContextLost = true;
+}
+
+bool Context::isContextLost()
+{
+    return mContextLost;
+}
+
 void Context::setClearColor(float red, float green, float blue, float alpha)
 {
     mState.colorClearValue.red = red;
@@ -837,6 +856,16 @@
     return mState.unpackAlignment;
 }
 
+void Context::setPackReverseRowOrder(bool reverseRowOrder)
+{
+    mState.packReverseRowOrder = reverseRowOrder;
+}
+
+bool Context::getPackReverseRowOrder() const
+{
+    return mState.packReverseRowOrder;
+}
+
 GLuint Context::createBuffer()
 {
     return mResourceManager->createBuffer();
@@ -1158,24 +1187,25 @@
 {
     switch (pname)
     {
-      case GL_SHADER_COMPILER:          *params = GL_TRUE;                          break;
-      case GL_SAMPLE_COVERAGE_INVERT:   *params = mState.sampleCoverageInvert;      break;
-      case GL_DEPTH_WRITEMASK:          *params = mState.depthMask;                 break;
+      case GL_SHADER_COMPILER:           *params = GL_TRUE;                            break;
+      case GL_SAMPLE_COVERAGE_INVERT:    *params = mState.sampleCoverageInvert;        break;
+      case GL_DEPTH_WRITEMASK:           *params = mState.depthMask;                   break;
       case GL_COLOR_WRITEMASK:
         params[0] = mState.colorMaskRed;
         params[1] = mState.colorMaskGreen;
         params[2] = mState.colorMaskBlue;
         params[3] = mState.colorMaskAlpha;
         break;
-      case GL_CULL_FACE:                *params = mState.cullFace;                  break;
-      case GL_POLYGON_OFFSET_FILL:      *params = mState.polygonOffsetFill;         break;
-      case GL_SAMPLE_ALPHA_TO_COVERAGE: *params = mState.sampleAlphaToCoverage;     break;
-      case GL_SAMPLE_COVERAGE:          *params = mState.sampleCoverage;            break;
-      case GL_SCISSOR_TEST:             *params = mState.scissorTest;               break;
-      case GL_STENCIL_TEST:             *params = mState.stencilTest;               break;
-      case GL_DEPTH_TEST:               *params = mState.depthTest;                 break;
-      case GL_BLEND:                    *params = mState.blend;                     break;
-      case GL_DITHER:                   *params = mState.dither;                    break;
+      case GL_CULL_FACE:                 *params = mState.cullFace;                    break;
+      case GL_POLYGON_OFFSET_FILL:       *params = mState.polygonOffsetFill;           break;
+      case GL_SAMPLE_ALPHA_TO_COVERAGE:  *params = mState.sampleAlphaToCoverage;       break;
+      case GL_SAMPLE_COVERAGE:           *params = mState.sampleCoverage;              break;
+      case GL_SCISSOR_TEST:              *params = mState.scissorTest;                 break;
+      case GL_STENCIL_TEST:              *params = mState.stencilTest;                 break;
+      case GL_DEPTH_TEST:                *params = mState.depthTest;                   break;
+      case GL_BLEND:                     *params = mState.blend;                       break;
+      case GL_DITHER:                    *params = mState.dither;                      break;
+      case GL_CONTEXT_ROBUST_ACCESS_EXT: *params = mRobustAccess ? GL_TRUE : GL_FALSE; break;
       default:
         return false;
     }
@@ -1254,6 +1284,7 @@
       case GL_RENDERBUFFER_BINDING:             *params = mState.renderbuffer.id();             break;
       case GL_CURRENT_PROGRAM:                  *params = mState.currentProgram;                break;
       case GL_PACK_ALIGNMENT:                   *params = mState.packAlignment;                 break;
+      case GL_PACK_REVERSE_ROW_ORDER_ANGLE:     *params = mState.packReverseRowOrder;           break;
       case GL_UNPACK_ALIGNMENT:                 *params = mState.unpackAlignment;               break;
       case GL_GENERATE_MIPMAP_HINT:             *params = mState.generateMipmapHint;            break;
       case GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES: *params = mState.fragmentShaderDerivativeHint; break;
@@ -1375,7 +1406,7 @@
       case GL_ALPHA_BITS:
         {
             gl::Framebuffer *framebuffer = getDrawFramebuffer();
-            gl::Colorbuffer *colorbuffer = framebuffer->getColorbuffer();
+            gl::Renderbuffer *colorbuffer = framebuffer->getColorbuffer();
 
             if (colorbuffer)
             {
@@ -1396,7 +1427,7 @@
       case GL_DEPTH_BITS:
         {
             gl::Framebuffer *framebuffer = getDrawFramebuffer();
-            gl::DepthStencilbuffer *depthbuffer = framebuffer->getDepthbuffer();
+            gl::Renderbuffer *depthbuffer = framebuffer->getDepthbuffer();
 
             if (depthbuffer)
             {
@@ -1411,7 +1442,7 @@
       case GL_STENCIL_BITS:
         {
             gl::Framebuffer *framebuffer = getDrawFramebuffer();
-            gl::DepthStencilbuffer *stencilbuffer = framebuffer->getStencilbuffer();
+            gl::Renderbuffer *stencilbuffer = framebuffer->getStencilbuffer();
 
             if (stencilbuffer)
             {
@@ -1445,6 +1476,9 @@
             *params = mState.samplerTexture[TEXTURE_CUBE][mState.activeSampler].id();
         }
         break;
+      case GL_RESET_NOTIFICATION_STRATEGY_EXT:
+        *params = mResetStrategy;
+        break;
       default:
         return false;
     }
@@ -1490,6 +1524,7 @@
       case GL_RENDERBUFFER_BINDING:
       case GL_CURRENT_PROGRAM:
       case GL_PACK_ALIGNMENT:
+      case GL_PACK_REVERSE_ROW_ORDER_ANGLE:
       case GL_UNPACK_ALIGNMENT:
       case GL_GENERATE_MIPMAP_HINT:
       case GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES:
@@ -1534,6 +1569,7 @@
       case GL_IMPLEMENTATION_COLOR_READ_FORMAT:
       case GL_TEXTURE_BINDING_2D:
       case GL_TEXTURE_BINDING_CUBE_MAP:
+      case GL_RESET_NOTIFICATION_STRATEGY_EXT:
         {
             *type = GL_INT;
             *numParams = 1;
@@ -1577,6 +1613,7 @@
       case GL_DEPTH_TEST:
       case GL_BLEND:
       case GL_DITHER:
+      case GL_CONTEXT_ROBUST_ACCESS_EXT:
         {
             *type = GL_BOOL;
             *numParams = 1;
@@ -1631,15 +1668,11 @@
         return error(GL_INVALID_FRAMEBUFFER_OPERATION, false);
     }
 
-    IDirect3DSurface9 *renderTarget = NULL;
-    IDirect3DSurface9 *depthStencil = NULL;
-
     bool renderTargetChanged = false;
     unsigned int renderTargetSerial = framebufferObject->getRenderTargetSerial();
     if (renderTargetSerial != mAppliedRenderTargetSerial)
     {
-        renderTarget = framebufferObject->getRenderTarget();
-
+        IDirect3DSurface9 *renderTarget = framebufferObject->getRenderTarget();
         if (!renderTarget)
         {
             return false;   // Context must be lost
@@ -1648,8 +1681,10 @@
         mAppliedRenderTargetSerial = renderTargetSerial;
         mScissorStateDirty = true; // Scissor area must be clamped to render target's size-- this is different for different render targets.
         renderTargetChanged = true;
+        renderTarget->Release();
     }
 
+    IDirect3DSurface9 *depthStencil = NULL;
     unsigned int depthbufferSerial = 0;
     unsigned int stencilbufferSerial = 0;
     if (framebufferObject->getDepthbufferType() != GL_NONE)
@@ -1687,17 +1722,14 @@
 
     if (!mRenderTargetDescInitialized || renderTargetChanged)
     {
+        IDirect3DSurface9 *renderTarget = framebufferObject->getRenderTarget();
         if (!renderTarget)
         {
-            renderTarget = framebufferObject->getRenderTarget();
-
-            if (!renderTarget)
-            {
-                return false;   // Context must be lost
-            }
+            return false;   // Context must be lost
         }
         renderTarget->GetDesc(&mRenderTargetDesc);
         mRenderTargetDescInitialized = true;
+        renderTarget->Release();
     }
 
     D3DVIEWPORT9 viewport;
@@ -1730,7 +1762,7 @@
         return false;   // Nothing to render
     }
 
-    if (!mViewportInitialized || memcmp(&viewport, &mSetViewport, sizeof mSetViewport) != 0)
+    if (renderTargetChanged || !mViewportInitialized || memcmp(&viewport, &mSetViewport, sizeof mSetViewport) != 0)
     {
         mDevice->SetViewport(&viewport);
         mSetViewport = viewport;
@@ -1766,11 +1798,13 @@
         GLfloat xy[2] = {1.0f / viewport.Width, -1.0f / viewport.Height};
         programObject->setUniform2fv(halfPixelSize, 1, xy);
 
-        GLint viewport = programObject->getDxViewportLocation();
-        GLfloat whxy[4] = {mState.viewportWidth / 2.0f, mState.viewportHeight / 2.0f, 
+        // These values are used for computing gl_FragCoord in Program::linkVaryings(). The approach depends on Shader Model 3.0 support.
+        GLint coord = programObject->getDxCoordLocation();
+        float h = mSupportsShaderModel3 ? mRenderTargetDesc.Height : mState.viewportHeight / 2.0f;
+        GLfloat whxy[4] = {mState.viewportWidth / 2.0f, h, 
                           (float)mState.viewportX + mState.viewportWidth / 2.0f, 
                           (float)mState.viewportY + mState.viewportHeight / 2.0f};
-        programObject->setUniform4fv(viewport, 1, whxy);
+        programObject->setUniform4fv(coord, 1, whxy);
 
         GLint depth = programObject->getDxDepthLocation();
         GLfloat dz[2] = {(zFar - zNear) / 2.0f, (zNear + zFar) / 2.0f};
@@ -1911,7 +1945,7 @@
             }
 
             // get the maximum size of the stencil ref
-            gl::DepthStencilbuffer *stencilbuffer = framebufferObject->getStencilbuffer();
+            gl::Renderbuffer *stencilbuffer = framebufferObject->getStencilbuffer();
             GLuint maxStencil = (1 << stencilbuffer->getStencilSize()) - 1;
 
             mDevice->SetRenderState(adjustedFrontFace == GL_CCW ? D3DRS_STENCILWRITEMASK : D3DRS_CCW_STENCILWRITEMASK, mState.stencilWritemask);
@@ -1978,7 +2012,7 @@
     {
         if (mState.polygonOffsetFill)
         {
-            gl::DepthStencilbuffer *depthbuffer = framebufferObject->getDepthbuffer();
+            gl::Renderbuffer *depthbuffer = framebufferObject->getDepthbuffer();
             if (depthbuffer)
             {
                 mDevice->SetRenderState(D3DRS_SLOPESCALEDEPTHBIAS, *((DWORD*)&mState.polygonOffsetFactor));
@@ -2127,13 +2161,13 @@
 
             Texture *texture = getSamplerTexture(textureUnit, textureType);
 
-            if (appliedTextureSerial[samplerIndex] != texture->getSerial() || texture->isDirtyParameter() || texture->isDirtyImage())
+            if (appliedTextureSerial[samplerIndex] != texture->getTextureSerial() || texture->hasDirtyParameters() || texture->hasDirtyImages())
             {
                 IDirect3DBaseTexture9 *d3dTexture = texture->getTexture();
 
                 if (d3dTexture)
                 {
-                    if (appliedTextureSerial[samplerIndex] != texture->getSerial() || texture->isDirtyParameter())
+                    if (appliedTextureSerial[samplerIndex] != texture->getTextureSerial() || texture->hasDirtyParameters())
                     {
                         GLenum wrapS = texture->getWrapS();
                         GLenum wrapT = texture->getWrapT();
@@ -2150,7 +2184,7 @@
                         mDevice->SetSamplerState(d3dSampler, D3DSAMP_MIPFILTER, d3dMipFilter);
                     }
 
-                    if (appliedTextureSerial[samplerIndex] != texture->getSerial() || texture->isDirtyImage())
+                    if (appliedTextureSerial[samplerIndex] != texture->getTextureSerial() || texture->hasDirtyImages())
                     {
                         mDevice->SetTexture(d3dSampler, d3dTexture);
                     }
@@ -2160,7 +2194,7 @@
                     mDevice->SetTexture(d3dSampler, getIncompleteTexture(textureType)->getTexture());
                 }
 
-                appliedTextureSerial[samplerIndex] = texture->getSerial();
+                appliedTextureSerial[samplerIndex] = texture->getTextureSerial();
                 texture->resetDirty();
             }
         }
@@ -2184,7 +2218,8 @@
     }
 }
 
-void Context::readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels)
+void Context::readPixels(GLint x, GLint y, GLsizei width, GLsizei height,
+                         GLenum format, GLenum type, GLsizei *bufSize, void* pixels)
 {
     Framebuffer *framebuffer = getReadFramebuffer();
 
@@ -2198,8 +2233,18 @@
         return error(GL_INVALID_OPERATION);
     }
 
+    GLsizei outputPitch = ComputePitch(width, format, type, mState.packAlignment);
+    // sized query sanity check
+    if (bufSize)
+    {
+        int requiredSize = outputPitch * height;
+        if (requiredSize > *bufSize)
+        {
+            return error(GL_INVALID_OPERATION);
+        }
+    }
+
     IDirect3DSurface9 *renderTarget = framebuffer->getRenderTarget();
-
     if (!renderTarget)
     {
         return;   // Context must be lost, return silently
@@ -2208,39 +2253,65 @@
     D3DSURFACE_DESC desc;
     renderTarget->GetDesc(&desc);
 
-    IDirect3DSurface9 *systemSurface;
-    HRESULT result = mDevice->CreateOffscreenPlainSurface(desc.Width, desc.Height, desc.Format, D3DPOOL_SYSTEMMEM, &systemSurface, NULL);
-
-    if (FAILED(result))
-    {
-        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-        return error(GL_OUT_OF_MEMORY);
-    }
-
     if (desc.MultiSampleType != D3DMULTISAMPLE_NONE)
     {
         UNIMPLEMENTED();   // FIXME: Requires resolve using StretchRect into non-multisampled render target
+        renderTarget->Release();
         return error(GL_OUT_OF_MEMORY);
     }
 
+    HRESULT result;
+    IDirect3DSurface9 *systemSurface = NULL;
+    bool directToPixels = getPackReverseRowOrder() && getPackAlignment() <= 4 && mDisplay->isD3d9ExDevice() &&
+                          x == 0 && y == 0 && width == desc.Width && height == desc.Height &&
+                          desc.Format == D3DFMT_A8R8G8B8 && format == GL_BGRA_EXT && type == GL_UNSIGNED_BYTE;
+    if (directToPixels)
+    {
+        // Use the pixels ptr as a shared handle to write directly into client's memory
+        result = mDevice->CreateOffscreenPlainSurface(desc.Width, desc.Height, desc.Format,
+                                                      D3DPOOL_SYSTEMMEM, &systemSurface, &pixels);
+        if (FAILED(result))
+        {
+            // Try again without the shared handle
+            directToPixels = false;
+        }
+    }
+
+    if (!directToPixels)
+    {
+        result = mDevice->CreateOffscreenPlainSurface(desc.Width, desc.Height, desc.Format,
+                                                      D3DPOOL_SYSTEMMEM, &systemSurface, NULL);
+        if (FAILED(result))
+        {
+            ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
+            return error(GL_OUT_OF_MEMORY);
+        }
+    }
+
     result = mDevice->GetRenderTargetData(renderTarget, systemSurface);
+    renderTarget->Release();
+    renderTarget = NULL;
 
     if (FAILED(result))
     {
         systemSurface->Release();
 
-        switch (result)
+        // It turns out that D3D will sometimes produce more error
+        // codes than those documented.
+        if (checkDeviceLost(result))
+            return error(GL_OUT_OF_MEMORY);
+        else
         {
-          // It turns out that D3D will sometimes produce more error
-          // codes than those documented.
-          case D3DERR_DRIVERINTERNALERROR:
-          case D3DERR_DEVICELOST:
-          case D3DERR_DEVICEHUNG:
-            return error(GL_OUT_OF_MEMORY);
-          default:
             UNREACHABLE();
-            return;   // No sensible error to generate
+            return;
         }
+
+    }
+
+    if (directToPixels)
+    {
+        systemSurface->Release();
+        return;
     }
 
     D3DLOCKED_RECT lock;
@@ -2260,11 +2331,21 @@
         return;   // No sensible error to generate
     }
 
-    unsigned char *source = ((unsigned char*)lock.pBits) + lock.Pitch * (rect.bottom - rect.top - 1);
     unsigned char *dest = (unsigned char*)pixels;
     unsigned short *dest16 = (unsigned short*)pixels;
-    int inputPitch = -lock.Pitch;
-    GLsizei outputPitch = ComputePitch(width, format, type, mState.packAlignment);
+
+    unsigned char *source;
+    int inputPitch;
+    if (getPackReverseRowOrder())
+    {
+        source = (unsigned char*)lock.pBits;
+        inputPitch = lock.Pitch;
+    }
+    else
+    {
+        source = ((unsigned char*)lock.pBits) + lock.Pitch * (rect.bottom - rect.top - 1);
+        inputPitch = -lock.Pitch;
+    }
 
     for (int j = 0; j < rect.bottom - rect.top; j++)
     {
@@ -2517,17 +2598,7 @@
     float depth = clamp01(mState.depthClearValue);
     int stencil = mState.stencilClearValue & 0x000000FF;
 
-    IDirect3DSurface9 *renderTarget = framebufferObject->getRenderTarget();
-
-    if (!renderTarget)
-    {
-        return;   // Context must be lost, return silently
-    }
-
-    D3DSURFACE_DESC desc;
-    renderTarget->GetDesc(&desc);
-
-    bool alphaUnmasked = (dx2es::GetAlphaSize(desc.Format) == 0) || mState.colorMaskAlpha;
+    bool alphaUnmasked = (dx2es::GetAlphaSize(mRenderTargetDesc.Format) == 0) || mState.colorMaskAlpha;
 
     const bool needMaskedStencilClear = (flags & D3DCLEAR_STENCIL) &&
                                         (mState.stencilWritemask & stencilUnmasked) != stencilUnmasked;
@@ -2628,12 +2699,12 @@
 
         float quad[4][4];   // A quadrilateral covering the target, aligned to match the edges
         quad[0][0] = -0.5f;
-        quad[0][1] = desc.Height - 0.5f;
+        quad[0][1] = mRenderTargetDesc.Height - 0.5f;
         quad[0][2] = 0.0f;
         quad[0][3] = 1.0f;
 
-        quad[1][0] = desc.Width - 0.5f;
-        quad[1][1] = desc.Height - 0.5f;
+        quad[1][0] = mRenderTargetDesc.Width - 0.5f;
+        quad[1][1] = mRenderTargetDesc.Height - 0.5f;
         quad[1][2] = 0.0f;
         quad[1][3] = 1.0f;
 
@@ -2642,7 +2713,7 @@
         quad[2][2] = 0.0f;
         quad[2][3] = 1.0f;
 
-        quad[3][0] = desc.Width - 0.5f;
+        quad[3][0] = mRenderTargetDesc.Width - 0.5f;
         quad[3][1] = -0.5f;
         quad[3][2] = 0.0f;
         quad[3][3] = 1.0f;
@@ -2715,7 +2786,7 @@
 
         if (mode == GL_LINE_LOOP)   // Draw the last segment separately
         {
-            drawClosingLine(first, first + count - 1);
+            drawClosingLine(0, count - 1, 0);
         }
     }
 }
@@ -2780,7 +2851,7 @@
 
         if (mode == GL_LINE_LOOP)   // Draw the last segment separately
         {
-            drawClosingLine(count, type, indices);
+            drawClosingLine(count, type, indices, indexInfo.minIndex);
         }
     }
 }
@@ -2788,6 +2859,7 @@
 // Implements glFlush when block is false, glFinish when block is true
 void Context::sync(bool block)
 {
+    egl::Display *display = getDisplay();
     IDirect3DQuery9 *eventQuery = NULL;
     HRESULT result;
 
@@ -2820,19 +2892,26 @@
         {
             // Keep polling, but allow other threads to do something useful first
             Sleep(0);
+            // explicitly check for device loss
+            // some drivers seem to return S_FALSE even if the device is lost
+            // instead of D3DERR_DEVICELOST like they should
+            if (display->testDeviceLost())
+            {
+                result = D3DERR_DEVICELOST;
+            }
         }
     }
     while(block && result == S_FALSE);
 
     eventQuery->Release();
 
-    if (result == D3DERR_DEVICELOST)
+    if (checkDeviceLost(result))
     {
         error(GL_OUT_OF_MEMORY);
     }
 }
 
-void Context::drawClosingLine(unsigned int first, unsigned int last)
+void Context::drawClosingLine(unsigned int first, unsigned int last, int minIndex)
 {
     IDirect3DIndexBuffer9 *indexBuffer = NULL;
     bool succeeded = false;
@@ -2886,7 +2965,7 @@
         mDevice->SetIndices(mClosingIB->getBuffer());
         mAppliedIBSerial = mClosingIB->getSerial();
 
-        mDevice->DrawIndexedPrimitive(D3DPT_LINELIST, 0, 0, last, offset, 1);
+        mDevice->DrawIndexedPrimitive(D3DPT_LINELIST, -minIndex, minIndex, last, offset, 1);
     }
     else
     {
@@ -2895,7 +2974,7 @@
     }
 }
 
-void Context::drawClosingLine(GLsizei count, GLenum type, const void *indices)
+void Context::drawClosingLine(GLsizei count, GLenum type, const void *indices, int minIndex)
 {
     unsigned int first = 0;
     unsigned int last = 0;
@@ -2924,7 +3003,7 @@
       default: UNREACHABLE();
     }
 
-    drawClosingLine(first, last);
+    drawClosingLine(first, last, minIndex);
 }
 
 void Context::recordInvalidEnum()
@@ -2994,6 +3073,36 @@
     return GL_NO_ERROR;
 }
 
+GLenum Context::getResetStatus()
+{
+    if (mResetStatus == GL_NO_ERROR)
+    {
+        bool lost = mDisplay->testDeviceLost();
+
+        if (lost)
+        {
+            mDisplay->notifyDeviceLost();   // Sets mResetStatus
+        }
+    }
+
+    GLenum status = mResetStatus;
+
+    if (mResetStatus != GL_NO_ERROR)
+    {
+        if (mDisplay->testDeviceResettable())
+        {
+            mResetStatus = GL_NO_ERROR;
+        }
+    }
+    
+    return status;
+}
+
+bool Context::isResetNotificationEnabled()
+{
+    return (mResetStrategy == GL_LOSE_CONTEXT_ON_RESET_EXT);
+}
+
 bool Context::supportsShaderModel3() const
 {
     return mSupportsShaderModel3;
@@ -3068,34 +3177,34 @@
     return mSupportsDXT5Textures;
 }
 
-bool Context::supportsFloatTextures() const
+bool Context::supportsFloat32Textures() const
 {
-    return mSupportsFloatTextures;
+    return mSupportsFloat32Textures;
 }
 
-bool Context::supportsFloatLinearFilter() const
+bool Context::supportsFloat32LinearFilter() const
 {
-    return mSupportsFloatLinearFilter;
+    return mSupportsFloat32LinearFilter;
 }
 
-bool Context::supportsFloatRenderableTextures() const
+bool Context::supportsFloat32RenderableTextures() const
 {
-    return mSupportsFloatRenderableTextures;
+    return mSupportsFloat32RenderableTextures;
 }
 
-bool Context::supportsHalfFloatTextures() const
+bool Context::supportsFloat16Textures() const
 {
-    return mSupportsHalfFloatTextures;
+    return mSupportsFloat16Textures;
 }
 
-bool Context::supportsHalfFloatLinearFilter() const
+bool Context::supportsFloat16LinearFilter() const
 {
-    return mSupportsHalfFloatLinearFilter;
+    return mSupportsFloat16LinearFilter;
 }
 
-bool Context::supportsHalfFloatRenderableTextures() const
+bool Context::supportsFloat16RenderableTextures() const
 {
-    return mSupportsHalfFloatRenderableTextures;
+    return mSupportsFloat16RenderableTextures;
 }
 
 int Context::getMaximumRenderbufferDimension() const
@@ -3344,19 +3453,19 @@
     mExtensionString += "GL_OES_rgb8_rgba8 ";
     mExtensionString += "GL_OES_standard_derivatives ";
 
-    if (supportsHalfFloatTextures())
+    if (supportsFloat16Textures())
     {
         mExtensionString += "GL_OES_texture_half_float ";
     }
-    if (supportsHalfFloatLinearFilter())
+    if (supportsFloat16LinearFilter())
     {
         mExtensionString += "GL_OES_texture_half_float_linear ";
     }
-    if (supportsFloatTextures())
+    if (supportsFloat32Textures())
     {
         mExtensionString += "GL_OES_texture_float ";
     }
-    if (supportsFloatLinearFilter())
+    if (supportsFloat32LinearFilter())
     {
         mExtensionString += "GL_OES_texture_float_linear ";
     }
@@ -3368,6 +3477,7 @@
 
     // Multi-vendor (EXT) extensions
     mExtensionString += "GL_EXT_read_format_bgra ";
+    mExtensionString += "GL_EXT_robustness ";
 
     if (supportsDXT1Textures())
     {
@@ -3375,6 +3485,7 @@
     }
 
     mExtensionString += "GL_EXT_texture_format_BGRA8888 ";
+    mExtensionString += "GL_EXT_texture_storage ";
 
     // ANGLE-specific extensions
     mExtensionString += "GL_ANGLE_framebuffer_blit ";
@@ -3383,6 +3494,8 @@
         mExtensionString += "GL_ANGLE_framebuffer_multisample ";
     }
 
+    mExtensionString += "GL_ANGLE_pack_reverse_row_order ";
+
     if (supportsDXT3Textures())
     {
         mExtensionString += "GL_ANGLE_texture_compression_dxt3 ";
@@ -3391,6 +3504,8 @@
     {
         mExtensionString += "GL_ANGLE_texture_compression_dxt5 ";
     }
+
+    mExtensionString += "GL_ANGLE_texture_usage ";
     mExtensionString += "GL_ANGLE_translated_shader_source ";
 
     // Other vendor-specific extensions
@@ -3616,8 +3731,8 @@
 
     if (mask & (GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT))
     {
-        DepthStencilbuffer *readDSBuffer = NULL;
-        DepthStencilbuffer *drawDSBuffer = NULL;
+        Renderbuffer *readDSBuffer = NULL;
+        Renderbuffer *drawDSBuffer = NULL;
 
         // We support OES_packed_depth_stencil, and do not support a separately attached depth and stencil buffer, so if we have
         // both a depth and stencil buffer, it will be the same buffer.
@@ -3673,8 +3788,14 @@
 
         if (blitRenderTarget)
         {
-            HRESULT result = mDevice->StretchRect(readFramebuffer->getRenderTarget(), &sourceTrimmedRect, 
-                                                 drawFramebuffer->getRenderTarget(), &destTrimmedRect, D3DTEXF_NONE);
+            IDirect3DSurface9* readRenderTarget = readFramebuffer->getRenderTarget();
+            IDirect3DSurface9* drawRenderTarget = drawFramebuffer->getRenderTarget();
+
+            HRESULT result = mDevice->StretchRect(readRenderTarget, &sourceTrimmedRect, 
+                                                  drawRenderTarget, &destTrimmedRect, D3DTEXF_NONE);
+
+            readRenderTarget->Release();
+            drawRenderTarget->Release();
 
             if (FAILED(result))
             {
@@ -3805,9 +3926,9 @@
 
 extern "C"
 {
-gl::Context *glCreateContext(const egl::Config *config, const gl::Context *shareContext)
+gl::Context *glCreateContext(const egl::Config *config, const gl::Context *shareContext, bool notifyResets, bool robustAccess)
 {
-    return new gl::Context(config, shareContext);
+    return new gl::Context(config, shareContext, notifyResets, robustAccess);
 }
 
 void glDestroyContext(gl::Context *context)
diff -r d713478624d8 gfx/angle/src/libGLESv2/Context.h
--- a/gfx/angle/src/libGLESv2/Context.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/Context.h	Thu Jan 05 10:52:20 2012 +0900
@@ -65,7 +65,7 @@
     MAX_TEXTURE_IMAGE_UNITS = 16,
     MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF = 4,   // For devices supporting vertex texture fetch
     MAX_COMBINED_TEXTURE_IMAGE_UNITS_VTF = MAX_TEXTURE_IMAGE_UNITS + MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF,    
-    MAX_FRAGMENT_UNIFORM_VECTORS_SM2 = 32 - 3,    // Reserve space for dx_Viewport, dx_Depth, and dx_DepthRange. dx_PointOrLines and dx_FrontCCW use separate bool registers.
+    MAX_FRAGMENT_UNIFORM_VECTORS_SM2 = 32 - 3,    // Reserve space for dx_Coord, dx_Depth, and dx_DepthRange. dx_PointOrLines and dx_FrontCCW use separate bool registers.
     MAX_FRAGMENT_UNIFORM_VECTORS_SM3 = 224 - 3,
     MAX_DRAW_BUFFERS = 1,
 
@@ -219,6 +219,7 @@
 
     GLint unpackAlignment;
     GLint packAlignment;
+    bool packReverseRowOrder;
 };
 
 // Helper class to construct and cache vertex declarations
@@ -258,7 +259,7 @@
 class Context
 {
   public:
-    Context(const egl::Config *config, const gl::Context *shareContext);
+    Context(const egl::Config *config, const gl::Context *shareContext, bool notifyResets, bool robustAccess);
 
     ~Context();
 
@@ -266,6 +267,9 @@
 
     void markAllStateDirty();
 
+    virtual void markContextLost();
+    bool isContextLost();
+
     // State manipulation
     void setClearColor(float red, float green, float blue, float alpha);
 
@@ -357,6 +361,9 @@
     void setPackAlignment(GLint alignment);
     GLint getPackAlignment() const;
 
+    void setPackReverseRowOrder(bool reverseRowOrder);
+    bool getPackReverseRowOrder() const;
+
     // These create  and destroy methods are merely pass-throughs to 
     // ResourceManager, which owns these object types
     GLuint createBuffer();
@@ -417,15 +424,15 @@
 
     bool getQueryParameterInfo(GLenum pname, GLenum *type, unsigned int *numParams);
 
-    void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);
+    void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei *bufSize, void* pixels);
     void clear(GLbitfield mask);
     void drawArrays(GLenum mode, GLint first, GLsizei count);
     void drawElements(GLenum mode, GLsizei count, GLenum type, const void *indices);
     void sync(bool block);   // flush/finish
 
 	// Draw the last segment of a line loop
-    void drawClosingLine(unsigned int first, unsigned int last);
-    void drawClosingLine(GLsizei count, GLenum type, const void *indices);
+    void drawClosingLine(unsigned int first, unsigned int last, int minIndex);
+    void drawClosingLine(GLsizei count, GLenum type, const void *indices, int minIndex);
 
     void recordInvalidEnum();
     void recordInvalidValue();
@@ -434,6 +441,8 @@
     void recordInvalidFramebufferOperation();
 
     GLenum getError();
+    GLenum getResetStatus();
+    virtual bool isResetNotificationEnabled();
 
     bool supportsShaderModel3() const;
     int getMaximumVaryingVectors() const;
@@ -452,12 +461,12 @@
     bool supportsDXT1Textures() const;
     bool supportsDXT3Textures() const;
     bool supportsDXT5Textures() const;
-    bool supportsFloatTextures() const;
-    bool supportsFloatLinearFilter() const;
-    bool supportsFloatRenderableTextures() const;
-    bool supportsHalfFloatTextures() const;
-    bool supportsHalfFloatLinearFilter() const;
-    bool supportsHalfFloatRenderableTextures() const;
+    bool supportsFloat32Textures() const;
+    bool supportsFloat32LinearFilter() const;
+    bool supportsFloat32RenderableTextures() const;
+    bool supportsFloat16Textures() const;
+    bool supportsFloat16LinearFilter() const;
+    bool supportsFloat16RenderableTextures() const;
     bool supportsLuminanceTextures() const;
     bool supportsLuminanceAlphaTextures() const;
     bool supports32bitIndices() const;
@@ -531,7 +540,12 @@
     bool mOutOfMemory;
     bool mInvalidFramebufferOperation;
 
+    // Current/lost context flags
     bool mHasBeenCurrent;
+    bool mContextLost;
+    GLenum mResetStatus;
+    GLenum mResetStrategy;
+    bool mRobustAccess;
 
     unsigned int mAppliedTextureSerialPS[MAX_TEXTURE_IMAGE_UNITS];
     unsigned int mAppliedTextureSerialVS[MAX_VERTEX_TEXTURE_IMAGE_UNITS_VTF];
@@ -562,12 +576,12 @@
     bool mSupportsDXT1Textures;
     bool mSupportsDXT3Textures;
     bool mSupportsDXT5Textures;
-    bool mSupportsFloatTextures;
-    bool mSupportsFloatLinearFilter;
-    bool mSupportsFloatRenderableTextures;
-    bool mSupportsHalfFloatTextures;
-    bool mSupportsHalfFloatLinearFilter;
-    bool mSupportsHalfFloatRenderableTextures;
+    bool mSupportsFloat32Textures;
+    bool mSupportsFloat32LinearFilter;
+    bool mSupportsFloat32RenderableTextures;
+    bool mSupportsFloat16Textures;
+    bool mSupportsFloat16LinearFilter;
+    bool mSupportsFloat16RenderableTextures;
     bool mSupportsLuminanceTextures;
     bool mSupportsLuminanceAlphaTextures;
     bool mSupports32bitIndices;
@@ -600,12 +614,12 @@
 extern "C"
 {
 // Exported functions for use by EGL
-gl::Context *glCreateContext(const egl::Config *config, const gl::Context *shareContext);
+gl::Context *glCreateContext(const egl::Config *config, const gl::Context *shareContext, bool notifyResets, bool robustAccess);
 void glDestroyContext(gl::Context *context);
 void glMakeCurrent(gl::Context *context, egl::Display *display, egl::Surface *surface);
 gl::Context *glGetCurrentContext();
 __eglMustCastToProperFunctionPointerType __stdcall glGetProcAddress(const char *procname);
-void __stdcall glBindTexImage(egl::Surface *surface);
+bool __stdcall glBindTexImage(egl::Surface *surface);
 }
 
 #endif   // INCLUDE_CONTEXT_H_
diff -r d713478624d8 gfx/angle/src/libGLESv2/Fence.cpp
--- a/gfx/angle/src/libGLESv2/Fence.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/Fence.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -65,7 +65,7 @@
 
     HRESULT result = mQuery->GetData(NULL, 0, D3DGETDATA_FLUSH);
 
-    if (result == D3DERR_DEVICELOST)
+    if (checkDeviceLost(result))
     {
        return error(GL_OUT_OF_MEMORY, GL_TRUE);
     }
@@ -110,7 +110,7 @@
             
             HRESULT result = mQuery->GetData(NULL, 0, 0);
             
-            if (result == D3DERR_DEVICELOST)
+            if (checkDeviceLost(result))
             {
                 params[0] = GL_TRUE;
                 return error(GL_OUT_OF_MEMORY);
diff -r d713478624d8 gfx/angle/src/libGLESv2/Framebuffer.cpp
--- a/gfx/angle/src/libGLESv2/Framebuffer.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/Framebuffer.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -181,46 +181,19 @@
     return 0;
 }
 
-Colorbuffer *Framebuffer::getColorbuffer()
+Renderbuffer *Framebuffer::getColorbuffer()
 {
-    Renderbuffer *rb = mColorbufferPointer.get();
-
-    if (rb != NULL && rb->isColorbuffer())
-    {
-        return static_cast<Colorbuffer*>(rb->getStorage());
-    }
-    else
-    {
-        return NULL;
-    }
+    return mColorbufferPointer.get();
 }
 
-DepthStencilbuffer *Framebuffer::getDepthbuffer()
+Renderbuffer *Framebuffer::getDepthbuffer()
 {
-    Renderbuffer *rb = mDepthbufferPointer.get();
-
-    if (rb != NULL && rb->isDepthbuffer())
-    {
-        return static_cast<DepthStencilbuffer*>(rb->getStorage());
-    }
-    else
-    {
-        return NULL;
-    }
+    return mDepthbufferPointer.get();
 }
 
-DepthStencilbuffer *Framebuffer::getStencilbuffer()
+Renderbuffer *Framebuffer::getStencilbuffer()
 {
-    Renderbuffer *rb = mStencilbufferPointer.get();
-
-    if (rb != NULL && rb->isStencilbuffer())
-    {
-        return static_cast<DepthStencilbuffer*>(rb->getStorage());
-    }
-    else
-    {
-        return NULL;
-    }
+    return mStencilbufferPointer.get();
 }
 
 GLenum Framebuffer::getColorbufferType()
@@ -257,7 +230,7 @@
 {
     if (mStencilbufferType != GL_NONE)
     {
-        DepthStencilbuffer *stencilbufferObject = getStencilbuffer();
+        Renderbuffer *stencilbufferObject = getStencilbuffer();
 
         if (stencilbufferObject)
         {
@@ -276,7 +249,7 @@
 
     if (mColorbufferType != GL_NONE)
     {
-        Colorbuffer *colorbuffer = getColorbuffer();
+        Renderbuffer *colorbuffer = getColorbuffer();
 
         if (!colorbuffer)
         {
@@ -302,8 +275,8 @@
                 return GL_FRAMEBUFFER_UNSUPPORTED;
             }
 
-            if ((colorbuffer->getType() == GL_FLOAT && !getContext()->supportsFloatRenderableTextures()) || 
-                (colorbuffer->getType() == GL_HALF_FLOAT_OES && !getContext()->supportsHalfFloatRenderableTextures()))
+            if ((dx2es::IsFloat32Format(colorbuffer->getD3DFormat()) && !getContext()->supportsFloat32RenderableTextures()) || 
+                (dx2es::IsFloat16Format(colorbuffer->getD3DFormat()) && !getContext()->supportsFloat16RenderableTextures()))
             {
                 return GL_FRAMEBUFFER_UNSUPPORTED;
             }
@@ -324,8 +297,8 @@
         return GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
     }
 
-    DepthStencilbuffer *depthbuffer = NULL;
-    DepthStencilbuffer *stencilbuffer = NULL;
+    Renderbuffer *depthbuffer = NULL;
+    Renderbuffer *stencilbuffer = NULL;
 
     if (mDepthbufferType != GL_NONE)
     {
@@ -418,17 +391,17 @@
     return GL_FRAMEBUFFER_COMPLETE;
 }
 
-DefaultFramebuffer::DefaultFramebuffer(Colorbuffer *color, DepthStencilbuffer *depthStencil)
+DefaultFramebuffer::DefaultFramebuffer(Colorbuffer *colorbuffer, DepthStencilbuffer *depthStencil)
 {
-    mColorbufferType = GL_RENDERBUFFER;
-    mDepthbufferType = (depthStencil->getDepthSize() != 0) ? GL_RENDERBUFFER : GL_NONE;
-    mStencilbufferType = (depthStencil->getStencilSize() != 0) ? GL_RENDERBUFFER : GL_NONE;
-
-    mColorbufferPointer.set(new Renderbuffer(0, color));
+    mColorbufferPointer.set(new Renderbuffer(0, colorbuffer));
 
     Renderbuffer *depthStencilRenderbuffer = new Renderbuffer(0, depthStencil);
     mDepthbufferPointer.set(depthStencilRenderbuffer);
     mStencilbufferPointer.set(depthStencilRenderbuffer);
+
+    mColorbufferType = GL_RENDERBUFFER;
+    mDepthbufferType = (depthStencilRenderbuffer->getDepthSize() != 0) ? GL_RENDERBUFFER : GL_NONE;
+    mStencilbufferType = (depthStencilRenderbuffer->getStencilSize() != 0) ? GL_RENDERBUFFER : GL_NONE;
 }
 
 int Framebuffer::getSamples()
diff -r d713478624d8 gfx/angle/src/libGLESv2/Framebuffer.h
--- a/gfx/angle/src/libGLESv2/Framebuffer.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/Framebuffer.h	Thu Jan 05 10:52:20 2012 +0900
@@ -46,9 +46,9 @@
     unsigned int getDepthbufferSerial();
     unsigned int getStencilbufferSerial();
 
-    Colorbuffer *getColorbuffer();
-    DepthStencilbuffer *getDepthbuffer();
-    DepthStencilbuffer *getStencilbuffer();
+    Renderbuffer *getColorbuffer();
+    Renderbuffer *getDepthbuffer();
+    Renderbuffer *getStencilbuffer();
 
     GLenum getColorbufferType();
     GLenum getDepthbufferType();
@@ -82,7 +82,7 @@
 class DefaultFramebuffer : public Framebuffer
 {
   public:
-    DefaultFramebuffer(Colorbuffer *color, DepthStencilbuffer *depthStencil);
+    DefaultFramebuffer(Colorbuffer *colorbuffer, DepthStencilbuffer *depthStencil);
 
     virtual GLenum completeness();
 
diff -r d713478624d8 gfx/angle/src/libGLESv2/Program.cpp
--- a/gfx/angle/src/libGLESv2/Program.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/Program.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -36,7 +36,7 @@
 Uniform::Uniform(GLenum type, const std::string &_name, unsigned int arraySize)
     : type(type), _name(_name), name(Program::undecorateUniform(_name)), arraySize(arraySize)
 {
-    int bytes = UniformTypeSize(type) * arraySize;
+    int bytes = UniformInternalSize(type) * arraySize;
     data = new unsigned char[bytes];
     memset(data, 0, bytes);
     dirty = true;
@@ -560,7 +560,7 @@
     {
         for (int y = 0; y < copyHeight; y++)
         {
-            target[x * targetWidth + y] = value[y * srcWidth + x];
+            target[x * targetWidth + y] = (T)value[y * srcWidth + x];
         }
     }
     // clear unfilled right side
@@ -568,7 +568,7 @@
     {
         for (int x = srcWidth; x < targetWidth; x++)
         {
-            target[y * targetWidth + x] = 0;
+            target[y * targetWidth + x] = (T)0;
         }
     }
     // clear unfilled bottom.
@@ -576,7 +576,7 @@
     {
         for (int x = 0; x < targetWidth; x++)
         {
-            target[y * targetWidth + x] = 0;
+            target[y * targetWidth + x] = (T)0;
         }
     }
 }
@@ -911,7 +911,7 @@
     return true;
 }
 
-bool Program::getUniformfv(GLint location, GLfloat *params)
+bool Program::getUniformfv(GLint location, GLsizei *bufSize, GLfloat *params)
 {
     if (location < 0 || location >= (int)mUniformIndex.size())
     {
@@ -920,6 +920,16 @@
 
     Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
 
+    // sized queries -- ensure the provided buffer is large enough
+    if (bufSize)
+    {
+        int requiredBytes = UniformExternalSize(targetUniform->type);
+        if (*bufSize < requiredBytes)
+        {
+            return false;
+        }
+    }
+
     switch (targetUniform->type)
     {
       case GL_FLOAT_MAT2:
@@ -933,7 +943,7 @@
         break;
       default:
         {
-            unsigned int count = UniformComponentCount(targetUniform->type);
+            unsigned int count = UniformExternalComponentCount(targetUniform->type);
             unsigned int internalCount = UniformInternalComponentCount(targetUniform->type);
 
             switch (UniformComponentType(targetUniform->type))
@@ -970,7 +980,7 @@
     return true;
 }
 
-bool Program::getUniformiv(GLint location, GLint *params)
+bool Program::getUniformiv(GLint location, GLsizei *bufSize, GLint *params)
 {
     if (location < 0 || location >= (int)mUniformIndex.size())
     {
@@ -979,6 +989,16 @@
 
     Uniform *targetUniform = mUniforms[mUniformIndex[location].index];
 
+    // sized queries -- ensure the provided buffer is large enough
+    if (bufSize)
+    {
+        int requiredBytes = UniformExternalSize(targetUniform->type);
+        if (*bufSize < requiredBytes)
+        {
+            return false;
+        }
+    }
+
     switch (targetUniform->type)
     {
       case GL_FLOAT_MAT2:
@@ -998,7 +1018,7 @@
         break;
       default:
         {
-            unsigned int count = UniformComponentCount(targetUniform->type);
+            unsigned int count = UniformExternalComponentCount(targetUniform->type);
             unsigned int internalCount = UniformInternalComponentCount(targetUniform->type);
 
             switch (UniformComponentType(targetUniform->type))
@@ -1580,13 +1600,20 @@
     if (mFragmentShader->mUsesFragCoord)
     {
         mPixelHLSL += "    float rhw = 1.0 / input.gl_FragCoord.w;\n";
-        if (sm3) {
+        
+        if (sm3)
+        {
+            // dx_Coord.y contains the render target height. See Context::applyRenderTarget()
             mPixelHLSL += "    gl_FragCoord.x = input.dx_VPos.x + 0.5;\n"
-                          "    gl_FragCoord.y = 2.0 * dx_Viewport.y - input.dx_VPos.y - 0.5;\n";
-        } else {
-            mPixelHLSL += "    gl_FragCoord.x = (input.gl_FragCoord.x * rhw) * dx_Viewport.x + dx_Viewport.z;\n"
-                          "    gl_FragCoord.y = -(input.gl_FragCoord.y * rhw) * dx_Viewport.y + dx_Viewport.w;\n";
+                          "    gl_FragCoord.y = dx_Coord.y - input.dx_VPos.y - 0.5;\n";
         }
+        else
+        {
+            // dx_Coord contains the viewport width/2, height/2, center.x and center.y. See Context::applyRenderTarget()
+            mPixelHLSL += "    gl_FragCoord.x = (input.gl_FragCoord.x * rhw) * dx_Coord.x + dx_Coord.z;\n"
+                          "    gl_FragCoord.y = -(input.gl_FragCoord.y * rhw) * dx_Coord.y + dx_Coord.w;\n";
+        }
+        
         mPixelHLSL += "    gl_FragCoord.z = (input.gl_FragCoord.z * rhw) * dx_Depth.x + dx_Depth.y;\n"
                       "    gl_FragCoord.w = rhw;\n";
     }
@@ -1712,7 +1739,7 @@
             // are reserved prefixes, and do not receive additional decoration
             mDxDepthRangeLocation = getUniformLocation("dx_DepthRange");
             mDxDepthLocation = getUniformLocation("dx_Depth");
-            mDxViewportLocation = getUniformLocation("dx_Viewport");
+            mDxCoordLocation = getUniformLocation("dx_Coord");
             mDxHalfPixelSizeLocation = getUniformLocation("dx_HalfPixelSize");
             mDxFrontCCWLocation = getUniformLocation("dx_FrontCCW");
             mDxPointsOrLinesLocation = getUniformLocation("dx_PointsOrLines");
@@ -1834,10 +1861,15 @@
 {
     if (constantDescription.RegisterSet == D3DXRS_SAMPLER)
     {
-        for (unsigned int samplerIndex = constantDescription.RegisterIndex; samplerIndex < constantDescription.RegisterIndex + constantDescription.RegisterCount; samplerIndex++)
+        for (unsigned int i = 0; i < constantDescription.RegisterCount; i++)
         {
-            if (mConstantTablePS->GetConstantByName(NULL, constantDescription.Name) != NULL)
+            D3DXHANDLE psConstant = mConstantTablePS->GetConstantByName(NULL, constantDescription.Name);
+            D3DXHANDLE vsConstant = mConstantTableVS->GetConstantByName(NULL, constantDescription.Name);
+
+            if (psConstant)
             {
+                unsigned int samplerIndex = mConstantTablePS->GetSamplerIndex(psConstant) + i;
+
                 if (samplerIndex < MAX_TEXTURE_IMAGE_UNITS)
                 {
                     mSamplersPS[samplerIndex].active = true;
@@ -1852,8 +1884,10 @@
                 }
             }
             
-            if (mConstantTableVS->GetConstantByName(NULL, constantDescription.Name) != NULL)
+            if (vsConstant)
             {
+                unsigned int samplerIndex = mConstantTableVS->GetSamplerIndex(vsConstant) + i;
+
                 if (samplerIndex < getContext()->getMaximumVertexTextureImageUnits())
                 {
                     mSamplersVS[samplerIndex].active = true;
@@ -2393,7 +2427,7 @@
 
     mDxDepthRangeLocation = -1;
     mDxDepthLocation = -1;
-    mDxViewportLocation = -1;
+    mDxCoordLocation = -1;
     mDxHalfPixelSizeLocation = -1;
     mDxFrontCCWLocation = -1;
     mDxPointsOrLinesLocation = -1;
@@ -2814,9 +2848,9 @@
     return mDxDepthLocation;
 }
 
-GLint Program::getDxViewportLocation() const
+GLint Program::getDxCoordLocation() const
 {
-    return mDxViewportLocation;
+    return mDxCoordLocation;
 }
 
 GLint Program::getDxHalfPixelSizeLocation() const
diff -r d713478624d8 gfx/angle/src/libGLESv2/Program.h
--- a/gfx/angle/src/libGLESv2/Program.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/Program.h	Thu Jan 05 10:52:20 2012 +0900
@@ -98,12 +98,12 @@
     bool setUniform3iv(GLint location, GLsizei count, const GLint *v);
     bool setUniform4iv(GLint location, GLsizei count, const GLint *v);
 
-    bool getUniformfv(GLint location, GLfloat *params);
-    bool getUniformiv(GLint location, GLint *params);
+    bool getUniformfv(GLint location, GLsizei *bufSize, GLfloat *params);
+    bool getUniformiv(GLint location, GLsizei *bufSize, GLint *params);
 
     GLint getDxDepthRangeLocation() const;
     GLint getDxDepthLocation() const;
-    GLint getDxViewportLocation() const;
+    GLint getDxCoordLocation() const;
     GLint getDxHalfPixelSizeLocation() const;
     GLint getDxFrontCCWLocation() const;
     GLint getDxPointsOrLinesLocation() const;
@@ -207,7 +207,7 @@
 
     GLint mDxDepthRangeLocation;
     GLint mDxDepthLocation;
-    GLint mDxViewportLocation;
+    GLint mDxCoordLocation;
     GLint mDxHalfPixelSizeLocation;
     GLint mDxFrontCCWLocation;
     GLint mDxPointsOrLinesLocation;
diff -r d713478624d8 gfx/angle/src/libGLESv2/Renderbuffer.cpp
--- a/gfx/angle/src/libGLESv2/Renderbuffer.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/Renderbuffer.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -18,103 +18,175 @@
 {
 unsigned int RenderbufferStorage::mCurrentSerial = 1;
 
-Renderbuffer::Renderbuffer(GLuint id, RenderbufferStorage *storage) : RefCountObject(id)
+RenderbufferInterface::RenderbufferInterface()
 {
-    ASSERT(storage != NULL);
-    mStorage = storage;
+}
+
+GLuint RenderbufferInterface::getRedSize() const
+{
+    return dx2es::GetRedSize(getD3DFormat());
+}
+
+GLuint RenderbufferInterface::getGreenSize() const
+{
+    return dx2es::GetGreenSize(getD3DFormat());
+}
+
+GLuint RenderbufferInterface::getBlueSize() const
+{
+    return dx2es::GetBlueSize(getD3DFormat());
+}
+
+GLuint RenderbufferInterface::getAlphaSize() const
+{
+    return dx2es::GetAlphaSize(getD3DFormat());
+}
+
+GLuint RenderbufferInterface::getDepthSize() const
+{
+    return dx2es::GetDepthSize(getD3DFormat());
+}
+
+GLuint RenderbufferInterface::getStencilSize() const
+{
+    return dx2es::GetStencilSize(getD3DFormat());
+}
+
+RenderbufferTexture::RenderbufferTexture(Texture *texture, GLenum target) : mTexture(texture), mTarget(target)
+{
+}
+
+RenderbufferTexture::~RenderbufferTexture()
+{
+}
+
+IDirect3DSurface9 *RenderbufferTexture::getRenderTarget()
+{
+    return mTexture->getRenderTarget(mTarget);
+}
+
+IDirect3DSurface9 *RenderbufferTexture::getDepthStencil()
+{
+    return NULL;
+}
+
+GLsizei RenderbufferTexture::getWidth() const
+{
+    return mTexture->getWidth(0);
+}
+ 
+GLsizei RenderbufferTexture::getHeight() const
+{
+    return mTexture->getHeight(0);
+}
+ 
+GLenum RenderbufferTexture::getInternalFormat() const
+{
+    return mTexture->getInternalFormat();
+}
+
+D3DFORMAT RenderbufferTexture::getD3DFormat() const
+{
+    return mTexture->getD3DFormat();
+}
+
+GLsizei RenderbufferTexture::getSamples() const
+{
+    return 0;
+}
+
+unsigned int RenderbufferTexture::getSerial() const
+{
+    return mTexture->getRenderTargetSerial(mTarget);
+}
+
+Renderbuffer::Renderbuffer(GLuint id, RenderbufferInterface *instance) : RefCountObject(id)
+{
+    ASSERT(instance != NULL);
+    mInstance = instance;
 }
 
 Renderbuffer::~Renderbuffer()
 {
-    delete mStorage;
-}
-
-bool Renderbuffer::isColorbuffer() const
-{
-    return mStorage->isColorbuffer();
-}
-
-bool Renderbuffer::isDepthbuffer() const
-{
-    return mStorage->isDepthbuffer();
-}
-
-bool Renderbuffer::isStencilbuffer() const
-{
-    return mStorage->isStencilbuffer();
+    delete mInstance;
 }
 
 IDirect3DSurface9 *Renderbuffer::getRenderTarget()
 {
-    return mStorage->getRenderTarget();
+    return mInstance->getRenderTarget();
 }
 
 IDirect3DSurface9 *Renderbuffer::getDepthStencil()
 {
-    return mStorage->getDepthStencil();
+    return mInstance->getDepthStencil();
 }
 
 GLsizei Renderbuffer::getWidth() const
 {
-    return mStorage->getWidth();
+    return mInstance->getWidth();
 }
 
 GLsizei Renderbuffer::getHeight() const
 {
-    return mStorage->getHeight();
+    return mInstance->getHeight();
 }
 
 GLenum Renderbuffer::getInternalFormat() const
 {
-    return mStorage->getInternalFormat();
+    return mInstance->getInternalFormat();
+}
+
+D3DFORMAT Renderbuffer::getD3DFormat() const
+{
+    return mInstance->getD3DFormat();
 }
 
 GLuint Renderbuffer::getRedSize() const
 {
-    return mStorage->getRedSize();
+    return mInstance->getRedSize();
 }
 
 GLuint Renderbuffer::getGreenSize() const
 {
-    return mStorage->getGreenSize();
+    return mInstance->getGreenSize();
 }
 
 GLuint Renderbuffer::getBlueSize() const
 {
-    return mStorage->getBlueSize();
+    return mInstance->getBlueSize();
 }
 
 GLuint Renderbuffer::getAlphaSize() const
 {
-    return mStorage->getAlphaSize();
+    return mInstance->getAlphaSize();
 }
 
 GLuint Renderbuffer::getDepthSize() const
 {
-    return mStorage->getDepthSize();
+    return mInstance->getDepthSize();
 }
 
 GLuint Renderbuffer::getStencilSize() const
 {
-    return mStorage->getStencilSize();
+    return mInstance->getStencilSize();
 }
 
 GLsizei Renderbuffer::getSamples() const
 {
-    return mStorage->getSamples();
+    return mInstance->getSamples();
 }
 
 unsigned int Renderbuffer::getSerial() const
 {
-    return mStorage->getSerial();
+    return mInstance->getSerial();
 }
 
 void Renderbuffer::setStorage(RenderbufferStorage *newStorage)
 {
     ASSERT(newStorage != NULL);
 
-    delete mStorage;
-    mStorage = newStorage;
+    delete mInstance;
+    mInstance = newStorage;
 }
 
 RenderbufferStorage::RenderbufferStorage() : mSerial(issueSerial())
@@ -130,21 +202,6 @@
 {
 }
 
-bool RenderbufferStorage::isColorbuffer() const
-{
-    return false;
-}
-
-bool RenderbufferStorage::isDepthbuffer() const
-{
-    return false;
-}
-
-bool RenderbufferStorage::isStencilbuffer() const
-{
-    return false;
-}
-
 IDirect3DSurface9 *RenderbufferStorage::getRenderTarget()
 {
     return NULL;
@@ -170,34 +227,9 @@
     return mInternalFormat;
 }
 
-GLuint RenderbufferStorage::getRedSize() const
+D3DFORMAT RenderbufferStorage::getD3DFormat() const
 {
-    return dx2es::GetRedSize(getD3DFormat());
-}
-
-GLuint RenderbufferStorage::getGreenSize() const
-{
-    return dx2es::GetGreenSize(getD3DFormat());
-}
-
-GLuint RenderbufferStorage::getBlueSize() const
-{
-    return dx2es::GetBlueSize(getD3DFormat());
-}
-
-GLuint RenderbufferStorage::getAlphaSize() const
-{
-    return dx2es::GetAlphaSize(getD3DFormat());
-}
-
-GLuint RenderbufferStorage::getDepthSize() const
-{
-    return dx2es::GetDepthSize(getD3DFormat());
-}
-
-GLuint RenderbufferStorage::getStencilSize() const
-{
-    return dx2es::GetStencilSize(getD3DFormat());
+    return mD3DFormat;
 }
 
 GLsizei RenderbufferStorage::getSamples() const
@@ -205,11 +237,6 @@
     return mSamples;
 }
 
-D3DFORMAT RenderbufferStorage::getD3DFormat() const
-{
-    return mD3DFormat;
-}
-
 unsigned int RenderbufferStorage::getSerial() const
 {
     return mSerial;
@@ -220,7 +247,14 @@
     return mCurrentSerial++;
 }
 
-Colorbuffer::Colorbuffer(IDirect3DSurface9 *renderTarget) : mRenderTarget(renderTarget), mTexture(NULL)
+unsigned int RenderbufferStorage::issueCubeSerials()
+{
+    unsigned int firstSerial = mCurrentSerial;
+    mCurrentSerial += 6;
+    return firstSerial;
+}
+
+Colorbuffer::Colorbuffer(IDirect3DSurface9 *renderTarget) : mRenderTarget(renderTarget)
 {
     if (renderTarget)
     {
@@ -237,21 +271,7 @@
     }
 }
 
-Colorbuffer::Colorbuffer(Texture *texture, GLenum target) : mRenderTarget(NULL), mTexture(texture), mTarget(target)
-{
-    if (texture)
-    {
-        mWidth = texture->getWidth();
-        mHeight = texture->getHeight();
-        mInternalFormat = texture->getInternalFormat();
-        mD3DFormat = texture->getD3DFormat();
-        mSamples = 0;
-
-        mRenderTarget = texture->getRenderTarget(target);
-    }
-}
-
-Colorbuffer::Colorbuffer(int width, int height, GLenum format, GLsizei samples) : mRenderTarget(NULL), mTexture(NULL)
+Colorbuffer::Colorbuffer(int width, int height, GLenum format, GLsizei samples) : mRenderTarget(NULL)
 {
     IDirect3DDevice9 *device = getDevice();
 
@@ -295,71 +315,11 @@
     }
 }
 
-GLsizei Colorbuffer::getWidth() const
-{
-    if (mTexture)
-    {
-        return mTexture->getWidth();
-    }
-
-    return mWidth;
-}
-
-GLsizei Colorbuffer::getHeight() const
-{
-    if (mTexture)
-    {
-        return mTexture->getHeight();
-    }
-
-    return mHeight;
-}
-
-GLenum Colorbuffer::getInternalFormat() const
-{
-    if (mTexture)
-    {
-        return mTexture->getInternalFormat();
-    }
-
-    return mInternalFormat;
-}
-
-GLenum Colorbuffer::getType() const
-{
-    if (mTexture)
-    {
-        return mTexture->getType();
-    }
-
-    return GL_UNSIGNED_BYTE;
-}
-
-D3DFORMAT Colorbuffer::getD3DFormat() const
-{
-    if (mTexture)
-    {
-        return mTexture->getD3DFormat();
-    }
-
-    return mD3DFormat;
-}
-
-bool Colorbuffer::isColorbuffer() const
-{
-    return true;
-}
-
 IDirect3DSurface9 *Colorbuffer::getRenderTarget()
 {
-    if (mTexture)
+    if (mRenderTarget)
     {
-        if (mRenderTarget)
-        {
-            mRenderTarget->Release();
-        }
-
-        mRenderTarget = mTexture->getRenderTarget(mTarget);
+        mRenderTarget->AddRef();
     }
 
     return mRenderTarget;
@@ -427,16 +387,6 @@
     }
 }
 
-bool DepthStencilbuffer::isDepthbuffer() const
-{
-    return true;
-}
-
-bool DepthStencilbuffer::isStencilbuffer() const
-{
-    return true;
-}
-
 IDirect3DSurface9 *DepthStencilbuffer::getDepthStencil()
 {
     return mDepthStencil;
@@ -454,7 +404,7 @@
 
 Depthbuffer::Depthbuffer(int width, int height, GLsizei samples) : DepthStencilbuffer(width, height, samples)
 {
-    if (getDepthStencil())
+    if (mDepthStencil)
     {
         mInternalFormat = GL_DEPTH_COMPONENT16;   // If the renderbuffer parameters are queried, the calling function
                                                   // will expect one of the valid renderbuffer formats for use in 
@@ -466,16 +416,6 @@
 {
 }
 
-bool Depthbuffer::isDepthbuffer() const
-{
-    return true;
-}
-
-bool Depthbuffer::isStencilbuffer() const
-{
-    return false;
-}
-
 Stencilbuffer::Stencilbuffer(IDirect3DSurface9 *depthStencil) : DepthStencilbuffer(depthStencil)
 {
     if (depthStencil)
@@ -488,7 +428,7 @@
 
 Stencilbuffer::Stencilbuffer(int width, int height, GLsizei samples) : DepthStencilbuffer(width, height, samples)
 {
-    if (getDepthStencil())
+    if (mDepthStencil)
     {
         mInternalFormat = GL_STENCIL_INDEX8;   // If the renderbuffer parameters are queried, the calling function
                                                // will expect one of the valid renderbuffer formats for use in 
@@ -500,13 +440,4 @@
 {
 }
 
-bool Stencilbuffer::isDepthbuffer() const
-{
-    return false;
 }
-
-bool Stencilbuffer::isStencilbuffer() const
-{
-    return true;
-}
-}
diff -r d713478624d8 gfx/angle/src/libGLESv2/Renderbuffer.h
--- a/gfx/angle/src/libGLESv2/Renderbuffer.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/Renderbuffer.h	Thu Jan 05 10:52:20 2012 +0900
@@ -22,38 +22,86 @@
 namespace gl
 {
 class Texture;
+class Colorbuffer;
+class DepthStencilbuffer;
+
+class RenderbufferInterface
+{
+  public:
+    RenderbufferInterface();
+
+    virtual ~RenderbufferInterface() {};
+
+    virtual IDirect3DSurface9 *getRenderTarget() = 0;
+    virtual IDirect3DSurface9 *getDepthStencil() = 0;
+
+    virtual GLsizei getWidth() const = 0;
+    virtual GLsizei getHeight() const = 0;
+    virtual GLenum getInternalFormat() const = 0;
+    virtual D3DFORMAT getD3DFormat() const = 0;
+    virtual GLsizei getSamples() const = 0;
+
+    GLuint getRedSize() const;
+    GLuint getGreenSize() const;
+    GLuint getBlueSize() const;
+    GLuint getAlphaSize() const;
+    GLuint getDepthSize() const;
+    GLuint getStencilSize() const;
+
+    virtual unsigned int getSerial() const = 0;
+
+  private:
+    DISALLOW_COPY_AND_ASSIGN(RenderbufferInterface);
+};
+
+class RenderbufferTexture : public RenderbufferInterface
+{
+  public:
+    RenderbufferTexture(Texture *texture, GLenum target);
+
+    virtual ~RenderbufferTexture();
+
+    IDirect3DSurface9 *getRenderTarget();
+    IDirect3DSurface9 *getDepthStencil();
+
+    virtual GLsizei getWidth() const;
+    virtual GLsizei getHeight() const;
+    virtual GLenum getInternalFormat() const;
+    virtual D3DFORMAT getD3DFormat() const;
+    virtual GLsizei getSamples() const;
+
+    virtual unsigned int getSerial() const;
+
+  private:
+    DISALLOW_COPY_AND_ASSIGN(RenderbufferTexture);
+
+    Texture *mTexture;
+    GLenum mTarget;
+};
 
 // A class derived from RenderbufferStorage is created whenever glRenderbufferStorage
 // is called. The specific concrete type depends on whether the internal format is
 // colour depth, stencil or packed depth/stencil.
-class RenderbufferStorage
+class RenderbufferStorage : public RenderbufferInterface
 {
   public:
     RenderbufferStorage();
 
     virtual ~RenderbufferStorage() = 0;
 
-    virtual bool isColorbuffer() const;
-    virtual bool isDepthbuffer() const;
-    virtual bool isStencilbuffer() const;
-
     virtual IDirect3DSurface9 *getRenderTarget();
     virtual IDirect3DSurface9 *getDepthStencil();
 
     virtual GLsizei getWidth() const;
     virtual GLsizei getHeight() const;
     virtual GLenum getInternalFormat() const;
-    GLuint getRedSize() const;
-    GLuint getGreenSize() const;
-    GLuint getBlueSize() const;
-    GLuint getAlphaSize() const;
-    GLuint getDepthSize() const;
-    GLuint getStencilSize() const;
+    virtual D3DFORMAT getD3DFormat() const;
     virtual GLsizei getSamples() const;
 
-    virtual D3DFORMAT getD3DFormat() const;
+    virtual unsigned int getSerial() const;
 
-    unsigned int getSerial() const;
+    static unsigned int issueSerial();
+    static unsigned int issueCubeSerials();
 
   protected:
     GLsizei mWidth;
@@ -65,26 +113,20 @@
   private:
     DISALLOW_COPY_AND_ASSIGN(RenderbufferStorage);
 
-    static unsigned int issueSerial();
-
     const unsigned int mSerial;
 
     static unsigned int mCurrentSerial;
 };
 
 // Renderbuffer implements the GL renderbuffer object.
-// It's only a proxy for a RenderbufferStorage instance; the internal object
+// It's only a proxy for a RenderbufferInterface instance; the internal object
 // can change whenever glRenderbufferStorage is called.
 class Renderbuffer : public RefCountObject
 {
   public:
-    Renderbuffer(GLuint id, RenderbufferStorage *storage);
+    Renderbuffer(GLuint id, RenderbufferInterface *storage);
 
-    ~Renderbuffer();
-
-    bool isColorbuffer() const;
-    bool isDepthbuffer() const;
-    bool isStencilbuffer() const;
+    virtual ~Renderbuffer();
 
     IDirect3DSurface9 *getRenderTarget();
     IDirect3DSurface9 *getDepthStencil();
@@ -104,40 +146,27 @@
     unsigned int getSerial() const;
 
     void setStorage(RenderbufferStorage *newStorage);
-    RenderbufferStorage *getStorage() { return mStorage; }
 
   private:
     DISALLOW_COPY_AND_ASSIGN(Renderbuffer);
 
-    RenderbufferStorage *mStorage;
+    RenderbufferInterface *mInstance;
 };
 
 class Colorbuffer : public RenderbufferStorage
 {
   public:
     explicit Colorbuffer(IDirect3DSurface9 *renderTarget);
-    Colorbuffer(Texture *texture, GLenum target);
     Colorbuffer(GLsizei width, GLsizei height, GLenum format, GLsizei samples);
 
     virtual ~Colorbuffer();
 
-    virtual bool isColorbuffer() const;
-
     virtual IDirect3DSurface9 *getRenderTarget();
 
-    virtual GLsizei getWidth() const;
-    virtual GLsizei getHeight() const;
-    virtual GLenum getInternalFormat() const;
-    virtual GLenum getType() const;
-
-    virtual D3DFORMAT getD3DFormat() const;
-
   private:
     DISALLOW_COPY_AND_ASSIGN(Colorbuffer);
 
     IDirect3DSurface9 *mRenderTarget;
-    Texture *mTexture;
-    GLenum mTarget;
 };
 
 class DepthStencilbuffer : public RenderbufferStorage
@@ -148,14 +177,13 @@
 
     ~DepthStencilbuffer();
 
-    virtual bool isDepthbuffer() const;
-    virtual bool isStencilbuffer() const;
+    virtual IDirect3DSurface9 *getDepthStencil();
 
-    virtual IDirect3DSurface9 *getDepthStencil();
+  protected:
+    IDirect3DSurface9 *mDepthStencil;
 
   private:
     DISALLOW_COPY_AND_ASSIGN(DepthStencilbuffer);
-    IDirect3DSurface9 *mDepthStencil;
 };
 
 class Depthbuffer : public DepthStencilbuffer
@@ -166,9 +194,6 @@
 
     virtual ~Depthbuffer();
 
-    virtual bool isDepthbuffer() const;
-    virtual bool isStencilbuffer() const;
-
   private:
     DISALLOW_COPY_AND_ASSIGN(Depthbuffer);
 };
@@ -181,9 +206,6 @@
 
     virtual ~Stencilbuffer();
 
-    virtual bool isDepthbuffer() const;
-    virtual bool isStencilbuffer() const;
-
   private:
     DISALLOW_COPY_AND_ASSIGN(Stencilbuffer);
 };
diff -r d713478624d8 gfx/angle/src/libGLESv2/Texture.cpp
--- a/gfx/angle/src/libGLESv2/Texture.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/Texture.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -33,44 +33,9 @@
 
 namespace gl
 {
-unsigned int Texture::mCurrentSerial = 1;
-
-Texture::Image::Image()
-  : width(0), height(0), dirty(false), surface(NULL), format(GL_NONE), type(GL_UNSIGNED_BYTE)
-{
-}
-
-Texture::Image::~Image()
-{
-    if (surface)
-    {
-        surface->Release();
-    }
-}
-
-bool Texture::Image::isRenderable() const
-{    
-    switch(getD3DFormat())
-    {
-      case D3DFMT_L8:
-      case D3DFMT_A8L8:
-      case D3DFMT_DXT1:
-      case D3DFMT_DXT3:
-      case D3DFMT_DXT5:
-        return false;
-      case D3DFMT_A8R8G8B8:
-      case D3DFMT_X8R8G8B8:
-      case D3DFMT_A16B16G16R16F:
-      case D3DFMT_A32B32G32R32F:
-        return true;
-      default:
-        UNREACHABLE();
-    }
-
-    return false;
-}
-
-D3DFORMAT Texture::Image::getD3DFormat() const
+unsigned int TextureStorage::mCurrentTextureSerial = 1;
+
+static D3DFORMAT ConvertTextureFormatType(GLenum format, GLenum type)
 {
     if (format == GL_COMPRESSED_RGB_S3TC_DXT1_EXT ||
         format == GL_COMPRESSED_RGBA_S3TC_DXT1_EXT)
@@ -114,243 +79,324 @@
     return D3DFMT_A8R8G8B8;
 }
 
-Texture::Texture(GLuint id) : RefCountObject(id), mSerial(issueSerial())
+static bool IsTextureFormatRenderable(D3DFORMAT format)
 {
-    mMinFilter = GL_NEAREST_MIPMAP_LINEAR;
-    mMagFilter = GL_LINEAR;
-    mWrapS = GL_REPEAT;
-    mWrapT = GL_REPEAT;
-    mDirtyParameter = true;
-    
-    mDirtyImage = true;
-    
-    mIsRenderable = false;
+    switch(format)
+    {
+      case D3DFMT_L8:
+      case D3DFMT_A8L8:
+      case D3DFMT_DXT1:
+      case D3DFMT_DXT3:
+      case D3DFMT_DXT5:
+        return false;
+      case D3DFMT_A8R8G8B8:
+      case D3DFMT_X8R8G8B8:
+      case D3DFMT_A16B16G16R16F:
+      case D3DFMT_A32B32G32R32F:
+        return true;
+      default:
+        UNREACHABLE();
+    }
+
+    return false;
 }
 
-Texture::~Texture()
+Image::Image()
 {
+    mWidth = 0; 
+    mHeight = 0;
+    mFormat = GL_NONE;
+    mType = GL_UNSIGNED_BYTE;
+
+    mSurface = NULL;
+
+    mDirty = false;
+
+    mD3DPool = D3DPOOL_SYSTEMMEM;
+    mD3DFormat = D3DFMT_UNKNOWN;
 }
 
-Blit *Texture::getBlitter()
+Image::~Image()
 {
-    Context *context = getContext();
-    return context->getBlitter();
-}
-
-// Returns true on successful filter state update (valid enum parameter)
-bool Texture::setMinFilter(GLenum filter)
-{
-    switch (filter)
+    if (mSurface)
     {
-      case GL_NEAREST:
-      case GL_LINEAR:
-      case GL_NEAREST_MIPMAP_NEAREST:
-      case GL_LINEAR_MIPMAP_NEAREST:
-      case GL_NEAREST_MIPMAP_LINEAR:
-      case GL_LINEAR_MIPMAP_LINEAR:
-        {
-            if (mMinFilter != filter)
-            {
-                mMinFilter = filter;
-                mDirtyParameter = true;
-            }
-            return true;
-        }
-      default:
-        return false;
+        mSurface->Release();
     }
 }
 
-// Returns true on successful filter state update (valid enum parameter)
-bool Texture::setMagFilter(GLenum filter)
+bool Image::redefine(GLenum format, GLsizei width, GLsizei height, GLenum type, bool forceRelease)
 {
-    switch (filter)
+    if (mWidth != width ||
+        mHeight != height ||
+        mFormat != format ||
+        mType != type ||
+        forceRelease)
     {
-      case GL_NEAREST:
-      case GL_LINEAR:
+        mWidth = width;
+        mHeight = height;
+        mFormat = format;
+        mType = type;
+        // compute the d3d format that will be used
+        mD3DFormat = ConvertTextureFormatType(mFormat, mType);
+
+        if (mSurface)
         {
-            if (mMagFilter != filter)
+            mSurface->Release();
+            mSurface = NULL;
+        }
+
+        return true;
+    }
+
+    return false;
+}
+
+void Image::createSurface()
+{
+    if(mSurface)
+    {
+        return;
+    }
+
+    IDirect3DTexture9 *newTexture = NULL;
+    IDirect3DSurface9 *newSurface = NULL;
+    const D3DPOOL poolToUse = D3DPOOL_SYSTEMMEM;
+
+    if (mWidth != 0 && mHeight != 0)
+    {
+        int levelToFetch = 0;
+        GLsizei requestWidth = mWidth;
+        GLsizei requestHeight = mHeight;
+        if (IsCompressed(mFormat) && (mWidth % 4 != 0 || mHeight % 4 != 0))
+        {
+            bool isMult4 = false;
+            int upsampleCount = 0;
+            while (!isMult4)
             {
-                mMagFilter = filter;
-                mDirtyParameter = true;
+                requestWidth <<= 1;
+                requestHeight <<= 1;
+                upsampleCount++;
+                if (requestWidth % 4 == 0 && requestHeight % 4 == 0)
+                {
+                    isMult4 = true;
+                }
             }
-            return true;
+            levelToFetch = upsampleCount;
         }
-      default:
-        return false;
+
+        HRESULT result = getDevice()->CreateTexture(requestWidth, requestHeight, levelToFetch + 1, NULL, getD3DFormat(),
+                                                    poolToUse, &newTexture, NULL);
+
+        if (FAILED(result))
+        {
+            ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
+            ERR("Creating image surface failed.");
+            return error(GL_OUT_OF_MEMORY);
+        }
+
+        newTexture->GetSurfaceLevel(levelToFetch, &newSurface);
+        newTexture->Release();
+    }
+
+    mSurface = newSurface;
+    mDirty = false;
+    mD3DPool = poolToUse;
+}
+
+HRESULT Image::lock(D3DLOCKED_RECT *lockedRect, const RECT *rect)
+{
+    createSurface();
+
+    HRESULT result = D3DERR_INVALIDCALL;
+
+    if (mSurface)
+    {
+        result = mSurface->LockRect(lockedRect, rect, 0);
+        ASSERT(SUCCEEDED(result));
+
+        mDirty = true;
+    }
+
+    return result;
+}
+
+void Image::unlock()
+{
+    if (mSurface)
+    {
+        HRESULT result = mSurface->UnlockRect();
+        ASSERT(SUCCEEDED(result));
     }
 }
 
-// Returns true on successful wrap state update (valid enum parameter)
-bool Texture::setWrapS(GLenum wrap)
+bool Image::isRenderableFormat() const
+{    
+    return IsTextureFormatRenderable(getD3DFormat());
+}
+
+D3DFORMAT Image::getD3DFormat() const
 {
-    switch (wrap)
+    // this should only happen if the image hasn't been redefined first
+    // which would be a bug by the caller
+    ASSERT(mD3DFormat != D3DFMT_UNKNOWN);
+
+    return mD3DFormat;
+}
+
+IDirect3DSurface9 *Image::getSurface()
+{
+    createSurface();
+
+    return mSurface;
+}
+
+void Image::setManagedSurface(IDirect3DSurface9 *surface)
+{
+    if (mSurface)
     {
-      case GL_REPEAT:
-      case GL_CLAMP_TO_EDGE:
-      case GL_MIRRORED_REPEAT:
+        D3DXLoadSurfaceFromSurface(surface, NULL, NULL, mSurface, NULL, NULL, D3DX_FILTER_BOX, 0);
+        mSurface->Release();
+    }
+
+    D3DSURFACE_DESC desc;
+    surface->GetDesc(&desc);
+    ASSERT(desc.Pool == D3DPOOL_MANAGED);
+
+    mSurface = surface;
+    mD3DPool = desc.Pool;
+}
+
+void Image::updateSurface(IDirect3DSurface9 *destSurface, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height)
+{
+    IDirect3DSurface9 *sourceSurface = getSurface();
+
+    if (sourceSurface != destSurface)
+    {
+        RECT rect = transformPixelRect(xoffset, yoffset, width, height, mHeight);
+
+        if (mD3DPool == D3DPOOL_MANAGED)
         {
-            if (mWrapS != wrap)
-            {
-                mWrapS = wrap;
-                mDirtyParameter = true;
-            }
-            return true;
+            HRESULT result = D3DXLoadSurfaceFromSurface(destSurface, NULL, &rect, sourceSurface, NULL, &rect, D3DX_FILTER_BOX, 0);
+            ASSERT(SUCCEEDED(result));
         }
-      default:
-        return false;
+        else
+        {
+            // UpdateSurface: source must be SYSTEMMEM, dest must be DEFAULT pools 
+            POINT point = {rect.left, rect.top};
+            HRESULT result = getDevice()->UpdateSurface(sourceSurface, &rect, destSurface, &point);
+            ASSERT(SUCCEEDED(result));
+        }
     }
 }
 
-// Returns true on successful wrap state update (valid enum parameter)
-bool Texture::setWrapT(GLenum wrap)
-{
-    switch (wrap)
-    {
-      case GL_REPEAT:
-      case GL_CLAMP_TO_EDGE:
-      case GL_MIRRORED_REPEAT:
-        {
-            if (mWrapT != wrap)
-            {
-                mWrapT = wrap;
-                mDirtyParameter = true;
-            }
-            return true;
-        }
-      default:
-        return false;
-    }
-}
-
-GLenum Texture::getMinFilter() const
-{
-    return mMinFilter;
-}
-
-GLenum Texture::getMagFilter() const
-{
-    return mMagFilter;
-}
-
-GLenum Texture::getWrapS() const
-{
-    return mWrapS;
-}
-
-GLenum Texture::getWrapT() const
-{
-    return mWrapT;
-}
-
 // Store the pixel rectangle designated by xoffset,yoffset,width,height with pixels stored as format/type at input
 // into the target pixel rectangle at output with outputPitch bytes in between each line.
-void Texture::loadImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type,
-                            GLint unpackAlignment, const void *input, size_t outputPitch, void *output, D3DSURFACE_DESC *description) const
+void Image::loadData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum type,
+                     GLint unpackAlignment, const void *input, size_t outputPitch, void *output) const
 {
-    GLsizei inputPitch = -ComputePitch(width, format, type, unpackAlignment);
+    GLsizei inputPitch = -ComputePitch(width, mFormat, type, unpackAlignment);
     input = ((char*)input) - inputPitch * (height - 1);
 
     switch (type)
     {
       case GL_UNSIGNED_BYTE:
-        switch (format)
+        switch (mFormat)
         {
           case GL_ALPHA:
-            loadAlphaImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadAlphaData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           case GL_LUMINANCE:
-            loadLuminanceImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output, description->Format == D3DFMT_L8);
+            loadLuminanceData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output, getD3DFormat() == D3DFMT_L8);
             break;
           case GL_LUMINANCE_ALPHA:
-            loadLuminanceAlphaImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output, description->Format == D3DFMT_A8L8);
+            loadLuminanceAlphaData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output, getD3DFormat() == D3DFMT_A8L8);
             break;
           case GL_RGB:
-            loadRGBUByteImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadRGBUByteData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           case GL_RGBA:
             if (supportsSSE2())
             {
-                loadRGBAUByteImageDataSSE2(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+                loadRGBAUByteDataSSE2(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             }
             else
             {
-                loadRGBAUByteImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+                loadRGBAUByteData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             }
             break;
           case GL_BGRA_EXT:
-            loadBGRAImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadBGRAData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           default: UNREACHABLE();
         }
         break;
       case GL_UNSIGNED_SHORT_5_6_5:
-        switch (format)
+        switch (mFormat)
         {
           case GL_RGB:
-            loadRGB565ImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadRGB565Data(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           default: UNREACHABLE();
         }
         break;
       case GL_UNSIGNED_SHORT_4_4_4_4:
-        switch (format)
+        switch (mFormat)
         {
           case GL_RGBA:
-            loadRGBA4444ImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadRGBA4444Data(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           default: UNREACHABLE();
         }
         break;
       case GL_UNSIGNED_SHORT_5_5_5_1:
-        switch (format)
+        switch (mFormat)
         {
           case GL_RGBA:
-            loadRGBA5551ImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadRGBA5551Data(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           default: UNREACHABLE();
         }
         break;
       case GL_FLOAT:
-        switch (format)
+        switch (mFormat)
         {
           // float textures are converted to RGBA, not BGRA, as they're stored that way in D3D
           case GL_ALPHA:
-            loadAlphaFloatImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadAlphaFloatData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           case GL_LUMINANCE:
-            loadLuminanceFloatImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadLuminanceFloatData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           case GL_LUMINANCE_ALPHA:
-            loadLuminanceAlphaFloatImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadLuminanceAlphaFloatData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           case GL_RGB:
-            loadRGBFloatImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadRGBFloatData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           case GL_RGBA:
-            loadRGBAFloatImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadRGBAFloatData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           default: UNREACHABLE();
         }
         break;
       case GL_HALF_FLOAT_OES:
-        switch (format)
+        switch (mFormat)
         {
           // float textures are converted to RGBA, not BGRA, as they're stored that way in D3D
           case GL_ALPHA:
-            loadAlphaHalfFloatImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadAlphaHalfFloatData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           case GL_LUMINANCE:
-            loadLuminanceHalfFloatImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadLuminanceHalfFloatData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           case GL_LUMINANCE_ALPHA:
-            loadLuminanceAlphaHalfFloatImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadLuminanceAlphaHalfFloatData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           case GL_RGB:
-            loadRGBHalfFloatImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadRGBHalfFloatData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           case GL_RGBA:
-            loadRGBAHalfFloatImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+            loadRGBAHalfFloatData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
             break;
           default: UNREACHABLE();
         }
@@ -359,8 +405,8 @@
     }
 }
 
-void Texture::loadAlphaImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                 int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadAlphaData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                          int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const unsigned char *source = NULL;
     unsigned char *dest = NULL;
@@ -379,8 +425,8 @@
     }
 }
 
-void Texture::loadAlphaFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                      int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadAlphaFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                               int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const float *source = NULL;
     float *dest = NULL;
@@ -399,8 +445,8 @@
     }
 }
 
-void Texture::loadAlphaHalfFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                          int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadAlphaHalfFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                   int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const unsigned short *source = NULL;
     unsigned short *dest = NULL;
@@ -419,8 +465,8 @@
     }
 }
 
-void Texture::loadLuminanceImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                     int inputPitch, const void *input, size_t outputPitch, void *output, bool native) const
+void Image::loadLuminanceData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                              int inputPitch, const void *input, size_t outputPitch, void *output, bool native) const
 {
     const int destBytesPerPixel = native? 1: 4;
     const unsigned char *source = NULL;
@@ -448,8 +494,8 @@
     }
 }
 
-void Texture::loadLuminanceFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                          int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadLuminanceFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                   int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const float *source = NULL;
     float *dest = NULL;
@@ -468,8 +514,8 @@
     }
 }
 
-void Texture::loadLuminanceHalfFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                                   int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadLuminanceHalfFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                       int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const unsigned short *source = NULL;
     unsigned short *dest = NULL;
@@ -488,8 +534,8 @@
     }
 }
 
-void Texture::loadLuminanceAlphaImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                          int inputPitch, const void *input, size_t outputPitch, void *output, bool native) const
+void Image::loadLuminanceAlphaData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                   int inputPitch, const void *input, size_t outputPitch, void *output, bool native) const
 {
     const int destBytesPerPixel = native? 2: 4;
     const unsigned char *source = NULL;
@@ -517,8 +563,8 @@
     }
 }
 
-void Texture::loadLuminanceAlphaFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                               int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadLuminanceAlphaFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                        int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const float *source = NULL;
     float *dest = NULL;
@@ -537,8 +583,8 @@
     }
 }
 
-void Texture::loadLuminanceAlphaHalfFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                                   int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadLuminanceAlphaHalfFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                            int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const unsigned short *source = NULL;
     unsigned short *dest = NULL;
@@ -557,8 +603,8 @@
     }
 }
 
-void Texture::loadRGBUByteImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                    int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadRGBUByteData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                             int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const unsigned char *source = NULL;
     unsigned char *dest = NULL;
@@ -577,8 +623,8 @@
     }
 }
 
-void Texture::loadRGB565ImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                  int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadRGB565Data(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                           int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const unsigned short *source = NULL;
     unsigned char *dest = NULL;
@@ -598,8 +644,8 @@
     }
 }
 
-void Texture::loadRGBFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                    int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadRGBFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                             int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const float *source = NULL;
     float *dest = NULL;
@@ -618,8 +664,8 @@
     }
 }
 
-void Texture::loadRGBHalfFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                        int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadRGBHalfFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                 int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const unsigned short *source = NULL;
     unsigned short *dest = NULL;
@@ -638,8 +684,8 @@
     }
 }
 
-void Texture::loadRGBAUByteImageDataSSE2(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                         int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadRGBAUByteDataSSE2(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                  int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const unsigned int *source = NULL;
     unsigned int *dest = NULL;
@@ -680,8 +726,8 @@
     }
 }
 
-void Texture::loadRGBAUByteImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                     int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadRGBAUByteData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                              int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const unsigned int *source = NULL;
     unsigned int *dest = NULL;
@@ -698,8 +744,8 @@
     }
 }
 
-void Texture::loadRGBA4444ImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                    int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadRGBA4444Data(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                             int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const unsigned short *source = NULL;
     unsigned char *dest = NULL;
@@ -719,8 +765,8 @@
     }
 }
 
-void Texture::loadRGBA5551ImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                    int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadRGBA5551Data(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                             int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const unsigned short *source = NULL;
     unsigned char *dest = NULL;
@@ -740,8 +786,8 @@
     }
 }
 
-void Texture::loadRGBAFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                     int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadRGBAFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                              int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const float *source = NULL;
     float *dest = NULL;
@@ -754,8 +800,8 @@
     }
 }
 
-void Texture::loadRGBAHalfFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                        int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadRGBAHalfFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                  int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const unsigned char *source = NULL;
     unsigned char *dest = NULL;
@@ -768,8 +814,8 @@
     }
 }
 
-void Texture::loadBGRAImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadBGRAData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                         int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     const unsigned char *source = NULL;
     unsigned char *dest = NULL;
@@ -782,18 +828,18 @@
     }
 }
 
-void Texture::loadCompressedImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                      int inputPitch, const void *input, size_t outputPitch, void *output) const {
+void Image::loadCompressedData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                               int inputPitch, const void *input, size_t outputPitch, void *output) const {
     switch (getD3DFormat())
     {
         case D3DFMT_DXT1:
-          loadDXT1ImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+          loadDXT1Data(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
           break;
         case D3DFMT_DXT3:
-          loadDXT3ImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+          loadDXT3Data(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
           break;
         case D3DFMT_DXT5:
-          loadDXT5ImageData(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
+          loadDXT5Data(xoffset, yoffset, width, height, inputPitch, input, outputPitch, output);
           break;
     }
 }
@@ -908,8 +954,8 @@
   FlipCopyDXT1BlockHalf(source + 2, dest + 2);
 }
 
-void Texture::loadDXT1ImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                      int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadDXT1Data(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                         int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     ASSERT(xoffset % 4 == 0);
     ASSERT(yoffset % 4 == 0);
@@ -956,8 +1002,8 @@
     }
 }
 
-void Texture::loadDXT3ImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadDXT3Data(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                         int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     ASSERT(xoffset % 4 == 0);
     ASSERT(yoffset % 4 == 0);
@@ -1006,8 +1052,8 @@
     }
 }
 
-void Texture::loadDXT5ImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                int inputPitch, const void *input, size_t outputPitch, void *output) const
+void Image::loadDXT5Data(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                         int inputPitch, const void *input, size_t outputPitch, void *output) const
 {
     ASSERT(xoffset % 4 == 0);
     ASSERT(yoffset % 4 == 0);
@@ -1056,212 +1102,9 @@
     }
 }
 
-void Texture::createSurface(Image *image)
+// This implements glCopyTex[Sub]Image2D for non-renderable internal texture formats and incomplete textures
+void Image::copy(GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, IDirect3DSurface9 *renderTarget)
 {
-    IDirect3DTexture9 *newTexture = NULL;
-    IDirect3DSurface9 *newSurface = NULL;
-
-    if (image->width != 0 && image->height != 0)
-    {
-        int levelToFetch = 0;
-        GLsizei requestWidth = image->width;
-        GLsizei requestHeight = image->height;
-        if (IsCompressed(image->format) && (image->width % 4 != 0 || image->height % 4 != 0))
-        {
-            bool isMult4 = false;
-            int upsampleCount = 0;
-            while (!isMult4)
-            {
-                requestWidth <<= 1;
-                requestHeight <<= 1;
-                upsampleCount++;
-                if (requestWidth % 4 == 0 && requestHeight % 4 == 0)
-                {
-                    isMult4 = true;
-                }
-            }
-            levelToFetch = upsampleCount;
-        }
-
-        HRESULT result = getDevice()->CreateTexture(requestWidth, requestHeight, levelToFetch + 1, NULL, image->getD3DFormat(),
-                                                    D3DPOOL_SYSTEMMEM, &newTexture, NULL);
-
-        if (FAILED(result))
-        {
-            ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-            return error(GL_OUT_OF_MEMORY);
-        }
-
-        newTexture->GetSurfaceLevel(levelToFetch, &newSurface);
-        newTexture->Release();
-    }
-
-    if (image->surface)
-    {
-        image->surface->Release();
-    }
-
-    image->surface = newSurface;
-}
-
-void Texture::setImage(GLint unpackAlignment, const void *pixels, Image *image)
-{
-    createSurface(image);
-
-    if (pixels != NULL && image->surface != NULL)
-    {
-        D3DSURFACE_DESC description;
-        image->surface->GetDesc(&description);
-
-        D3DLOCKED_RECT locked;
-        HRESULT result = image->surface->LockRect(&locked, NULL, 0);
-
-        ASSERT(SUCCEEDED(result));
-
-        if (SUCCEEDED(result))
-        {
-            loadImageData(0, 0, image->width, image->height, image->format, image->type, unpackAlignment, pixels, locked.Pitch, locked.pBits, &description);
-            image->surface->UnlockRect();
-        }
-
-        image->dirty = true;
-        mDirtyImage = true;
-    }
-}
-
-void Texture::setCompressedImage(GLsizei imageSize, const void *pixels, Image *image)
-{
-    createSurface(image);
-
-    if (pixels != NULL && image->surface != NULL)
-    {
-        D3DLOCKED_RECT locked;
-        HRESULT result = image->surface->LockRect(&locked, NULL, 0);
-
-        ASSERT(SUCCEEDED(result));
-
-        if (SUCCEEDED(result))
-        {
-            int inputPitch = ComputeCompressedPitch(image->width, image->format);
-            int inputSize = ComputeCompressedSize(image->width, image->height, image->format);
-            loadCompressedImageData(0, 0, image->width, image->height, -inputPitch, static_cast<const char*>(pixels) + inputSize - inputPitch, locked.Pitch, locked.pBits);
-            image->surface->UnlockRect();
-        }
-
-        image->dirty = true;
-        mDirtyImage = true;
-    }
-}
-
-bool Texture::subImage(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels, Image *image)
-{
-    if (width + xoffset > image->width || height + yoffset > image->height)
-    {
-        error(GL_INVALID_VALUE);
-        return false;
-    }
-
-    if (IsCompressed(image->format))
-    {
-        error(GL_INVALID_OPERATION);
-        return false;
-    }
-
-    if (format != image->format)
-    {
-        error(GL_INVALID_OPERATION);
-        return false;
-    }
-
-    if (!image->surface)
-    {
-        createSurface(image);
-    }
-
-    if (pixels != NULL && image->surface != NULL)
-    {
-        D3DSURFACE_DESC description;
-        image->surface->GetDesc(&description);
-
-        D3DLOCKED_RECT locked;
-        HRESULT result = image->surface->LockRect(&locked, NULL, 0);
-
-        ASSERT(SUCCEEDED(result));
-
-        if (SUCCEEDED(result))
-        {
-            loadImageData(xoffset, transformPixelYOffset(yoffset, height, image->height), width, height, format, type, unpackAlignment, pixels, locked.Pitch, locked.pBits, &description);
-            image->surface->UnlockRect();
-        }
-
-        image->dirty = true;
-        mDirtyImage = true;
-    }
-
-    return true;
-}
-
-bool Texture::subImageCompressed(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *pixels, Image *image)
-{
-    if (width + xoffset > image->width || height + yoffset > image->height)
-    {
-        error(GL_INVALID_VALUE);
-        return false;
-    }
-
-    if (format != getInternalFormat())
-    {
-        error(GL_INVALID_OPERATION);
-        return false;
-    }
-
-    if (!image->surface)
-    {
-        createSurface(image);
-    }
-
-    if (pixels != NULL && image->surface != NULL)
-    {
-        RECT updateRegion;
-        updateRegion.left = xoffset;
-        updateRegion.right = xoffset + width;
-        updateRegion.bottom = yoffset + height;
-        updateRegion.top = yoffset;
-
-        D3DLOCKED_RECT locked;
-        HRESULT result = image->surface->LockRect(&locked, &updateRegion, 0);
-
-        ASSERT(SUCCEEDED(result));
-
-        if (SUCCEEDED(result))
-        {
-            int inputPitch = ComputeCompressedPitch(width, format);
-            int inputSize = ComputeCompressedSize(width, height, format);
-            loadCompressedImageData(xoffset, transformPixelYOffset(yoffset, height, image->height), width, height, -inputPitch, static_cast<const char*>(pixels) + inputSize - inputPitch, locked.Pitch, locked.pBits);
-            image->surface->UnlockRect();
-        }
-
-        image->dirty = true;
-        mDirtyImage = true;
-    }
-
-    return true;
-}
-
-// This implements glCopyTex[Sub]Image2D for non-renderable internal texture formats and incomplete textures
-void Texture::copyToImage(Image *image, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, IDirect3DSurface9 *renderTarget)
-{
-    if (!image->surface)
-    {
-        createSurface(image);
-
-        if (!image->surface)
-        {
-            ERR("Failed to create an image surface.");
-            return error(GL_OUT_OF_MEMORY);
-        }
-    }
-
     IDirect3DDevice9 *device = getDevice();
     IDirect3DSurface9 *renderTargetData = NULL;
     D3DSURFACE_DESC description;
@@ -1285,12 +1128,12 @@
     }
 
     RECT sourceRect = transformPixelRect(x, y, width, height, description.Height);
-    int destYOffset = transformPixelYOffset(yoffset, height, image->height);
+    int destYOffset = transformPixelYOffset(yoffset, height, mHeight);
     RECT destRect = {xoffset, destYOffset, xoffset + width, destYOffset + height};
 
-    if (image->isRenderable())
+    if (isRenderableFormat())
     {
-        result = D3DXLoadSurfaceFromSurface(image->surface, NULL, &destRect, renderTargetData, NULL, &sourceRect, D3DX_FILTER_BOX, 0);
+        result = D3DXLoadSurfaceFromSurface(getSurface(), NULL, &destRect, renderTargetData, NULL, &sourceRect, D3DX_FILTER_BOX, 0);
         
         if (FAILED(result))
         {
@@ -1312,7 +1155,7 @@
         }
 
         D3DLOCKED_RECT destLock = {0};
-        result = image->surface->LockRect(&destLock, &destRect, 0);
+        result = lock(&destLock, &destRect);
         
         if (FAILED(result))
         {
@@ -1331,7 +1174,7 @@
             {
               case D3DFMT_X8R8G8B8:
               case D3DFMT_A8R8G8B8:
-                switch(image->getD3DFormat())
+                switch(getD3DFormat())
                 {
                   case D3DFMT_L8:
                     for(int y = 0; y < height; y++)
@@ -1363,7 +1206,7 @@
                 }
                 break;
               case D3DFMT_R5G6B5:
-                switch(image->getD3DFormat())
+                switch(getD3DFormat())
                 {
                   case D3DFMT_L8:
                     for(int y = 0; y < height; y++)
@@ -1383,7 +1226,7 @@
                 }
                 break;
               case D3DFMT_A1R5G5B5:
-                switch(image->getD3DFormat())
+                switch(getD3DFormat())
                 {
                   case D3DFMT_L8:
                     for(int y = 0; y < height; y++)
@@ -1421,26 +1264,317 @@
             }
         }
 
-        image->surface->UnlockRect();
+        unlock();
         renderTargetData->UnlockRect();
     }
 
     renderTargetData->Release();
 
-    image->dirty = true;
-    mDirtyImage = true;
+    mDirty = true;
+}
+
+TextureStorage::TextureStorage(bool renderTarget)
+    : mRenderTarget(renderTarget),
+      mD3DPool(getDisplay()->getTexturePool(mRenderTarget)),
+      mTextureSerial(issueTextureSerial())
+{
+}
+
+TextureStorage::~TextureStorage()
+{
+}
+
+bool TextureStorage::isRenderTarget() const
+{
+    return mRenderTarget;
+}
+
+bool TextureStorage::isManaged() const
+{
+    return (mD3DPool == D3DPOOL_MANAGED);
+}
+
+D3DPOOL TextureStorage::getPool() const
+{
+    return mD3DPool;
+}
+
+unsigned int TextureStorage::getTextureSerial() const
+{
+    return mTextureSerial;
+}
+
+unsigned int TextureStorage::issueTextureSerial()
+{
+    return mCurrentTextureSerial++;
+}
+
+Texture::Texture(GLuint id) : RefCountObject(id)
+{
+    mMinFilter = GL_NEAREST_MIPMAP_LINEAR;
+    mMagFilter = GL_LINEAR;
+    mWrapS = GL_REPEAT;
+    mWrapT = GL_REPEAT;
+    mDirtyParameters = true;
+    mUsage = GL_NONE;
+    
+    mDirtyImages = true;
+
+    mImmutable = false;
+}
+
+Texture::~Texture()
+{
+}
+
+// Returns true on successful filter state update (valid enum parameter)
+bool Texture::setMinFilter(GLenum filter)
+{
+    switch (filter)
+    {
+      case GL_NEAREST:
+      case GL_LINEAR:
+      case GL_NEAREST_MIPMAP_NEAREST:
+      case GL_LINEAR_MIPMAP_NEAREST:
+      case GL_NEAREST_MIPMAP_LINEAR:
+      case GL_LINEAR_MIPMAP_LINEAR:
+        {
+            if (mMinFilter != filter)
+            {
+                mMinFilter = filter;
+                mDirtyParameters = true;
+            }
+            return true;
+        }
+      default:
+        return false;
+    }
+}
+
+// Returns true on successful filter state update (valid enum parameter)
+bool Texture::setMagFilter(GLenum filter)
+{
+    switch (filter)
+    {
+      case GL_NEAREST:
+      case GL_LINEAR:
+        {
+            if (mMagFilter != filter)
+            {
+                mMagFilter = filter;
+                mDirtyParameters = true;
+            }
+            return true;
+        }
+      default:
+        return false;
+    }
+}
+
+// Returns true on successful wrap state update (valid enum parameter)
+bool Texture::setWrapS(GLenum wrap)
+{
+    switch (wrap)
+    {
+      case GL_REPEAT:
+      case GL_CLAMP_TO_EDGE:
+      case GL_MIRRORED_REPEAT:
+        {
+            if (mWrapS != wrap)
+            {
+                mWrapS = wrap;
+                mDirtyParameters = true;
+            }
+            return true;
+        }
+      default:
+        return false;
+    }
+}
+
+// Returns true on successful wrap state update (valid enum parameter)
+bool Texture::setWrapT(GLenum wrap)
+{
+    switch (wrap)
+    {
+      case GL_REPEAT:
+      case GL_CLAMP_TO_EDGE:
+      case GL_MIRRORED_REPEAT:
+        {
+            if (mWrapT != wrap)
+            {
+                mWrapT = wrap;
+                mDirtyParameters = true;
+            }
+            return true;
+        }
+      default:
+        return false;
+    }
+}
+
+// Returns true on successful usage state update (valid enum parameter)
+bool Texture::setUsage(GLenum usage)
+{
+    switch (usage)
+    {
+      case GL_NONE:
+      case GL_FRAMEBUFFER_ATTACHMENT_ANGLE:
+        mUsage = usage;
+        return true;
+      default:
+        return false;
+    }
+}
+
+GLenum Texture::getMinFilter() const
+{
+    return mMinFilter;
+}
+
+GLenum Texture::getMagFilter() const
+{
+    return mMagFilter;
+}
+
+GLenum Texture::getWrapS() const
+{
+    return mWrapS;
+}
+
+GLenum Texture::getWrapT() const
+{
+    return mWrapT;
+}
+
+GLenum Texture::getUsage() const
+{
+    return mUsage;
+}
+
+void Texture::setImage(GLint unpackAlignment, const void *pixels, Image *image)
+{
+    if (pixels != NULL)
+    {
+        D3DLOCKED_RECT locked;
+        HRESULT result = image->lock(&locked, NULL);
+
+        if (SUCCEEDED(result))
+        {
+            image->loadData(0, 0, image->getWidth(), image->getHeight(), image->getType(), unpackAlignment, pixels, locked.Pitch, locked.pBits);
+            image->unlock();
+        }
+
+        mDirtyImages = true;
+    }
+}
+
+void Texture::setCompressedImage(GLsizei imageSize, const void *pixels, Image *image)
+{
+    if (pixels != NULL)
+    {
+        D3DLOCKED_RECT locked;
+        HRESULT result = image->lock(&locked, NULL);
+
+        if (SUCCEEDED(result))
+        {
+            int inputPitch = ComputeCompressedPitch(image->getWidth(), image->getFormat());
+            int inputSize = ComputeCompressedSize(image->getWidth(), image->getHeight(), image->getFormat());
+            image->loadCompressedData(0, 0, image->getWidth(), image->getHeight(), -inputPitch, static_cast<const char*>(pixels) + inputSize - inputPitch, locked.Pitch, locked.pBits);
+            image->unlock();
+        }
+
+        mDirtyImages = true;
+    }
+}
+
+bool Texture::subImage(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels, Image *image)
+{
+    if (width + xoffset > image->getWidth() || height + yoffset > image->getHeight())
+    {
+        error(GL_INVALID_VALUE);
+        return false;
+    }
+
+    if (IsCompressed(image->getFormat()))
+    {
+        error(GL_INVALID_OPERATION);
+        return false;
+    }
+
+    if (format != image->getFormat())
+    {
+        error(GL_INVALID_OPERATION);
+        return false;
+    }
+
+    if (pixels != NULL)
+    {
+        D3DLOCKED_RECT locked;
+        HRESULT result = image->lock(&locked, NULL);
+
+        if (SUCCEEDED(result))
+        {
+            image->loadData(xoffset, transformPixelYOffset(yoffset, height, image->getHeight()), width, height, type, unpackAlignment, pixels, locked.Pitch, locked.pBits);
+            image->unlock();
+        }
+
+        mDirtyImages = true;
+    }
+
+    return true;
+}
+
+bool Texture::subImageCompressed(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *pixels, Image *image)
+{
+    if (width + xoffset > image->getWidth() || height + yoffset > image->getHeight())
+    {
+        error(GL_INVALID_VALUE);
+        return false;
+    }
+
+    if (format != getInternalFormat())
+    {
+        error(GL_INVALID_OPERATION);
+        return false;
+    }
+
+    if (pixels != NULL)
+    {
+        RECT updateRegion;
+        updateRegion.left = xoffset;
+        updateRegion.right = xoffset + width;
+        updateRegion.bottom = yoffset + height;
+        updateRegion.top = yoffset;
+
+        D3DLOCKED_RECT locked;
+        HRESULT result = image->lock(&locked, &updateRegion);
+
+        if (SUCCEEDED(result))
+        {
+            int inputPitch = ComputeCompressedPitch(width, format);
+            int inputSize = ComputeCompressedSize(width, height, format);
+            image->loadCompressedData(xoffset, transformPixelYOffset(yoffset, height, image->getHeight()), width, height, -inputPitch, static_cast<const char*>(pixels) + inputSize - inputPitch, locked.Pitch, locked.pBits);
+            image->unlock();
+        }
+
+        mDirtyImages = true;
+    }
+
+    return true;
 }
 
 IDirect3DBaseTexture9 *Texture::getTexture()
 {
-    if (!isComplete())
+    if (!isSamplerComplete())
     {
         return NULL;
     }
 
-    if (!getBaseTexture())
+    // ensure the underlying texture is created
+    if (getStorage(false) == NULL)
     {
-        createTexture();
+        return NULL;
     }
 
     updateTexture();
@@ -1448,32 +1582,44 @@
     return getBaseTexture();
 }
 
-bool Texture::isDirtyParameter() const
+bool Texture::hasDirtyParameters() const
 {
-    return mDirtyParameter;
+    return mDirtyParameters;
 }
 
-bool Texture::isDirtyImage() const
+bool Texture::hasDirtyImages() const
 {
-    return mDirtyImage;
+    return mDirtyImages;
 }
 
 void Texture::resetDirty()
 {
-    mDirtyParameter = false;
-    mDirtyImage = false;
+    mDirtyParameters = false;
+    mDirtyImages = false;
 }
 
-unsigned int Texture::getSerial() const
+unsigned int Texture::getTextureSerial()
 {
-    return mSerial;
+    TextureStorage *texture = getStorage(false);
+    return texture ? texture->getTextureSerial() : 0;
 }
 
-GLint Texture::creationLevels(GLsizei width, GLsizei height, GLint maxlevel) const
+unsigned int Texture::getRenderTargetSerial(GLenum target)
+{
+    TextureStorage *texture = getStorage(true);
+    return texture ? texture->getRenderTargetSerial(target) : 0;
+}
+
+bool Texture::isImmutable() const
+{
+    return mImmutable;
+}
+
+GLint Texture::creationLevels(GLsizei width, GLsizei height) const
 {
     if ((isPow2(width) && isPow2(height)) || getContext()->supportsNonPower2Texture())
     {
-        return maxlevel;
+        return 0;   // Maximum number of levels
     }
     else
     {
@@ -1482,9 +1628,9 @@
     }
 }
 
-GLint Texture::creationLevels(GLsizei size, GLint maxlevel) const
+GLint Texture::creationLevels(GLsizei size) const
 {
-    return creationLevels(size, size, maxlevel);
+    return creationLevels(size, size);
 }
 
 int Texture::levelCount() const
@@ -1492,14 +1638,95 @@
     return getBaseTexture() ? getBaseTexture()->GetLevelCount() : 0;
 }
 
-unsigned int Texture::issueSerial()
+Blit *Texture::getBlitter()
 {
-    return mCurrentSerial++;
+    Context *context = getContext();
+    return context->getBlitter();
+}
+
+bool Texture::copyToRenderTarget(IDirect3DSurface9 *dest, IDirect3DSurface9 *source, bool fromManaged)
+{
+    if (source && dest)
+    {
+        HRESULT result;
+
+        if (fromManaged)
+        {
+            result = D3DXLoadSurfaceFromSurface(dest, NULL, NULL, source, NULL, NULL, D3DX_FILTER_BOX, 0);
+        }
+        else
+        {
+            egl::Display *display = getDisplay();
+            IDirect3DDevice9 *device = display->getDevice();
+
+            display->endScene();
+            result = device->StretchRect(source, NULL, dest, NULL, D3DTEXF_NONE);
+        }
+
+        if (FAILED(result))
+        {
+            ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
+            return false;
+        }
+    }
+
+    return true;
+}
+
+TextureStorage2D::TextureStorage2D(IDirect3DTexture9 *surfaceTexture) : TextureStorage(true), mRenderTargetSerial(RenderbufferStorage::issueSerial())
+{
+    mTexture = surfaceTexture;
+}
+
+TextureStorage2D::TextureStorage2D(int levels, D3DFORMAT format, int width, int height, bool renderTarget)
+    : TextureStorage(renderTarget), mRenderTargetSerial(RenderbufferStorage::issueSerial())
+{
+    IDirect3DDevice9 *device = getDevice();
+
+    mTexture = NULL;
+    HRESULT result = device->CreateTexture(width, height, levels, isRenderTarget() ? D3DUSAGE_RENDERTARGET : 0, format, getPool(), &mTexture, NULL);
+
+    if (FAILED(result))
+    {
+        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
+        error(GL_OUT_OF_MEMORY);
+    }
+}
+
+TextureStorage2D::~TextureStorage2D()
+{
+    if (mTexture)
+    {
+        mTexture->Release();
+    }
+}
+
+IDirect3DSurface9 *TextureStorage2D::getSurfaceLevel(int level)
+{
+    IDirect3DSurface9 *surface = NULL;
+
+    if (mTexture)
+    {
+        HRESULT result = mTexture->GetSurfaceLevel(level, &surface);
+        ASSERT(SUCCEEDED(result));
+    }
+
+    return surface;
+}
+
+IDirect3DBaseTexture9 *TextureStorage2D::getBaseTexture() const
+{
+    return mTexture;
+}
+
+unsigned int TextureStorage2D::getRenderTargetSerial(GLenum target) const
+{
+    return mRenderTargetSerial;
 }
 
 Texture2D::Texture2D(GLuint id) : Texture(id)
 {
-    mTexture = NULL;
+    mTexStorage = NULL;
     mSurface = NULL;
 }
 
@@ -1507,12 +1734,9 @@
 {
     mColorbufferProxy.set(NULL);
 
-    if (mTexture)
-    {
-        mTexture->Release();
-        mTexture = NULL;
-    }
-
+    delete mTexStorage;
+    mTexStorage = NULL;
+    
     if (mSurface)
     {
         mSurface->setBoundTexture(NULL);
@@ -1525,24 +1749,30 @@
     return GL_TEXTURE_2D;
 }
 
-GLsizei Texture2D::getWidth() const
+GLsizei Texture2D::getWidth(GLint level) const
 {
-    return mImageArray[0].width;
+    if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
+        return mImageArray[level].getWidth();
+    else
+        return 0;
 }
 
-GLsizei Texture2D::getHeight() const
+GLsizei Texture2D::getHeight(GLint level) const
 {
-    return mImageArray[0].height;
+    if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
+        return mImageArray[level].getHeight();
+    else
+        return 0;
 }
 
 GLenum Texture2D::getInternalFormat() const
 {
-    return mImageArray[0].format;
+    return mImageArray[0].getFormat();
 }
 
 GLenum Texture2D::getType() const
 {
-    return mImageArray[0].type;
+    return mImageArray[0].getType();
 }
 
 D3DFORMAT Texture2D::getD3DFormat() const
@@ -1550,66 +1780,36 @@
     return mImageArray[0].getD3DFormat();
 }
 
-void Texture2D::redefineTexture(GLint level, GLenum format, GLsizei width, GLsizei height, GLenum type, bool forceRedefine)
+void Texture2D::redefineImage(GLint level, GLenum format, GLsizei width, GLsizei height, GLenum type)
 {
-    GLsizei textureWidth = mImageArray[0].width;
-    GLsizei textureHeight = mImageArray[0].height;
-    GLenum textureFormat = mImageArray[0].format;
-    GLenum textureType = mImageArray[0].type;
-
-    mImageArray[level].width = width;
-    mImageArray[level].height = height;
-    mImageArray[level].format = format;
-    mImageArray[level].type = type;
-
-    if (!mTexture)
-    {
-        return;
-    }
-
-    bool widthOkay = (textureWidth >> level == width) || (textureWidth >> level == 0 && width == 1);
-    bool heightOkay = (textureHeight >> level == height) || (textureHeight >> level == 0 && height == 1);
-    bool textureOkay = (widthOkay && heightOkay && textureFormat == format && textureType == type);
-
-    if (!textureOkay || forceRedefine || mSurface)   // Purge all the levels and the texture.
+    releaseTexImage();
+
+    bool redefined = mImageArray[level].redefine(format, width, height, type, false);
+
+    if (mTexStorage && redefined)
     {
         for (int i = 0; i < IMPLEMENTATION_MAX_TEXTURE_LEVELS; i++)
         {
-            if (mImageArray[i].surface != NULL)
-            {
-                mImageArray[i].surface->Release();
-                mImageArray[i].surface = NULL;
-                mImageArray[i].dirty = true;
-            }
+            mImageArray[i].markDirty();
         }
 
-        if (mTexture != NULL)
-        {
-            mTexture->Release();
-            mTexture = NULL;
-            mDirtyImage = true;
-            mIsRenderable = false;
-        }
-
-        if (mSurface)
-        {
-            mSurface->setBoundTexture(NULL);
-            mSurface = NULL;
-        }
-
-        mColorbufferProxy.set(NULL);
+        delete mTexStorage;
+        mTexStorage = NULL;
+        mDirtyImages = true;
     }
 }
 
 void Texture2D::setImage(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
 {
-    redefineTexture(level, format, width, height, type, false);
+    redefineImage(level, format, width, height, type);
 
     Texture::setImage(unpackAlignment, pixels, &mImageArray[level]);
 }
 
 void Texture2D::bindTexImage(egl::Surface *surface)
 {
+    releaseTexImage();
+
     GLenum format;
 
     switch(surface->getFormat())
@@ -1625,56 +1825,58 @@
         return;
     }
 
-    redefineTexture(0, format, surface->getWidth(), surface->getHeight(), GL_UNSIGNED_BYTE, true);
-
-    IDirect3DTexture9 *texture = surface->getOffscreenTexture();
-
-    mTexture = texture;
-    mDirtyImage = true;
-    mIsRenderable = true;
+    mImageArray[0].redefine(format, surface->getWidth(), surface->getHeight(), GL_UNSIGNED_BYTE, true);
+
+    delete mTexStorage;
+    mTexStorage = new TextureStorage2D(surface->getOffscreenTexture());
+
+    mDirtyImages = true;
     mSurface = surface;
     mSurface->setBoundTexture(this);
 }
 
 void Texture2D::releaseTexImage()
 {
-    redefineTexture(0, GL_RGB, 0, 0, GL_UNSIGNED_BYTE, true);
+    if (mSurface)
+    {
+        mSurface->setBoundTexture(NULL);
+        mSurface = NULL;
+
+        if (mTexStorage)
+        {
+            delete mTexStorage;
+            mTexStorage = NULL;
+        }
+
+        for (int i = 0; i < IMPLEMENTATION_MAX_TEXTURE_LEVELS; i++)
+        {
+            mImageArray[i].redefine(GL_RGBA, 0, 0, GL_UNSIGNED_BYTE, true);
+        }
+    }
 }
 
 void Texture2D::setCompressedImage(GLint level, GLenum format, GLsizei width, GLsizei height, GLsizei imageSize, const void *pixels)
 {
-    redefineTexture(level, format, width, height, GL_UNSIGNED_BYTE, false);
+    redefineImage(level, format, width, height, GL_UNSIGNED_BYTE);
 
     Texture::setCompressedImage(imageSize, pixels, &mImageArray[level]);
 }
 
 void Texture2D::commitRect(GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height)
 {
-    ASSERT(mImageArray[level].surface != NULL);
+    ASSERT(mImageArray[level].getSurface() != NULL);
 
     if (level < levelCount())
     {
-        IDirect3DSurface9 *destLevel = NULL;
-        HRESULT result = mTexture->GetSurfaceLevel(level, &destLevel);
-
-        ASSERT(SUCCEEDED(result));
-
-        if (SUCCEEDED(result))
+        IDirect3DSurface9 *destLevel = mTexStorage->getSurfaceLevel(level);
+
+        if (destLevel)
         {
             Image *image = &mImageArray[level];
-
-            RECT sourceRect = transformPixelRect(xoffset, yoffset, width, height, image->height);;
-
-            POINT destPoint;
-            destPoint.x = sourceRect.left;
-            destPoint.y = sourceRect.top;
-
-            result = getDevice()->UpdateSurface(image->surface, &sourceRect, destLevel, &destPoint);
-            ASSERT(SUCCEEDED(result));
+            image->updateSurface(destLevel, xoffset, yoffset, width, height);
 
             destLevel->Release();
-
-            image->dirty = false;
+            image->markClean();
         }
     }
 }
@@ -1705,20 +1907,21 @@
         return error(GL_OUT_OF_MEMORY);
     }
 
-    redefineTexture(level, format, width, height, GL_UNSIGNED_BYTE, false);
+    redefineImage(level, format, width, height, GL_UNSIGNED_BYTE);
    
-    if (!mImageArray[level].isRenderable())
+    if (!mImageArray[level].isRenderableFormat())
     {
-        copyToImage(&mImageArray[level], 0, 0, x, y, width, height, renderTarget);
+        mImageArray[level].copy(0, 0, x, y, width, height, renderTarget);
+        mDirtyImages = true;
     }
     else
     {
-        if (!mTexture || !mIsRenderable)
+        if (!mTexStorage || !mTexStorage->isRenderTarget())
         {
             convertToRenderTarget();
         }
         
-        updateTexture();
+        mImageArray[level].markClean();
 
         if (width != 0 && height != 0 && level < levelCount())
         {
@@ -1728,20 +1931,24 @@
             sourceRect.right = clamp(sourceRect.right, 0, source->getColorbuffer()->getWidth());
             sourceRect.bottom = clamp(sourceRect.bottom, 0, source->getColorbuffer()->getHeight());
 
-            GLint destYOffset = transformPixelYOffset(0, height, mImageArray[level].height);
+            GLint destYOffset = transformPixelYOffset(0, height, mImageArray[level].getHeight());
             
-            IDirect3DSurface9 *dest;
-            HRESULT hr = mTexture->GetSurfaceLevel(level, &dest);
-
-            getBlitter()->copy(source->getRenderTarget(), sourceRect, format, 0, destYOffset, dest);
-            dest->Release();
+            IDirect3DSurface9 *dest = mTexStorage->getSurfaceLevel(level);
+
+            if (dest)
+            {
+                getBlitter()->copy(renderTarget, sourceRect, format, 0, destYOffset, dest);
+                dest->Release();
+            }
         }
     }
+
+    renderTarget->Release();
 }
 
 void Texture2D::copySubImage(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, Framebuffer *source)
 {
-    if (xoffset + width > mImageArray[level].width || yoffset + height > mImageArray[level].height)
+    if (xoffset + width > mImageArray[level].getWidth() || yoffset + height > mImageArray[level].getHeight())
     {
         return error(GL_INVALID_VALUE);
     }
@@ -1754,15 +1961,14 @@
         return error(GL_OUT_OF_MEMORY);
     }
 
-    redefineTexture(level, mImageArray[level].format, mImageArray[level].width, mImageArray[level].height, GL_UNSIGNED_BYTE, false);
-   
-    if (!mImageArray[level].isRenderable() || (!mTexture && !isComplete()))
+    if (!mImageArray[level].isRenderableFormat() || (!mTexStorage && !isSamplerComplete()))
     {
-        copyToImage(&mImageArray[level], xoffset, yoffset, x, y, width, height, renderTarget);
+        mImageArray[level].copy(xoffset, yoffset, x, y, width, height, renderTarget);
+        mDirtyImages = true;
     }
     else
     {
-        if (!mTexture || !mIsRenderable)
+        if (!mTexStorage || !mTexStorage->isRenderTarget())
         {
             convertToRenderTarget();
         }
@@ -1777,22 +1983,61 @@
             sourceRect.right = clamp(sourceRect.right, 0, source->getColorbuffer()->getWidth());
             sourceRect.bottom = clamp(sourceRect.bottom, 0, source->getColorbuffer()->getHeight());
 
-            GLint destYOffset = transformPixelYOffset(yoffset, height, mImageArray[level].height);
-
-            IDirect3DSurface9 *dest;
-            HRESULT hr = mTexture->GetSurfaceLevel(level, &dest);
-
-            getBlitter()->copy(source->getRenderTarget(), sourceRect, mImageArray[0].format, xoffset, destYOffset, dest);
-            dest->Release();
+            GLint destYOffset = transformPixelYOffset(yoffset, height, mImageArray[level].getHeight());
+
+            IDirect3DSurface9 *dest = mTexStorage->getSurfaceLevel(level);
+
+            if (dest)
+            {
+                getBlitter()->copy(renderTarget, sourceRect, mImageArray[0].getFormat(), xoffset, destYOffset, dest);
+                dest->Release();
+            }
+        }
+    }
+
+    renderTarget->Release();
+}
+
+void Texture2D::storage(GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
+{
+    GLenum format = gl::ExtractFormat(internalformat);
+    GLenum type = gl::ExtractType(internalformat);
+    D3DFORMAT d3dfmt = ConvertTextureFormatType(format, type);
+    const bool renderTarget = IsTextureFormatRenderable(d3dfmt) && (mUsage == GL_FRAMEBUFFER_ATTACHMENT_ANGLE);
+
+    delete mTexStorage;
+    mTexStorage = new TextureStorage2D(levels, d3dfmt, width, height, renderTarget);
+    mImmutable = true;
+
+    for (int level = 0; level < levels; level++)
+    {
+        mImageArray[level].redefine(format, width, height, type, true);
+        width = std::max(1, width >> 1);
+        height = std::max(1, height >> 1);
+    }
+
+    for (int level = levels; level < IMPLEMENTATION_MAX_TEXTURE_LEVELS; level++)
+    {
+        mImageArray[level].redefine(GL_NONE, 0, 0, GL_UNSIGNED_BYTE, true);
+    }
+
+    if (mTexStorage->isManaged())
+    {
+        int levels = levelCount();
+
+        for (int level = 0; level < levels; level++)
+        {
+            IDirect3DSurface9 *surface = mTexStorage->getSurfaceLevel(level);
+            mImageArray[level].setManagedSurface(surface);
         }
     }
 }
 
-// Tests for GL texture object completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
-bool Texture2D::isComplete() const
+// Tests for 2D texture sampling completeness. [OpenGL ES 2.0.24] section 3.8.2 page 85.
+bool Texture2D::isSamplerComplete() const
 {
-    GLsizei width = mImageArray[0].width;
-    GLsizei height = mImageArray[0].height;
+    GLsizei width = mImageArray[0].getWidth();
+    GLsizei height = mImageArray[0].getHeight();
 
     if (width <= 0 || height <= 0)
     {
@@ -1813,491 +2058,11 @@
       case GL_LINEAR_MIPMAP_LINEAR:
         mipmapping = true;
         break;
-     default: UNREACHABLE();
-    }
-
-    if ((getInternalFormat() == GL_FLOAT && !getContext()->supportsFloatLinearFilter()) ||
-        (getInternalFormat() == GL_HALF_FLOAT_OES && !getContext()->supportsHalfFloatLinearFilter()))
-    {
-        if (mMagFilter != GL_NEAREST || (mMinFilter != GL_NEAREST && mMinFilter != GL_NEAREST_MIPMAP_NEAREST))
-        {
-            return false;
-        }
-    }
-
-    bool npot = getContext()->supportsNonPower2Texture();
-
-    if (!npot)
-    {
-        if ((getWrapS() != GL_CLAMP_TO_EDGE && !isPow2(width)) ||
-            (getWrapT() != GL_CLAMP_TO_EDGE && !isPow2(height)))
-        {
-            return false;
-        }
-    }
-
-    if (mipmapping)
-    {
-        if (!npot)
-        {
-            if (!isPow2(width) || !isPow2(height))
-            {
-                return false;
-            }
-        }
-
-        int q = log2(std::max(width, height));
-
-        for (int level = 1; level <= q; level++)
-        {
-            if (mImageArray[level].format != mImageArray[0].format)
-            {
-                return false;
-            }
-
-            if (mImageArray[level].type != mImageArray[0].type)
-            {
-                return false;
-            }
-
-            if (mImageArray[level].width != std::max(1, width >> level))
-            {
-                return false;
-            }
-
-            if (mImageArray[level].height != std::max(1, height >> level))
-            {
-                return false;
-            }
-        }
-    }
-
-    return true;
-}
-
-bool Texture2D::isCompressed() const
-{
-    return IsCompressed(getInternalFormat());
-}
-
-IDirect3DBaseTexture9 *Texture2D::getBaseTexture() const
-{
-    return mTexture;
-}
-
-// Constructs a Direct3D 9 texture resource from the texture images
-void Texture2D::createTexture()
-{
-    IDirect3DDevice9 *device = getDevice();
-    D3DFORMAT format = mImageArray[0].getD3DFormat();
-    GLint levels = creationLevels(mImageArray[0].width, mImageArray[0].height, 0);
-
-    IDirect3DTexture9 *texture = NULL;
-    HRESULT result = device->CreateTexture(mImageArray[0].width, mImageArray[0].height, levels, 0, format, D3DPOOL_DEFAULT, &texture, NULL);
-
-    if (FAILED(result))
-    {
-        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-        return error(GL_OUT_OF_MEMORY);
-    }
-
-    if (mTexture)
-    {
-        mTexture->Release();
-    }
-
-    mTexture = texture;
-    mDirtyImage = true;
-    mIsRenderable = false;
-}
-
-void Texture2D::updateTexture()
-{
-    IDirect3DDevice9 *device = getDevice();
-
-    int levels = levelCount();
-
-    for (int level = 0; level < levels; level++)
-    {
-        if (mImageArray[level].surface && mImageArray[level].dirty)
-        {
-            IDirect3DSurface9 *levelSurface = NULL;
-            HRESULT result = mTexture->GetSurfaceLevel(level, &levelSurface);
-
-            ASSERT(SUCCEEDED(result));
-
-            if (SUCCEEDED(result))
-            {
-                result = device->UpdateSurface(mImageArray[level].surface, NULL, levelSurface, NULL);
-                ASSERT(SUCCEEDED(result));
-
-                levelSurface->Release();
-
-                mImageArray[level].dirty = false;
-            }
-        }
-    }
-}
-
-void Texture2D::convertToRenderTarget()
-{
-    IDirect3DTexture9 *texture = NULL;
-
-    if (mImageArray[0].width != 0 && mImageArray[0].height != 0)
-    {
-        egl::Display *display = getDisplay();
-        IDirect3DDevice9 *device = getDevice();
-        D3DFORMAT format = mImageArray[0].getD3DFormat();
-        GLint levels = creationLevels(mImageArray[0].width, mImageArray[0].height, 0);
-
-        HRESULT result = device->CreateTexture(mImageArray[0].width, mImageArray[0].height, levels, D3DUSAGE_RENDERTARGET, format, D3DPOOL_DEFAULT, &texture, NULL);
-
-        if (FAILED(result))
-        {
-            ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-            return error(GL_OUT_OF_MEMORY);
-        }
-
-        if (mTexture != NULL)
-        {
-            int levels = levelCount();
-            for (int i = 0; i < levels; i++)
-            {
-                IDirect3DSurface9 *source;
-                result = mTexture->GetSurfaceLevel(i, &source);
-
-                if (FAILED(result))
-                {
-                    ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-
-                    texture->Release();
-
-                    return error(GL_OUT_OF_MEMORY);
-                }
-
-                IDirect3DSurface9 *dest;
-                result = texture->GetSurfaceLevel(i, &dest);
-
-                if (FAILED(result))
-                {
-                    ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-
-                    texture->Release();
-                    source->Release();
-
-                    return error(GL_OUT_OF_MEMORY);
-                }
-
-                display->endScene();
-                result = device->StretchRect(source, NULL, dest, NULL, D3DTEXF_NONE);
-
-                if (FAILED(result))
-                {
-                    ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-
-                    texture->Release();
-                    source->Release();
-                    dest->Release();
-
-                    return error(GL_OUT_OF_MEMORY);
-                }
-
-                source->Release();
-                dest->Release();
-            }
-        }
-    }
-
-    if (mTexture != NULL)
-    {
-        mTexture->Release();
-    }
-
-    mTexture = texture;
-    mDirtyImage = true;
-    mIsRenderable = true;
-}
-
-void Texture2D::generateMipmaps()
-{
-    if (!getContext()->supportsNonPower2Texture())
-    {
-        if (!isPow2(mImageArray[0].width) || !isPow2(mImageArray[0].height))
-        {
-            return error(GL_INVALID_OPERATION);
-        }
-    }
-
-    // Purge array levels 1 through q and reset them to represent the generated mipmap levels.
-    unsigned int q = log2(std::max(mImageArray[0].width, mImageArray[0].height));
-    for (unsigned int i = 1; i <= q; i++)
-    {
-        if (mImageArray[i].surface != NULL)
-        {
-            mImageArray[i].surface->Release();
-            mImageArray[i].surface = NULL;
-        }
-
-        mImageArray[i].width = std::max(mImageArray[0].width >> i, 1);
-        mImageArray[i].height = std::max(mImageArray[0].height >> i, 1);
-        mImageArray[i].format = mImageArray[0].format;
-        mImageArray[i].type = mImageArray[0].type;
-    }
-
-    if (mIsRenderable)
-    {
-        if (mTexture == NULL)
-        {
-            ERR(" failed because mTexture was null.");
-            return;
-        }
-
-        for (unsigned int i = 1; i <= q; i++)
-        {
-            IDirect3DSurface9 *upper = NULL;
-            IDirect3DSurface9 *lower = NULL;
-
-            mTexture->GetSurfaceLevel(i-1, &upper);
-            mTexture->GetSurfaceLevel(i, &lower);
-
-            if (upper != NULL && lower != NULL)
-            {
-                getBlitter()->boxFilter(upper, lower);
-            }
-
-            if (upper != NULL) upper->Release();
-            if (lower != NULL) lower->Release();
-
-            mImageArray[i].dirty = false;
-        }
-    }
-    else
-    {
-        for (unsigned int i = 1; i <= q; i++)
-        {
-            createSurface(&mImageArray[i]);
-            
-            if (mImageArray[i].surface == NULL)
-            {
-                return error(GL_OUT_OF_MEMORY);
-            }
-
-            if (FAILED(D3DXLoadSurfaceFromSurface(mImageArray[i].surface, NULL, NULL, mImageArray[i - 1].surface, NULL, NULL, D3DX_FILTER_BOX, 0)))
-            {
-                ERR(" failed to load filter %d to %d.", i - 1, i);
-            }
-
-            mImageArray[i].dirty = true;
-        }
-    }
-}
-
-Renderbuffer *Texture2D::getRenderbuffer(GLenum target)
-{
-    if (target != GL_TEXTURE_2D)
-    {
-        return error(GL_INVALID_OPERATION, (Renderbuffer *)NULL);
-    }
-
-    if (mColorbufferProxy.get() == NULL)
-    {
-        mColorbufferProxy.set(new Renderbuffer(id(), new Colorbuffer(this, target)));
-    }
-
-    return mColorbufferProxy.get();
-}
-
-IDirect3DSurface9 *Texture2D::getRenderTarget(GLenum target)
-{
-    ASSERT(target == GL_TEXTURE_2D);
-
-    if (!mIsRenderable)
-    {
-        convertToRenderTarget();
-    }
-
-    if (mTexture == NULL)
-    {
-        return NULL;
-    }
-
-    updateTexture();
-    
-    IDirect3DSurface9 *renderTarget = NULL;
-    mTexture->GetSurfaceLevel(0, &renderTarget);
-
-    return renderTarget;
-}
-
-TextureCubeMap::TextureCubeMap(GLuint id) : Texture(id)
-{
-    mTexture = NULL;
-}
-
-TextureCubeMap::~TextureCubeMap()
-{
-    for (int i = 0; i < 6; i++)
-    {
-        mFaceProxies[i].set(NULL);
-    }
-
-    if (mTexture)
-    {
-        mTexture->Release();
-        mTexture = NULL;
-    }
-}
-
-GLenum TextureCubeMap::getTarget() const
-{
-    return GL_TEXTURE_CUBE_MAP;
-}
-
-GLsizei TextureCubeMap::getWidth() const
-{
-    return mImageArray[0][0].width;
-}
-
-GLsizei TextureCubeMap::getHeight() const
-{
-    return mImageArray[0][0].height;
-}
-
-GLenum TextureCubeMap::getInternalFormat() const
-{
-    return mImageArray[0][0].format;
-}
-
-GLenum TextureCubeMap::getType() const
-{
-    return mImageArray[0][0].type;
-}
-
-D3DFORMAT TextureCubeMap::getD3DFormat() const
-{
-    return mImageArray[0][0].getD3DFormat();
-}
-
-void TextureCubeMap::setImagePosX(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
-{
-    setImage(0, level, width, height, format, type, unpackAlignment, pixels);
-}
-
-void TextureCubeMap::setImageNegX(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
-{
-    setImage(1, level, width, height, format, type, unpackAlignment, pixels);
-}
-
-void TextureCubeMap::setImagePosY(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
-{
-    setImage(2, level, width, height, format, type, unpackAlignment, pixels);
-}
-
-void TextureCubeMap::setImageNegY(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
-{
-    setImage(3, level, width, height, format, type, unpackAlignment, pixels);
-}
-
-void TextureCubeMap::setImagePosZ(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
-{
-    setImage(4, level, width, height, format, type, unpackAlignment, pixels);
-}
-
-void TextureCubeMap::setImageNegZ(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
-{
-    setImage(5, level, width, height, format, type, unpackAlignment, pixels);
-}
-
-void TextureCubeMap::setCompressedImage(GLenum face, GLint level, GLenum format, GLsizei width, GLsizei height, GLsizei imageSize, const void *pixels)
-{
-    redefineTexture(faceIndex(face), level, format, width, height, GL_UNSIGNED_BYTE);
-
-    Texture::setCompressedImage(imageSize, pixels, &mImageArray[faceIndex(face)][level]);
-}
-
-void TextureCubeMap::commitRect(GLenum faceTarget, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height)
-{
-    int face = faceIndex(faceTarget);
-    ASSERT(mImageArray[face][level].surface != NULL);
-
-    if (level < levelCount())
-    {
-        IDirect3DSurface9 *destLevel = getCubeMapSurface(faceTarget, level);
-        ASSERT(destLevel != NULL);
-
-        if (destLevel != NULL)
-        {
-            Image *image = &mImageArray[face][level];
-
-            RECT sourceRect = transformPixelRect(xoffset, yoffset, width, height, image->height);;
-
-            POINT destPoint;
-            destPoint.x = sourceRect.left;
-            destPoint.y = sourceRect.top;
-
-            HRESULT result = getDevice()->UpdateSurface(image->surface, &sourceRect, destLevel, &destPoint);
-            ASSERT(SUCCEEDED(result));
-
-            destLevel->Release();
-
-            image->dirty = false;
-        }
-    }
-}
-
-void TextureCubeMap::subImage(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
-{
-    if (Texture::subImage(xoffset, yoffset, width, height, format, type, unpackAlignment, pixels, &mImageArray[faceIndex(target)][level]))
-    {
-        commitRect(target, level, xoffset, yoffset, width, height);
-    }
-}
-
-void TextureCubeMap::subImageCompressed(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *pixels)
-{
-    if (Texture::subImageCompressed(xoffset, yoffset, width, height, format, imageSize, pixels, &mImageArray[faceIndex(target)][level]))
-    {
-        commitRect(target, level, xoffset, yoffset, width, height);
-    }
-}
-
-// Tests for GL texture object completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
-bool TextureCubeMap::isComplete() const
-{
-    int size = mImageArray[0][0].width;
-
-    if (size <= 0)
-    {
-        return false;
-    }
-
-    bool mipmapping;
-
-    switch (mMinFilter)
-    {
-      case GL_NEAREST:
-      case GL_LINEAR:
-        mipmapping = false;
-        break;
-      case GL_NEAREST_MIPMAP_NEAREST:
-      case GL_LINEAR_MIPMAP_NEAREST:
-      case GL_NEAREST_MIPMAP_LINEAR:
-      case GL_LINEAR_MIPMAP_LINEAR:
-        mipmapping = true;
-        break;
       default: UNREACHABLE();
     }
 
-    for (int face = 0; face < 6; face++)
-    {
-        if (mImageArray[face][0].width != size || mImageArray[face][0].height != size)
-        {
-            return false;
-        }
-    }
-
-    if ((getInternalFormat() == GL_FLOAT && !getContext()->supportsFloatLinearFilter()) ||
-        (getInternalFormat() == GL_HALF_FLOAT_OES && !getContext()->supportsHalfFloatLinearFilter()))
+    if ((getInternalFormat() == GL_FLOAT && !getContext()->supportsFloat32LinearFilter()) ||
+        (getInternalFormat() == GL_HALF_FLOAT_OES && !getContext()->supportsFloat16LinearFilter()))
     {
         if (mMagFilter != GL_NEAREST || (mMinFilter != GL_NEAREST && mMinFilter != GL_NEAREST_MIPMAP_NEAREST))
         {
@@ -2305,11 +2070,12 @@
         }
     }
 
-    bool npot = getContext()->supportsNonPower2Texture();
-
-    if (!npot)
+    bool npotSupport = getContext()->supportsNonPower2Texture();
+
+    if (!npotSupport)
     {
-        if ((getWrapS() != GL_CLAMP_TO_EDGE || getWrapT() != GL_CLAMP_TO_EDGE) && !isPow2(size))
+        if ((getWrapS() != GL_CLAMP_TO_EDGE && !isPow2(width)) ||
+            (getWrapT() != GL_CLAMP_TO_EDGE && !isPow2(height)))
         {
             return false;
         }
@@ -2317,36 +2083,546 @@
 
     if (mipmapping)
     {
-        if (!npot)
+        if (!npotSupport)
         {
-            if (!isPow2(size))
+            if (!isPow2(width) || !isPow2(height))
             {
                 return false;
             }
         }
 
-        int q = log2(size);
-
-        for (int face = 0; face < 6; face++)
+        if (!isMipmapComplete())
         {
-            for (int level = 1; level <= q; level++)
+            return false;
+        }
+    }
+
+    return true;
+}
+
+// Tests for 2D texture (mipmap) completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
+bool Texture2D::isMipmapComplete() const
+{
+    if (isImmutable())
+    {
+        return true;
+    }
+
+    GLsizei width = mImageArray[0].getWidth();
+    GLsizei height = mImageArray[0].getHeight();
+
+    if (width <= 0 || height <= 0)
+    {
+        return false;
+    }
+
+    int q = log2(std::max(width, height));
+
+    for (int level = 1; level <= q; level++)
+    {
+        if (mImageArray[level].getFormat() != mImageArray[0].getFormat())
+        {
+            return false;
+        }
+
+        if (mImageArray[level].getType() != mImageArray[0].getType())
+        {
+            return false;
+        }
+
+        if (mImageArray[level].getWidth() != std::max(1, width >> level))
+        {
+            return false;
+        }
+
+        if (mImageArray[level].getHeight() != std::max(1, height >> level))
+        {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool Texture2D::isCompressed() const
+{
+    return IsCompressed(getInternalFormat());
+}
+
+IDirect3DBaseTexture9 *Texture2D::getBaseTexture() const
+{
+    return mTexStorage ? mTexStorage->getBaseTexture() : NULL;
+}
+
+// Constructs a Direct3D 9 texture resource from the texture images
+void Texture2D::createTexture()
+{
+    GLsizei width = mImageArray[0].getWidth();
+    GLsizei height = mImageArray[0].getHeight();
+    GLint levels = creationLevels(width, height);
+    D3DFORMAT format = mImageArray[0].getD3DFormat();
+    const bool renderTarget = IsTextureFormatRenderable(format) && (mUsage == GL_FRAMEBUFFER_ATTACHMENT_ANGLE);
+
+    delete mTexStorage;
+    mTexStorage = new TextureStorage2D(levels, format, width, height, renderTarget);
+    
+    if (mTexStorage->isManaged())
+    {
+        int levels = levelCount();
+
+        for (int level = 0; level < levels; level++)
+        {
+            IDirect3DSurface9 *surface = mTexStorage->getSurfaceLevel(level);
+            mImageArray[level].setManagedSurface(surface);
+        }
+    }
+
+    mDirtyImages = true;
+}
+
+void Texture2D::updateTexture()
+{
+    int levels = levelCount();
+
+    for (int level = 0; level < levels; level++)
+    {
+        Image *image = &mImageArray[level];
+
+        if (image->isDirty())
+        {
+            commitRect(level, 0, 0, mImageArray[level].getWidth(), mImageArray[level].getHeight());
+        }
+    }
+}
+
+void Texture2D::convertToRenderTarget()
+{
+    TextureStorage2D *newTexStorage = NULL;
+
+    if (mImageArray[0].getWidth() != 0 && mImageArray[0].getHeight() != 0)
+    {
+        GLsizei width = mImageArray[0].getWidth();
+        GLsizei height = mImageArray[0].getHeight();
+        GLint levels = creationLevels(width, height);
+        D3DFORMAT format = mImageArray[0].getD3DFormat();
+
+        newTexStorage = new TextureStorage2D(levels, format, width, height, true);
+
+        if (mTexStorage != NULL)
+        {
+            int levels = levelCount();
+            for (int i = 0; i < levels; i++)
             {
-                if (mImageArray[face][level].format != mImageArray[0][0].format)
-                {
-                    return false;
+                IDirect3DSurface9 *source = mTexStorage->getSurfaceLevel(i);
+                IDirect3DSurface9 *dest = newTexStorage->getSurfaceLevel(i);
+
+                if (!copyToRenderTarget(dest, source, mTexStorage->isManaged()))
+                {   
+                   delete newTexStorage;
+                   source->Release();
+                   dest->Release();
+                   return error(GL_OUT_OF_MEMORY);
                 }
 
-                if (mImageArray[face][level].type != mImageArray[0][0].type)
-                {
-                    return false;
-                }
-
-                if (mImageArray[face][level].width != std::max(1, size >> level))
-                {
-                    return false;
-                }
-
-                ASSERT(mImageArray[face][level].height == mImageArray[face][level].width);
+                if (source) source->Release();
+                if (dest) dest->Release();
+            }
+        }
+    }
+
+    delete mTexStorage;
+    mTexStorage = newTexStorage;
+
+    mDirtyImages = true;
+}
+
+void Texture2D::generateMipmaps()
+{
+    if (!getContext()->supportsNonPower2Texture())
+    {
+        if (!isPow2(mImageArray[0].getWidth()) || !isPow2(mImageArray[0].getHeight()))
+        {
+            return error(GL_INVALID_OPERATION);
+        }
+    }
+
+    // Purge array levels 1 through q and reset them to represent the generated mipmap levels.
+    unsigned int q = log2(std::max(mImageArray[0].getWidth(), mImageArray[0].getHeight()));
+    for (unsigned int i = 1; i <= q; i++)
+    {
+        redefineImage(i, mImageArray[0].getFormat(), 
+                         std::max(mImageArray[0].getWidth() >> i, 1),
+                         std::max(mImageArray[0].getHeight() >> i, 1),
+                         mImageArray[0].getType());
+    }
+
+    if (mTexStorage && mTexStorage->isRenderTarget())
+    {
+        for (unsigned int i = 1; i <= q; i++)
+        {
+            IDirect3DSurface9 *upper = mTexStorage->getSurfaceLevel(i - 1);
+            IDirect3DSurface9 *lower = mTexStorage->getSurfaceLevel(i);
+
+            if (upper != NULL && lower != NULL)
+            {
+                getBlitter()->boxFilter(upper, lower);
+            }
+
+            if (upper != NULL) upper->Release();
+            if (lower != NULL) lower->Release();
+
+            mImageArray[i].markClean();
+        }
+    }
+    else
+    {
+        for (unsigned int i = 1; i <= q; i++)
+        {
+            if (mImageArray[i].getSurface() == NULL)
+            {
+                return error(GL_OUT_OF_MEMORY);
+            }
+
+            if (FAILED(D3DXLoadSurfaceFromSurface(mImageArray[i].getSurface(), NULL, NULL, mImageArray[i - 1].getSurface(), NULL, NULL, D3DX_FILTER_BOX, 0)))
+            {
+                ERR(" failed to load filter %d to %d.", i - 1, i);
+            }
+
+            mImageArray[i].markDirty();
+        }
+    }
+}
+
+Renderbuffer *Texture2D::getRenderbuffer(GLenum target)
+{
+    if (target != GL_TEXTURE_2D)
+    {
+        return error(GL_INVALID_OPERATION, (Renderbuffer *)NULL);
+    }
+
+    if (mColorbufferProxy.get() == NULL)
+    {
+        mColorbufferProxy.set(new Renderbuffer(id(), new RenderbufferTexture(this, target)));
+    }
+
+    return mColorbufferProxy.get();
+}
+
+IDirect3DSurface9 *Texture2D::getRenderTarget(GLenum target)
+{
+    ASSERT(target == GL_TEXTURE_2D);
+
+    // ensure the underlying texture is created
+    if (getStorage(true) == NULL)
+    {
+        return NULL;
+    }
+
+    updateTexture();
+    
+    return mTexStorage->getSurfaceLevel(0);
+}
+
+TextureStorage *Texture2D::getStorage(bool renderTarget)
+{
+    if (!mTexStorage || (renderTarget && !mTexStorage->isRenderTarget()))
+    {
+        if (renderTarget)
+        {
+            convertToRenderTarget();
+        }
+        else
+        {
+            createTexture();
+        }
+    }
+
+    return mTexStorage;
+}
+
+TextureStorageCubeMap::TextureStorageCubeMap(int levels, D3DFORMAT format, int size, bool renderTarget)
+    : TextureStorage(renderTarget), mFirstRenderTargetSerial(RenderbufferStorage::issueCubeSerials())
+{
+    IDirect3DDevice9 *device = getDevice();
+
+    mTexture = NULL;
+    HRESULT result = device->CreateCubeTexture(size, levels, isRenderTarget() ? D3DUSAGE_RENDERTARGET : 0, format, getPool(), &mTexture, NULL);
+
+    if (FAILED(result))
+    {
+        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
+        error(GL_OUT_OF_MEMORY);
+    }
+}
+
+TextureStorageCubeMap::~TextureStorageCubeMap()
+{
+    if (mTexture)
+    {
+        mTexture->Release();
+    }
+}
+
+IDirect3DSurface9 *TextureStorageCubeMap::getCubeMapSurface(GLenum faceTarget, int level)
+{
+    IDirect3DSurface9 *surface = NULL;
+
+    if (mTexture)
+    {
+        HRESULT result = mTexture->GetCubeMapSurface(es2dx::ConvertCubeFace(faceTarget), level, &surface);
+        ASSERT(SUCCEEDED(result));
+    }
+
+    return surface;
+}
+
+IDirect3DBaseTexture9 *TextureStorageCubeMap::getBaseTexture() const
+{
+    return mTexture;
+}
+
+unsigned int TextureStorageCubeMap::getRenderTargetSerial(GLenum target) const
+{
+    return mFirstRenderTargetSerial + TextureCubeMap::faceIndex(target);
+}
+
+TextureCubeMap::TextureCubeMap(GLuint id) : Texture(id)
+{
+    mTexStorage = NULL;
+}
+
+TextureCubeMap::~TextureCubeMap()
+{
+    for (int i = 0; i < 6; i++)
+    {
+        mFaceProxies[i].set(NULL);
+    }
+
+    delete mTexStorage;
+    mTexStorage = NULL;
+}
+
+GLenum TextureCubeMap::getTarget() const
+{
+    return GL_TEXTURE_CUBE_MAP;
+}
+
+GLsizei TextureCubeMap::getWidth(GLint level) const
+{
+    if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
+        return mImageArray[0][level].getWidth();
+    else
+        return 0;
+}
+
+GLsizei TextureCubeMap::getHeight(GLint level) const
+{
+    if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
+        return mImageArray[0][level].getHeight();
+    else
+        return 0;
+}
+
+GLenum TextureCubeMap::getInternalFormat() const
+{
+    return mImageArray[0][0].getFormat();
+}
+
+GLenum TextureCubeMap::getType() const
+{
+    return mImageArray[0][0].getType();
+}
+
+D3DFORMAT TextureCubeMap::getD3DFormat() const
+{
+    return mImageArray[0][0].getD3DFormat();
+}
+
+void TextureCubeMap::setImagePosX(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
+{
+    setImage(0, level, width, height, format, type, unpackAlignment, pixels);
+}
+
+void TextureCubeMap::setImageNegX(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
+{
+    setImage(1, level, width, height, format, type, unpackAlignment, pixels);
+}
+
+void TextureCubeMap::setImagePosY(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
+{
+    setImage(2, level, width, height, format, type, unpackAlignment, pixels);
+}
+
+void TextureCubeMap::setImageNegY(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
+{
+    setImage(3, level, width, height, format, type, unpackAlignment, pixels);
+}
+
+void TextureCubeMap::setImagePosZ(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
+{
+    setImage(4, level, width, height, format, type, unpackAlignment, pixels);
+}
+
+void TextureCubeMap::setImageNegZ(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
+{
+    setImage(5, level, width, height, format, type, unpackAlignment, pixels);
+}
+
+void TextureCubeMap::setCompressedImage(GLenum face, GLint level, GLenum format, GLsizei width, GLsizei height, GLsizei imageSize, const void *pixels)
+{
+    redefineImage(faceIndex(face), level, format, width, height, GL_UNSIGNED_BYTE);
+
+    Texture::setCompressedImage(imageSize, pixels, &mImageArray[faceIndex(face)][level]);
+}
+
+void TextureCubeMap::commitRect(int face, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height)
+{
+    ASSERT(mImageArray[face][level].getSurface() != NULL);
+
+    if (level < levelCount())
+    {
+        IDirect3DSurface9 *destLevel = mTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, level);
+        ASSERT(destLevel != NULL);
+
+        if (destLevel != NULL)
+        {
+            Image *image = &mImageArray[face][level];
+            image->updateSurface(destLevel, xoffset, yoffset, width, height);
+
+            destLevel->Release();
+            image->markClean();
+        }
+    }
+}
+
+void TextureCubeMap::subImage(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
+{
+    if (Texture::subImage(xoffset, yoffset, width, height, format, type, unpackAlignment, pixels, &mImageArray[faceIndex(target)][level]))
+    {
+        commitRect(faceIndex(target), level, xoffset, yoffset, width, height);
+    }
+}
+
+void TextureCubeMap::subImageCompressed(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *pixels)
+{
+    if (Texture::subImageCompressed(xoffset, yoffset, width, height, format, imageSize, pixels, &mImageArray[faceIndex(target)][level]))
+    {
+        commitRect(faceIndex(target), level, xoffset, yoffset, width, height);
+    }
+}
+
+// Tests for cube map sampling completeness. [OpenGL ES 2.0.24] section 3.8.2 page 86.
+bool TextureCubeMap::isSamplerComplete() const
+{
+    int size = mImageArray[0][0].getWidth();
+
+    bool mipmapping;
+
+    switch (mMinFilter)
+    {
+      case GL_NEAREST:
+      case GL_LINEAR:
+        mipmapping = false;
+        break;
+      case GL_NEAREST_MIPMAP_NEAREST:
+      case GL_LINEAR_MIPMAP_NEAREST:
+      case GL_NEAREST_MIPMAP_LINEAR:
+      case GL_LINEAR_MIPMAP_LINEAR:
+        mipmapping = true;
+        break;
+      default: UNREACHABLE();
+    }
+
+    if ((getInternalFormat() == GL_FLOAT && !getContext()->supportsFloat32LinearFilter()) ||
+        (getInternalFormat() == GL_HALF_FLOAT_OES && !getContext()->supportsFloat16LinearFilter()))
+    {
+        if (mMagFilter != GL_NEAREST || (mMinFilter != GL_NEAREST && mMinFilter != GL_NEAREST_MIPMAP_NEAREST))
+        {
+            return false;
+        }
+    }
+
+    if (!isPow2(size) && !getContext()->supportsNonPower2Texture())
+    {
+        if (getWrapS() != GL_CLAMP_TO_EDGE || getWrapT() != GL_CLAMP_TO_EDGE || mipmapping)
+        {
+            return false;
+        }
+    }
+
+    if (!mipmapping)
+    {
+        if (!isCubeComplete())
+        {
+            return false;
+        }
+    }
+    else
+    {
+        if (!isMipmapCubeComplete())   // Also tests for isCubeComplete()
+        {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+// Tests for cube texture completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
+bool TextureCubeMap::isCubeComplete() const
+{
+    if (mImageArray[0][0].getWidth() <= 0 || mImageArray[0][0].getHeight() != mImageArray[0][0].getWidth())
+    {
+        return false;
+    }
+
+    for (unsigned int face = 1; face < 6; face++)
+    {
+        if (mImageArray[face][0].getWidth() != mImageArray[0][0].getWidth() ||
+            mImageArray[face][0].getWidth() != mImageArray[0][0].getHeight() ||
+            mImageArray[face][0].getFormat() != mImageArray[0][0].getFormat() ||
+            mImageArray[face][0].getType() != mImageArray[0][0].getType())
+        {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool TextureCubeMap::isMipmapCubeComplete() const
+{
+    if (isImmutable())
+    {
+        return true;
+    }
+
+    if (!isCubeComplete())
+    {
+        return false;
+    }
+
+    GLsizei size = mImageArray[0][0].getWidth();
+
+    int q = log2(size);
+
+    for (int face = 0; face < 6; face++)
+    {
+        for (int level = 1; level <= q; level++)
+        {
+            if (mImageArray[face][level].getFormat() != mImageArray[0][0].getFormat())
+            {
+                return false;
+            }
+
+            if (mImageArray[face][level].getType() != mImageArray[0][0].getType())
+            {
+                return false;
+            }
+
+            if (mImageArray[face][level].getWidth() != std::max(1, size >> level))
+            {
+                return false;
             }
         }
     }
@@ -2361,39 +2637,39 @@
 
 IDirect3DBaseTexture9 *TextureCubeMap::getBaseTexture() const
 {
-    return mTexture;
+    return mTexStorage ? mTexStorage->getBaseTexture() : NULL;
 }
 
 // Constructs a Direct3D 9 texture resource from the texture images, or returns an existing one
 void TextureCubeMap::createTexture()
 {
-    IDirect3DDevice9 *device = getDevice();
+    GLsizei size = mImageArray[0][0].getWidth();
+    GLint levels = creationLevels(size, 0);
     D3DFORMAT format = mImageArray[0][0].getD3DFormat();
-    GLint levels = creationLevels(mImageArray[0][0].width, 0);
-
-    IDirect3DCubeTexture9 *texture = NULL;
-    HRESULT result = device->CreateCubeTexture(mImageArray[0][0].width, levels, 0, format, D3DPOOL_DEFAULT, &texture, NULL);
-
-    if (FAILED(result))
+    const bool renderTarget = IsTextureFormatRenderable(format) && (mUsage == GL_FRAMEBUFFER_ATTACHMENT_ANGLE);
+
+    delete mTexStorage;
+    mTexStorage = new TextureStorageCubeMap(levels, format, size, renderTarget);
+
+    if (mTexStorage->isManaged())
     {
-        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-        return error(GL_OUT_OF_MEMORY);
+        int levels = levelCount();
+
+        for (int face = 0; face < 6; face++)
+        {
+            for (int level = 0; level < levels; level++)
+            {
+                IDirect3DSurface9 *surface = mTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, level);
+                mImageArray[face][level].setManagedSurface(surface);
+            }
+        }
     }
 
-    if (mTexture)
-    {
-        mTexture->Release();
-    }
-
-    mTexture = texture;
-    mDirtyImage = true;
-    mIsRenderable = false;
+    mDirtyImages = true;
 }
 
 void TextureCubeMap::updateTexture()
 {
-    IDirect3DDevice9 *device = getDevice();
-
     for (int face = 0; face < 6; face++)
     {
         int levels = levelCount();
@@ -2401,20 +2677,9 @@
         {
             Image *image = &mImageArray[face][level];
 
-            if (image->surface && image->dirty)
+            if (image->isDirty())
             {
-                IDirect3DSurface9 *levelSurface = getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, level);
-                ASSERT(levelSurface != NULL);
-
-                if (levelSurface != NULL)
-                {
-                    HRESULT result = device->UpdateSurface(image->surface, NULL, levelSurface, NULL);
-                    ASSERT(SUCCEEDED(result));
-
-                    levelSurface->Release();
-
-                    image->dirty = false;
-                }
+                commitRect(face, level, 0, 0, image->getWidth(), image->getHeight());
             }
         }
     }
@@ -2422,89 +2687,53 @@
 
 void TextureCubeMap::convertToRenderTarget()
 {
-    IDirect3DCubeTexture9 *texture = NULL;
-
-    if (mImageArray[0][0].width != 0)
+    TextureStorageCubeMap *newTexStorage = NULL;
+
+    if (mImageArray[0][0].getWidth() != 0)
     {
-        egl::Display *display = getDisplay();
-        IDirect3DDevice9 *device = getDevice();
+        GLsizei size = mImageArray[0][0].getWidth();
+        GLint levels = creationLevels(size, 0);
         D3DFORMAT format = mImageArray[0][0].getD3DFormat();
-        GLint levels = creationLevels(mImageArray[0][0].width, 0);
-
-        HRESULT result = device->CreateCubeTexture(mImageArray[0][0].width, levels, D3DUSAGE_RENDERTARGET, format, D3DPOOL_DEFAULT, &texture, NULL);
-
-        if (FAILED(result))
+
+        newTexStorage = new TextureStorageCubeMap(levels, format, size, true);
+
+        if (mTexStorage != NULL)
         {
-            ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-            return error(GL_OUT_OF_MEMORY);
-        }
-
-        if (mTexture != NULL)
-        {
+            egl::Display *display = getDisplay();
+            IDirect3DDevice9 *device = display->getDevice();
+
             int levels = levelCount();
             for (int f = 0; f < 6; f++)
             {
                 for (int i = 0; i < levels; i++)
                 {
-                    IDirect3DSurface9 *source;
-                    result = mTexture->GetCubeMapSurface(static_cast<D3DCUBEMAP_FACES>(f), i, &source);
-
-                    if (FAILED(result))
+                    IDirect3DSurface9 *source = mTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + f, i);
+                    IDirect3DSurface9 *dest = newTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + f, i);
+
+                    if (!copyToRenderTarget(dest, source, mTexStorage->isManaged()))
                     {
-                        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-
-                        texture->Release();
-
-                        return error(GL_OUT_OF_MEMORY);
+                       delete newTexStorage;
+                       source->Release();
+                       dest->Release();
+                       return error(GL_OUT_OF_MEMORY);
                     }
 
-                    IDirect3DSurface9 *dest;
-                    result = texture->GetCubeMapSurface(static_cast<D3DCUBEMAP_FACES>(f), i, &dest);
-
-                    if (FAILED(result))
-                    {
-                        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-
-                        texture->Release();
-                        source->Release();
-
-                        return error(GL_OUT_OF_MEMORY);
-                    }
-
-                    display->endScene();
-                    result = device->StretchRect(source, NULL, dest, NULL, D3DTEXF_NONE);
-
-                    if (FAILED(result))
-                    {
-                        ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
-
-                        texture->Release();
-                        source->Release();
-                        dest->Release();
-
-                        return error(GL_OUT_OF_MEMORY);
-                    }
-
-                    source->Release();
-                    dest->Release();
+                    if (source) source->Release();
+                    if (dest) dest->Release();
                 }
             }
         }
     }
 
-    if (mTexture != NULL)
-    {
-        mTexture->Release();
-    }
-
-    mTexture = texture;
-    mDirtyImage = true;
-    mIsRenderable = true;
+    delete mTexStorage;
+    mTexStorage = newTexStorage;
+
+    mDirtyImages = true;
 }
 
 void TextureCubeMap::setImage(int faceIndex, GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
 {
-    redefineTexture(faceIndex, level, format, width, height, type);
+    redefineImage(faceIndex, level, format, width, height, type);
 
     Texture::setImage(unpackAlignment, pixels, &mImageArray[faceIndex][level]);
 }
@@ -2520,48 +2749,24 @@
     return face - GL_TEXTURE_CUBE_MAP_POSITIVE_X;
 }
 
-void TextureCubeMap::redefineTexture(int face, GLint level, GLenum format, GLsizei width, GLsizei height, GLenum type)
+void TextureCubeMap::redefineImage(int face, GLint level, GLenum format, GLsizei width, GLsizei height, GLenum type)
 {
-    GLsizei textureWidth = mImageArray[0][0].width;
-    GLsizei textureHeight = mImageArray[0][0].height;
-    GLenum textureFormat = mImageArray[0][0].format;
-    GLenum textureType = mImageArray[0][0].type;
-
-    mImageArray[face][level].width = width;
-    mImageArray[face][level].height = height;
-    mImageArray[face][level].format = format;
-    mImageArray[face][level].type = type;
-
-    if (!mTexture)
-    {
-        return;
-    }
-
-    bool sizeOkay = (textureWidth >> level == width);
-    bool textureOkay = (sizeOkay && textureFormat == format && textureType == type);
-
-    if (!textureOkay)   // Purge all the levels and the texture.
+    bool redefined = mImageArray[face][level].redefine(format, width, height, type, false);
+
+    if (mTexStorage && redefined)
     {
         for (int i = 0; i < IMPLEMENTATION_MAX_TEXTURE_LEVELS; i++)
         {
             for (int f = 0; f < 6; f++)
             {
-                if (mImageArray[f][i].surface != NULL)
-                {
-                    mImageArray[f][i].surface->Release();
-                    mImageArray[f][i].surface = NULL;
-                    mImageArray[f][i].dirty = true;
-                }
+                mImageArray[f][i].markDirty();
             }
         }
 
-        if (mTexture != NULL)
-        {
-            mTexture->Release();
-            mTexture = NULL;
-            mDirtyImage = true;
-            mIsRenderable = false;
-        }
+        delete mTexStorage;
+        mTexStorage = NULL;
+
+        mDirtyImages = true;
     }
 }
 
@@ -2576,20 +2781,21 @@
     }
 
     unsigned int faceindex = faceIndex(target);
-    redefineTexture(faceindex, level, format, width, height, GL_UNSIGNED_BYTE);
-
-    if (!mImageArray[faceindex][level].isRenderable())
+    redefineImage(faceindex, level, format, width, height, GL_UNSIGNED_BYTE);
+
+    if (!mImageArray[faceindex][level].isRenderableFormat())
     {
-        copyToImage(&mImageArray[faceindex][level], 0, 0, x, y, width, height, renderTarget);
+        mImageArray[faceindex][level].copy(0, 0, x, y, width, height, renderTarget);
+        mDirtyImages = true;
     }
     else
     {
-        if (!mTexture || !mIsRenderable)
+        if (!mTexStorage || !mTexStorage->isRenderTarget())
         {
             convertToRenderTarget();
         }
         
-        updateTexture();
+        mImageArray[faceindex][level].markClean();
 
         ASSERT(width == height);
 
@@ -2601,34 +2807,24 @@
             sourceRect.right = clamp(sourceRect.right, 0, source->getColorbuffer()->getWidth());
             sourceRect.bottom = clamp(sourceRect.bottom, 0, source->getColorbuffer()->getHeight());
 
-            GLint destYOffset = transformPixelYOffset(0, height, mImageArray[faceindex][level].width);
-
-            IDirect3DSurface9 *dest = getCubeMapSurface(target, level);
-
-            getBlitter()->copy(source->getRenderTarget(), sourceRect, format, 0, destYOffset, dest);
-            dest->Release();
+            GLint destYOffset = transformPixelYOffset(0, height, mImageArray[faceindex][level].getWidth());
+
+            IDirect3DSurface9 *dest = mTexStorage->getCubeMapSurface(target, level);
+
+            if (dest)
+            {
+                getBlitter()->copy(renderTarget, sourceRect, format, 0, destYOffset, dest);
+                dest->Release();
+            }
         }
     }
-}
-
-IDirect3DSurface9 *TextureCubeMap::getCubeMapSurface(GLenum face, unsigned int level)
-{
-    if (mTexture == NULL)
-    {
-        UNREACHABLE();
-        return NULL;
-    }
-
-    IDirect3DSurface9 *surface = NULL;
-
-    HRESULT hr = mTexture->GetCubeMapSurface(es2dx::ConvertCubeFace(face), level, &surface);
-
-    return (SUCCEEDED(hr)) ? surface : NULL;
+
+    renderTarget->Release();
 }
 
 void TextureCubeMap::copySubImage(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, Framebuffer *source)
 {
-    GLsizei size = mImageArray[faceIndex(target)][level].width;
+    GLsizei size = mImageArray[faceIndex(target)][level].getWidth();
 
     if (xoffset + width > size || yoffset + height > size)
     {
@@ -2644,15 +2840,15 @@
     }
 
     unsigned int faceindex = faceIndex(target);
-    redefineTexture(faceindex, level, mImageArray[faceindex][level].format, mImageArray[faceindex][level].width, mImageArray[faceindex][level].height, GL_UNSIGNED_BYTE);
-   
-    if (!mImageArray[faceindex][level].isRenderable() || (!mTexture && !isComplete()))
+
+    if (!mImageArray[faceindex][level].isRenderableFormat() || (!mTexStorage && !isSamplerComplete()))
     {
-        copyToImage(&mImageArray[faceindex][level], 0, 0, x, y, width, height, renderTarget);
+        mImageArray[faceindex][level].copy(0, 0, x, y, width, height, renderTarget);
+        mDirtyImages = true;
     }
     else
     {
-        if (!mTexture || !mIsRenderable)
+        if (!mTexStorage || !mTexStorage->isRenderTarget())
         {
             convertToRenderTarget();
         }
@@ -2667,33 +2863,62 @@
             sourceRect.right = clamp(sourceRect.right, 0, source->getColorbuffer()->getWidth());
             sourceRect.bottom = clamp(sourceRect.bottom, 0, source->getColorbuffer()->getHeight());
 
-            GLint destYOffset = transformPixelYOffset(yoffset, height, mImageArray[faceindex][level].width);
-
-            IDirect3DSurface9 *dest = getCubeMapSurface(target, level);
-
-            getBlitter()->copy(source->getRenderTarget(), sourceRect, mImageArray[0][0].format, xoffset, destYOffset, dest);
-            dest->Release();
+            GLint destYOffset = transformPixelYOffset(yoffset, height, mImageArray[faceindex][level].getWidth());
+
+            IDirect3DSurface9 *dest = mTexStorage->getCubeMapSurface(target, level);
+
+            if (dest)
+            {
+                getBlitter()->copy(renderTarget, sourceRect, mImageArray[0][0].getFormat(), xoffset, destYOffset, dest);
+                dest->Release();
+            }
         }
     }
+
+    renderTarget->Release();
 }
 
-bool TextureCubeMap::isCubeComplete() const
+void TextureCubeMap::storage(GLsizei levels, GLenum internalformat, GLsizei size)
 {
-    if (mImageArray[0][0].width == 0)
+    GLenum format = gl::ExtractFormat(internalformat);
+    GLenum type = gl::ExtractType(internalformat);
+    D3DFORMAT d3dfmt = ConvertTextureFormatType(format, type);
+    const bool renderTarget = IsTextureFormatRenderable(d3dfmt) && (mUsage == GL_FRAMEBUFFER_ATTACHMENT_ANGLE);
+
+    delete mTexStorage;
+    mTexStorage = new TextureStorageCubeMap(levels, d3dfmt, size, renderTarget);
+    mImmutable = true;
+
+    for (int level = 0; level < levels; level++)
     {
-        return false;
-    }
-
-    for (unsigned int f = 1; f < 6; f++)
-    {
-        if (mImageArray[f][0].width != mImageArray[0][0].width
-            || mImageArray[f][0].format != mImageArray[0][0].format)
+        for (int face = 0; face < 6; face++)
         {
-            return false;
+            mImageArray[face][level].redefine(format, size, size, type, true);
+            size = std::max(1, size >> 1);
         }
     }
 
-    return true;
+    for (int level = levels; level < IMPLEMENTATION_MAX_TEXTURE_LEVELS; level++)
+    {
+        for (int face = 0; face < 6; face++)
+        {
+            mImageArray[face][level].redefine(GL_NONE, 0, 0, GL_UNSIGNED_BYTE, true);
+        }
+    }
+
+    if (mTexStorage->isManaged())
+    {
+        int levels = levelCount();
+
+        for (int face = 0; face < 6; face++)
+        {
+            for (int level = 0; level < levels; level++)
+            {
+                IDirect3DSurface9 *surface = mTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, level);
+                mImageArray[face][level].setManagedSurface(surface);
+            }
+        }
+    }
 }
 
 void TextureCubeMap::generateMipmaps()
@@ -2705,44 +2930,33 @@
 
     if (!getContext()->supportsNonPower2Texture())
     {
-        if (!isPow2(mImageArray[0][0].width))
+        if (!isPow2(mImageArray[0][0].getWidth()))
         {
             return error(GL_INVALID_OPERATION);
         }
     }
 
     // Purge array levels 1 through q and reset them to represent the generated mipmap levels.
-    unsigned int q = log2(mImageArray[0][0].width);
+    unsigned int q = log2(mImageArray[0][0].getWidth());
     for (unsigned int f = 0; f < 6; f++)
     {
         for (unsigned int i = 1; i <= q; i++)
         {
-            if (mImageArray[f][i].surface != NULL)
-            {
-                mImageArray[f][i].surface->Release();
-                mImageArray[f][i].surface = NULL;
-            }
-
-            mImageArray[f][i].width = std::max(mImageArray[f][0].width >> i, 1);
-            mImageArray[f][i].height = mImageArray[f][i].width;
-            mImageArray[f][i].format = mImageArray[f][0].format;
-            mImageArray[f][i].type = mImageArray[f][0].type;
+            redefineImage(f, i, mImageArray[f][0].getFormat(),
+                                std::max(mImageArray[f][0].getWidth() >> i, 1),
+                                std::max(mImageArray[f][0].getWidth() >> i, 1),
+                                mImageArray[f][0].getType());
         }
     }
 
-    if (mIsRenderable)
+    if (mTexStorage && mTexStorage->isRenderTarget())
     {
-        if (mTexture == NULL)
-        {
-            return;
-        }
-
         for (unsigned int f = 0; f < 6; f++)
         {
             for (unsigned int i = 1; i <= q; i++)
             {
-                IDirect3DSurface9 *upper = getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + f, i-1);
-                IDirect3DSurface9 *lower = getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + f, i);
+                IDirect3DSurface9 *upper = mTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + f, i-1);
+                IDirect3DSurface9 *lower = mTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + f, i);
 
                 if (upper != NULL && lower != NULL)
                 {
@@ -2752,7 +2966,7 @@
                 if (upper != NULL) upper->Release();
                 if (lower != NULL) lower->Release();
 
-                mImageArray[f][i].dirty = false;
+                mImageArray[f][i].markClean();
             }
         }
     }
@@ -2762,18 +2976,17 @@
         {
             for (unsigned int i = 1; i <= q; i++)
             {
-                createSurface(&mImageArray[f][i]);
-                if (mImageArray[f][i].surface == NULL)
+                if (mImageArray[f][i].getSurface() == NULL)
                 {
                     return error(GL_OUT_OF_MEMORY);
                 }
 
-                if (FAILED(D3DXLoadSurfaceFromSurface(mImageArray[f][i].surface, NULL, NULL, mImageArray[f][i - 1].surface, NULL, NULL, D3DX_FILTER_BOX, 0)))
+                if (FAILED(D3DXLoadSurfaceFromSurface(mImageArray[f][i].getSurface(), NULL, NULL, mImageArray[f][i - 1].getSurface(), NULL, NULL, D3DX_FILTER_BOX, 0)))
                 {
                     ERR(" failed to load filter %d to %d.", i - 1, i);
                 }
 
-                mImageArray[f][i].dirty = true;
+                mImageArray[f][i].markDirty();
             }
         }
     }
@@ -2790,7 +3003,7 @@
 
     if (mFaceProxies[face].get() == NULL)
     {
-        mFaceProxies[face].set(new Renderbuffer(id(), new Colorbuffer(this, target)));
+        mFaceProxies[face].set(new Renderbuffer(id(), new RenderbufferTexture(this, target)));
     }
 
     return mFaceProxies[face].get();
@@ -2800,22 +3013,32 @@
 {
     ASSERT(IsCubemapTextureTarget(target));
 
-    if (!mIsRenderable)
-    {
-        convertToRenderTarget();
-    }
-
-    if (mTexture == NULL)
+    // ensure the underlying texture is created
+    if (getStorage(true) == NULL)
     {
         return NULL;
     }
 
     updateTexture();
     
-    IDirect3DSurface9 *renderTarget = NULL;
-    mTexture->GetCubeMapSurface(es2dx::ConvertCubeFace(target), 0, &renderTarget);
-
-    return renderTarget;
+    return mTexStorage->getCubeMapSurface(target, 0);
 }
 
+TextureStorage *TextureCubeMap::getStorage(bool renderTarget)
+{
+    if (!mTexStorage || (renderTarget && !mTexStorage->isRenderTarget()))
+    {
+        if (renderTarget)
+        {
+            convertToRenderTarget();
+        }
+        else
+        {
+            createTexture();
+        }
+    }
+
+    return mTexStorage;
 }
+
+}
\ No newline at end of file
diff -r d713478624d8 gfx/angle/src/libGLESv2/Texture.h
--- a/gfx/angle/src/libGLESv2/Texture.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/Texture.h	Thu Jan 05 10:52:20 2012 +0900
@@ -43,6 +43,129 @@
     IMPLEMENTATION_MAX_TEXTURE_LEVELS = 15   // 1+log2 of MAX_TEXTURE_SIZE
 };
 
+class Image
+{
+  public:
+    Image();
+    ~Image();
+
+    bool redefine(GLenum format, GLsizei width, GLsizei height, GLenum type, bool forceRelease);
+    void markDirty() {mDirty = true;}
+    void markClean() {mDirty = false;}
+
+    HRESULT lock(D3DLOCKED_RECT *lockedRect, const RECT *rect);
+    void unlock();
+
+    bool isRenderableFormat() const;
+    D3DFORMAT getD3DFormat() const;
+
+    GLsizei getWidth() const {return mWidth;}
+    GLsizei getHeight() const {return mHeight;}
+    GLenum getFormat() const {return mFormat;}
+    GLenum getType() const {return mType;}
+    bool isDirty() const {return mSurface && mDirty;}
+    IDirect3DSurface9 *getSurface();
+
+    void setManagedSurface(IDirect3DSurface9 *surface);
+    void updateSurface(IDirect3DSurface9 *dest, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height);
+
+    void loadData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum type,
+                  GLint unpackAlignment, const void *input, std::size_t outputPitch, void *output) const;
+
+    void loadAlphaData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                       int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadAlphaFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                            int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadAlphaHalfFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadLuminanceData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                           int inputPitch, const void *input, size_t outputPitch, void *output, bool native) const;
+    void loadLuminanceFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadLuminanceHalfFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                    int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadLuminanceAlphaData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                int inputPitch, const void *input, size_t outputPitch, void *output, bool native) const;
+    void loadLuminanceAlphaFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                     int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadLuminanceAlphaHalfFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                                         int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadRGBUByteData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                          int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadRGB565Data(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                        int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadRGBFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                          int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadRGBHalfFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                              int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadRGBAUByteDataSSE2(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                               int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadRGBAUByteData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                           int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadRGBA4444Data(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                          int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadRGBA5551Data(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                          int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadRGBAFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                           int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadRGBAHalfFloatData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                               int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadBGRAData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                      int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadCompressedData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                            int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadDXT1Data(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                      int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadDXT3Data(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                      int inputPitch, const void *input, size_t outputPitch, void *output) const;
+    void loadDXT5Data(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
+                      int inputPitch, const void *input, size_t outputPitch, void *output) const;
+
+    void copy(GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, IDirect3DSurface9 *renderTarget);
+
+  private:
+    DISALLOW_COPY_AND_ASSIGN(Image);
+
+    void createSurface();
+
+    GLsizei mWidth;
+    GLsizei mHeight;
+    GLenum mFormat;
+    GLenum mType;
+
+    bool mDirty;
+
+    D3DPOOL mD3DPool;   // can only be D3DPOOL_SYSTEMMEM or D3DPOOL_MANAGED since it needs to be lockable.
+    D3DFORMAT mD3DFormat;
+
+    IDirect3DSurface9 *mSurface;
+};
+
+class TextureStorage
+{
+  public:
+    explicit TextureStorage(bool renderTarget);
+
+    virtual ~TextureStorage();
+
+    bool isRenderTarget() const;
+    bool isManaged() const;
+    D3DPOOL getPool() const;
+    unsigned int getTextureSerial() const;
+    virtual unsigned int getRenderTargetSerial(GLenum target) const = 0;
+
+  private:
+    DISALLOW_COPY_AND_ASSIGN(TextureStorage);
+
+    const bool mRenderTarget;
+    const D3DPOOL mD3DPool;
+
+    const unsigned int mTextureSerial;
+    static unsigned int issueTextureSerial();
+
+    static unsigned int mCurrentTextureSerial;
+};
+
 class Texture : public RefCountObject
 {
   public:
@@ -56,19 +179,21 @@
     bool setMagFilter(GLenum filter);
     bool setWrapS(GLenum wrap);
     bool setWrapT(GLenum wrap);
+    bool setUsage(GLenum usage);
 
     GLenum getMinFilter() const;
     GLenum getMagFilter() const;
     GLenum getWrapS() const;
     GLenum getWrapT() const;
+    GLenum getUsage() const;
 
-    virtual GLsizei getWidth() const = 0;
-    virtual GLsizei getHeight() const = 0;
+    virtual GLsizei getWidth(GLint level) const = 0;
+    virtual GLsizei getHeight(GLint level) const = 0;
     virtual GLenum getInternalFormat() const = 0;
     virtual GLenum getType() const = 0;
     virtual D3DFORMAT getD3DFormat() const = 0;
 
-    virtual bool isComplete() const = 0;
+    virtual bool isSamplerComplete() const = 0;
     virtual bool isCompressed() const = 0;
 
     IDirect3DBaseTexture9 *getTexture();
@@ -77,43 +202,26 @@
     virtual void generateMipmaps() = 0;
     virtual void copySubImage(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, Framebuffer *source) = 0;
 
-    bool isDirtyParameter() const;
-    bool isDirtyImage() const;
+    bool hasDirtyParameters() const;
+    bool hasDirtyImages() const;
     void resetDirty();
-    unsigned int getSerial() const;
+    unsigned int getTextureSerial();
+    unsigned int getRenderTargetSerial(GLenum target);
+
+    bool isImmutable() const;
 
     static const GLuint INCOMPLETE_TEXTURE_ID = static_cast<GLuint>(-1);   // Every texture takes an id at creation time. The value is arbitrary because it is never registered with the resource manager.
 
   protected:
-    friend class Colorbuffer;
-
-    // Helper structure representing a single image layer
-    struct Image
-    {
-        Image();
-        ~Image();
-
-        bool isRenderable() const;
-        D3DFORMAT getD3DFormat() const;
-
-        GLsizei width;
-        GLsizei height;
-        GLenum format;
-        GLenum type;
-
-        bool dirty;
-
-        IDirect3DSurface9 *surface;
-    };
+    friend class RenderbufferTexture;
 
     void setImage(GLint unpackAlignment, const void *pixels, Image *image);
     bool subImage(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels, Image *image);
     void setCompressedImage(GLsizei imageSize, const void *pixels, Image *image);
     bool subImageCompressed(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *pixels, Image *image);
-    void copyToImage(Image *image, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, IDirect3DSurface9 *renderTarget);
 
-    GLint creationLevels(GLsizei width, GLsizei height, GLint maxlevel) const;
-    GLint creationLevels(GLsizei size, GLint maxlevel) const;
+    GLint creationLevels(GLsizei width, GLsizei height) const;
+    GLint creationLevels(GLsizei size) const;
 
     virtual IDirect3DBaseTexture9 *getBaseTexture() const = 0;
     virtual void createTexture() = 0;
@@ -121,82 +229,46 @@
     virtual void convertToRenderTarget() = 0;
     virtual IDirect3DSurface9 *getRenderTarget(GLenum target) = 0;
 
-    void createSurface(Image *image);
+    int levelCount() const;
 
-    Blit *getBlitter();
-
-    int levelCount() const;
+    static Blit *getBlitter();
+    static bool copyToRenderTarget(IDirect3DSurface9 *dest, IDirect3DSurface9 *source, bool fromManaged);
 
     GLenum mMinFilter;
     GLenum mMagFilter;
     GLenum mWrapS;
     GLenum mWrapT;
-    bool mDirtyParameter;
+    bool mDirtyParameters;
+    GLenum mUsage;
 
-    bool mDirtyImage;
+    bool mDirtyImages;
 
-    bool mIsRenderable;
+    bool mImmutable;
 
   private:
     DISALLOW_COPY_AND_ASSIGN(Texture);
 
-    void loadImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type,
-                       GLint unpackAlignment, const void *input, std::size_t outputPitch, void *output, D3DSURFACE_DESC *description) const;
+    virtual TextureStorage *getStorage(bool renderTarget) = 0;
+};
 
-    void loadAlphaImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                            int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadAlphaFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                 int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadAlphaHalfFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                     int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadLuminanceImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                int inputPitch, const void *input, size_t outputPitch, void *output, bool native) const;
-    void loadLuminanceFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                     int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadLuminanceHalfFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                         int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadLuminanceAlphaImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                     int inputPitch, const void *input, size_t outputPitch, void *output, bool native) const;
-    void loadLuminanceAlphaFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                          int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadLuminanceAlphaHalfFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                              int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadRGBUByteImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                               int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadRGB565ImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                             int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadRGBFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                               int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadRGBHalfFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                   int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadRGBAUByteImageDataSSE2(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                    int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadRGBAUByteImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadRGBA4444ImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                               int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadRGBA5551ImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                               int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadRGBAFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadRGBAHalfFloatImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                    int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadBGRAImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                           int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadCompressedImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                                 int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadDXT1ImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                           int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadDXT3ImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                           int inputPitch, const void *input, size_t outputPitch, void *output) const;
-    void loadDXT5ImageData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
-                           int inputPitch, const void *input, size_t outputPitch, void *output) const;
+class TextureStorage2D : public TextureStorage
+{
+  public:
+    explicit TextureStorage2D(IDirect3DTexture9 *surfaceTexture);
+    TextureStorage2D(int levels, D3DFORMAT format, int width, int height, bool renderTarget);
 
-    static unsigned int issueSerial();
+    virtual ~TextureStorage2D();
 
-    const unsigned int mSerial;
+    IDirect3DSurface9 *getSurfaceLevel(int level);
+    IDirect3DBaseTexture9 *getBaseTexture() const;
 
-    static unsigned int mCurrentSerial;
+    virtual unsigned int getRenderTargetSerial(GLenum target) const;
+
+  private:
+    DISALLOW_COPY_AND_ASSIGN(TextureStorage2D);
+
+    IDirect3DTexture9 *mTexture;
+    const unsigned int mRenderTargetSerial;
 };
 
 class Texture2D : public Texture
@@ -208,8 +280,8 @@
 
     virtual GLenum getTarget() const;
 
-    virtual GLsizei getWidth() const;
-    virtual GLsizei getHeight() const;
+    virtual GLsizei getWidth(GLint level) const;
+    virtual GLsizei getHeight(GLint level) const;
     virtual GLenum getInternalFormat() const;
     virtual GLenum getType() const;
     virtual D3DFORMAT getD3DFormat() const;
@@ -219,9 +291,10 @@
     void subImage(GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels);
     void subImageCompressed(GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *pixels);
     void copyImage(GLint level, GLenum format, GLint x, GLint y, GLsizei width, GLsizei height, Framebuffer *source);
-    void copySubImage(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, Framebuffer *source);
+    virtual void copySubImage(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, Framebuffer *source);
+    void storage(GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
 
-    virtual bool isComplete() const;
+    virtual bool isSamplerComplete() const;
     virtual bool isCompressed() const;
     virtual void bindTexImage(egl::Surface *surface);
     virtual void releaseTexImage();
@@ -238,18 +311,40 @@
     virtual void updateTexture();
     virtual void convertToRenderTarget();
     virtual IDirect3DSurface9 *getRenderTarget(GLenum target);
+    virtual TextureStorage *getStorage(bool renderTarget);
 
-    void redefineTexture(GLint level, GLenum format, GLsizei width, GLsizei height, GLenum type, bool force);
+    bool isMipmapComplete() const;
+
+    void redefineImage(GLint level, GLenum format, GLsizei width, GLsizei height, GLenum type);
     void commitRect(GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height);
 
     Image mImageArray[IMPLEMENTATION_MAX_TEXTURE_LEVELS];
 
-    IDirect3DTexture9 *mTexture;
+    TextureStorage2D *mTexStorage;
     egl::Surface *mSurface;
 
     BindingPointer<Renderbuffer> mColorbufferProxy;
 };
 
+class TextureStorageCubeMap : public TextureStorage
+{
+  public:
+    TextureStorageCubeMap(int levels, D3DFORMAT format, int size, bool renderTarget);
+
+    virtual ~TextureStorageCubeMap();
+
+    IDirect3DSurface9 *getCubeMapSurface(GLenum faceTarget, int level);
+    IDirect3DBaseTexture9 *getBaseTexture() const;
+
+    virtual unsigned int getRenderTargetSerial(GLenum target) const;
+
+  private:
+    DISALLOW_COPY_AND_ASSIGN(TextureStorageCubeMap);
+
+    IDirect3DCubeTexture9 *mTexture;
+    const unsigned int mFirstRenderTargetSerial;
+};
+
 class TextureCubeMap : public Texture
 {
   public:
@@ -259,8 +354,8 @@
 
     virtual GLenum getTarget() const;
     
-    virtual GLsizei getWidth() const;
-    virtual GLsizei getHeight() const;
+    virtual GLsizei getWidth(GLint level) const;
+    virtual GLsizei getHeight(GLint level) const;
     virtual GLenum getInternalFormat() const;
     virtual GLenum getType() const;
     virtual D3DFORMAT getD3DFormat() const;
@@ -278,14 +373,17 @@
     void subImageCompressed(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *pixels);
     void copyImage(GLenum target, GLint level, GLenum format, GLint x, GLint y, GLsizei width, GLsizei height, Framebuffer *source);
     virtual void copySubImage(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, Framebuffer *source);
+    void storage(GLsizei levels, GLenum internalformat, GLsizei size);
 
-    virtual bool isComplete() const;
+    virtual bool isSamplerComplete() const;
     virtual bool isCompressed() const;
 
     virtual void generateMipmaps();
 
     virtual Renderbuffer *getRenderbuffer(GLenum target);
 
+    static unsigned int faceIndex(GLenum face);
+
   private:
     DISALLOW_COPY_AND_ASSIGN(TextureCubeMap);
 
@@ -294,25 +392,21 @@
     virtual void updateTexture();
     virtual void convertToRenderTarget();
     virtual IDirect3DSurface9 *getRenderTarget(GLenum target);
-
-    // face is one of the GL_TEXTURE_CUBE_MAP_* enumerants.
-    // Returns NULL if the call underlying Direct3D call fails.
-    IDirect3DSurface9 *getCubeMapSurface(GLenum face, unsigned int level);
-
-    static unsigned int faceIndex(GLenum face);
+    virtual TextureStorage *getStorage(bool renderTarget);
 
     bool isCubeComplete() const;
+    bool isMipmapCubeComplete() const;
 
     void setImage(int faceIndex, GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels);
-    void commitRect(GLenum faceTarget, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height);
-    void redefineTexture(int faceIndex, GLint level, GLenum format, GLsizei width, GLsizei height, GLenum type);
+    void commitRect(int faceIndex, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height);
+    void redefineImage(int faceIndex, GLint level, GLenum format, GLsizei width, GLsizei height, GLenum type);
 
     Image mImageArray[6][IMPLEMENTATION_MAX_TEXTURE_LEVELS];
 
-    IDirect3DCubeTexture9 *mTexture;
+    TextureStorageCubeMap *mTexStorage;
 
     BindingPointer<Renderbuffer> mFaceProxies[6];
 };
 }
 
-#endif   // LIBGLESV2_TEXTURE_H_
+#endif   // LIBGLESV2_TEXTURE_H_
\ No newline at end of file
diff -r d713478624d8 gfx/angle/src/libGLESv2/VertexDataManager.cpp
--- a/gfx/angle/src/libGLESv2/VertexDataManager.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/VertexDataManager.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -29,6 +29,12 @@
 {
 unsigned int VertexBuffer::mCurrentSerial = 1;
 
+int elementsInBuffer(const VertexAttribute &attribute, int size)
+{
+    int stride = attribute.stride();
+    return (size - attribute.mOffset % stride + (stride - attribute.typeSize())) / stride;
+}
+
 VertexDataManager::VertexDataManager(Context *context, IDirect3DDevice9 *device) : mContext(context), mDevice(device)
 {
     for (int i = 0; i < MAX_VERTEX_ATTRIBS; i++)
@@ -137,7 +143,7 @@
             {
                 if (staticBuffer->size() == 0)
                 {
-                    int totalCount = buffer->size() / attribs[i].stride();
+                    int totalCount = elementsInBuffer(attribs[i], buffer->size());
                     staticBuffer->addRequiredSpace(spaceRequired(attribs[i], totalCount));
                 }
                 else if (staticBuffer->lookupAttribute(attribs[i]) == -1)
@@ -216,7 +222,7 @@
                     if (streamOffset == -1)
                     {
                         // Convert the entire buffer
-                        int totalCount = buffer->size() / attribs[i].stride();
+                        int totalCount = elementsInBuffer(attribs[i], buffer->size());
                         int startIndex = attribs[i].mOffset / attribs[i].stride();
 
                         streamOffset = writeAttributeData(staticBuffer, -startIndex, totalCount, attribs[i]);
diff -r d713478624d8 gfx/angle/src/libGLESv2/libGLESv2.cpp
--- a/gfx/angle/src/libGLESv2/libGLESv2.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/libGLESv2.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -53,6 +53,81 @@
     return false;
 }
 
+bool validateSubImageParams(bool compressed, GLsizei width, GLsizei height, GLint xoffset, GLint yoffset, GLint level, GLenum format, gl::Texture *texture)
+{
+    if (!texture)
+    {
+        return error(GL_INVALID_OPERATION, false);
+    }
+
+    if (compressed != texture->isCompressed())
+    {
+        return error(GL_INVALID_OPERATION, false);
+    }
+
+    if (format != GL_NONE && format != texture->getInternalFormat())
+    {
+        return error(GL_INVALID_OPERATION, false);
+    }
+
+    if (compressed)
+    {
+        if ((width % 4 != 0 && width != texture->getWidth(0)) || 
+            (height % 4 != 0 && height != texture->getHeight(0)))
+        {
+            return error(GL_INVALID_OPERATION, false);
+        }
+    }
+
+    if (xoffset + width > texture->getWidth(level) ||
+        yoffset + height > texture->getHeight(level))
+    {
+        return error(GL_INVALID_VALUE, false);
+    }
+
+    return true;
+}
+
+// check for combinations of format and type that are valid for ReadPixels
+bool validReadFormatType(GLenum format, GLenum type)
+{
+    switch (format)
+    {
+      case GL_RGBA:
+        switch (type)
+        {
+          case GL_UNSIGNED_BYTE:
+            break;
+          default:
+            return false;
+        }
+        break;
+      case GL_BGRA_EXT:
+        switch (type)
+        {
+          case GL_UNSIGNED_BYTE:
+          case GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT:
+          case GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT:
+            break;
+          default:
+            return false;
+        }
+        break;
+      case gl::IMPLEMENTATION_COLOR_READ_FORMAT:
+        switch (type)
+        {
+          case gl::IMPLEMENTATION_COLOR_READ_TYPE:
+            break;
+          default:
+            return false;
+        }
+        break;
+      default:
+        return false;
+    }
+    return true;
+}
+
 extern "C"
 {
 
@@ -62,7 +137,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -86,7 +161,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -140,7 +215,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -178,7 +253,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -212,7 +287,7 @@
             return error(GL_INVALID_ENUM);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -244,7 +319,7 @@
             return error(GL_INVALID_ENUM);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -263,7 +338,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -300,7 +375,7 @@
 
     try
     {
-        gl::Context* context = gl::getContext();
+        gl::Context* context = gl::getNonLostContext();
 
         if (context)
         {
@@ -344,7 +419,7 @@
             return error(GL_INVALID_ENUM);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -467,7 +542,7 @@
             return error(GL_INVALID_OPERATION);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -502,7 +577,7 @@
             return error(GL_INVALID_ENUM);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -551,7 +626,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -599,7 +674,7 @@
             return error(GL_INVALID_ENUM, 0);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -630,7 +705,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -650,7 +725,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -669,7 +744,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -688,7 +763,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -708,7 +783,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -727,7 +802,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -784,7 +859,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -860,6 +935,11 @@
                     return error(GL_INVALID_OPERATION);
                 }
 
+                if (texture->isImmutable())
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+
                 texture->setCompressedImage(level, internalformat, width, height, imageSize, data);
             }
             else
@@ -871,6 +951,11 @@
                     return error(GL_INVALID_OPERATION);
                 }
 
+                if (texture->isImmutable())
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+
                 switch (target)
                 {
                   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
@@ -929,7 +1014,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -975,46 +1060,18 @@
             if (target == GL_TEXTURE_2D)
             {
                 gl::Texture2D *texture = context->getTexture2D();
-
-                if (!texture)
+                if (validateSubImageParams(true, width, height, xoffset, yoffset, level, GL_NONE, texture))
                 {
-                    return error(GL_INVALID_OPERATION);
+                    texture->subImageCompressed(level, xoffset, yoffset, width, height, format, imageSize, data);
                 }
-
-                if (!texture->isCompressed())
+            }
+            else if (gl::IsCubemapTextureTarget(target))
+            {
+                gl::TextureCubeMap *texture = context->getTextureCubeMap();
+                if (validateSubImageParams(true, width, height, xoffset, yoffset, level, GL_NONE, texture))
                 {
-                    return error(GL_INVALID_OPERATION);
+                    texture->subImageCompressed(target, level, xoffset, yoffset, width, height, format, imageSize, data);
                 }
-
-                if ((width % 4 != 0 && width != texture->getWidth()) || 
-                    (height % 4 != 0 && height != texture->getHeight()))
-                {
-                    return error(GL_INVALID_OPERATION);
-                }
-
-                texture->subImageCompressed(level, xoffset, yoffset, width, height, format, imageSize, data);
-            }
-            else if (gl::IsCubemapTextureTarget(target))
-            {
-                gl::TextureCubeMap *texture = context->getTextureCubeMap();
-
-                if (!texture)
-                {
-                    return error(GL_INVALID_OPERATION);
-                }
-
-                if (!texture->isCompressed())
-                {
-                    return error(GL_INVALID_OPERATION);
-                }
-
-                if ((width % 4 != 0 && width != texture->getWidth()) || 
-                    (height % 4 != 0 && height != texture->getHeight()))
-                {
-                    return error(GL_INVALID_OPERATION);
-                }
-
-                texture->subImageCompressed(target, level, xoffset, yoffset, width, height, format, imageSize, data);
             }
             else
             {
@@ -1046,7 +1103,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1097,7 +1154,7 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            gl::Colorbuffer *source = framebuffer->getColorbuffer();
+            gl::Renderbuffer *source = framebuffer->getColorbuffer();
             GLenum colorbufferFormat = source->getInternalFormat();
 
             // [OpenGL ES 2.0.24] table 3.9
@@ -1180,6 +1237,11 @@
                     return error(GL_INVALID_OPERATION);
                 }
 
+                if (texture->isImmutable())
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+
                 texture->copyImage(level, internalformat, x, y, width, height, framebuffer);
             }
             else if (gl::IsCubemapTextureTarget(target))
@@ -1191,6 +1253,11 @@
                     return error(GL_INVALID_OPERATION);
                 }
 
+                if (texture->isImmutable())
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+
                 texture->copyImage(target, level, internalformat, x, y, width, height, framebuffer);
             }
             else UNREACHABLE();
@@ -1230,7 +1297,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1251,7 +1318,7 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            gl::Colorbuffer *source = framebuffer->getColorbuffer();
+            gl::Renderbuffer *source = framebuffer->getColorbuffer();
             GLenum colorbufferFormat = source->getInternalFormat();
             gl::Texture *texture = NULL;
 
@@ -1265,9 +1332,9 @@
             }
             else UNREACHABLE();
 
-            if (!texture)
-            {
-                return error(GL_INVALID_OPERATION);
+            if (!validateSubImageParams(false, width, height, xoffset, yoffset, level, GL_NONE, texture))
+            {
+                return; // error already registered by validateSubImageParams
             }
 
             GLenum textureFormat = texture->getInternalFormat();
@@ -1333,7 +1400,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1354,7 +1421,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1388,7 +1455,7 @@
           case GL_BACK:
           case GL_FRONT_AND_BACK:
             {
-                gl::Context *context = gl::getContext();
+                gl::Context *context = gl::getNonLostContext();
 
                 if (context)
                 {
@@ -1417,7 +1484,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1444,7 +1511,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1471,7 +1538,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1501,7 +1568,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1537,7 +1604,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1564,7 +1631,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1600,7 +1667,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1640,7 +1707,7 @@
             return error(GL_INVALID_ENUM);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1659,7 +1726,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1678,7 +1745,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1697,7 +1764,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1750,7 +1817,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1787,7 +1854,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1811,7 +1878,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1836,7 +1903,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1870,7 +1937,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1907,7 +1974,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1926,7 +1993,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1952,7 +2019,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1971,7 +2038,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -1997,7 +2064,7 @@
             return error(GL_INVALID_ENUM);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2063,7 +2130,7 @@
             return error(GL_INVALID_ENUM);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2159,7 +2226,7 @@
           case GL_CW:
           case GL_CCW:
             {
-                gl::Context *context = gl::getContext();
+                gl::Context *context = gl::getNonLostContext();
 
                 if (context)
                 {
@@ -2188,7 +2255,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2210,7 +2277,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2255,7 +2322,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2282,7 +2349,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2309,7 +2376,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2336,7 +2403,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2365,7 +2432,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2410,7 +2477,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2454,7 +2521,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2487,7 +2554,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2528,7 +2595,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2591,7 +2658,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2653,7 +2720,7 @@
     try
     {
     
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2679,7 +2746,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2740,7 +2807,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2852,13 +2919,34 @@
     }
 }
 
+GLenum __stdcall glGetGraphicsResetStatusEXT(void)
+{
+    EVENT("()");
+
+    try
+    {
+        gl::Context *context = gl::getContext();
+
+        if (context)
+        {
+            return context->getResetStatus();
+        }
+
+        return GL_NO_ERROR;
+    }
+    catch(std::bad_alloc&)
+    {
+        return GL_OUT_OF_MEMORY;
+    }
+}
+
 void __stdcall glGetIntegerv(GLenum pname, GLint* params)
 {
     EVENT("(GLenum pname = 0x%X, GLint* params = 0x%0.8p)", pname, params);
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2923,7 +3011,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -2986,7 +3074,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3012,7 +3100,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3066,7 +3154,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3120,7 +3208,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3197,7 +3285,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3229,7 +3317,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3255,7 +3343,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         switch (name)
         {
@@ -3287,7 +3375,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3319,6 +3407,12 @@
               case GL_TEXTURE_WRAP_T:
                 *params = (GLfloat)texture->getWrapT();
                 break;
+              case GL_TEXTURE_IMMUTABLE_FORMAT_EXT:
+                *params = (GLfloat)(texture->isImmutable() ? GL_TRUE : GL_FALSE);
+                break;
+              case GL_TEXTURE_USAGE_ANGLE:
+                *params = (GLfloat)texture->getUsage();
+                break;
               default:
                 return error(GL_INVALID_ENUM);
             }
@@ -3336,7 +3430,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3368,6 +3462,12 @@
               case GL_TEXTURE_WRAP_T:
                 *params = texture->getWrapT();
                 break;
+              case GL_TEXTURE_IMMUTABLE_FORMAT_EXT:
+                *params = texture->isImmutable() ? GL_TRUE : GL_FALSE;
+                break;
+              case GL_TEXTURE_USAGE_ANGLE:
+                *params = texture->getUsage();
+                break;
               default:
                 return error(GL_INVALID_ENUM);
             }
@@ -3379,13 +3479,53 @@
     }
 }
 
+void __stdcall glGetnUniformfvEXT(GLuint program, GLint location, GLsizei bufSize, GLfloat* params)
+{
+    EVENT("(GLuint program = %d, GLint location = %d, GLsizei bufSize = %d, GLfloat* params = 0x%0.8p)",
+          program, location, bufSize, params);
+
+    try
+    {
+        if (bufSize < 0)
+        {
+            return error(GL_INVALID_VALUE);
+        }
+
+        gl::Context *context = gl::getNonLostContext();
+
+        if (context)
+        {
+            if (program == 0)
+            {
+                return error(GL_INVALID_VALUE);
+            }
+
+            gl::Program *programObject = context->getProgram(program);
+
+            if (!programObject || !programObject->isLinked())
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            if (!programObject->getUniformfv(location, &bufSize, params))
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+        }
+    }
+    catch(std::bad_alloc&)
+    {
+        return error(GL_OUT_OF_MEMORY);
+    }
+}
+
 void __stdcall glGetUniformfv(GLuint program, GLint location, GLfloat* params)
 {
     EVENT("(GLuint program = %d, GLint location = %d, GLfloat* params = 0x%0.8p)", program, location, params);
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3401,7 +3541,7 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!programObject->getUniformfv(location, params))
+            if (!programObject->getUniformfv(location, NULL, params))
             {
                 return error(GL_INVALID_OPERATION);
             }
@@ -3413,13 +3553,58 @@
     }
 }
 
+void __stdcall glGetnUniformivEXT(GLuint program, GLint location, GLsizei bufSize, GLint* params)
+{
+    EVENT("(GLuint program = %d, GLint location = %d, GLsizei bufSize = %d, GLint* params = 0x%0.8p)", 
+          program, location, bufSize, params);
+
+    try
+    {
+        if (bufSize < 0)
+        {
+            return error(GL_INVALID_VALUE);
+        }
+
+        gl::Context *context = gl::getNonLostContext();
+
+        if (context)
+        {
+            if (program == 0)
+            {
+                return error(GL_INVALID_VALUE);
+            }
+
+            gl::Program *programObject = context->getProgram(program);
+
+            if (!programObject || !programObject->isLinked())
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            if (!programObject)
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+
+            if (!programObject->getUniformiv(location, &bufSize, params))
+            {
+                return error(GL_INVALID_OPERATION);
+            }
+        }
+    }
+    catch(std::bad_alloc&)
+    {
+        return error(GL_OUT_OF_MEMORY);
+    }
+}
+
 void __stdcall glGetUniformiv(GLuint program, GLint location, GLint* params)
 {
     EVENT("(GLuint program = %d, GLint location = %d, GLint* params = 0x%0.8p)", program, location, params);
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3440,7 +3625,7 @@
                 return error(GL_INVALID_OPERATION);
             }
 
-            if (!programObject->getUniformiv(location, params))
+            if (!programObject->getUniformiv(location, NULL, params))
             {
                 return error(GL_INVALID_OPERATION);
             }
@@ -3458,7 +3643,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (strstr(name, "gl_") == name)
         {
@@ -3503,7 +3688,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3556,7 +3741,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3610,7 +3795,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3649,7 +3834,7 @@
             return error(GL_INVALID_ENUM); 
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
         switch (target)
         {
           case GL_GENERATE_MIPMAP_HINT:
@@ -3674,7 +3859,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context && buffer)
         {
@@ -3700,7 +3885,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3734,7 +3919,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3762,7 +3947,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context && framebuffer)
         {
@@ -3788,7 +3973,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context && program)
         {
@@ -3814,7 +3999,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context && renderbuffer)
         {
@@ -3840,7 +4025,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context && shader)
         {
@@ -3866,7 +4051,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context && texture)
         {
@@ -3897,7 +4082,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3916,7 +4101,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3949,7 +4134,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -3973,6 +4158,10 @@
                 context->setPackAlignment(param);
                 break;
 
+              case GL_PACK_REVERSE_ROW_ORDER_ANGLE:
+                context->setPackReverseRowOrder(param != 0);
+                break;
+
               default:
                 return error(GL_INVALID_ENUM);
             }
@@ -3990,7 +4179,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4003,7 +4192,41 @@
     }
 }
 
-void __stdcall glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels)
+void __stdcall glReadnPixelsEXT(GLint x, GLint y, GLsizei width, GLsizei height,
+                                GLenum format, GLenum type, GLsizei bufSize,
+                                GLvoid *data)
+{
+    EVENT("(GLint x = %d, GLint y = %d, GLsizei width = %d, GLsizei height = %d, "
+          "GLenum format = 0x%X, GLenum type = 0x%X, GLsizei bufSize = 0x%d, GLvoid *data = 0x%0.8p)",
+          x, y, width, height, format, type, bufSize, data);
+
+    try
+    {
+        if (width < 0 || height < 0 || bufSize < 0)
+        {
+            return error(GL_INVALID_VALUE);
+        }
+
+        if (!validReadFormatType(format, type))
+        {
+            return error(GL_INVALID_OPERATION);
+        }
+
+        gl::Context *context = gl::getNonLostContext();
+
+        if (context)
+        {
+            context->readPixels(x, y, width, height, format, type, &bufSize, data);
+        }
+    }
+    catch(std::bad_alloc&)
+    {
+        return error(GL_OUT_OF_MEMORY);
+    }
+}
+
+void __stdcall glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height,
+                            GLenum format, GLenum type, GLvoid* pixels)
 {
     EVENT("(GLint x = %d, GLint y = %d, GLsizei width = %d, GLsizei height = %d, "
           "GLenum format = 0x%X, GLenum type = 0x%X, GLvoid* pixels = 0x%0.8p)",
@@ -4016,46 +4239,16 @@
             return error(GL_INVALID_VALUE);
         }
 
-        switch (format)
-        {
-          case GL_RGBA:
-            switch (type)
-            {
-              case GL_UNSIGNED_BYTE:
-                break;
-              default:
-                return error(GL_INVALID_OPERATION);
-            }
-            break;
-          case GL_BGRA_EXT:
-            switch (type)
-            {
-              case GL_UNSIGNED_BYTE:
-              case GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT:
-              case GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT:
-                break;
-              default:
-                return error(GL_INVALID_OPERATION);
-            }
-            break;
-          case gl::IMPLEMENTATION_COLOR_READ_FORMAT:
-            switch (type)
-            {
-              case gl::IMPLEMENTATION_COLOR_READ_TYPE:
-                break;
-              default:
-                return error(GL_INVALID_OPERATION);
-            }
-            break;
-          default:
+        if (!validReadFormatType(format, type))
+        {
             return error(GL_INVALID_OPERATION);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
-            context->readPixels(x, y, width, height, format, type, pixels);
+            context->readPixels(x, y, width, height, format, type, NULL, pixels);
         }
     }
     catch(std::bad_alloc&)
@@ -4103,7 +4296,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4160,7 +4353,7 @@
 
     try
     {
-        gl::Context* context = gl::getContext();
+        gl::Context* context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4184,7 +4377,7 @@
             return error(GL_INVALID_ENUM);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4215,7 +4408,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context* context = gl::getContext();
+        gl::Context* context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4257,7 +4450,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4320,7 +4513,7 @@
             return error(GL_INVALID_ENUM);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4362,7 +4555,7 @@
             return error(GL_INVALID_ENUM);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4450,7 +4643,7 @@
             return error(GL_INVALID_ENUM);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4477,7 +4670,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4581,7 +4774,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4658,14 +4851,14 @@
 
             if (type == GL_FLOAT)
             {
-                if (!context->supportsFloatTextures())
+                if (!context->supportsFloat32Textures())
                 {
                     return error(GL_INVALID_ENUM);
                 }
             }
             else if (type == GL_HALF_FLOAT_OES)
             {
-                if (!context->supportsHalfFloatTextures())
+                if (!context->supportsFloat16Textures())
                 {
                     return error(GL_INVALID_ENUM);
                 }
@@ -4680,6 +4873,11 @@
                     return error(GL_INVALID_OPERATION);
                 }
 
+                if (texture->isImmutable())
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+
                 texture->setImage(level, width, height, format, type, context->getUnpackAlignment(), pixels);
             }
             else
@@ -4691,6 +4889,11 @@
                     return error(GL_INVALID_OPERATION);
                 }
 
+                if (texture->isImmutable())
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+
                 switch (target)
                 {
                   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
@@ -4738,7 +4941,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4782,6 +4985,12 @@
                     return error(GL_INVALID_ENUM);
                 }
                 break;
+              case GL_TEXTURE_USAGE_ANGLE:
+                if (!texture->setUsage((GLenum)param))
+                {
+                    return error(GL_INVALID_ENUM);
+                }
+                break;
               default:
                 return error(GL_INVALID_ENUM);
             }
@@ -4798,6 +5007,157 @@
     glTexParameteri(target, pname, *params);
 }
 
+void __stdcall glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
+{
+    EVENT("(GLenum target = 0x%X, GLsizei levels = %d, GLenum internalformat = 0x%X, GLsizei width = %d, GLsizei height = %d)",
+           target, levels, internalformat, width, height);
+
+    try
+    {
+        if (target != GL_TEXTURE_2D && target != GL_TEXTURE_CUBE_MAP)
+        {
+            return error(GL_INVALID_ENUM);
+        }
+
+        if (width < 1 || height < 1 || levels < 1)
+        {
+            return error(GL_INVALID_VALUE);
+        }
+
+        if (target == GL_TEXTURE_CUBE_MAP && width != height)
+        {
+            return error(GL_INVALID_VALUE);
+        }
+
+        if (levels != 1 && levels != gl::log2(std::max(width, height)) + 1)
+        {
+            return error(GL_INVALID_OPERATION);
+        }
+
+        GLenum format = gl::ExtractFormat(internalformat);
+        GLenum type = gl::ExtractType(internalformat);
+
+        if (format == GL_NONE || type == GL_NONE)
+        {
+            return error(GL_INVALID_ENUM);
+        }
+
+        gl::Context *context = gl::getNonLostContext();
+
+        if (context)
+        {
+            switch (target)
+            {
+              case GL_TEXTURE_2D:
+                if (width > context->getMaximumTextureDimension() ||
+                    height > context->getMaximumTextureDimension())
+                {
+                    return error(GL_INVALID_VALUE);
+                }
+                break;
+              case GL_TEXTURE_CUBE_MAP:
+                if (width > context->getMaximumCubeTextureDimension() ||
+                    height > context->getMaximumCubeTextureDimension())
+                {
+                    return error(GL_INVALID_VALUE);
+                }
+                break;
+              default:
+                return error(GL_INVALID_ENUM);
+            }
+
+            if (levels != 1 && !context->supportsNonPower2Texture())
+            {
+                if (!gl::isPow2(width) || !gl::isPow2(height))
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+            }
+
+            switch (internalformat)
+            {
+              case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
+              case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+                if (!context->supportsDXT1Textures())
+                {
+                    return error(GL_INVALID_ENUM);
+                }
+                break;
+              case GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE:
+                if (!context->supportsDXT3Textures())
+                {
+                    return error(GL_INVALID_ENUM);
+                }
+                break;
+              case GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE:
+                if (!context->supportsDXT5Textures())
+                {
+                    return error(GL_INVALID_ENUM);
+                }
+                break;
+              case GL_RGBA32F_EXT:
+              case GL_RGB32F_EXT:
+              case GL_ALPHA32F_EXT:
+              case GL_LUMINANCE32F_EXT:
+              case GL_LUMINANCE_ALPHA32F_EXT:
+                if (!context->supportsFloat32Textures())
+                {
+                    return error(GL_INVALID_ENUM);
+                }
+                break;
+              case GL_RGBA16F_EXT:
+              case GL_RGB16F_EXT:
+              case GL_ALPHA16F_EXT:
+              case GL_LUMINANCE16F_EXT:
+              case GL_LUMINANCE_ALPHA16F_EXT:
+                if (!context->supportsFloat16Textures())
+                {
+                    return error(GL_INVALID_ENUM);
+                }
+                break;
+            }
+
+            if (target == GL_TEXTURE_2D)
+            {
+                gl::Texture2D *texture = context->getTexture2D();
+
+                if (!texture || texture->id() == 0)
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+
+                if (texture->isImmutable())
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+
+                texture->storage(levels, internalformat, width, height);
+            }
+            else if (target == GL_TEXTURE_CUBE_MAP)
+            {
+                gl::TextureCubeMap *texture = context->getTextureCubeMap();
+
+                if (!texture || texture->id() == 0)
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+
+                if (texture->isImmutable())
+                {
+                    return error(GL_INVALID_OPERATION);
+                }
+
+                texture->storage(levels, internalformat, width);
+            }
+            else UNREACHABLE();
+        }
+    }
+    catch(std::bad_alloc&)
+    {
+        return error(GL_OUT_OF_MEMORY);
+    }
+}
+
 void __stdcall glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
                                GLenum format, GLenum type, const GLvoid* pixels)
 {
@@ -4833,7 +5193,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4844,14 +5204,14 @@
 
             if (format == GL_FLOAT)
             {
-                if (!context->supportsFloatTextures())
+                if (!context->supportsFloat32Textures())
                 {
                     return error(GL_INVALID_ENUM);
                 }
             }
             else if (format == GL_HALF_FLOAT_OES)
             {
-                if (!context->supportsHalfFloatTextures())
+                if (!context->supportsFloat16Textures())
                 {
                     return error(GL_INVALID_ENUM);
                 }
@@ -4860,34 +5220,18 @@
             if (target == GL_TEXTURE_2D)
             {
                 gl::Texture2D *texture = context->getTexture2D();
-
-                if (!texture)
+                if (validateSubImageParams(false, width, height, xoffset, yoffset, level, format, texture))
                 {
-                    return error(GL_INVALID_OPERATION);
+                    texture->subImage(level, xoffset, yoffset, width, height, format, type, context->getUnpackAlignment(), pixels);
                 }
-
-                if (texture->isCompressed())
+            }
+            else if (gl::IsCubemapTextureTarget(target))
+            {
+                gl::TextureCubeMap *texture = context->getTextureCubeMap();
+                if (validateSubImageParams(false, width, height, xoffset, yoffset, level, format, texture))
                 {
-                    return error(GL_INVALID_OPERATION);
+                    texture->subImage(target, level, xoffset, yoffset, width, height, format, type, context->getUnpackAlignment(), pixels);
                 }
-
-                if (format != texture->getInternalFormat())
-                {
-                    return error(GL_INVALID_OPERATION);
-                }
-
-                texture->subImage(level, xoffset, yoffset, width, height, format, type, context->getUnpackAlignment(), pixels);
-            }
-            else if (gl::IsCubemapTextureTarget(target))
-            {
-                gl::TextureCubeMap *texture = context->getTextureCubeMap();
-
-                if (!texture)
-                {
-                    return error(GL_INVALID_OPERATION);
-                }
-
-                texture->subImage(target, level, xoffset, yoffset, width, height, format, type, context->getUnpackAlignment(), pixels);
             }
             else
             {
@@ -4922,7 +5266,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -4966,7 +5310,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5012,7 +5356,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5058,7 +5402,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5104,7 +5448,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5150,7 +5494,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5196,7 +5540,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5242,7 +5586,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5282,7 +5626,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5322,7 +5666,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5362,7 +5706,7 @@
             return;
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5391,7 +5735,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5429,7 +5773,7 @@
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5467,7 +5811,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5492,7 +5836,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5517,7 +5861,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5542,7 +5886,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5567,7 +5911,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5592,7 +5936,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5617,7 +5961,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5642,7 +5986,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5691,7 +6035,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5715,7 +6059,7 @@
             return error(GL_INVALID_VALUE);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5757,7 +6101,7 @@
             return error(GL_INVALID_OPERATION);
         }
 
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
@@ -5815,6 +6159,11 @@
         {"glFinishFenceNV", (__eglMustCastToProperFunctionPointerType)glFinishFenceNV},
         {"glSetFenceNV", (__eglMustCastToProperFunctionPointerType)glSetFenceNV},
         {"glGetTranslatedShaderSourceANGLE", (__eglMustCastToProperFunctionPointerType)glGetTranslatedShaderSourceANGLE},
+        {"glTexStorage2DEXT", (__eglMustCastToProperFunctionPointerType)glTexStorage2DEXT},
+        {"glGetGraphicsResetStatusEXT", (__eglMustCastToProperFunctionPointerType)glGetGraphicsResetStatusEXT},
+        {"glReadnPixelsEXT", (__eglMustCastToProperFunctionPointerType)glReadnPixelsEXT},
+        {"glGetnUniformfvEXT", (__eglMustCastToProperFunctionPointerType)glGetnUniformfvEXT},
+        {"glGetnUniformivEXT", (__eglMustCastToProperFunctionPointerType)glGetnUniformivEXT},
     };
 
     for (int ext = 0; ext < sizeof(glExtensions) / sizeof(Extension); ext++)
@@ -5828,19 +6177,26 @@
     return NULL;
 }
 
-void __stdcall glBindTexImage(egl::Surface *surface)
+// Non-public functions used by EGL
+
+bool __stdcall glBindTexImage(egl::Surface *surface)
 {
     EVENT("(egl::Surface* surface = 0x%0.8p)",
           surface);
 
     try
     {
-        gl::Context *context = gl::getContext();
+        gl::Context *context = gl::getNonLostContext();
 
         if (context)
         {
             gl::Texture2D *textureObject = context->getTexture2D();
 
+            if (textureObject->isImmutable())
+            {
+                return false;
+            }
+
             if (textureObject)
             {
                 textureObject->bindTexImage(surface);
@@ -5849,8 +6205,10 @@
     }
     catch(std::bad_alloc&)
     {
-        return error(GL_OUT_OF_MEMORY);
-    }
-}
-
-}
+        return error(GL_OUT_OF_MEMORY, false);
+    }
+
+    return true;
+}
+
+}
diff -r d713478624d8 gfx/angle/src/libGLESv2/libGLESv2.def
--- a/gfx/angle/src/libGLESv2/libGLESv2.def	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/libGLESv2.def	Thu Jan 05 10:52:20 2012 +0900
@@ -155,6 +155,11 @@
     glSetFenceNV                    @156
     glTestFenceNV                   @157
     glGetTranslatedShaderSourceANGLE @159
+    glTexStorage2DEXT               @160
+    glGetGraphicsResetStatusEXT     @161
+    glReadnPixelsEXT                @162
+    glGetnUniformfvEXT              @163
+    glGetnUniformivEXT              @164
 
     ; EGL dependencies
     glCreateContext                 @144 NONAME
diff -r d713478624d8 gfx/angle/src/libGLESv2/main.cpp
--- a/gfx/angle/src/libGLESv2/main.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/main.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -7,6 +7,7 @@
 // main.cpp: DLL entry point and management of thread-local data.
 
 #include "libGLESv2/main.h"
+#include "libGLESv2/utilities.h"
 
 #include "common/debug.h"
 #include "libEGL/Surface.h"
@@ -93,6 +94,25 @@
     return current->context;
 }
 
+Context *getNonLostContext()
+{
+    Context *context = getContext();
+    
+    if (context)
+    {
+        if (context->isContextLost())
+        {
+            error(GL_OUT_OF_MEMORY);
+            return NULL;
+        }
+        else
+        {
+            return context;
+        }
+    }
+    return NULL;
+}
+
 egl::Display *getDisplay()
 {
     Current *current = (Current*)TlsGetValue(currentTLS);
@@ -106,6 +126,19 @@
 
     return display->getDevice();
 }
+
+bool checkDeviceLost(HRESULT errorCode)
+{
+    egl::Display *display = NULL;
+
+    if (isDeviceLostError(errorCode))
+    {
+        display = gl::getDisplay();
+        display->notifyDeviceLost();
+        return true;
+    }
+    return false;
+}
 }
 
 // Records an error code
diff -r d713478624d8 gfx/angle/src/libGLESv2/main.h
--- a/gfx/angle/src/libGLESv2/main.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/main.h	Thu Jan 05 10:52:20 2012 +0900
@@ -29,9 +29,12 @@
 void makeCurrent(Context *context, egl::Display *display, egl::Surface *surface);
 
 Context *getContext();
+Context *getNonLostContext();
 egl::Display *getDisplay();
 
 IDirect3DDevice9 *getDevice();
+
+bool checkDeviceLost(HRESULT errorCode);
 }
 
 void error(GLenum errorCode);
diff -r d713478624d8 gfx/angle/src/libGLESv2/utilities.cpp
--- a/gfx/angle/src/libGLESv2/utilities.cpp	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/utilities.cpp	Thu Jan 05 10:52:20 2012 +0900
@@ -20,7 +20,8 @@
 namespace gl
 {
 
-int UniformComponentCount(GLenum type)
+// This is how much data the application expects for a uniform
+int UniformExternalComponentCount(GLenum type)
 {
     switch (type)
     {
@@ -125,7 +126,7 @@
 {
     switch(type)
     {
-      case GL_BOOL:  return sizeof(GLboolean);
+      case GL_BOOL:  return sizeof(GLint);
       case GL_FLOAT: return sizeof(GLfloat);
       case GL_INT:   return sizeof(GLint);
       default:       UNREACHABLE();
@@ -134,11 +135,16 @@
     return 0;
 }
 
-size_t UniformTypeSize(GLenum type)
+size_t UniformInternalSize(GLenum type)
 {
     return UniformComponentSize(UniformComponentType(type)) * UniformInternalComponentCount(type);
 }
 
+size_t UniformExternalSize(GLenum type)
+{
+    return UniformComponentSize(UniformComponentType(type)) * UniformExternalComponentCount(type);
+}
+
 int VariableRowCount(GLenum type)
 {
     switch (type)
@@ -374,6 +380,68 @@
     }
 }
 
+GLenum ExtractFormat(GLenum internalformat)
+{
+    switch (internalformat)
+    {
+      case GL_RGB565:                          return GL_RGB;
+      case GL_RGBA4:                           return GL_RGBA;
+      case GL_RGB5_A1:                         return GL_RGBA;
+      case GL_RGB8_OES:                        return GL_RGB;
+      case GL_RGBA8_OES:                       return GL_RGBA;
+      case GL_LUMINANCE8_ALPHA8_EXT:           return GL_LUMINANCE_ALPHA;
+      case GL_LUMINANCE8_EXT:                  return GL_LUMINANCE;
+      case GL_ALPHA8_EXT:                      return GL_ALPHA;
+      case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:    return GL_COMPRESSED_RGB_S3TC_DXT1_EXT;
+      case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:   return GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
+      case GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE: return GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE;
+      case GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE: return GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE;
+      case GL_RGBA32F_EXT:                     return GL_RGBA;
+      case GL_RGB32F_EXT:                      return GL_RGB;
+      case GL_ALPHA32F_EXT:                    return GL_ALPHA;
+      case GL_LUMINANCE32F_EXT:                return GL_LUMINANCE;
+      case GL_LUMINANCE_ALPHA32F_EXT:          return GL_LUMINANCE_ALPHA;
+      case GL_RGBA16F_EXT:                     return GL_RGBA;
+      case GL_RGB16F_EXT:                      return GL_RGB;
+      case GL_ALPHA16F_EXT:                    return GL_ALPHA;
+      case GL_LUMINANCE16F_EXT:                return GL_LUMINANCE;
+      case GL_LUMINANCE_ALPHA16F_EXT:          return GL_LUMINANCE_ALPHA;
+      case GL_BGRA8_EXT:                       return GL_BGRA_EXT;
+      default:                                 return GL_NONE;   // Unsupported
+    }
+}
+
+GLenum ExtractType(GLenum internalformat)
+{
+    switch (internalformat)
+    {
+      case GL_RGB565:                          return GL_UNSIGNED_SHORT_5_6_5;
+      case GL_RGBA4:                           return GL_UNSIGNED_SHORT_4_4_4_4;
+      case GL_RGB5_A1:                         return GL_UNSIGNED_SHORT_5_5_5_1;
+      case GL_RGB8_OES:                        return GL_UNSIGNED_BYTE;
+      case GL_RGBA8_OES:                       return GL_UNSIGNED_BYTE;
+      case GL_LUMINANCE8_ALPHA8_EXT:           return GL_UNSIGNED_BYTE;
+      case GL_LUMINANCE8_EXT:                  return GL_UNSIGNED_BYTE;
+      case GL_ALPHA8_EXT:                      return GL_UNSIGNED_BYTE;
+      case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:    return GL_UNSIGNED_BYTE;
+      case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:   return GL_UNSIGNED_BYTE;
+      case GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE: return GL_UNSIGNED_BYTE;
+      case GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE: return GL_UNSIGNED_BYTE;
+      case GL_RGBA32F_EXT:                     return GL_FLOAT;
+      case GL_RGB32F_EXT:                      return GL_FLOAT;
+      case GL_ALPHA32F_EXT:                    return GL_FLOAT;
+      case GL_LUMINANCE32F_EXT:                return GL_FLOAT;
+      case GL_LUMINANCE_ALPHA32F_EXT:          return GL_FLOAT;
+      case GL_RGBA16F_EXT:                     return GL_HALF_FLOAT_OES;
+      case GL_RGB16F_EXT:                      return GL_HALF_FLOAT_OES;
+      case GL_ALPHA16F_EXT:                    return GL_HALF_FLOAT_OES;
+      case GL_LUMINANCE16F_EXT:                return GL_HALF_FLOAT_OES;
+      case GL_LUMINANCE_ALPHA16F_EXT:          return GL_HALF_FLOAT_OES;
+      case GL_BGRA8_EXT:                       return GL_UNSIGNED_BYTE;
+      default:                                 return GL_NONE;   // Unsupported
+    }
+}
+
 bool IsColorRenderable(GLenum internalformat)
 {
     switch (internalformat)
@@ -853,6 +921,50 @@
     }
 }
 
+bool IsFloat32Format(D3DFORMAT surfaceFormat)
+{
+    switch(surfaceFormat)
+    {
+      case D3DFMT_R16F:
+      case D3DFMT_G16R16F:
+      case D3DFMT_A16B16G16R16F:
+        return false;
+      case D3DFMT_R32F:
+      case D3DFMT_G32R32F:
+      case D3DFMT_A32B32G32R32F:
+        return true;
+      case D3DFMT_A8R8G8B8:
+      case D3DFMT_X8R8G8B8:
+      case D3DFMT_A1R5G5B5:
+      case D3DFMT_R5G6B5:
+        return false;
+      default: UNREACHABLE();
+    }
+    return false;
+}
+
+bool IsFloat16Format(D3DFORMAT surfaceFormat)
+{
+    switch(surfaceFormat)
+    {
+      case D3DFMT_R16F:
+      case D3DFMT_G16R16F:
+      case D3DFMT_A16B16G16R16F:
+        return true;
+      case D3DFMT_R32F:
+      case D3DFMT_G32R32F:
+      case D3DFMT_A32B32G32R32F:
+        return false;
+      case D3DFMT_A8R8G8B8:
+      case D3DFMT_X8R8G8B8:
+      case D3DFMT_A1R5G5B5:
+      case D3DFMT_R5G6B5:
+        return false;
+      default: UNREACHABLE();
+    }
+    return false;
+}
+
 GLsizei GetSamplesFromMultisampleType(D3DMULTISAMPLE_TYPE type)
 {
     if (type == D3DMULTISAMPLE_NONMASKABLE)
diff -r d713478624d8 gfx/angle/src/libGLESv2/utilities.h
--- a/gfx/angle/src/libGLESv2/utilities.h	Thu Jan 05 01:16:58 2012 +0200
+++ b/gfx/angle/src/libGLESv2/utilities.h	Thu Jan 05 10:52:20 2012 +0900
@@ -21,10 +21,11 @@
 
 struct Color;
 
-int UniformComponentCount(GLenum type);
+int UniformExternalComponentCount(GLenum type);
 int UniformInternalComponentCount(GLenum type);
 GLenum UniformComponentType(GLenum type);
-size_t UniformTypeSize(GLenum type);
+size_t UniformInternalSize(GLenum type);
+size_t UniformExternalSize(GLenum type);
 int VariableRowCount(GLenum type);
 int VariableColumnCount(GLenum type);
 
@@ -38,6 +39,8 @@
 bool IsCubemapTextureTarget(GLenum target);
 bool IsTextureTarget(GLenum target);
 bool CheckTextureFormatType(GLenum format, GLenum type);
+GLenum ExtractFormat(GLenum internalformat);
+GLenum ExtractType(GLenum internalformat);
 
 bool IsColorRenderable(GLenum internalformat);
 bool IsDepthRenderable(GLenum internalformat);
@@ -74,6 +77,8 @@
 GLuint GetBlueSize(D3DFORMAT colorFormat);
 GLuint GetDepthSize(D3DFORMAT depthFormat);
 GLuint GetStencilSize(D3DFORMAT stencilFormat);
+bool IsFloat32Format(D3DFORMAT surfaceFormat);
+bool IsFloat16Format(D3DFORMAT surfaceFormat);
 
 GLsizei GetSamplesFromMultisampleType(D3DMULTISAMPLE_TYPE type);
 
@@ -85,4 +90,18 @@
 std::string getTempPath();
 void writeFile(const char* path, const void* data, size_t size);
 
+inline bool isDeviceLostError(HRESULT errorCode)
+{
+    switch (errorCode)
+    {
+      case D3DERR_DRIVERINTERNALERROR:
+      case D3DERR_DEVICELOST:
+      case D3DERR_DEVICEHUNG:
+      case D3DERR_DEVICEREMOVED:
+        return true;
+      default:
+        return false;
+    }
+};
+
 #endif  // LIBGLESV2_UTILITIES_H

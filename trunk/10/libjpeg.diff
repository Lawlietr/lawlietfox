diff -r 3a99d7ff459c media/libjpeg/Makefile.in
--- a/media/libjpeg/Makefile.in    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/Makefile.in    Tue Jan 24 23:47:27 2012 +0900
@@ -123,6 +123,7 @@
   CSRCS   += simd/jsimd_x86_64.c
   ASFILES += \
     simd/jccolss2-64.asm \
+    simd/jcgrass2-64.asm \
     simd/jcqnts2f-64.asm \
     simd/jcqnts2i-64.asm \
     simd/jcsamss2-64.asm \
@@ -144,6 +145,8 @@
   ASFILES += \
     simd/jccolmmx.asm \
     simd/jccolss2.asm \
+    simd/jcgrammx.asm \
+    simd/jcgrass2.asm \
     simd/jcqnt3dn.asm \
     simd/jcqntmmx.asm \
     simd/jcqnts2f.asm \
diff -r 3a99d7ff459c media/libjpeg/README
--- a/media/libjpeg/README    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/README    Tue Jan 24 23:47:27 2012 +0900
@@ -62,7 +62,7 @@
 This package contains C software to implement JPEG image encoding, decoding,
 and transcoding.  JPEG (pronounced "jay-peg") is a standardized compression
 method for full-color and gray-scale images.  JPEG's strong suit is compressing
-photographic images or other types of images which have smooth color and
+photographic images or other types of images that have smooth color and
 brightness transitions between neighboring pixels.  Images with sharp lines or
 other abrupt features may not compress well with JPEG, and a higher JPEG
 quality may have to be used to avoid visible compression artifacts with such
@@ -274,7 +274,7 @@
 ================
 
 The ISO JPEG standards committee actually promotes different formats like
-"JPEG 2000" or "JPEG XR" which are incompatible with original DCT-based
+"JPEG 2000" or "JPEG XR", which are incompatible with original DCT-based
 JPEG.  IJG therefore does not support these formats (see REFERENCES).  Indeed,
 one of the original reasons for developing this free software was to help
 force convergence on common, interoperable format standards for JPEG files.
diff -r 3a99d7ff459c media/libjpeg/README-turbo.txt
--- a/media/libjpeg/README-turbo.txt    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/README-turbo.txt    Tue Jan 24 23:47:27 2012 +0900
@@ -2,7 +2,7 @@
 **     Background
 *******************************************************************************
 
-libjpeg-turbo is a derivative of libjpeg which uses SIMD instructions (MMX,
+libjpeg-turbo is a derivative of libjpeg that uses SIMD instructions (MMX,
 SSE2, etc.) to accelerate baseline JPEG compression and decompression on x86
 and x86-64 systems.  On such systems, libjpeg-turbo is generally 2-4x as fast
 as the unmodified version of libjpeg, all else being equal.
@@ -26,27 +26,56 @@
 **     License
 *******************************************************************************
 
-The TurboJPEG/OSS wrapper, as well as some of the optimizations to the Huffman
-encoder (jchuff.c) and decoder (jdhuff.c), were borrowed from VirtualGL, and
-thus any distribution of libjpeg-turbo which includes those files must, as a
-whole, be subject to the terms of the wxWindows Library Licence, Version 3.1.
-A copy of this license can be found in this directory under LICENSE.txt.  The
-wxWindows Library License is based on the LGPL but includes provisions which
-allow the Library to be statically linked into proprietary libraries and
-applications without requiring the resulting binaries to be distributed under
-the terms of the LGPL.
+libjpeg-turbo is licensed under a non-restrictive, BSD-style license
+(see README.)  The TurboJPEG/OSS wrapper (both C and Java versions) and
+associated test programs bear a similar license, which is reproduced below:
 
-The rest of the source code, apart from TurboJPEG/OSS and the Huffman codec
-optimizations, falls under a less restrictive, BSD-style license (see README.)
-You can choose to distribute libjpeg-turbo, as a whole, under this BSD-style
-license by simply removing TurboJPEG/OSS and replacing the optimized jchuff.c
-and jdhuff.c with their unoptimized counterparts from the libjpeg v6b source.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+- Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+- Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+- Neither the name of the libjpeg-turbo Project nor the names of its
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS",
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
 
 
 *******************************************************************************
 **     Using libjpeg-turbo
 *******************************************************************************
 
+libjpeg-turbo includes two APIs that can be used to compress and decompress
+JPEG images:
+
+  TurboJPEG API:  This API wraps libjpeg-turbo and provides an easy-to-use
+  interface for compressing and decompressing JPEG images in memory.  It also
+  provides some features that would not be straightforward to implement using
+  the underlying libjpeg API, such as generating planar YUV images and
+  performing multiple simultaneous lossless transforms on an image.  The Java
+  interface for libjpeg-turbo is written on top of the TurboJPEG API.
+
+  libjpeg API:  This is the industry standard API for compressing and
+  decompressing JPEG images.  It is more difficult to use than the TurboJPEG
+  API but also more powerful.  libjpeg-turbo is both API/ABI-compatible and
+  mathematically compatible with libjpeg v6b.  It can also optionally be
+  configured to be API/ABI-compatible with libjpeg v7 and v8 (see below.)
+
+
 =============================
 Replacing libjpeg at Run Time
 =============================
@@ -93,7 +122,7 @@
 Windows releases can obtain it from the Visual C++ 2008 Redistributable
 Package, which is available as a free download from Microsoft's web site.
 
-NOTE:  Features of libjpeg which require passing a C run time structure, such
+NOTE:  Features of libjpeg that require passing a C run time structure, such
 as a file handle, from an application to libjpeg will probably not work with
 the version of the libjpeg-turbo DLL distributed in the libjpeg-turbo SDK for
 Visual C++, unless the application is also built to use the Visual C++ 2008 C
@@ -179,9 +208,9 @@
 Colorspace Extensions
 =====================
 
-libjpeg-turbo includes extensions which allow JPEG images to be compressed
-directly from (and decompressed directly to) buffers which use BGR, BGRX,
-RGBX, XBGR, and XRGB pixel ordering.  This is implemented with six new
+libjpeg-turbo includes extensions that allow JPEG images to be compressed
+directly from (and decompressed directly to) buffers that use BGR, BGRX,
+RGBX, XBGR, and XRGB pixel ordering.  This is implemented with ten new
 colorspace constants:
 
   JCS_EXT_RGB   /* red/green/blue */
@@ -190,11 +219,15 @@
   JCS_EXT_BGRX  /* blue/green/red/x */
   JCS_EXT_XBGR  /* x/blue/green/red */
   JCS_EXT_XRGB  /* x/red/green/blue */
+  JCS_EXT_RGBA  /* red/green/blue/alpha */
+  JCS_EXT_BGRA  /* blue/green/red/alpha */
+  JCS_EXT_ABGR  /* alpha/blue/green/red */
+  JCS_EXT_ARGB  /* alpha/red/green/blue */
 
 Setting cinfo.in_color_space (compression) or cinfo.out_color_space
 (decompression) to one of these values will cause libjpeg-turbo to read the
 red, green, and blue values from (or write them to) the appropriate position in
-the pixel when YUV conversion is performed.
+the pixel when compressing from/decompressing to an RGB buffer.
 
 Your application can check for the existence of these extensions at compile
 time with:
@@ -204,13 +237,28 @@
 At run time, attempting to use these extensions with a version of libjpeg
 that doesn't support them will result in a "Bogus input colorspace" error.
 
+When using the RGBX, BGRX, XBGR, and XRGB colorspaces during decompression, the
+X byte is undefined, and in order to ensure the best performance, libjpeg-turbo
+can set that byte to whatever value it wishes.  If an application expects the X
+byte to be used as an alpha channel, then it should specify JCS_EXT_RGBA,
+JCS_EXT_BGRA, JCS_EXT_ABGR, or JCS_EXT_ARGB.  When these colorspace constants
+are used, the X byte is guaranteed to be 0xFF, which is interpreted as opaque.
+
+Your application can check for the existence of the alpha channel colorspace
+extensions at compile time with:
+
+  #ifdef JCS_ALPHA_EXTENSIONS
+
+jcstest.c, located in the libjpeg-turbo source tree, demonstrates how to check
+for the existence of the colorspace extensions at compile time and run time.
+
 =================================
 libjpeg v7 and v8 API/ABI support
 =================================
 
 libjpeg v7 and v8 added new features to the API/ABI, and, unfortunately, the
 compression and decompression structures were extended in a backward-
-incompatible manner to accommodate these features.  Thus, programs which are
+incompatible manner to accommodate these features.  Thus, programs that are
 built to use libjpeg v7 or v8 did not work with libjpeg-turbo, since it is
 based on the libjpeg v6b code base.  Although libjpeg v7 and v8 are still not
 as widely used as v6b, enough programs (including a few Linux distros) have
@@ -218,7 +266,7 @@
 API/ABI in libjpeg-turbo.
 
 Some of the libjpeg v7 and v8 features -- DCT scaling, to name one -- involve
-deep modifications to the code which cannot be accommodated by libjpeg-turbo
+deep modifications to the code that cannot be accommodated by libjpeg-turbo
 without either breaking compatibility with libjpeg v6b or producing an
 unsupportable mess.  In order to fully support libjpeg v8 with all of its
 features, we would have to essentially port the SIMD extensions to the libjpeg
@@ -229,8 +277,8 @@
 
 By passing an argument of --with-jpeg7 or --with-jpeg8 to configure, or an
 argument of -DWITH_JPEG7=1 or -DWITH_JPEG8=1 to cmake, you can build a version
-of libjpeg-turbo which emulates the libjpeg v7 or v8 API/ABI, so that programs
-which are built against libjpeg v7 or v8 can be run with libjpeg-turbo.  The
+of libjpeg-turbo that emulates the libjpeg v7 or v8 API/ABI, so that programs
+that are built against libjpeg v7 or v8 can be run with libjpeg-turbo.  The
 following section describes which libjpeg v7+ features are supported and which
 aren't.
 
diff -r 3a99d7ff459c media/libjpeg/jaricom.c
--- a/media/libjpeg/jaricom.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jaricom.c    Tue Jan 24 23:47:27 2012 +0900
@@ -150,3 +150,4 @@
  * as recommended in Section 10.3 Table 5 of ITU-T Rec. T.851.
  */
   V( 113, 0x5a1d, 113, 113, 0 )
+};
diff -r 3a99d7ff459c media/libjpeg/jccolext.c
--- /dev/null    Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libjpeg/jccolext.c    Tue Jan 24 23:47:27 2012 +0900
@@ -0,0 +1,114 @@
+/*
+ * jccolext.c
+ *
+ * Copyright (C) 1991-1996, Thomas G. Lane.
+ * Copyright (C) 2009-2011, D. R. Commander.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains input colorspace conversion routines.
+ */
+
+
+/* This file is included by jccolor.c */
+
+
+/*
+ * Convert some rows of samples to the JPEG colorspace.
+ *
+ * Note that we change from the application's interleaved-pixel format
+ * to our internal noninterleaved, one-plane-per-component format.
+ * The input buffer is therefore three times as wide as the output buffer.
+ *
+ * A starting row offset is provided only for the output buffer.  The caller
+ * can easily adjust the passed input_buf value to accommodate any row
+ * offset required on that side.
+ */
+
+INLINE
+LOCAL(void)
+rgb_ycc_convert_internal (j_compress_ptr cinfo,
+                          JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+                          JDIMENSION output_row, int num_rows)
+{
+  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
+  register int r, g, b;
+  register INT32 * ctab = cconvert->rgb_ycc_tab;
+  register JSAMPROW inptr;
+  register JSAMPROW outptr0, outptr1, outptr2;
+  register JDIMENSION col;
+  JDIMENSION num_cols = cinfo->image_width;
+
+  while (--num_rows >= 0) {
+    inptr = *input_buf++;
+    outptr0 = output_buf[0][output_row];
+    outptr1 = output_buf[1][output_row];
+    outptr2 = output_buf[2][output_row];
+    output_row++;
+    for (col = 0; col < num_cols; col++) {
+      r = GETJSAMPLE(inptr[RGB_RED]);
+      g = GETJSAMPLE(inptr[RGB_GREEN]);
+      b = GETJSAMPLE(inptr[RGB_BLUE]);
+      inptr += RGB_PIXELSIZE;
+      /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
+       * must be too; we do not need an explicit range-limiting operation.
+       * Hence the value being shifted is never negative, and we don't
+       * need the general RIGHT_SHIFT macro.
+       */
+      /* Y */
+      outptr0[col] = (JSAMPLE)
+        ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
+         >> SCALEBITS);
+      /* Cb */
+      outptr1[col] = (JSAMPLE)
+        ((ctab[r+R_CB_OFF] + ctab[g+G_CB_OFF] + ctab[b+B_CB_OFF])
+         >> SCALEBITS);
+      /* Cr */
+      outptr2[col] = (JSAMPLE)
+        ((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])
+         >> SCALEBITS);
+    }
+  }
+}
+
+
+/**************** Cases other than RGB -> YCbCr **************/
+
+
+/*
+ * Convert some rows of samples to the JPEG colorspace.
+ * This version handles RGB->grayscale conversion, which is the same
+ * as the RGB->Y portion of RGB->YCbCr.
+ * We assume rgb_ycc_start has been called (we only use the Y tables).
+ */
+
+INLINE
+LOCAL(void)
+rgb_gray_convert_internal (j_compress_ptr cinfo,
+                           JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+                           JDIMENSION output_row, int num_rows)
+{
+  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
+  register int r, g, b;
+  register INT32 * ctab = cconvert->rgb_ycc_tab;
+  register JSAMPROW inptr;
+  register JSAMPROW outptr;
+  register JDIMENSION col;
+  JDIMENSION num_cols = cinfo->image_width;
+
+  while (--num_rows >= 0) {
+    inptr = *input_buf++;
+    outptr = output_buf[0][output_row];
+    output_row++;
+    for (col = 0; col < num_cols; col++) {
+      r = GETJSAMPLE(inptr[RGB_RED]);
+      g = GETJSAMPLE(inptr[RGB_GREEN]);
+      b = GETJSAMPLE(inptr[RGB_BLUE]);
+      inptr += RGB_PIXELSIZE;
+      /* Y */
+      outptr[col] = (JSAMPLE)
+        ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
+         >> SCALEBITS);
+    }
+  }
+}
diff -r 3a99d7ff459c media/libjpeg/jccolor.c
--- a/media/libjpeg/jccolor.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jccolor.c    Tue Jan 24 23:47:27 2012 +0900
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 1991-1996, Thomas G. Lane.
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright 2009 D. R. Commander
+ * Copyright (C) 2009-2011, D. R. Commander.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -81,72 +81,97 @@
 #define TABLE_SIZE    (8*(MAXJSAMPLE+1))
 
 
-#if BITS_IN_JSAMPLE == 8
+/* Include inline routines for colorspace extensions */
 
-static const unsigned char red_lut[256] = {
-  0 , 0 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 4 ,
-  5 , 5 , 5 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 9 , 9 , 9 ,
-  10, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14,
-  14, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19,
-  19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 24,
-  24, 24, 25, 25, 25, 25, 26, 26, 26, 27, 27, 27, 28, 28, 28, 28,
-  29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 32, 32, 32, 33, 33, 33,
-  33, 34, 34, 34, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 38, 38,
-  38, 39, 39, 39, 39, 40, 40, 40, 41, 41, 41, 42, 42, 42, 42, 43,
-  43, 43, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 47, 47, 47, 48,
-  48, 48, 48, 49, 49, 49, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52,
-  53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 56, 56, 56, 57, 57, 57,
-  57, 58, 58, 58, 59, 59, 59, 60, 60, 60, 60, 61, 61, 61, 62, 62,
-  62, 62, 63, 63, 63, 64, 64, 64, 65, 65, 65, 65, 66, 66, 66, 67,
-  67, 67, 68, 68, 68, 68, 69, 69, 69, 70, 70, 70, 71, 71, 71, 71,
-  72, 72, 72, 73, 73, 73, 74, 74, 74, 74, 75, 75, 75, 76, 76, 76
-};
+#include "jccolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
 
-static const unsigned char green_lut[256] = {
-  0  , 1  , 1  , 2  , 2  , 3  , 4  , 4  , 5  , 5  , 6  , 6  ,
-  7  , 8  , 8  , 9  , 9  , 10 , 11 , 11 , 12 , 12 , 13 , 14 ,
-  14 , 15 , 15 , 16 , 16 , 17 , 18 , 18 , 19 , 19 , 20 , 21 ,
-  21 , 22 , 22 , 23 , 23 , 24 , 25 , 25 , 26 , 26 , 27 , 28 ,
-  28 , 29 , 29 , 30 , 31 , 31 , 32 , 32 , 33 , 33 , 34 , 35 ,
-  35 , 36 , 36 , 37 , 38 , 38 , 39 , 39 , 40 , 41 , 41 , 42 ,
-  42 , 43 , 43 , 44 , 45 , 45 , 46 , 46 , 47 , 48 , 48 , 49 ,
-  49 , 50 , 50 , 51 , 52 , 52 , 53 , 53 , 54 , 55 , 55 , 56 ,
-  56 , 57 , 58 , 58 , 59 , 59 , 60 , 60 , 61 , 62 , 62 , 63 ,
-  63 , 64 , 65 , 65 , 66 , 66 , 67 , 68 , 68 , 69 , 69 , 70 ,
-  70 , 71 , 72 , 72 , 73 , 73 , 74 , 75 , 75 , 76 , 76 , 77 ,
-  77 , 78 , 79 , 79 , 80 , 80 , 81 , 82 , 82 , 83 , 83 , 84 ,
-  85 , 85 , 86 , 86 , 87 , 87 , 88 , 89 , 89 , 90 , 90 , 91 ,
-  92 , 92 , 93 , 93 , 94 , 95 , 95 , 96 , 96 , 97 , 97 , 98 ,
-  99 , 99 , 100, 100, 101, 102, 102, 103, 103, 104, 104, 105,
-  106, 106, 107, 107, 108, 109, 109, 110, 110, 111, 112, 112,
-  113, 113, 114, 114, 115, 116, 116, 117, 117, 118, 119, 119,
-  120, 120, 121, 122, 122, 123, 123, 124, 124, 125, 126, 126,
-  127, 127, 128, 129, 129, 130, 130, 131, 131, 132, 133, 133,
-  134, 134, 135, 136, 136, 137, 137, 138, 139, 139, 140, 140,
-  141, 141, 142, 143, 143, 144, 144, 145, 146, 146, 147, 147,
-  148, 149, 149, 150
-};
+#define RGB_RED EXT_RGB_RED
+#define RGB_GREEN EXT_RGB_GREEN
+#define RGB_BLUE EXT_RGB_BLUE
+#define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+#define rgb_ycc_convert_internal extrgb_ycc_convert_internal
+#define rgb_gray_convert_internal extrgb_gray_convert_internal
+#include "jccolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef rgb_ycc_convert_internal
+#undef rgb_gray_convert_internal
 
-static const unsigned char blue_lut[256] = {
-  0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 2 ,
-  2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 4 ,
-  4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 ,
-  5 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 7 , 7 ,
-  7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 9 , 9 , 9 , 9 , 9 ,
-  9 , 9 , 9 , 9 , 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11,
-  11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13,
-  13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-  15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
-  16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18,
-  18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20,
-  20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22,
-  22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24,
-  24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-  26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27,
-  27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29
-};
+#define RGB_RED EXT_RGBX_RED
+#define RGB_GREEN EXT_RGBX_GREEN
+#define RGB_BLUE EXT_RGBX_BLUE
+#define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+#define rgb_ycc_convert_internal extrgbx_ycc_convert_internal
+#define rgb_gray_convert_internal extrgbx_gray_convert_internal
+#include "jccolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef rgb_ycc_convert_internal
+#undef rgb_gray_convert_internal
 
-#endif
+#define RGB_RED EXT_BGR_RED
+#define RGB_GREEN EXT_BGR_GREEN
+#define RGB_BLUE EXT_BGR_BLUE
+#define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+#define rgb_ycc_convert_internal extbgr_ycc_convert_internal
+#define rgb_gray_convert_internal extbgr_gray_convert_internal
+#include "jccolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef rgb_ycc_convert_internal
+#undef rgb_gray_convert_internal
+
+#define RGB_RED EXT_BGRX_RED
+#define RGB_GREEN EXT_BGRX_GREEN
+#define RGB_BLUE EXT_BGRX_BLUE
+#define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+#define rgb_ycc_convert_internal extbgrx_ycc_convert_internal
+#define rgb_gray_convert_internal extbgrx_gray_convert_internal
+#include "jccolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef rgb_ycc_convert_internal
+#undef rgb_gray_convert_internal
+
+#define RGB_RED EXT_XBGR_RED
+#define RGB_GREEN EXT_XBGR_GREEN
+#define RGB_BLUE EXT_XBGR_BLUE
+#define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+#define rgb_ycc_convert_internal extxbgr_ycc_convert_internal
+#define rgb_gray_convert_internal extxbgr_gray_convert_internal
+#include "jccolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef rgb_ycc_convert_internal
+#undef rgb_gray_convert_internal
+
+#define RGB_RED EXT_XRGB_RED
+#define RGB_GREEN EXT_XRGB_GREEN
+#define RGB_BLUE EXT_XRGB_BLUE
+#define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+#define rgb_ycc_convert_internal extxrgb_ycc_convert_internal
+#define rgb_gray_convert_internal extxrgb_gray_convert_internal
+#include "jccolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef rgb_ycc_convert_internal
+#undef rgb_gray_convert_internal
 
 
 /*
@@ -187,14 +212,6 @@
 
 /*
  * Convert some rows of samples to the JPEG colorspace.
- *
- * Note that we change from the application's interleaved-pixel format
- * to our internal noninterleaved, one-plane-per-component format.
- * The input buffer is therefore three times as wide as the output buffer.
- *
- * A starting row offset is provided only for the output buffer.  The caller
- * can easily adjust the passed input_buf value to accommodate any row
- * offset required on that side.
  */
 
 METHODDEF(void)
@@ -202,43 +219,39 @@
          JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
          JDIMENSION output_row, int num_rows)
 {
-  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
-  register int r, g, b;
-  register INT32 * ctab = cconvert->rgb_ycc_tab;
-  register JSAMPROW inptr;
-  register JSAMPROW outptr0, outptr1, outptr2;
-  register JDIMENSION col;
-  JDIMENSION num_cols = cinfo->image_width;
-
-  while (--num_rows >= 0) {
-    inptr = *input_buf++;
-    outptr0 = output_buf[0][output_row];
-    outptr1 = output_buf[1][output_row];
-    outptr2 = output_buf[2][output_row];
-    output_row++;
-    for (col = 0; col < num_cols; col++) {
-      r = GETJSAMPLE(inptr[rgb_red[cinfo->in_color_space]]);
-      g = GETJSAMPLE(inptr[rgb_green[cinfo->in_color_space]]);
-      b = GETJSAMPLE(inptr[rgb_blue[cinfo->in_color_space]]);
-      inptr += rgb_pixelsize[cinfo->in_color_space];
-      /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
-       * must be too; we do not need an explicit range-limiting operation.
-       * Hence the value being shifted is never negative, and we don't
-       * need the general RIGHT_SHIFT macro.
-       */
-      /* Y */
-      outptr0[col] = (JSAMPLE)
-        ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
-         >> SCALEBITS);
-      /* Cb */
-      outptr1[col] = (JSAMPLE)
-        ((ctab[r+R_CB_OFF] + ctab[g+G_CB_OFF] + ctab[b+B_CB_OFF])
-         >> SCALEBITS);
-      /* Cr */
-      outptr2[col] = (JSAMPLE)
-        ((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])
-         >> SCALEBITS);
-    }
+  switch (cinfo->in_color_space) {
+    case JCS_EXT_RGB:
+      extrgb_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,
+                                  num_rows);
+      break;
+    case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
+      extrgbx_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,
+                                   num_rows);
+      break;
+    case JCS_EXT_BGR:
+      extbgr_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,
+                                  num_rows);
+      break;
+    case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
+      extbgrx_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,
+                                   num_rows);
+      break;
+    case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
+      extxbgr_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,
+                                   num_rows);
+      break;
+    case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
+      extxrgb_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,
+                                   num_rows);
+      break;
+    default:
+      rgb_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,
+                               num_rows);
+      break;
   }
 }
 
@@ -248,9 +261,6 @@
 
 /*
  * Convert some rows of samples to the JPEG colorspace.
- * This version handles RGB->grayscale conversion, which is the same
- * as the RGB->Y portion of RGB->YCbCr.
- * We assume rgb_ycc_start has been called (we only use the Y tables).
  */
 
 METHODDEF(void)
@@ -258,36 +268,39 @@
           JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
           JDIMENSION output_row, int num_rows)
 {
-  #if BITS_IN_JSAMPLE != 8
-  register INT32 * ctab = cconvert->rgb_ycc_tab;
-  #endif
-  register JSAMPROW inptr;
-  register JSAMPROW outptr;
-  JSAMPLE *maxoutptr;
-  JDIMENSION num_cols = cinfo->image_width;
-  int rindex = rgb_red[cinfo->in_color_space];
-  int gindex = rgb_green[cinfo->in_color_space];
-  int bindex = rgb_blue[cinfo->in_color_space];
-  int rgbstride = rgb_pixelsize[cinfo->in_color_space];
-
-  while (--num_rows >= 0) {
-    inptr = *input_buf++;
-    outptr = output_buf[0][output_row];
-    maxoutptr = &outptr[num_cols];
-    output_row++;
-    for (; outptr < maxoutptr; outptr++, inptr += rgbstride) {
-      /* Y */
-      #if BITS_IN_JSAMPLE == 8
-      *outptr = red_lut[inptr[rindex]] + green_lut[inptr[gindex]]
-        + blue_lut[inptr[bindex]];
-      #else
-      *outptr = (JSAMPLE)
-        ((ctab[GETJSAMPLE(inptr[rindex])+R_Y_OFF]
-         + ctab[GETJSAMPLE(inptr[gindex])+G_Y_OFF]
-         + ctab[GETJSAMPLE(inptr[bindex])+B_Y_OFF])
-         >> SCALEBITS);
-      #endif
-    }
+  switch (cinfo->in_color_space) {
+    case JCS_EXT_RGB:
+      extrgb_gray_convert_internal(cinfo, input_buf, output_buf, output_row,
+                                   num_rows);
+      break;
+    case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
+      extrgbx_gray_convert_internal(cinfo, input_buf, output_buf, output_row,
+                                    num_rows);
+      break;
+    case JCS_EXT_BGR:
+      extbgr_gray_convert_internal(cinfo, input_buf, output_buf, output_row,
+                                   num_rows);
+      break;
+    case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
+      extbgrx_gray_convert_internal(cinfo, input_buf, output_buf, output_row,
+                                    num_rows);
+      break;
+    case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
+      extxbgr_gray_convert_internal(cinfo, input_buf, output_buf, output_row,
+                                    num_rows);
+      break;
+    case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
+      extxrgb_gray_convert_internal(cinfo, input_buf, output_buf, output_row,
+                                    num_rows);
+      break;
+    default:
+      rgb_gray_convert_internal(cinfo, input_buf, output_buf, output_row,
+                                num_rows);
+      break;
   }
 }
 
@@ -453,6 +466,10 @@
   case JCS_EXT_BGRX:
   case JCS_EXT_XBGR:
   case JCS_EXT_XRGB:
+  case JCS_EXT_RGBA:
+  case JCS_EXT_BGRA:
+  case JCS_EXT_ABGR:
+  case JCS_EXT_ARGB:
     if (cinfo->input_components != rgb_pixelsize[cinfo->in_color_space])
       ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
     break;
@@ -487,9 +504,17 @@
              cinfo->in_color_space == JCS_EXT_BGR ||
              cinfo->in_color_space == JCS_EXT_BGRX ||
              cinfo->in_color_space == JCS_EXT_XBGR ||
-             cinfo->in_color_space == JCS_EXT_XRGB) {
-      cconvert->pub.start_pass = rgb_ycc_start;
-      cconvert->pub.color_convert = rgb_gray_convert;
+             cinfo->in_color_space == JCS_EXT_XRGB ||
+             cinfo->in_color_space == JCS_EXT_RGBA ||
+             cinfo->in_color_space == JCS_EXT_BGRA ||
+             cinfo->in_color_space == JCS_EXT_ABGR ||
+             cinfo->in_color_space == JCS_EXT_ARGB) {
+      if (jsimd_can_rgb_gray())
+        cconvert->pub.color_convert = jsimd_rgb_gray_convert;
+      else {
+        cconvert->pub.start_pass = rgb_ycc_start;
+        cconvert->pub.color_convert = rgb_gray_convert;
+      }
     } else if (cinfo->in_color_space == JCS_YCbCr)
       cconvert->pub.color_convert = grayscale_convert;
     else
@@ -503,6 +528,10 @@
   case JCS_EXT_BGRX:
   case JCS_EXT_XBGR:
   case JCS_EXT_XRGB:
+  case JCS_EXT_RGBA:
+  case JCS_EXT_BGRA:
+  case JCS_EXT_ABGR:
+  case JCS_EXT_ARGB:
     if (cinfo->num_components != 3)
       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
     if (cinfo->in_color_space == cinfo->jpeg_color_space &&
@@ -521,7 +550,11 @@
         cinfo->in_color_space == JCS_EXT_BGR ||
         cinfo->in_color_space == JCS_EXT_BGRX ||
         cinfo->in_color_space == JCS_EXT_XBGR ||
-        cinfo->in_color_space == JCS_EXT_XRGB) {
+        cinfo->in_color_space == JCS_EXT_XRGB ||
+        cinfo->in_color_space == JCS_EXT_RGBA ||
+        cinfo->in_color_space == JCS_EXT_BGRA ||
+        cinfo->in_color_space == JCS_EXT_ABGR ||
+        cinfo->in_color_space == JCS_EXT_ARGB) {
       if (jsimd_can_rgb_ycc())
         cconvert->pub.color_convert = jsimd_rgb_ycc_convert;
       else {
diff -r 3a99d7ff459c media/libjpeg/jcdctmgr.c
--- a/media/libjpeg/jcdctmgr.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jcdctmgr.c    Tue Jan 24 23:47:27 2012 +0900
@@ -182,7 +182,7 @@
     /* fq will be one bit too large to fit in DCTELEM, so adjust */
     fq >>= 1;
     r--;
-  } else if (fr <= (divisor / 2)) { /* fractional part is < 0.5 */
+  } else if (fr <= (UDCTELEM2)(divisor / 2)) { /* fractional part is < 0.5 */
     c++;
   } else { /* fractional part is > 0.5 */
     fq++;
diff -r 3a99d7ff459c media/libjpeg/jchuff.c
--- a/media/libjpeg/jchuff.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jchuff.c    Tue Jan 24 23:47:27 2012 +0900
@@ -2,6 +2,7 @@
  * jchuff.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
+ * Copyright (C) 2009-2011, D. R. Commander.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -18,6 +19,15 @@
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "jchuff.h"        /* Declarations shared with jcphuff.c */
+#include <limits.h>
+
+static unsigned char jpeg_nbits_table[65536];
+static int jpeg_nbits_table_init = 0;
+
+#ifndef min
+ #define min(a,b) ((a)<(b)?(a):(b))
+#endif
+
 
 /* Expanded entropy encoder object for Huffman encoding.
  *
@@ -26,7 +36,7 @@
  */
 
 typedef struct {
-  INT32 put_buffer;        /* current bit-accumulation buffer */
+  size_t put_buffer;        /* current bit-accumulation buffer */
   int put_bits;            /* # of bits now in it */
   int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
 } savable_state;
@@ -260,6 +270,15 @@
     dtbl->ehufco[i] = huffcode[p];
     dtbl->ehufsi[i] = huffsize[p];
   }
+
+  if(!jpeg_nbits_table_init) {
+    for(i = 0; i < 65536; i++) {
+      int nbits = 0, temp = i;
+      while (temp) {temp >>= 1;  nbits++;}
+      jpeg_nbits_table[i] = nbits;
+    }
+    jpeg_nbits_table_init = 1;
+  }
 }
 
 
@@ -279,6 +298,8 @@
 {
   struct jpeg_destination_mgr * dest = state->cinfo->dest;
 
+  dest->free_in_buffer = state->free_in_buffer;
+
   if (! (*dest->empty_output_buffer) (state->cinfo))
     return FALSE;
   /* After a successful buffer dump, must reset buffer pointers */
@@ -290,58 +311,138 @@
 
 /* Outputting bits to the file */
 
-/* Only the right 24 bits of put_buffer are used; the valid bits are
- * left-justified in this part.  At most 16 bits can be passed to emit_bits
- * in one call, and we never retain more than 7 bits in put_buffer
- * between calls, so 24 bits are sufficient.
+/* These macros perform the same task as the emit_bits() function in the
+ * original libjpeg code.  In addition to reducing overhead by explicitly
+ * inlining the code, additional performance is achieved by taking into
+ * account the size of the bit buffer and waiting until it is almost full
+ * before emptying it.  This mostly benefits 64-bit platforms, since 6
+ * bytes can be stored in a 64-bit bit buffer before it has to be emptied.
  */
 
-INLINE
-LOCAL(boolean)
-emit_bits (working_state * state, unsigned int code, int size)
-/* Emit some bits; return TRUE if successful, FALSE if must suspend */
-{
-  /* This routine is heavily used, so it's worth coding tightly. */
-  register INT32 put_buffer = (INT32) code;
-  register int put_bits = state->cur.put_bits;
+#define EMIT_BYTE() { \
+  JOCTET c; \
+  put_bits -= 8; \
+  c = (JOCTET)GETJOCTET(put_buffer >> put_bits); \
+  *buffer++ = c; \
+  if (c == 0xFF)  /* need to stuff a zero byte? */ \
+    *buffer++ = 0; \
+ }
 
-  /* if size is 0, caller used an invalid Huffman table entry */
-  if (size == 0)
-    ERREXIT(state->cinfo, JERR_HUFF_MISSING_CODE);
+#define PUT_BITS(code, size) { \
+  put_bits += size; \
+  put_buffer = (put_buffer << size) | code; \
+}
 
-  put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
-  
-  put_bits += size;        /* new number of bits in buffer */
-  
-  put_buffer <<= 24 - put_bits; /* align incoming bits */
+#define CHECKBUF15() { \
+  if (put_bits > 15) { \
+    EMIT_BYTE() \
+    EMIT_BYTE() \
+  } \
+}
 
-  put_buffer |= state->cur.put_buffer; /* and merge with old buffer contents */
-  
-  while (put_bits >= 8) {
-    int c = (int) ((put_buffer >> 16) & 0xFF);
-    
-    emit_byte(state, c, return FALSE);
-    if (c == 0xFF) {        /* need to stuff a zero byte? */
-      emit_byte(state, 0, return FALSE);
-    }
-    put_buffer <<= 8;
-    put_bits -= 8;
-  }
+#define CHECKBUF31() { \
+  if (put_bits > 31) { \
+    EMIT_BYTE() \
+    EMIT_BYTE() \
+    EMIT_BYTE() \
+    EMIT_BYTE() \
+  } \
+}
 
-  state->cur.put_buffer = put_buffer; /* update state variables */
-  state->cur.put_bits = put_bits;
+#define CHECKBUF47() { \
+  if (put_bits > 47) { \
+    EMIT_BYTE() \
+    EMIT_BYTE() \
+    EMIT_BYTE() \
+    EMIT_BYTE() \
+    EMIT_BYTE() \
+    EMIT_BYTE() \
+  } \
+}
 
-  return TRUE;
+#if __WORDSIZE==64 || defined(_WIN64)
+
+#define EMIT_BITS(code, size) { \
+  CHECKBUF47() \
+  PUT_BITS(code, size) \
 }
 
+#define EMIT_CODE(code, size) { \
+  temp2 &= (((INT32) 1)<<nbits) - 1; \
+  CHECKBUF31() \
+  PUT_BITS(code, size) \
+  PUT_BITS(temp2, nbits) \
+ }
+
+#else
+
+#define EMIT_BITS(code, size) { \
+  PUT_BITS(code, size) \
+  CHECKBUF15() \
+}
+
+#define EMIT_CODE(code, size) { \
+  temp2 &= (((INT32) 1)<<nbits) - 1; \
+  PUT_BITS(code, size) \
+  CHECKBUF15() \
+  PUT_BITS(temp2, nbits) \
+  CHECKBUF15() \
+ }
+
+#endif
+
+
+#define BUFSIZE (DCTSIZE2 * 2)
+
+#define LOAD_BUFFER() { \
+  if (state->free_in_buffer < BUFSIZE) { \
+    localbuf = 1; \
+    buffer = _buffer; \
+  } \
+  else buffer = state->next_output_byte; \
+ }
+
+#define STORE_BUFFER() { \
+  if (localbuf) { \
+    bytes = buffer - _buffer; \
+    buffer = _buffer; \
+    while (bytes > 0) { \
+      bytestocopy = min(bytes, state->free_in_buffer); \
+      MEMCOPY(state->next_output_byte, buffer, bytestocopy); \
+      state->next_output_byte += bytestocopy; \
+      buffer += bytestocopy; \
+      state->free_in_buffer -= bytestocopy; \
+      if (state->free_in_buffer == 0) \
+        if (! dump_buffer(state)) return FALSE; \
+      bytes -= bytestocopy; \
+    } \
+  } \
+  else { \
+    state->free_in_buffer -= (buffer - state->next_output_byte); \
+    state->next_output_byte = buffer; \
+  } \
+ }
+
 
 LOCAL(boolean)
 flush_bits (working_state * state)
 {
-  if (! emit_bits(state, 0x7F, 7)) /* fill any partial byte with ones */
-    return FALSE;
+  JOCTET _buffer[BUFSIZE], *buffer;
+  size_t put_buffer;  int put_bits;
+  size_t bytes, bytestocopy;  int localbuf = 0;
+
+  put_buffer = state->cur.put_buffer;
+  put_bits = state->cur.put_bits;
+  LOAD_BUFFER()
+
+  /* fill any partial byte with ones */
+  PUT_BITS(0x7F, 7)
+  while (put_bits >= 8) EMIT_BYTE()
+
   state->cur.put_buffer = 0;    /* and reset bit-buffer to empty */
   state->cur.put_bits = 0;
+  STORE_BUFFER()
+
   return TRUE;
 }
 
@@ -352,91 +453,108 @@
 encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
           c_derived_tbl *dctbl, c_derived_tbl *actbl)
 {
-  register int temp, temp2;
-  register int nbits;
-  register int k, r, i;
-  
+  int temp, temp2, temp3;
+  int nbits;
+  int r, code, size;
+  JOCTET _buffer[BUFSIZE], *buffer;
+  size_t put_buffer;  int put_bits;
+  int code_0xf0 = actbl->ehufco[0xf0], size_0xf0 = actbl->ehufsi[0xf0];
+  size_t bytes, bytestocopy;  int localbuf = 0;
+
+  put_buffer = state->cur.put_buffer;
+  put_bits = state->cur.put_bits;
+  LOAD_BUFFER()
+
   /* Encode the DC coefficient difference per section F.1.2.1 */
   
   temp = temp2 = block[0] - last_dc_val;
 
-  if (temp < 0) {
-    temp = -temp;        /* temp is abs value of input */
-    /* For a negative input, want temp2 = bitwise complement of abs(input) */
-    /* This code assumes we are on a two's complement machine */
-    temp2--;
-  }
-  
+ /* This is a well-known technique for obtaining the absolute value without a
+  * branch.  It is derived from an assembly language technique presented in
+  * "How to Optimize for the Pentium Processors", Copyright (c) 1996, 1997 by
+  * Agner Fog.
+  */
+  temp3 = temp >> (CHAR_BIT * sizeof(int) - 1);
+  temp ^= temp3;
+  temp -= temp3;
+
+  /* For a negative input, want temp2 = bitwise complement of abs(input) */
+  /* This code assumes we are on a two's complement machine */
+  temp2 += temp3;
+
   /* Find the number of bits needed for the magnitude of the coefficient */
-  nbits = 0;
-  while (temp) {
-    nbits++;
-    temp >>= 1;
-  }
-  /* Check for out-of-range coefficient values.
-   * Since we're encoding a difference, the range limit is twice as much.
-   */
-  if (nbits > MAX_COEF_BITS+1)
-    ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
-  
+  nbits = jpeg_nbits_table[temp];
+
   /* Emit the Huffman-coded symbol for the number of bits */
-  if (! emit_bits(state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))
-    return FALSE;
+  code = dctbl->ehufco[nbits];
+  size = dctbl->ehufsi[nbits];
+  PUT_BITS(code, size)
+  CHECKBUF15()
+
+  /* Mask off any extra bits in code */
+  temp2 &= (((INT32) 1)<<nbits) - 1;
 
   /* Emit that number of bits of the value, if positive, */
   /* or the complement of its magnitude, if negative. */
-  if (nbits)            /* emit_bits rejects calls with size 0 */
-    if (! emit_bits(state, (unsigned int) temp2, nbits))
-      return FALSE;
+  PUT_BITS(temp2, nbits)
+  CHECKBUF15()
 
   /* Encode the AC coefficients per section F.1.2.2 */
   
   r = 0;            /* r = run length of zeros */
-  
-  for (k = 1; k < DCTSIZE2; k++) {
-    if ((temp = block[jpeg_natural_order[k]]) == 0) {
-      r++;
-    } else {
-      /* if run length > 15, must emit special run-length-16 codes (0xF0) */
-      while (r > 15) {
-    if (! emit_bits(state, actbl->ehufco[0xF0], actbl->ehufsi[0xF0]))
-      return FALSE;
-    r -= 16;
-      }
 
-      temp2 = temp;
-      if (temp < 0) {
-    temp = -temp;        /* temp is abs value of input */
-    /* This code assumes we are on a two's complement machine */
-    temp2--;
-      }
-      
-      /* Find the number of bits needed for the magnitude of the coefficient */
-      nbits = 1;        /* there must be at least one 1 bit */
-      while ((temp >>= 1))
-    nbits++;
-      /* Check for out-of-range coefficient values */
-      if (nbits > MAX_COEF_BITS)
-    ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
-      
-      /* Emit Huffman symbol for run length / number of bits */
-      i = (r << 4) + nbits;
-      if (! emit_bits(state, actbl->ehufco[i], actbl->ehufsi[i]))
-    return FALSE;
+/* Manually unroll the k loop to eliminate the counter variable.  This
+ * improves performance greatly on systems with a limited number of
+ * registers (such as x86.)
+ */
+#define kloop(jpeg_natural_order_of_k) {  \
+  if ((temp = block[jpeg_natural_order_of_k]) == 0) { \
+    r++; \
+  } else { \
+    temp2 = temp; \
+    /* Branch-less absolute value, bitwise complement, etc., same as above */ \
+    temp3 = temp >> (CHAR_BIT * sizeof(int) - 1); \
+    temp ^= temp3; \
+    temp -= temp3; \
+    temp2 += temp3; \
+    nbits = jpeg_nbits_table[temp]; \
+    /* if run length > 15, must emit special run-length-16 codes (0xF0) */ \
+    while (r > 15) { \
+      EMIT_BITS(code_0xf0, size_0xf0) \
+      r -= 16; \
+    } \
+    /* Emit Huffman symbol for run length / number of bits */ \
+    temp3 = (r << 4) + nbits;  \
+    code = actbl->ehufco[temp3]; \
+    size = actbl->ehufsi[temp3]; \
+    EMIT_CODE(code, size) \
+    r = 0;  \
+  } \
+}
 
-      /* Emit that number of bits of the value, if positive, */
-      /* or the complement of its magnitude, if negative. */
-      if (! emit_bits(state, (unsigned int) temp2, nbits))
-    return FALSE;
-      
-      r = 0;
-    }
+  /* One iteration for each value in jpeg_natural_order[] */
+  kloop(1);   kloop(8);   kloop(16);  kloop(9);   kloop(2);   kloop(3);
+  kloop(10);  kloop(17);  kloop(24);  kloop(32);  kloop(25);  kloop(18);
+  kloop(11);  kloop(4);   kloop(5);   kloop(12);  kloop(19);  kloop(26);
+  kloop(33);  kloop(40);  kloop(48);  kloop(41);  kloop(34);  kloop(27);
+  kloop(20);  kloop(13);  kloop(6);   kloop(7);   kloop(14);  kloop(21);
+  kloop(28);  kloop(35);  kloop(42);  kloop(49);  kloop(56);  kloop(57);
+  kloop(50);  kloop(43);  kloop(36);  kloop(29);  kloop(22);  kloop(15);
+  kloop(23);  kloop(30);  kloop(37);  kloop(44);  kloop(51);  kloop(58);
+  kloop(59);  kloop(52);  kloop(45);  kloop(38);  kloop(31);  kloop(39);
+  kloop(46);  kloop(53);  kloop(60);  kloop(61);  kloop(54);  kloop(47);
+  kloop(55);  kloop(62);  kloop(63);
+
+  /* If the last coef(s) were zero, emit an end-of-block code */
+  if (r > 0) {
+    code = actbl->ehufco[0];
+    size = actbl->ehufsi[0];
+    EMIT_BITS(code, size)
   }
 
-  /* If the last coef(s) were zero, emit an end-of-block code */
-  if (r > 0)
-    if (! emit_bits(state, actbl->ehufco[0], actbl->ehufsi[0]))
-      return FALSE;
+  state->cur.put_buffer = put_buffer;
+  state->cur.put_bits = put_bits;
+  STORE_BUFFER()
 
   return TRUE;
 }
diff -r 3a99d7ff459c media/libjpeg/jcmainct.c
--- a/media/libjpeg/jcmainct.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jcmainct.c    Tue Jan 24 23:47:27 2012 +0900
@@ -68,32 +68,32 @@
 METHODDEF(void)
 start_pass_main (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr main_ptr = (my_main_ptr) cinfo->main;
 
   /* Do nothing in raw-data mode. */
   if (cinfo->raw_data_in)
     return;
 
-  main->cur_iMCU_row = 0;    /* initialize counters */
-  main->rowgroup_ctr = 0;
-  main->suspended = FALSE;
-  main->pass_mode = pass_mode;    /* save mode for use by process_data */
+  main_ptr->cur_iMCU_row = 0;    /* initialize counters */
+  main_ptr->rowgroup_ctr = 0;
+  main_ptr->suspended = FALSE;
+  main_ptr->pass_mode = pass_mode;    /* save mode for use by process_data */
 
   switch (pass_mode) {
   case JBUF_PASS_THRU:
 #ifdef FULL_MAIN_BUFFER_SUPPORTED
-    if (main->whole_image[0] != NULL)
+    if (main_ptr->whole_image[0] != NULL)
       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 #endif
-    main->pub.process_data = process_data_simple_main;
+    main_ptr->pub.process_data = process_data_simple_main;
     break;
 #ifdef FULL_MAIN_BUFFER_SUPPORTED
   case JBUF_SAVE_SOURCE:
   case JBUF_CRANK_DEST:
   case JBUF_SAVE_AND_PASS:
-    if (main->whole_image[0] == NULL)
+    if (main_ptr->whole_image[0] == NULL)
       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
-    main->pub.process_data = process_data_buffer_main;
+    main_ptr->pub.process_data = process_data_buffer_main;
     break;
 #endif
   default:
@@ -114,46 +114,46 @@
               JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
               JDIMENSION in_rows_avail)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr main_ptr = (my_main_ptr) cinfo->main;
 
-  while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
+  while (main_ptr->cur_iMCU_row < cinfo->total_iMCU_rows) {
     /* Read input data if we haven't filled the main buffer yet */
-    if (main->rowgroup_ctr < DCTSIZE)
+    if (main_ptr->rowgroup_ctr < DCTSIZE)
       (*cinfo->prep->pre_process_data) (cinfo,
                     input_buf, in_row_ctr, in_rows_avail,
-                    main->buffer, &main->rowgroup_ctr,
+                    main_ptr->buffer, &main_ptr->rowgroup_ctr,
                     (JDIMENSION) DCTSIZE);
 
     /* If we don't have a full iMCU row buffered, return to application for
      * more data.  Note that preprocessor will always pad to fill the iMCU row
      * at the bottom of the image.
      */
-    if (main->rowgroup_ctr != DCTSIZE)
+    if (main_ptr->rowgroup_ctr != DCTSIZE)
       return;
 
     /* Send the completed row to the compressor */
-    if (! (*cinfo->coef->compress_data) (cinfo, main->buffer)) {
+    if (! (*cinfo->coef->compress_data) (cinfo, main_ptr->buffer)) {
       /* If compressor did not consume the whole row, then we must need to
        * suspend processing and return to the application.  In this situation
        * we pretend we didn't yet consume the last input row; otherwise, if
        * it happened to be the last row of the image, the application would
        * think we were done.
        */
-      if (! main->suspended) {
+      if (! main_ptr->suspended) {
     (*in_row_ctr)--;
-    main->suspended = TRUE;
+    main_ptr->suspended = TRUE;
       }
       return;
     }
     /* We did finish the row.  Undo our little suspension hack if a previous
      * call suspended; then mark the main buffer empty.
      */
-    if (main->suspended) {
+    if (main_ptr->suspended) {
       (*in_row_ctr)++;
-      main->suspended = FALSE;
+      main_ptr->suspended = FALSE;
     }
-    main->rowgroup_ctr = 0;
-    main->cur_iMCU_row++;
+    main_ptr->rowgroup_ctr = 0;
+    main_ptr->cur_iMCU_row++;
   }
 }
 
@@ -173,22 +173,22 @@
   my_main_ptr main = (my_main_ptr) cinfo->main;
   int ci;
   jpeg_component_info *compptr;
-  boolean writing = (main->pass_mode != JBUF_CRANK_DEST);
+  boolean writing = (main_ptr->pass_mode != JBUF_CRANK_DEST);
 
-  while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
+  while (main_ptr->cur_iMCU_row < cinfo->total_iMCU_rows) {
     /* Realign the virtual buffers if at the start of an iMCU row. */
-    if (main->rowgroup_ctr == 0) {
+    if (main_ptr->rowgroup_ctr == 0) {
       for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
-    main->buffer[ci] = (*cinfo->mem->access_virt_sarray)
-      ((j_common_ptr) cinfo, main->whole_image[ci],
-       main->cur_iMCU_row * (compptr->v_samp_factor * DCTSIZE),
+    main_ptr->buffer[ci] = (*cinfo->mem->access_virt_sarray)
+      ((j_common_ptr) cinfo, main_ptr->whole_image[ci],
+       main_ptr->cur_iMCU_row * (compptr->v_samp_factor * DCTSIZE),
        (JDIMENSION) (compptr->v_samp_factor * DCTSIZE), writing);
       }
       /* In a read pass, pretend we just read some source data. */
       if (! writing) {
     *in_row_ctr += cinfo->max_v_samp_factor * DCTSIZE;
-    main->rowgroup_ctr = DCTSIZE;
+    main_ptr->rowgroup_ctr = DCTSIZE;
       }
     }
 
@@ -197,40 +197,40 @@
     if (writing) {
       (*cinfo->prep->pre_process_data) (cinfo,
                     input_buf, in_row_ctr, in_rows_avail,
-                    main->buffer, &main->rowgroup_ctr,
+                    main_ptr->buffer, &main_ptr->rowgroup_ctr,
                     (JDIMENSION) DCTSIZE);
       /* Return to application if we need more data to fill the iMCU row. */
-      if (main->rowgroup_ctr < DCTSIZE)
+      if (main_ptr->rowgroup_ctr < DCTSIZE)
     return;
     }
 
     /* Emit data, unless this is a sink-only pass. */
-    if (main->pass_mode != JBUF_SAVE_SOURCE) {
-      if (! (*cinfo->coef->compress_data) (cinfo, main->buffer)) {
+    if (main_ptr->pass_mode != JBUF_SAVE_SOURCE) {
+      if (! (*cinfo->coef->compress_data) (cinfo, main_ptr->buffer)) {
     /* If compressor did not consume the whole row, then we must need to
      * suspend processing and return to the application.  In this situation
      * we pretend we didn't yet consume the last input row; otherwise, if
      * it happened to be the last row of the image, the application would
      * think we were done.
      */
-    if (! main->suspended) {
+    if (! main_ptr->suspended) {
       (*in_row_ctr)--;
-      main->suspended = TRUE;
+      main_ptr->suspended = TRUE;
     }
     return;
       }
       /* We did finish the row.  Undo our little suspension hack if a previous
        * call suspended; then mark the main buffer empty.
        */
-      if (main->suspended) {
+      if (main_ptr->suspended) {
     (*in_row_ctr)++;
-    main->suspended = FALSE;
+    main_ptr->suspended = FALSE;
       }
     }
 
     /* If get here, we are done with this iMCU row.  Mark buffer empty. */
-    main->rowgroup_ctr = 0;
-    main->cur_iMCU_row++;
+    main_ptr->rowgroup_ctr = 0;
+    main_ptr->cur_iMCU_row++;
   }
 }
 
@@ -244,15 +244,15 @@
 GLOBAL(void)
 jinit_c_main_controller (j_compress_ptr cinfo, boolean need_full_buffer)
 {
-  my_main_ptr main;
+  my_main_ptr main_ptr;
   int ci;
   jpeg_component_info *compptr;
 
-  main = (my_main_ptr)
+  main_ptr = (my_main_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
                 SIZEOF(my_main_controller));
-  cinfo->main = (struct jpeg_c_main_controller *) main;
-  main->pub.start_pass = start_pass_main;
+  cinfo->main = (struct jpeg_c_main_controller *) main_ptr;
+  main_ptr->pub.start_pass = start_pass_main;
 
   /* We don't need to create a buffer in raw-data mode. */
   if (cinfo->raw_data_in)
@@ -267,7 +267,7 @@
     /* Note we pad the bottom to a multiple of the iMCU height */
     for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
      ci++, compptr++) {
-      main->whole_image[ci] = (*cinfo->mem->request_virt_sarray)
+      main_ptr->whole_image[ci] = (*cinfo->mem->request_virt_sarray)
     ((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
      compptr->width_in_blocks * DCTSIZE,
      (JDIMENSION) jround_up((long) compptr->height_in_blocks,
@@ -279,12 +279,12 @@
 #endif
   } else {
 #ifdef FULL_MAIN_BUFFER_SUPPORTED
-    main->whole_image[0] = NULL; /* flag for no virtual arrays */
+    main_ptr->whole_image[0] = NULL; /* flag for no virtual arrays */
 #endif
     /* Allocate a strip buffer for each component */
     for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
      ci++, compptr++) {
-      main->buffer[ci] = (*cinfo->mem->alloc_sarray)
+      main_ptr->buffer[ci] = (*cinfo->mem->alloc_sarray)
     ((j_common_ptr) cinfo, JPOOL_IMAGE,
      compptr->width_in_blocks * DCTSIZE,
      (JDIMENSION) (compptr->v_samp_factor * DCTSIZE));
diff -r 3a99d7ff459c media/libjpeg/jcmaster.c
--- a/media/libjpeg/jcmaster.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jcmaster.c    Tue Jan 24 23:47:27 2012 +0900
@@ -75,7 +75,9 @@
   JDIMENSION jd_samplesperrow;
 
 #if JPEG_LIB_VERSION >= 70
+#if JPEG_LIB_VERSION >= 80
   if (!transcode_only)
+#endif
     jpeg_calc_jpeg_dimensions(cinfo);
 #endif
 
diff -r 3a99d7ff459c media/libjpeg/jcparam.c
--- a/media/libjpeg/jcparam.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jcparam.c    Tue Jan 24 23:47:27 2012 +0900
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 1991-1998, Thomas G. Lane.
  * Modified 2003-2008 by Guido Vollbeding.
- * Copyright (C) 2009-2010, D. R. Commander.
+ * Copyright (C) 2009-2011, D. R. Commander.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -398,6 +398,10 @@
   case JCS_EXT_BGRX:
   case JCS_EXT_XBGR:
   case JCS_EXT_XRGB:
+  case JCS_EXT_RGBA:
+  case JCS_EXT_BGRA:
+  case JCS_EXT_ABGR:
+  case JCS_EXT_ARGB:
     jpeg_set_colorspace(cinfo, JCS_YCbCr);
     break;
   case JCS_YCbCr:
diff -r 3a99d7ff459c media/libjpeg/jdcolext.c
--- /dev/null    Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libjpeg/jdcolext.c    Tue Jan 24 23:47:27 2012 +0900
@@ -0,0 +1,104 @@
+/*
+ * jdcolext.c
+ *
+ * Copyright (C) 1991-1997, Thomas G. Lane.
+ * Copyright (C) 2009, 2011, D. R. Commander.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains output colorspace conversion routines.
+ */
+
+
+/* This file is included by jdcolor.c */
+
+
+/*
+ * Convert some rows of samples to the output colorspace.
+ *
+ * Note that we change from noninterleaved, one-plane-per-component format
+ * to interleaved-pixel format.  The output buffer is therefore three times
+ * as wide as the input buffer.
+ * A starting row offset is provided only for the input buffer.  The caller
+ * can easily adjust the passed output_buf value to accommodate any row
+ * offset required on that side.
+ */
+
+INLINE
+LOCAL(void)
+ycc_rgb_convert_internal (j_decompress_ptr cinfo,
+                          JSAMPIMAGE input_buf, JDIMENSION input_row,
+                          JSAMPARRAY output_buf, int num_rows)
+{
+  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
+  register int y, cb, cr;
+  register JSAMPROW outptr;
+  register JSAMPROW inptr0, inptr1, inptr2;
+  register JDIMENSION col;
+  JDIMENSION num_cols = cinfo->output_width;
+  /* copy these pointers into registers if possible */
+  register JSAMPLE * range_limit = cinfo->sample_range_limit;
+  register int * Crrtab = cconvert->Cr_r_tab;
+  register int * Cbbtab = cconvert->Cb_b_tab;
+  register INT32 * Crgtab = cconvert->Cr_g_tab;
+  register INT32 * Cbgtab = cconvert->Cb_g_tab;
+  SHIFT_TEMPS
+
+  while (--num_rows >= 0) {
+    inptr0 = input_buf[0][input_row];
+    inptr1 = input_buf[1][input_row];
+    inptr2 = input_buf[2][input_row];
+    input_row++;
+    outptr = *output_buf++;
+    for (col = 0; col < num_cols; col++) {
+      y  = GETJSAMPLE(inptr0[col]);
+      cb = GETJSAMPLE(inptr1[col]);
+      cr = GETJSAMPLE(inptr2[col]);
+      /* Range-limiting is essential due to noise introduced by DCT losses. */
+      outptr[RGB_RED] =   range_limit[y + Crrtab[cr]];
+      outptr[RGB_GREEN] = range_limit[y +
+                  ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
+                         SCALEBITS))];
+      outptr[RGB_BLUE] =  range_limit[y + Cbbtab[cb]];
+      /* Set unused byte to 0xFF so it can be interpreted as an opaque */
+      /* alpha channel value */
+#ifdef RGB_ALPHA
+      outptr[RGB_ALPHA] = 0xFF;
+#endif
+      outptr += RGB_PIXELSIZE;
+    }
+  }
+}
+
+
+/*
+ * Convert grayscale to RGB: just duplicate the graylevel three times.
+ * This is provided to support applications that don't want to cope
+ * with grayscale as a separate case.
+ */
+
+INLINE
+LOCAL(void)
+gray_rgb_convert_internal (j_decompress_ptr cinfo,
+                           JSAMPIMAGE input_buf, JDIMENSION input_row,
+                           JSAMPARRAY output_buf, int num_rows)
+{
+  register JSAMPROW inptr, outptr;
+  register JDIMENSION col;
+  JDIMENSION num_cols = cinfo->output_width;
+
+  while (--num_rows >= 0) {
+    inptr = input_buf[0][input_row++];
+    outptr = *output_buf++;
+    for (col = 0; col < num_cols; col++) {
+      /* We can dispense with GETJSAMPLE() here */
+      outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = inptr[col];
+      /* Set unused byte to 0xFF so it can be interpreted as an opaque */
+      /* alpha channel value */
+#ifdef RGB_ALPHA
+      outptr[RGB_ALPHA] = 0xFF;
+#endif
+      outptr += RGB_PIXELSIZE;
+    }
+  }
+}
diff -r 3a99d7ff459c media/libjpeg/jdcolor.c
--- a/media/libjpeg/jdcolor.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jdcolor.c    Tue Jan 24 23:47:27 2012 +0900
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright (C) 2009, D. R. Commander.
+ * Copyright (C) 2009, 2011, D. R. Commander.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -65,6 +65,107 @@
 #define FIX(x)        ((INT32) ((x) * (1L<<SCALEBITS) + 0.5))
 
 
+/* Include inline routines for colorspace extensions */
+
+#include "jdcolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+
+#define RGB_RED EXT_RGB_RED
+#define RGB_GREEN EXT_RGB_GREEN
+#define RGB_BLUE EXT_RGB_BLUE
+#define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+#define ycc_rgb_convert_internal ycc_extrgb_convert_internal
+#define gray_rgb_convert_internal gray_extrgb_convert_internal
+#include "jdcolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef ycc_rgb_convert_internal
+#undef gray_rgb_convert_internal
+
+#define RGB_RED EXT_RGBX_RED
+#define RGB_GREEN EXT_RGBX_GREEN
+#define RGB_BLUE EXT_RGBX_BLUE
+#define RGB_ALPHA 3
+#define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+#define ycc_rgb_convert_internal ycc_extrgbx_convert_internal
+#define gray_rgb_convert_internal gray_extrgbx_convert_internal
+#include "jdcolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_ALPHA
+#undef RGB_PIXELSIZE
+#undef ycc_rgb_convert_internal
+#undef gray_rgb_convert_internal
+
+#define RGB_RED EXT_BGR_RED
+#define RGB_GREEN EXT_BGR_GREEN
+#define RGB_BLUE EXT_BGR_BLUE
+#define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+#define ycc_rgb_convert_internal ycc_extbgr_convert_internal
+#define gray_rgb_convert_internal gray_extbgr_convert_internal
+#include "jdcolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef ycc_rgb_convert_internal
+#undef gray_rgb_convert_internal
+
+#define RGB_RED EXT_BGRX_RED
+#define RGB_GREEN EXT_BGRX_GREEN
+#define RGB_BLUE EXT_BGRX_BLUE
+#define RGB_ALPHA 3
+#define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+#define ycc_rgb_convert_internal ycc_extbgrx_convert_internal
+#define gray_rgb_convert_internal gray_extbgrx_convert_internal
+#include "jdcolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_ALPHA
+#undef RGB_PIXELSIZE
+#undef ycc_rgb_convert_internal
+#undef gray_rgb_convert_internal
+
+#define RGB_RED EXT_XBGR_RED
+#define RGB_GREEN EXT_XBGR_GREEN
+#define RGB_BLUE EXT_XBGR_BLUE
+#define RGB_ALPHA 0
+#define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+#define ycc_rgb_convert_internal ycc_extxbgr_convert_internal
+#define gray_rgb_convert_internal gray_extxbgr_convert_internal
+#include "jdcolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_ALPHA
+#undef RGB_PIXELSIZE
+#undef ycc_rgb_convert_internal
+#undef gray_rgb_convert_internal
+
+#define RGB_RED EXT_XRGB_RED
+#define RGB_GREEN EXT_XRGB_GREEN
+#define RGB_BLUE EXT_XRGB_BLUE
+#define RGB_ALPHA 0
+#define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+#define ycc_rgb_convert_internal ycc_extxrgb_convert_internal
+#define gray_rgb_convert_internal gray_extxrgb_convert_internal
+#include "jdcolext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_ALPHA
+#undef RGB_PIXELSIZE
+#undef ycc_rgb_convert_internal
+#undef gray_rgb_convert_internal
+
+
 /*
  * Initialize tables for YCC->RGB colorspace conversion.
  */
@@ -110,13 +211,6 @@
 
 /*
  * Convert some rows of samples to the output colorspace.
- *
- * Note that we change from noninterleaved, one-plane-per-component format
- * to interleaved-pixel format.  The output buffer is therefore three times
- * as wide as the input buffer.
- * A starting row offset is provided only for the input buffer.  The caller
- * can easily adjust the passed output_buf value to accommodate any row
- * offset required on that side.
  */
 
 METHODDEF(void)
@@ -124,38 +218,39 @@
          JSAMPIMAGE input_buf, JDIMENSION input_row,
          JSAMPARRAY output_buf, int num_rows)
 {
-  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
-  register int y, cb, cr;
-  register JSAMPROW outptr;
-  register JSAMPROW inptr0, inptr1, inptr2;
-  register JDIMENSION col;
-  JDIMENSION num_cols = cinfo->output_width;
-  /* copy these pointers into registers if possible */
-  register JSAMPLE * range_limit = cinfo->sample_range_limit;
-  register int * Crrtab = cconvert->Cr_r_tab;
-  register int * Cbbtab = cconvert->Cb_b_tab;
-  register INT32 * Crgtab = cconvert->Cr_g_tab;
-  register INT32 * Cbgtab = cconvert->Cb_g_tab;
-  SHIFT_TEMPS
-
-  while (--num_rows >= 0) {
-    inptr0 = input_buf[0][input_row];
-    inptr1 = input_buf[1][input_row];
-    inptr2 = input_buf[2][input_row];
-    input_row++;
-    outptr = *output_buf++;
-    for (col = 0; col < num_cols; col++) {
-      y  = GETJSAMPLE(inptr0[col]);
-      cb = GETJSAMPLE(inptr1[col]);
-      cr = GETJSAMPLE(inptr2[col]);
-      /* Range-limiting is essential due to noise introduced by DCT losses. */
-      outptr[rgb_red[cinfo->out_color_space]] =   range_limit[y + Crrtab[cr]];
-      outptr[rgb_green[cinfo->out_color_space]] = range_limit[y +
-                  ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
-                         SCALEBITS))];
-      outptr[rgb_blue[cinfo->out_color_space]] =  range_limit[y + Cbbtab[cb]];
-      outptr += rgb_pixelsize[cinfo->out_color_space];
-    }
+  switch (cinfo->out_color_space) {
+    case JCS_EXT_RGB:
+      ycc_extrgb_convert_internal(cinfo, input_buf, input_row, output_buf,
+                                  num_rows);
+      break;
+    case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
+      ycc_extrgbx_convert_internal(cinfo, input_buf, input_row, output_buf,
+                                   num_rows);
+      break;
+    case JCS_EXT_BGR:
+      ycc_extbgr_convert_internal(cinfo, input_buf, input_row, output_buf,
+                                  num_rows);
+      break;
+    case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
+      ycc_extbgrx_convert_internal(cinfo, input_buf, input_row, output_buf,
+                                   num_rows);
+      break;
+    case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
+      ycc_extxbgr_convert_internal(cinfo, input_buf, input_row, output_buf,
+                                   num_rows);
+      break;
+    case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
+      ycc_extxrgb_convert_internal(cinfo, input_buf, input_row, output_buf,
+                                   num_rows);
+      break;
+    default:
+      ycc_rgb_convert_internal(cinfo, input_buf, input_row, output_buf,
+                               num_rows);
+      break;
   }
 }
 
@@ -211,9 +306,7 @@
 
 
 /*
- * Convert grayscale to RGB: just duplicate the graylevel three times.
- * This is provided to support applications that don't want to cope
- * with grayscale as a separate case.
+ * Convert grayscale to RGB
  */
 
 METHODDEF(void)
@@ -221,22 +314,39 @@
           JSAMPIMAGE input_buf, JDIMENSION input_row,
           JSAMPARRAY output_buf, int num_rows)
 {
-  register JSAMPROW inptr, outptr;
-  JSAMPLE *maxinptr;
-  JDIMENSION num_cols = cinfo->output_width;
-  int rindex = rgb_red[cinfo->out_color_space];
-  int gindex = rgb_green[cinfo->out_color_space];
-  int bindex = rgb_blue[cinfo->out_color_space];
-  int rgbstride = rgb_pixelsize[cinfo->out_color_space];
-
-  while (--num_rows >= 0) {
-    inptr = input_buf[0][input_row++];
-    maxinptr = &inptr[num_cols];
-    outptr = *output_buf++;
-    for (; inptr < maxinptr; inptr++, outptr += rgbstride) {
-      /* We can dispense with GETJSAMPLE() here */
-      outptr[rindex] = outptr[gindex] = outptr[bindex] = *inptr;
-    }
+  switch (cinfo->out_color_space) {
+    case JCS_EXT_RGB:
+      gray_extrgb_convert_internal(cinfo, input_buf, input_row, output_buf,
+                                   num_rows);
+      break;
+    case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
+      gray_extrgbx_convert_internal(cinfo, input_buf, input_row, output_buf,
+                                    num_rows);
+      break;
+    case JCS_EXT_BGR:
+      gray_extbgr_convert_internal(cinfo, input_buf, input_row, output_buf,
+                                   num_rows);
+      break;
+    case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
+      gray_extbgrx_convert_internal(cinfo, input_buf, input_row, output_buf,
+                                    num_rows);
+      break;
+    case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
+      gray_extxbgr_convert_internal(cinfo, input_buf, input_row, output_buf,
+                                    num_rows);
+      break;
+    case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
+      gray_extxrgb_convert_internal(cinfo, input_buf, input_row, output_buf,
+                                    num_rows);
+      break;
+    default:
+      gray_rgb_convert_internal(cinfo, input_buf, input_row, output_buf,
+                                num_rows);
+      break;
   }
 }
 
@@ -369,6 +479,10 @@
   case JCS_EXT_BGRX:
   case JCS_EXT_XBGR:
   case JCS_EXT_XRGB:
+  case JCS_EXT_RGBA:
+  case JCS_EXT_BGRA:
+  case JCS_EXT_ABGR:
+  case JCS_EXT_ARGB:
     cinfo->out_color_components = rgb_pixelsize[cinfo->out_color_space];
     if (cinfo->jpeg_color_space == JCS_YCbCr) {
       if (jsimd_can_ycc_rgb())
diff -r 3a99d7ff459c media/libjpeg/jdhuff.c
--- a/media/libjpeg/jdhuff.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jdhuff.c    Tue Jan 24 23:47:27 2012 +0900
@@ -2,6 +2,7 @@
  * jdhuff.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
+ * Copyright (C) 2009-2011, D. R. Commander.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -18,6 +19,7 @@
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "jdhuff.h"        /* Declarations shared with jdphuff.c */
+#include "jpegcomp.h"
 
 
 /*
@@ -122,7 +124,7 @@
     if (compptr->component_needed) {
       entropy->dc_needed[blkn] = TRUE;
       /* we don't need the ACs if producing a 1/8th-size image */
-      entropy->ac_needed[blkn] = (compptr->DCT_scaled_size > 1);
+      entropy->ac_needed[blkn] = (compptr->_DCT_scaled_size > 1);
     } else {
       entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;
     }
@@ -225,6 +227,7 @@
       dtbl->maxcode[l] = -1;    /* -1 if no codes of this length */
     }
   }
+  dtbl->valoffset[17] = 0;
   dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */
 
   /* Compute lookahead tables to speed up decoding.
@@ -234,7 +237,8 @@
    * with that code.
    */
 
-  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));
+   for (i = 0; i < (1 << HUFF_LOOKAHEAD); i++)
+     dtbl->lookup[i] = (HUFF_LOOKAHEAD + 1) << HUFF_LOOKAHEAD;
 
   p = 0;
   for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
@@ -243,8 +247,7 @@
       /* Generate left-justified code followed by all possible bit sequences */
       lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
       for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
-    dtbl->look_nbits[lookbits] = l;
-    dtbl->look_sym[lookbits] = htbl->huffval[p];
+    dtbl->lookup[lookbits] = (l << HUFF_LOOKAHEAD) | htbl->huffval[p];
     lookbits++;
       }
     }
@@ -389,6 +392,50 @@
 }
 
 
+/* Macro version of the above, which performs much better but does not
+   handle markers.  We have to hand off any blocks with markers to the
+   slower routines. */
+
+#define GET_BYTE \
+{ \
+  register int c0, c1; \
+  c0 = GETJOCTET(*buffer++); \
+  c1 = GETJOCTET(*buffer); \
+  /* Pre-execute most common case */ \
+  get_buffer = (get_buffer << 8) | c0; \
+  bits_left += 8; \
+  if (c0 == 0xFF) { \
+    /* Pre-execute case of FF/00, which represents an FF data byte */ \
+    buffer++; \
+    if (c1 != 0) { \
+      /* Oops, it's actually a marker indicating end of compressed data. */ \
+      cinfo->unread_marker = c1; \
+      /* Back out pre-execution and fill the buffer with zero bits */ \
+      buffer -= 2; \
+      get_buffer &= ~0xFF; \
+    } \
+  } \
+}
+
+#if __WORDSIZE == 64 || defined(_WIN64)
+
+/* Pre-fetch 48 bytes, because the holding register is 64-bit */
+#define FILL_BIT_BUFFER_FAST \
+  if (bits_left < 16) { \
+    GET_BYTE GET_BYTE GET_BYTE GET_BYTE GET_BYTE GET_BYTE \
+  }
+
+#else
+
+/* Pre-fetch 16 bytes, because the holding register is 32-bit */
+#define FILL_BIT_BUFFER_FAST \
+  if (bits_left < 16) { \
+    GET_BYTE GET_BYTE \
+  }
+
+#endif
+
+
 /*
  * Out-of-line code for Huffman code decoding.
  * See jdhuff.h for info about usage.
@@ -438,9 +485,10 @@
  * On some machines, a shift and add will be faster than a table lookup.
  */
 
+#define AVOID_TABLES
 #ifdef AVOID_TABLES
 
-#define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))
+#define HUFF_EXTEND(x,s)  ((x) + ((((x) - (1<<((s)-1))) >> 31) & (((-1)<<(s)) + 1)))
 
 #else
 
@@ -498,6 +546,187 @@
 }
 
 
+LOCAL(boolean)
+decode_mcu_slow (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
+{
+  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
+  BITREAD_STATE_VARS;
+  int blkn;
+  savable_state state;
+  /* Outer loop handles each block in the MCU */
+
+  /* Load up working state */
+  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+  ASSIGN_STATE(state, entropy->saved);
+
+  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
+    JBLOCKROW block = MCU_data[blkn];
+    d_derived_tbl * dctbl = entropy->dc_cur_tbls[blkn];
+    d_derived_tbl * actbl = entropy->ac_cur_tbls[blkn];
+    register int s, k, r;
+
+    /* Decode a single block's worth of coefficients */
+
+    /* Section F.2.2.1: decode the DC coefficient difference */
+    HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
+    if (s) {
+      CHECK_BIT_BUFFER(br_state, s, return FALSE);
+      r = GET_BITS(s);
+      s = HUFF_EXTEND(r, s);
+    }
+
+    if (entropy->dc_needed[blkn]) {
+      /* Convert DC difference to actual value, update last_dc_val */
+      int ci = cinfo->MCU_membership[blkn];
+      s += state.last_dc_val[ci];
+      state.last_dc_val[ci] = s;
+      /* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */
+      (*block)[0] = (JCOEF) s;
+    }
+
+    if (entropy->ac_needed[blkn]) {
+
+      /* Section F.2.2.2: decode the AC coefficients */
+      /* Since zeroes are skipped, output area must be cleared beforehand */
+      for (k = 1; k < DCTSIZE2; k++) {
+        HUFF_DECODE(s, br_state, actbl, return FALSE, label2);
+
+        r = s >> 4;
+        s &= 15;
+      
+        if (s) {
+          k += r;
+          CHECK_BIT_BUFFER(br_state, s, return FALSE);
+          r = GET_BITS(s);
+          s = HUFF_EXTEND(r, s);
+          /* Output coefficient in natural (dezigzagged) order.
+           * Note: the extra entries in jpeg_natural_order[] will save us
+           * if k >= DCTSIZE2, which could happen if the data is corrupted.
+           */
+          (*block)[jpeg_natural_order[k]] = (JCOEF) s;
+        } else {
+          if (r != 15)
+            break;
+          k += 15;
+        }
+      }
+
+    } else {
+
+      /* Section F.2.2.2: decode the AC coefficients */
+      /* In this path we just discard the values */
+      for (k = 1; k < DCTSIZE2; k++) {
+        HUFF_DECODE(s, br_state, actbl, return FALSE, label3);
+
+        r = s >> 4;
+        s &= 15;
+
+        if (s) {
+          k += r;
+          CHECK_BIT_BUFFER(br_state, s, return FALSE);
+          DROP_BITS(s);
+        } else {
+          if (r != 15)
+            break;
+          k += 15;
+        }
+      }
+    }
+  }
+
+  /* Completed MCU, so update state */
+  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+  ASSIGN_STATE(entropy->saved, state);
+  return TRUE;
+}
+
+
+LOCAL(boolean)
+decode_mcu_fast (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
+{
+  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
+  BITREAD_STATE_VARS;
+  JOCTET *buffer;
+  int blkn;
+  savable_state state;
+  /* Outer loop handles each block in the MCU */
+
+  /* Load up working state */
+  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+  buffer = (JOCTET *) br_state.next_input_byte;
+  ASSIGN_STATE(state, entropy->saved);
+
+  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
+    JBLOCKROW block = MCU_data[blkn];
+    d_derived_tbl * dctbl = entropy->dc_cur_tbls[blkn];
+    d_derived_tbl * actbl = entropy->ac_cur_tbls[blkn];
+    register int s, k, r, l;
+
+    HUFF_DECODE_FAST(s, l, dctbl);
+    if (s) {
+      FILL_BIT_BUFFER_FAST
+      r = GET_BITS(s);
+      s = HUFF_EXTEND(r, s);
+    }
+
+    if (entropy->dc_needed[blkn]) {
+      int ci = cinfo->MCU_membership[blkn];
+      s += state.last_dc_val[ci];
+      state.last_dc_val[ci] = s;
+      (*block)[0] = (JCOEF) s;
+    }
+
+    if (entropy->ac_needed[blkn]) {
+
+      for (k = 1; k < DCTSIZE2; k++) {
+        HUFF_DECODE_FAST(s, l, actbl);
+        r = s >> 4;
+        s &= 15;
+      
+        if (s) {
+          k += r;
+          FILL_BIT_BUFFER_FAST
+          r = GET_BITS(s);
+          s = HUFF_EXTEND(r, s);
+          (*block)[jpeg_natural_order[k]] = (JCOEF) s;
+        } else {
+          if (r != 15) break;
+          k += 15;
+        }
+      }
+
+    } else {
+
+      for (k = 1; k < DCTSIZE2; k++) {
+        HUFF_DECODE_FAST(s, l, actbl);
+        r = s >> 4;
+        s &= 15;
+
+        if (s) {
+          k += r;
+          FILL_BIT_BUFFER_FAST
+          DROP_BITS(s);
+        } else {
+          if (r != 15) break;
+          k += 15;
+        }
+      }
+    }
+  }
+
+  if (cinfo->unread_marker != 0) {
+    cinfo->unread_marker = 0;
+    return FALSE;
+  }
+
+  br_state.bytes_in_buffer -= (buffer - br_state.next_input_byte);
+  br_state.next_input_byte = buffer;
+  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+  ASSIGN_STATE(entropy->saved, state);
+  return TRUE;
+}
+
+
 /*
  * Decode and return one MCU's worth of Huffman-compressed coefficients.
  * The coefficients are reordered from zigzag order into natural array order,
@@ -513,111 +742,39 @@
  * this module, since we'll just re-assign them on the next call.)
  */
 
+#define BUFSIZE (DCTSIZE2 * 2)
+
 METHODDEF(boolean)
 decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
-  int blkn;
-  BITREAD_STATE_VARS;
-  savable_state state;
+  int usefast = 1;
 
   /* Process restart marker if needed; may have to suspend */
   if (cinfo->restart_interval) {
     if (entropy->restarts_to_go == 0)
       if (! process_restart(cinfo))
     return FALSE;
+    usefast = 0;
   }
 
+  if (cinfo->src->bytes_in_buffer < (size_t)BUFSIZE * cinfo->blocks_in_MCU
+    || cinfo->unread_marker != 0)
+    usefast = 0;
+
   /* If we've run out of data, just leave the MCU set to zeroes.
    * This way, we return uniform gray for the remainder of the segment.
    */
   if (! entropy->pub.insufficient_data) {
 
-    /* Load up working state */
-    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
-    ASSIGN_STATE(state, entropy->saved);
-
-    /* Outer loop handles each block in the MCU */
-
-    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
-      JBLOCKROW block = MCU_data[blkn];
-      d_derived_tbl * dctbl = entropy->dc_cur_tbls[blkn];
-      d_derived_tbl * actbl = entropy->ac_cur_tbls[blkn];
-      register int s, k, r;
-
-      /* Decode a single block's worth of coefficients */
-
-      /* Section F.2.2.1: decode the DC coefficient difference */
-      HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
-      if (s) {
-    CHECK_BIT_BUFFER(br_state, s, return FALSE);
-    r = GET_BITS(s);
-    s = HUFF_EXTEND(r, s);
-      }
-
-      if (entropy->dc_needed[blkn]) {
-    /* Convert DC difference to actual value, update last_dc_val */
-    int ci = cinfo->MCU_membership[blkn];
-    s += state.last_dc_val[ci];
-    state.last_dc_val[ci] = s;
-    /* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */
-    (*block)[0] = (JCOEF) s;
-      }
-
-      if (entropy->ac_needed[blkn]) {
-
-    /* Section F.2.2.2: decode the AC coefficients */
-    /* Since zeroes are skipped, output area must be cleared beforehand */
-    for (k = 1; k < DCTSIZE2; k++) {
-      HUFF_DECODE(s, br_state, actbl, return FALSE, label2);
-      
-      r = s >> 4;
-      s &= 15;
-      
-      if (s) {
-        k += r;
-        CHECK_BIT_BUFFER(br_state, s, return FALSE);
-        r = GET_BITS(s);
-        s = HUFF_EXTEND(r, s);
-        /* Output coefficient in natural (dezigzagged) order.
-         * Note: the extra entries in jpeg_natural_order[] will save us
-         * if k >= DCTSIZE2, which could happen if the data is corrupted.
-         */
-        (*block)[jpeg_natural_order[k]] = (JCOEF) s;
-      } else {
-        if (r != 15)
-          break;
-        k += 15;
-      }
-    }
-
-      } else {
-
-    /* Section F.2.2.2: decode the AC coefficients */
-    /* In this path we just discard the values */
-    for (k = 1; k < DCTSIZE2; k++) {
-      HUFF_DECODE(s, br_state, actbl, return FALSE, label3);
-      
-      r = s >> 4;
-      s &= 15;
-      
-      if (s) {
-        k += r;
-        CHECK_BIT_BUFFER(br_state, s, return FALSE);
-        DROP_BITS(s);
-      } else {
-        if (r != 15)
-          break;
-        k += 15;
-      }
-    }
-
-      }
+    if (usefast) {
+      if (!decode_mcu_fast(cinfo, MCU_data)) goto use_slow;
+    }
+    else {
+      use_slow:
+      if (!decode_mcu_slow(cinfo, MCU_data)) return FALSE;
     }
 
-    /* Completed MCU, so update state */
-    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
-    ASSIGN_STATE(entropy->saved, state);
   }
 
   /* Account for restart interval (no-op if not using restarts) */
diff -r 3a99d7ff459c media/libjpeg/jdhuff.h
--- a/media/libjpeg/jdhuff.h    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jdhuff.h    Tue Jan 24 23:47:27 2012 +0900
@@ -2,6 +2,7 @@
  * jdhuff.h
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
+ * Copyright (C) 2010-2011, D. R. Commander.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -27,7 +28,7 @@
   /* Basic tables: (element [0] of each array is unused) */
   INT32 maxcode[18];        /* largest code of length k (-1 if none) */
   /* (maxcode[17] is a sentinel to ensure jpeg_huff_decode terminates) */
-  INT32 valoffset[17];        /* huffval[] offset for codes of length k */
+  INT32 valoffset[18];        /* huffval[] offset for codes of length k */
   /* valoffset[k] = huffval[] index of 1st symbol of code length k, less
    * the smallest code of length k; so given a code of length k, the
    * corresponding symbol is huffval[code + valoffset[k]]
@@ -36,13 +37,17 @@
   /* Link to public Huffman table (needed only in jpeg_huff_decode) */
   JHUFF_TBL *pub;
 
-  /* Lookahead tables: indexed by the next HUFF_LOOKAHEAD bits of
+  /* Lookahead table: indexed by the next HUFF_LOOKAHEAD bits of
    * the input data stream.  If the next Huffman code is no more
    * than HUFF_LOOKAHEAD bits long, we can obtain its length and
-   * the corresponding symbol directly from these tables.
+   * the corresponding symbol directly from this tables.
+   *
+   * The lower 8 bits of each table entry contain the number of
+   * bits in the corresponding Huffman code, or HUFF_LOOKAHEAD + 1
+   * if too long.  The next 8 bits of each entry contain the
+   * symbol.
    */
-  int look_nbits[1<<HUFF_LOOKAHEAD]; /* # bits, or 0 if too long */
-  UINT8 look_sym[1<<HUFF_LOOKAHEAD]; /* symbol, or unused */
+  int lookup[1<<HUFF_LOOKAHEAD];
 } d_derived_tbl;
 
 /* Expand a Huffman table definition into the derived format */
@@ -69,8 +74,17 @@
  * necessary.
  */
 
+#if __WORDSIZE == 64 || defined(_WIN64)
+
+typedef size_t bit_buf_type;    /* type of bit-extraction buffer */
+#define BIT_BUF_SIZE  64        /* size of buffer in bits */
+
+#else
+
 typedef INT32 bit_buf_type;    /* type of bit-extraction buffer */
-#define BIT_BUF_SIZE  32    /* size of buffer in bits */
+#define BIT_BUF_SIZE  32        /* size of buffer in bits */
+
+#endif
 
 /* If long is > 32 bits on your machine, and shifting/masking longs is
  * reasonably fast, making bit_buf_type be long and setting BIT_BUF_SIZE
@@ -183,11 +197,10 @@
     } \
   } \
   look = PEEK_BITS(HUFF_LOOKAHEAD); \
-  if ((nb = htbl->look_nbits[look]) != 0) { \
+  if ((nb = (htbl->lookup[look] >> HUFF_LOOKAHEAD)) <= HUFF_LOOKAHEAD) { \
     DROP_BITS(nb); \
-    result = htbl->look_sym[look]; \
+    result = htbl->lookup[look] & ((1 << HUFF_LOOKAHEAD) - 1); \
   } else { \
-    nb = HUFF_LOOKAHEAD+1; \
 slowlabel: \
     if ((result=jpeg_huff_decode(&state,get_buffer,bits_left,htbl,nb)) < 0) \
     { failaction; } \
@@ -195,6 +208,26 @@
   } \
 }
 
+#define HUFF_DECODE_FAST(s,nb,htbl) \
+  FILL_BIT_BUFFER_FAST; \
+  s = PEEK_BITS(HUFF_LOOKAHEAD); \
+  s = htbl->lookup[s]; \
+  nb = s >> HUFF_LOOKAHEAD; \
+  /* Pre-execute the common case of nb <= HUFF_LOOKAHEAD */ \
+  DROP_BITS(nb); \
+  s = s & ((1 << HUFF_LOOKAHEAD) - 1); \
+  if (nb > HUFF_LOOKAHEAD) { \
+    /* Equivalent of jpeg_huff_decode() */ \
+    /* Don't use GET_BITS() here because we don't want to modify bits_left */ \
+    s = (get_buffer >> bits_left) & ((1 << (nb)) - 1); \
+    while (s > htbl->maxcode[nb]) { \
+      s <<= 1; \
+      s |= GET_BITS(1); \
+      nb++; \
+    } \
+    s = htbl->pub->huffval[ (int) (s + htbl->valoffset[nb]) & 0xFF ]; \
+  }
+
 /* Out-of-line case for Huffman code fetching */
 EXTERN(int) jpeg_huff_decode
     JPP((bitread_working_state * state, register bit_buf_type get_buffer,
diff -r 3a99d7ff459c media/libjpeg/jdmainct.c
--- a/media/libjpeg/jdmainct.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jdmainct.c    Tue Jan 24 23:47:27 2012 +0900
@@ -161,7 +161,7 @@
  * This is done only once, not once per pass.
  */
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr main_ptr = (my_main_ptr) cinfo->main;
   int ci, rgroup;
   int M = cinfo->_min_DCT_scaled_size;
   jpeg_component_info *compptr;
@@ -170,10 +170,10 @@
   /* Get top-level space for component array pointers.
    * We alloc both arrays with one call to save a few cycles.
    */
-  main->xbuffer[0] = (JSAMPIMAGE)
+  main_ptr->xbuffer[0] = (JSAMPIMAGE)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
                 cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
-  main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;
+  main_ptr->xbuffer[1] = main_ptr->xbuffer[0] + cinfo->num_components;
 
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
@@ -186,9 +186,9 @@
       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
                   2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
     xbuf += rgroup;        /* want one row group at negative offsets */
-    main->xbuffer[0][ci] = xbuf;
+    main_ptr->xbuffer[0][ci] = xbuf;
     xbuf += rgroup * (M + 4);
-    main->xbuffer[1][ci] = xbuf;
+    main_ptr->xbuffer[1][ci] = xbuf;
   }
 }
 
@@ -196,13 +196,13 @@
 LOCAL(void)
 make_funny_pointers (j_decompress_ptr cinfo)
 /* Create the funny pointer lists discussed in the comments above.
- * The actual workspace is already allocated (in main->buffer),
+ * The actual workspace is already allocated (in main_ptr->buffer),
  * and the space for the pointer lists is allocated too.
  * This routine just fills in the curiously ordered lists.
  * This will be repeated at the beginning of each pass.
  */
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr main_ptr = (my_main_ptr) cinfo->main;
   int ci, i, rgroup;
   int M = cinfo->_min_DCT_scaled_size;
   jpeg_component_info *compptr;
@@ -212,10 +212,10 @@
        ci++, compptr++) {
     rgroup = (compptr->v_samp_factor * compptr->_DCT_scaled_size) /
       cinfo->_min_DCT_scaled_size; /* height of a row group of component */
-    xbuf0 = main->xbuffer[0][ci];
-    xbuf1 = main->xbuffer[1][ci];
+    xbuf0 = main_ptr->xbuffer[0][ci];
+    xbuf1 = main_ptr->xbuffer[1][ci];
     /* First copy the workspace pointers as-is */
-    buf = main->buffer[ci];
+    buf = main_ptr->buffer[ci];
     for (i = 0; i < rgroup * (M + 2); i++) {
       xbuf0[i] = xbuf1[i] = buf[i];
     }
@@ -242,7 +242,7 @@
  * This changes the pointer list state from top-of-image to the normal state.
  */
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr main_ptr = (my_main_ptr) cinfo->main;
   int ci, i, rgroup;
   int M = cinfo->_min_DCT_scaled_size;
   jpeg_component_info *compptr;
@@ -252,8 +252,8 @@
        ci++, compptr++) {
     rgroup = (compptr->v_samp_factor * compptr->_DCT_scaled_size) /
       cinfo->_min_DCT_scaled_size; /* height of a row group of component */
-    xbuf0 = main->xbuffer[0][ci];
-    xbuf1 = main->xbuffer[1][ci];
+    xbuf0 = main_ptr->xbuffer[0][ci];
+    xbuf1 = main_ptr->xbuffer[1][ci];
     for (i = 0; i < rgroup; i++) {
       xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
       xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
@@ -271,7 +271,7 @@
  * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
  */
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr main_ptr = (my_main_ptr) cinfo->main;
   int ci, i, rgroup, iMCUheight, rows_left;
   jpeg_component_info *compptr;
   JSAMPARRAY xbuf;
@@ -288,12 +288,12 @@
      * so we need only do it once.
      */
     if (ci == 0) {
-      main->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
+      main_ptr->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
     }
     /* Duplicate the last real sample row rgroup*2 times; this pads out the
      * last partial rowgroup and ensures at least one full rowgroup of context.
      */
-    xbuf = main->xbuffer[main->whichptr][ci];
+    xbuf = main_ptr->xbuffer[main_ptr->whichptr][ci];
     for (i = 0; i < rgroup * 2; i++) {
       xbuf[rows_left + i] = xbuf[rows_left-1];
     }
@@ -308,27 +308,27 @@
 METHODDEF(void)
 start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr main_ptr = (my_main_ptr) cinfo->main;
 
   switch (pass_mode) {
   case JBUF_PASS_THRU:
     if (cinfo->upsample->need_context_rows) {
-      main->pub.process_data = process_data_context_main;
+      main_ptr->pub.process_data = process_data_context_main;
       make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
-      main->whichptr = 0;    /* Read first iMCU row into xbuffer[0] */
-      main->context_state = CTX_PREPARE_FOR_IMCU;
-      main->iMCU_row_ctr = 0;
+      main_ptr->whichptr = 0;    /* Read first iMCU row into xbuffer[0] */
+      main_ptr->context_state = CTX_PREPARE_FOR_IMCU;
+      main_ptr->iMCU_row_ctr = 0;
     } else {
       /* Simple case with no context needed */
-      main->pub.process_data = process_data_simple_main;
+      main_ptr->pub.process_data = process_data_simple_main;
     }
-    main->buffer_full = FALSE;    /* Mark buffer empty */
-    main->rowgroup_ctr = 0;
+    main_ptr->buffer_full = FALSE;    /* Mark buffer empty */
+    main_ptr->rowgroup_ctr = 0;
     break;
 #ifdef QUANT_2PASS_SUPPORTED
   case JBUF_CRANK_DEST:
     /* For last pass of 2-pass quantization, just crank the postprocessor */
-    main->pub.process_data = process_data_crank_post;
+    main_ptr->pub.process_data = process_data_crank_post;
     break;
 #endif
   default:
@@ -348,14 +348,14 @@
               JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
               JDIMENSION out_rows_avail)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr main_ptr = (my_main_ptr) cinfo->main;
   JDIMENSION rowgroups_avail;
 
   /* Read input data if we haven't filled the main buffer yet */
-  if (! main->buffer_full) {
-    if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))
+  if (! main_ptr->buffer_full) {
+    if (! (*cinfo->coef->decompress_data) (cinfo, main_ptr->buffer))
       return;            /* suspension forced, can do nothing more */
-    main->buffer_full = TRUE;    /* OK, we have an iMCU row to work with */
+    main_ptr->buffer_full = TRUE;    /* OK, we have an iMCU row to work with */
   }
 
   /* There are always min_DCT_scaled_size row groups in an iMCU row. */
@@ -366,14 +366,14 @@
    */
 
   /* Feed the postprocessor */
-  (*cinfo->post->post_process_data) (cinfo, main->buffer,
-                     &main->rowgroup_ctr, rowgroups_avail,
+  (*cinfo->post->post_process_data) (cinfo, main_ptr->buffer,
+                     &main_ptr->rowgroup_ctr, rowgroups_avail,
                      output_buf, out_row_ctr, out_rows_avail);
 
   /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
-  if (main->rowgroup_ctr >= rowgroups_avail) {
-    main->buffer_full = FALSE;
-    main->rowgroup_ctr = 0;
+  if (main_ptr->rowgroup_ctr >= rowgroups_avail) {
+    main_ptr->buffer_full = FALSE;
+    main_ptr->rowgroup_ctr = 0;
   }
 }
 
@@ -388,15 +388,15 @@
                JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
                JDIMENSION out_rows_avail)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  my_main_ptr main_ptr = (my_main_ptr) cinfo->main;
 
   /* Read input data if we haven't filled the main buffer yet */
-  if (! main->buffer_full) {
+  if (! main_ptr->buffer_full) {
     if (! (*cinfo->coef->decompress_data) (cinfo,
-                       main->xbuffer[main->whichptr]))
+                       main_ptr->xbuffer[main_ptr->whichptr]))
       return;            /* suspension forced, can do nothing more */
-    main->buffer_full = TRUE;    /* OK, we have an iMCU row to work with */
-    main->iMCU_row_ctr++;    /* count rows received */
+    main_ptr->buffer_full = TRUE;    /* OK, we have an iMCU row to work with */
+    main_ptr->iMCU_row_ctr++;    /* count rows received */
   }
 
   /* Postprocessor typically will not swallow all the input data it is handed
@@ -404,47 +404,47 @@
    * to exit and restart.  This switch lets us keep track of how far we got.
    * Note that each case falls through to the next on successful completion.
    */
-  switch (main->context_state) {
+  switch (main_ptr->context_state) {
   case CTX_POSTPONED_ROW:
     /* Call postprocessor using previously set pointers for postponed row */
-    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
-            &main->rowgroup_ctr, main->rowgroups_avail,
+    (*cinfo->post->post_process_data) (cinfo, main_ptr->xbuffer[main_ptr->whichptr],
+            &main_ptr->rowgroup_ctr, main_ptr->rowgroups_avail,
             output_buf, out_row_ctr, out_rows_avail);
-    if (main->rowgroup_ctr < main->rowgroups_avail)
+    if (main_ptr->rowgroup_ctr < main_ptr->rowgroups_avail)
       return;            /* Need to suspend */
-    main->context_state = CTX_PREPARE_FOR_IMCU;
+    main_ptr->context_state = CTX_PREPARE_FOR_IMCU;
     if (*out_row_ctr >= out_rows_avail)
       return;            /* Postprocessor exactly filled output buf */
     /*FALLTHROUGH*/
   case CTX_PREPARE_FOR_IMCU:
     /* Prepare to process first M-1 row groups of this iMCU row */
-    main->rowgroup_ctr = 0;
-    main->rowgroups_avail = (JDIMENSION) (cinfo->_min_DCT_scaled_size - 1);
+    main_ptr->rowgroup_ctr = 0;
+    main_ptr->rowgroups_avail = (JDIMENSION) (cinfo->_min_DCT_scaled_size - 1);
     /* Check for bottom of image: if so, tweak pointers to "duplicate"
      * the last sample row, and adjust rowgroups_avail to ignore padding rows.
      */
-    if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)
+    if (main_ptr->iMCU_row_ctr == cinfo->total_iMCU_rows)
       set_bottom_pointers(cinfo);
-    main->context_state = CTX_PROCESS_IMCU;
+    main_ptr->context_state = CTX_PROCESS_IMCU;
     /*FALLTHROUGH*/
   case CTX_PROCESS_IMCU:
     /* Call postprocessor using previously set pointers */
-    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
-            &main->rowgroup_ctr, main->rowgroups_avail,
+    (*cinfo->post->post_process_data) (cinfo, main_ptr->xbuffer[main_ptr->whichptr],
+            &main_ptr->rowgroup_ctr, main_ptr->rowgroups_avail,
             output_buf, out_row_ctr, out_rows_avail);
-    if (main->rowgroup_ctr < main->rowgroups_avail)
+    if (main_ptr->rowgroup_ctr < main_ptr->rowgroups_avail)
       return;            /* Need to suspend */
     /* After the first iMCU, change wraparound pointers to normal state */
-    if (main->iMCU_row_ctr == 1)
+    if (main_ptr->iMCU_row_ctr == 1)
       set_wraparound_pointers(cinfo);
     /* Prepare to load new iMCU row using other xbuffer list */
-    main->whichptr ^= 1;    /* 0=>1 or 1=>0 */
-    main->buffer_full = FALSE;
+    main_ptr->whichptr ^= 1;    /* 0=>1 or 1=>0 */
+    main_ptr->buffer_full = FALSE;
     /* Still need to process last row group of this iMCU row, */
     /* which is saved at index M+1 of the other xbuffer */
-    main->rowgroup_ctr = (JDIMENSION) (cinfo->_min_DCT_scaled_size + 1);
-    main->rowgroups_avail = (JDIMENSION) (cinfo->_min_DCT_scaled_size + 2);
-    main->context_state = CTX_POSTPONED_ROW;
+    main_ptr->rowgroup_ctr = (JDIMENSION) (cinfo->_min_DCT_scaled_size + 1);
+    main_ptr->rowgroups_avail = (JDIMENSION) (cinfo->_min_DCT_scaled_size + 2);
+    main_ptr->context_state = CTX_POSTPONED_ROW;
   }
 }
 
@@ -477,15 +477,15 @@
 GLOBAL(void)
 jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
 {
-  my_main_ptr main;
+  my_main_ptr main_ptr;
   int ci, rgroup, ngroups;
   jpeg_component_info *compptr;
 
-  main = (my_main_ptr)
+  main_ptr = (my_main_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
                 SIZEOF(my_main_controller));
-  cinfo->main = (struct jpeg_d_main_controller *) main;
-  main->pub.start_pass = start_pass_main;
+  cinfo->main = (struct jpeg_d_main_controller *) main_ptr;
+  main_ptr->pub.start_pass = start_pass_main;
 
   if (need_full_buffer)        /* shouldn't happen */
     ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
@@ -506,7 +506,7 @@
        ci++, compptr++) {
     rgroup = (compptr->v_samp_factor * compptr->_DCT_scaled_size) /
       cinfo->_min_DCT_scaled_size; /* height of a row group of component */
-    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
+    main_ptr->buffer[ci] = (*cinfo->mem->alloc_sarray)
             ((j_common_ptr) cinfo, JPOOL_IMAGE,
              compptr->width_in_blocks * compptr->_DCT_scaled_size,
              (JDIMENSION) (rgroup * ngroups));
diff -r 3a99d7ff459c media/libjpeg/jdmaster.c
--- a/media/libjpeg/jdmaster.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jdmaster.c    Tue Jan 24 23:47:27 2012 +0900
@@ -2,7 +2,7 @@
  * jdmaster.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
- * Copyright (C) 2009-2010, D. R. Commander.
+ * Copyright (C) 2009-2011, D. R. Commander.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -57,7 +57,11 @@
       cinfo->out_color_space != JCS_EXT_BGR &&
       cinfo->out_color_space != JCS_EXT_BGRX &&
       cinfo->out_color_space != JCS_EXT_XBGR &&
-      cinfo->out_color_space != JCS_EXT_XRGB) ||
+      cinfo->out_color_space != JCS_EXT_XRGB &&
+      cinfo->out_color_space != JCS_EXT_RGBA &&
+      cinfo->out_color_space != JCS_EXT_BGRA &&
+      cinfo->out_color_space != JCS_EXT_ABGR &&
+      cinfo->out_color_space != JCS_EXT_ARGB) ||
       cinfo->out_color_components != rgb_pixelsize[cinfo->out_color_space])
     return FALSE;
   /* and it only handles 2h1v or 2h2v sampling ratios */
@@ -209,6 +213,10 @@
   case JCS_EXT_BGRX:
   case JCS_EXT_XBGR:
   case JCS_EXT_XRGB:
+  case JCS_EXT_RGBA:
+  case JCS_EXT_BGRA:
+  case JCS_EXT_ABGR:
+  case JCS_EXT_ARGB:
     cinfo->out_color_components = rgb_pixelsize[cinfo->out_color_space];
     break;
   case JCS_YCbCr:
diff -r 3a99d7ff459c media/libjpeg/jdmerge.c
--- a/media/libjpeg/jdmerge.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jdmerge.c    Tue Jan 24 23:47:27 2012 +0900
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright (C) 2009, D. R. Commander.
+ * Copyright (C) 2009, 2011, D. R. Commander.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -77,6 +77,99 @@
 #define FIX(x)        ((INT32) ((x) * (1L<<SCALEBITS) + 0.5))
 
 
+/* Include inline routines for colorspace extensions */
+
+#include "jdmrgext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+
+#define RGB_RED EXT_RGB_RED
+#define RGB_GREEN EXT_RGB_GREEN
+#define RGB_BLUE EXT_RGB_BLUE
+#define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+#define h2v1_merged_upsample_internal extrgb_h2v1_merged_upsample_internal
+#define h2v2_merged_upsample_internal extrgb_h2v2_merged_upsample_internal
+#include "jdmrgext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef h2v1_merged_upsample_internal
+#undef h2v2_merged_upsample_internal
+
+#define RGB_RED EXT_RGBX_RED
+#define RGB_GREEN EXT_RGBX_GREEN
+#define RGB_BLUE EXT_RGBX_BLUE
+#define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+#define h2v1_merged_upsample_internal extrgbx_h2v1_merged_upsample_internal
+#define h2v2_merged_upsample_internal extrgbx_h2v2_merged_upsample_internal
+#include "jdmrgext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef h2v1_merged_upsample_internal
+#undef h2v2_merged_upsample_internal
+
+#define RGB_RED EXT_BGR_RED
+#define RGB_GREEN EXT_BGR_GREEN
+#define RGB_BLUE EXT_BGR_BLUE
+#define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+#define h2v1_merged_upsample_internal extbgr_h2v1_merged_upsample_internal
+#define h2v2_merged_upsample_internal extbgr_h2v2_merged_upsample_internal
+#include "jdmrgext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef h2v1_merged_upsample_internal
+#undef h2v2_merged_upsample_internal
+
+#define RGB_RED EXT_BGRX_RED
+#define RGB_GREEN EXT_BGRX_GREEN
+#define RGB_BLUE EXT_BGRX_BLUE
+#define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+#define h2v1_merged_upsample_internal extbgrx_h2v1_merged_upsample_internal
+#define h2v2_merged_upsample_internal extbgrx_h2v2_merged_upsample_internal
+#include "jdmrgext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef h2v1_merged_upsample_internal
+#undef h2v2_merged_upsample_internal
+
+#define RGB_RED EXT_XBGR_RED
+#define RGB_GREEN EXT_XBGR_GREEN
+#define RGB_BLUE EXT_XBGR_BLUE
+#define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+#define h2v1_merged_upsample_internal extxbgr_h2v1_merged_upsample_internal
+#define h2v2_merged_upsample_internal extxbgr_h2v2_merged_upsample_internal
+#include "jdmrgext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef h2v1_merged_upsample_internal
+#undef h2v2_merged_upsample_internal
+
+#define RGB_RED EXT_XRGB_RED
+#define RGB_GREEN EXT_XRGB_GREEN
+#define RGB_BLUE EXT_XRGB_BLUE
+#define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+#define h2v1_merged_upsample_internal extxrgb_h2v1_merged_upsample_internal
+#define h2v2_merged_upsample_internal extxrgb_h2v2_merged_upsample_internal
+#include "jdmrgext.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef h2v1_merged_upsample_internal
+#undef h2v2_merged_upsample_internal
+
+
 /*
  * Initialize tables for YCC->RGB colorspace conversion.
  * This is taken directly from jdcolor.c; see that file for more info.
@@ -230,55 +323,39 @@
               JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
               JSAMPARRAY output_buf)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
-  register int y, cred, cgreen, cblue;
-  int cb, cr;
-  register JSAMPROW outptr;
-  JSAMPROW inptr0, inptr1, inptr2;
-  JDIMENSION col;
-  /* copy these pointers into registers if possible */
-  register JSAMPLE * range_limit = cinfo->sample_range_limit;
-  int * Crrtab = upsample->Cr_r_tab;
-  int * Cbbtab = upsample->Cb_b_tab;
-  INT32 * Crgtab = upsample->Cr_g_tab;
-  INT32 * Cbgtab = upsample->Cb_g_tab;
-  SHIFT_TEMPS
-
-  inptr0 = input_buf[0][in_row_group_ctr];
-  inptr1 = input_buf[1][in_row_group_ctr];
-  inptr2 = input_buf[2][in_row_group_ctr];
-  outptr = output_buf[0];
-  /* Loop for each pair of output pixels */
-  for (col = cinfo->output_width >> 1; col > 0; col--) {
-    /* Do the chroma part of the calculation */
-    cb = GETJSAMPLE(*inptr1++);
-    cr = GETJSAMPLE(*inptr2++);
-    cred = Crrtab[cr];
-    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
-    cblue = Cbbtab[cb];
-    /* Fetch 2 Y values and emit 2 pixels */
-    y  = GETJSAMPLE(*inptr0++);
-    outptr[rgb_red[cinfo->out_color_space]] =   range_limit[y + cred];
-    outptr[rgb_green[cinfo->out_color_space]] = range_limit[y + cgreen];
-    outptr[rgb_blue[cinfo->out_color_space]] =  range_limit[y + cblue];
-    outptr += rgb_pixelsize[cinfo->out_color_space];
-    y  = GETJSAMPLE(*inptr0++);
-    outptr[rgb_red[cinfo->out_color_space]] =   range_limit[y + cred];
-    outptr[rgb_green[cinfo->out_color_space]] = range_limit[y + cgreen];
-    outptr[rgb_blue[cinfo->out_color_space]] =  range_limit[y + cblue];
-    outptr += rgb_pixelsize[cinfo->out_color_space];
-  }
-  /* If image width is odd, do the last output column separately */
-  if (cinfo->output_width & 1) {
-    cb = GETJSAMPLE(*inptr1);
-    cr = GETJSAMPLE(*inptr2);
-    cred = Crrtab[cr];
-    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
-    cblue = Cbbtab[cb];
-    y  = GETJSAMPLE(*inptr0);
-    outptr[rgb_red[cinfo->out_color_space]] =   range_limit[y + cred];
-    outptr[rgb_green[cinfo->out_color_space]] = range_limit[y + cgreen];
-    outptr[rgb_blue[cinfo->out_color_space]] =  range_limit[y + cblue];
+  switch (cinfo->out_color_space) {
+    case JCS_EXT_RGB:
+      extrgb_h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                           output_buf);
+      break;
+    case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
+      extrgbx_h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                            output_buf);
+      break;
+    case JCS_EXT_BGR:
+      extbgr_h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                           output_buf);
+      break;
+    case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
+      extbgrx_h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                            output_buf);
+      break;
+    case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
+      extxbgr_h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                            output_buf);
+      break;
+    case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
+      extxrgb_h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                            output_buf);
+      break;
+    default:
+      h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                    output_buf);
+      break;
   }
 }
 
@@ -292,71 +369,39 @@
               JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
               JSAMPARRAY output_buf)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
-  register int y, cred, cgreen, cblue;
-  int cb, cr;
-  register JSAMPROW outptr0, outptr1;
-  JSAMPROW inptr00, inptr01, inptr1, inptr2;
-  JDIMENSION col;
-  /* copy these pointers into registers if possible */
-  register JSAMPLE * range_limit = cinfo->sample_range_limit;
-  int * Crrtab = upsample->Cr_r_tab;
-  int * Cbbtab = upsample->Cb_b_tab;
-  INT32 * Crgtab = upsample->Cr_g_tab;
-  INT32 * Cbgtab = upsample->Cb_g_tab;
-  SHIFT_TEMPS
-
-  inptr00 = input_buf[0][in_row_group_ctr*2];
-  inptr01 = input_buf[0][in_row_group_ctr*2 + 1];
-  inptr1 = input_buf[1][in_row_group_ctr];
-  inptr2 = input_buf[2][in_row_group_ctr];
-  outptr0 = output_buf[0];
-  outptr1 = output_buf[1];
-  /* Loop for each group of output pixels */
-  for (col = cinfo->output_width >> 1; col > 0; col--) {
-    /* Do the chroma part of the calculation */
-    cb = GETJSAMPLE(*inptr1++);
-    cr = GETJSAMPLE(*inptr2++);
-    cred = Crrtab[cr];
-    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
-    cblue = Cbbtab[cb];
-    /* Fetch 4 Y values and emit 4 pixels */
-    y  = GETJSAMPLE(*inptr00++);
-    outptr0[rgb_red[cinfo->out_color_space]] =   range_limit[y + cred];
-    outptr0[rgb_green[cinfo->out_color_space]] = range_limit[y + cgreen];
-    outptr0[rgb_blue[cinfo->out_color_space]] =  range_limit[y + cblue];
-    outptr0 += RGB_PIXELSIZE;
-    y  = GETJSAMPLE(*inptr00++);
-    outptr0[rgb_red[cinfo->out_color_space]] =   range_limit[y + cred];
-    outptr0[rgb_green[cinfo->out_color_space]] = range_limit[y + cgreen];
-    outptr0[rgb_blue[cinfo->out_color_space]] =  range_limit[y + cblue];
-    outptr0 += RGB_PIXELSIZE;
-    y  = GETJSAMPLE(*inptr01++);
-    outptr1[rgb_red[cinfo->out_color_space]] =   range_limit[y + cred];
-    outptr1[rgb_green[cinfo->out_color_space]] = range_limit[y + cgreen];
-    outptr1[rgb_blue[cinfo->out_color_space]] =  range_limit[y + cblue];
-    outptr1 += RGB_PIXELSIZE;
-    y  = GETJSAMPLE(*inptr01++);
-    outptr1[rgb_red[cinfo->out_color_space]] =   range_limit[y + cred];
-    outptr1[rgb_green[cinfo->out_color_space]] = range_limit[y + cgreen];
-    outptr1[rgb_blue[cinfo->out_color_space]] =  range_limit[y + cblue];
-    outptr1 += RGB_PIXELSIZE;
-  }
-  /* If image width is odd, do the last output column separately */
-  if (cinfo->output_width & 1) {
-    cb = GETJSAMPLE(*inptr1);
-    cr = GETJSAMPLE(*inptr2);
-    cred = Crrtab[cr];
-    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
-    cblue = Cbbtab[cb];
-    y  = GETJSAMPLE(*inptr00);
-    outptr0[rgb_red[cinfo->out_color_space]] =   range_limit[y + cred];
-    outptr0[rgb_green[cinfo->out_color_space]] = range_limit[y + cgreen];
-    outptr0[rgb_blue[cinfo->out_color_space]] =  range_limit[y + cblue];
-    y  = GETJSAMPLE(*inptr01);
-    outptr1[rgb_red[cinfo->out_color_space]] =   range_limit[y + cred];
-    outptr1[rgb_green[cinfo->out_color_space]] = range_limit[y + cgreen];
-    outptr1[rgb_blue[cinfo->out_color_space]] =  range_limit[y + cblue];
+  switch (cinfo->out_color_space) {
+    case JCS_EXT_RGB:
+      extrgb_h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                           output_buf);
+      break;
+    case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
+      extrgbx_h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                            output_buf);
+      break;
+    case JCS_EXT_BGR:
+      extbgr_h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                           output_buf);
+      break;
+    case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
+      extbgrx_h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                            output_buf);
+      break;
+    case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
+      extxbgr_h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                            output_buf);
+      break;
+    case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
+      extxrgb_h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                            output_buf);
+      break;
+    default:
+      h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,
+                                    output_buf);
+      break;
   }
 }
 
diff -r 3a99d7ff459c media/libjpeg/jdmrgext.c
--- /dev/null    Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libjpeg/jdmrgext.c    Tue Jan 24 23:47:27 2012 +0900
@@ -0,0 +1,156 @@
+/*
+ * jdmrgext.c
+ *
+ * Copyright (C) 1994-1996, Thomas G. Lane.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains code for merged upsampling/color conversion.
+ */
+
+
+/* This file is included by jdmerge.c */
+
+
+/*
+ * Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
+ */
+
+INLINE
+LOCAL(void)
+h2v1_merged_upsample_internal (j_decompress_ptr cinfo,
+                               JSAMPIMAGE input_buf,
+                               JDIMENSION in_row_group_ctr,
+                               JSAMPARRAY output_buf)
+{
+  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
+  register int y, cred, cgreen, cblue;
+  int cb, cr;
+  register JSAMPROW outptr;
+  JSAMPROW inptr0, inptr1, inptr2;
+  JDIMENSION col;
+  /* copy these pointers into registers if possible */
+  register JSAMPLE * range_limit = cinfo->sample_range_limit;
+  int * Crrtab = upsample->Cr_r_tab;
+  int * Cbbtab = upsample->Cb_b_tab;
+  INT32 * Crgtab = upsample->Cr_g_tab;
+  INT32 * Cbgtab = upsample->Cb_g_tab;
+  SHIFT_TEMPS
+
+  inptr0 = input_buf[0][in_row_group_ctr];
+  inptr1 = input_buf[1][in_row_group_ctr];
+  inptr2 = input_buf[2][in_row_group_ctr];
+  outptr = output_buf[0];
+  /* Loop for each pair of output pixels */
+  for (col = cinfo->output_width >> 1; col > 0; col--) {
+    /* Do the chroma part of the calculation */
+    cb = GETJSAMPLE(*inptr1++);
+    cr = GETJSAMPLE(*inptr2++);
+    cred = Crrtab[cr];
+    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
+    cblue = Cbbtab[cb];
+    /* Fetch 2 Y values and emit 2 pixels */
+    y  = GETJSAMPLE(*inptr0++);
+    outptr[RGB_RED] =   range_limit[y + cred];
+    outptr[RGB_GREEN] = range_limit[y + cgreen];
+    outptr[RGB_BLUE] =  range_limit[y + cblue];
+    outptr += RGB_PIXELSIZE;
+    y  = GETJSAMPLE(*inptr0++);
+    outptr[RGB_RED] =   range_limit[y + cred];
+    outptr[RGB_GREEN] = range_limit[y + cgreen];
+    outptr[RGB_BLUE] =  range_limit[y + cblue];
+    outptr += RGB_PIXELSIZE;
+  }
+  /* If image width is odd, do the last output column separately */
+  if (cinfo->output_width & 1) {
+    cb = GETJSAMPLE(*inptr1);
+    cr = GETJSAMPLE(*inptr2);
+    cred = Crrtab[cr];
+    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
+    cblue = Cbbtab[cb];
+    y  = GETJSAMPLE(*inptr0);
+    outptr[RGB_RED] =   range_limit[y + cred];
+    outptr[RGB_GREEN] = range_limit[y + cgreen];
+    outptr[RGB_BLUE] =  range_limit[y + cblue];
+  }
+}
+
+
+/*
+ * Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
+ */
+
+INLINE
+LOCAL(void)
+h2v2_merged_upsample_internal (j_decompress_ptr cinfo,
+                               JSAMPIMAGE input_buf,
+                               JDIMENSION in_row_group_ctr,
+                               JSAMPARRAY output_buf)
+{
+  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
+  register int y, cred, cgreen, cblue;
+  int cb, cr;
+  register JSAMPROW outptr0, outptr1;
+  JSAMPROW inptr00, inptr01, inptr1, inptr2;
+  JDIMENSION col;
+  /* copy these pointers into registers if possible */
+  register JSAMPLE * range_limit = cinfo->sample_range_limit;
+  int * Crrtab = upsample->Cr_r_tab;
+  int * Cbbtab = upsample->Cb_b_tab;
+  INT32 * Crgtab = upsample->Cr_g_tab;
+  INT32 * Cbgtab = upsample->Cb_g_tab;
+  SHIFT_TEMPS
+
+  inptr00 = input_buf[0][in_row_group_ctr*2];
+  inptr01 = input_buf[0][in_row_group_ctr*2 + 1];
+  inptr1 = input_buf[1][in_row_group_ctr];
+  inptr2 = input_buf[2][in_row_group_ctr];
+  outptr0 = output_buf[0];
+  outptr1 = output_buf[1];
+  /* Loop for each group of output pixels */
+  for (col = cinfo->output_width >> 1; col > 0; col--) {
+    /* Do the chroma part of the calculation */
+    cb = GETJSAMPLE(*inptr1++);
+    cr = GETJSAMPLE(*inptr2++);
+    cred = Crrtab[cr];
+    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
+    cblue = Cbbtab[cb];
+    /* Fetch 4 Y values and emit 4 pixels */
+    y  = GETJSAMPLE(*inptr00++);
+    outptr0[RGB_RED] =   range_limit[y + cred];
+    outptr0[RGB_GREEN] = range_limit[y + cgreen];
+    outptr0[RGB_BLUE] =  range_limit[y + cblue];
+    outptr0 += RGB_PIXELSIZE;
+    y  = GETJSAMPLE(*inptr00++);
+    outptr0[RGB_RED] =   range_limit[y + cred];
+    outptr0[RGB_GREEN] = range_limit[y + cgreen];
+    outptr0[RGB_BLUE] =  range_limit[y + cblue];
+    outptr0 += RGB_PIXELSIZE;
+    y  = GETJSAMPLE(*inptr01++);
+    outptr1[RGB_RED] =   range_limit[y + cred];
+    outptr1[RGB_GREEN] = range_limit[y + cgreen];
+    outptr1[RGB_BLUE] =  range_limit[y + cblue];
+    outptr1 += RGB_PIXELSIZE;
+    y  = GETJSAMPLE(*inptr01++);
+    outptr1[RGB_RED] =   range_limit[y + cred];
+    outptr1[RGB_GREEN] = range_limit[y + cgreen];
+    outptr1[RGB_BLUE] =  range_limit[y + cblue];
+    outptr1 += RGB_PIXELSIZE;
+  }
+  /* If image width is odd, do the last output column separately */
+  if (cinfo->output_width & 1) {
+    cb = GETJSAMPLE(*inptr1);
+    cr = GETJSAMPLE(*inptr2);
+    cred = Crrtab[cr];
+    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
+    cblue = Cbbtab[cb];
+    y  = GETJSAMPLE(*inptr00);
+    outptr0[RGB_RED] =   range_limit[y + cred];
+    outptr0[RGB_GREEN] = range_limit[y + cgreen];
+    outptr0[RGB_BLUE] =  range_limit[y + cblue];
+    y  = GETJSAMPLE(*inptr01);
+    outptr1[RGB_RED] =   range_limit[y + cred];
+    outptr1[RGB_GREEN] = range_limit[y + cgreen];
+    outptr1[RGB_BLUE] =  range_limit[y + cblue];
+  }
+}
diff -r 3a99d7ff459c media/libjpeg/jdsample.c
--- a/media/libjpeg/jdsample.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jdsample.c    Tue Jan 24 23:47:27 2012 +0900
@@ -289,6 +289,34 @@
 }
 
 
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+
+/*
+ * Fast processing for the common case of 1:1 horizontal and 2:1 vertical.
+ * It's still a box filter.
+ */
+
+METHODDEF(void)
+h1v2_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+           JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
+{
+  JSAMPARRAY output_data = *output_data_ptr;
+  int inrow, outrow;
+
+  inrow = outrow = 0;
+  while (outrow < cinfo->max_v_samp_factor) {
+    jcopy_sample_rows(input_data, inrow, output_data, outrow,
+              1, cinfo->output_width);
+    jcopy_sample_rows(input_data, inrow, output_data, outrow+1,
+              1, cinfo->output_width);
+    inrow++;
+    outrow += 2;
+  }
+}
+
+#endif /* UPSAMPLE_H1V2_SUPPORTED */
+
+
 /*
  * Fancy processing for the common case of 2:1 horizontal and 1:1 vertical.
  *
@@ -395,6 +423,49 @@
 }
 
 
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+
+/*
+ * Fancy processing for the common case of 1:1 horizontal and 2:1 vertical.
+ * Again a triangle filter; see comments for h2v1 case, above.
+ *
+ * It is OK for us to reference the adjacent input rows because we demanded
+ * context from the main buffer controller (see initialization code).
+ */
+
+METHODDEF(void)
+h1v2_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+             JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
+{
+  JSAMPARRAY output_data = *output_data_ptr;
+  register JSAMPROW inptr0, inptr1, outptr;
+  register int colsum;
+  register JDIMENSION colctr;
+  int inrow, outrow, v;
+
+  inrow = outrow = 0;
+  while (outrow < cinfo->max_v_samp_factor) {
+    for (v = 0; v < 2; v++) {
+      /* inptr0 points to nearest input row, inptr1 points to next nearest */
+      inptr0 = input_data[inrow];
+      if (v == 0)        /* next nearest is row above */
+    inptr1 = input_data[inrow-1];
+      else            /* next nearest is row below */
+    inptr1 = input_data[inrow+1];
+      outptr = output_data[outrow++];
+
+      for (colctr = compptr->downsampled_width; colctr > 0; colctr--) {
+    colsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
+    *outptr++ = (JSAMPLE) ((colsum + v + 1) >> 2);
+      }
+    }
+    inrow++;
+  }
+}
+
+#endif /* UPSAMPLE_H1V2_SUPPORTED */
+
+
 /*
  * Module initialization routine for upsampling.
  */
@@ -477,6 +548,27 @@
     else
       upsample->methods[ci] = h2v2_upsample;
       }
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+    } else if (h_in_group == h_out_group &&
+           v_in_group * 2 == v_out_group) {
+      /* Special cases for 1h2v upsampling */
+      if (do_fancy && compptr->downsampled_height > 2) {
+#ifdef JDSAMPLE_FANCY_SSE2_SUPPORTED
+    if (jsimd_can_h1v2_fancy_upsample())
+      upsample->methods[ci] = jsimd_h1v2_fancy_upsample;
+    else
+#endif // JDSAMPLE_FANCY_SSE2_SUPPORTED
+      upsample->methods[ci] = h1v2_fancy_upsample;
+    upsample->pub.need_context_rows = TRUE;
+      } else {
+#ifdef JDSAMPLE_SSE2_SUPPORTED
+    if (jsimd_can_h1v2_upsample())
+      upsample->methods[ci] = jsimd_h1v2_upsample;
+    else
+#endif // JDSAMPLE_SSE2_SUPPORTED
+      upsample->methods[ci] = h1v2_upsample;
+      }
+#endif
     } else if ((h_out_group % h_in_group) == 0 &&
            (v_out_group % v_in_group) == 0) {
       /* Generic integral-factors upsampling method */
diff -r 3a99d7ff459c media/libjpeg/jdtrans.c
--- a/media/libjpeg/jdtrans.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jdtrans.c    Tue Jan 24 23:47:27 2012 +0900
@@ -99,6 +99,11 @@
   /* This is effectively a buffered-image operation. */
   cinfo->buffered_image = TRUE;
 
+#if JPEG_LIB_VERSION >= 80
+  /* Compute output image dimensions and related values. */
+  jpeg_core_output_dimensions(cinfo);
+#endif
+
   /* Entropy decoding: either Huffman or arithmetic coding. */
   if (cinfo->arith_code) {
 #ifdef D_ARITH_CODING_SUPPORTED
diff -r 3a99d7ff459c media/libjpeg/jerror.h
--- a/media/libjpeg/jerror.h    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jerror.h    Tue Jan 24 23:47:27 2012 +0900
@@ -40,15 +40,23 @@
 JMESSAGE(JMSG_NOMESSAGE, "Bogus message code %d") /* Must be first entry! */
 
 /* For maintenance convenience, list is alphabetical by message code name */
+#if JPEG_LIB_VERSION < 70
 JMESSAGE(JERR_ARITH_NOTIMPL,
      "Sorry, arithmetic coding is not implemented")
+#endif
 JMESSAGE(JERR_BAD_ALIGN_TYPE, "ALIGN_TYPE is wrong, please fix")
 JMESSAGE(JERR_BAD_ALLOC_CHUNK, "MAX_ALLOC_CHUNK is wrong, please fix")
 JMESSAGE(JERR_BAD_BUFFER_MODE, "Bogus buffer control mode")
 JMESSAGE(JERR_BAD_COMPONENT_ID, "Invalid component ID %d in SOS")
+#if JPEG_LIB_VERSION >= 70
 JMESSAGE(JERR_BAD_CROP_SPEC, "Invalid crop request")
+#endif
 JMESSAGE(JERR_BAD_DCT_COEF, "DCT coefficient out of range")
 JMESSAGE(JERR_BAD_DCTSIZE, "IDCT output block size %d not supported")
+#if JPEG_LIB_VERSION >= 70
+JMESSAGE(JERR_BAD_DROP_SAMPLING,
+     "Component index %d: mismatching sampling ratio %d:%d, %d:%d, %c")
+#endif
 JMESSAGE(JERR_BAD_HUFF_TABLE, "Bogus Huffman table definition")
 JMESSAGE(JERR_BAD_IN_COLORSPACE, "Bogus input colorspace")
 JMESSAGE(JERR_BAD_J_COLORSPACE, "Bogus JPEG colorspace")
@@ -95,7 +103,9 @@
 JMESSAGE(JERR_MODE_CHANGE, "Invalid color quantization mode change")
 JMESSAGE(JERR_NOTIMPL, "Not implemented yet")
 JMESSAGE(JERR_NOT_COMPILED, "Requested feature was omitted at compile time")
+#if JPEG_LIB_VERSION >= 70
 JMESSAGE(JERR_NO_ARITH_TABLE, "Arithmetic table 0x%02x was not defined")
+#endif
 JMESSAGE(JERR_NO_BACKING_STORE, "Backing store not supported")
 JMESSAGE(JERR_NO_HUFF_TABLE, "Huffman table 0x%02x was not defined")
 JMESSAGE(JERR_NO_IMAGE, "JPEG datastream contains no image")
@@ -173,7 +183,9 @@
 JMESSAGE(JTRC_XMS_CLOSE, "Freed XMS handle %u")
 JMESSAGE(JTRC_XMS_OPEN, "Obtained XMS handle %u")
 JMESSAGE(JWRN_ADOBE_XFORM, "Unknown Adobe color transform code %d")
+#if JPEG_LIB_VERSION >= 70
 JMESSAGE(JWRN_ARITH_BAD_CODE, "Corrupt JPEG data: bad arithmetic code")
+#endif
 JMESSAGE(JWRN_BOGUS_PROGRESSION,
      "Inconsistent progression sequence for component %d coefficient %d")
 JMESSAGE(JWRN_EXTRANEOUS_DATA,
@@ -186,6 +198,13 @@
      "Corrupt JPEG data: found marker 0x%02x instead of RST%d")
 JMESSAGE(JWRN_NOT_SEQUENTIAL, "Invalid SOS parameters for sequential JPEG")
 JMESSAGE(JWRN_TOO_MUCH_DATA, "Application transferred too many scanlines")
+#if JPEG_LIB_VERSION < 70
+JMESSAGE(JERR_BAD_CROP_SPEC, "Invalid crop request")
+#if defined(C_ARITH_CODING_SUPPORTED) || defined(D_ARITH_CODING_SUPPORTED)
+JMESSAGE(JERR_NO_ARITH_TABLE, "Arithmetic table 0x%02x was not defined")
+JMESSAGE(JWRN_ARITH_BAD_CODE, "Corrupt JPEG data: bad arithmetic code")
+#endif
+#endif
 
 #ifdef JMAKE_ENUM_LIST
 
diff -r 3a99d7ff459c media/libjpeg/jmemmgr.c
--- a/media/libjpeg/jmemmgr.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jmemmgr.c    Tue Jan 24 23:47:27 2012 +0900
@@ -37,6 +37,15 @@
 #endif
 
 
+LOCAL(size_t)
+round_up_pow2 (size_t a, size_t b)
+/* a rounded up to the next multiple of b, i.e. ceil(a/b)*b */
+/* Assumes a >= 0, b > 0, and b is a power of 2 */
+{
+  return ((a + b - 1) & (~(b - 1)));
+}
+
+
 /*
  * Some important notes:
  *   The allocation routines provided here must never return NULL.
@@ -265,7 +274,7 @@
    * and so that algorithms can straddle outside the proper area up
    * to the next alignment.
    */
-  sizeofobject = jround_up(sizeofobject, ALIGN_SIZE);
+  sizeofobject = round_up_pow2(sizeofobject, ALIGN_SIZE);
 
   /* Check for unsatisfiable request (do now to ensure no overflow below) */
   if ((SIZEOF(small_pool_hdr) + sizeofobject + ALIGN_SIZE - 1) > MAX_ALLOC_CHUNK)
@@ -354,7 +363,7 @@
    * algorithms can straddle outside the proper area up to the next
    * alignment.
    */
-  sizeofobject = jround_up(sizeofobject, ALIGN_SIZE);
+  sizeofobject = round_up_pow2(sizeofobject, ALIGN_SIZE);
 
   /* Check for unsatisfiable request (do now to ensure no overflow below) */
   if ((SIZEOF(large_pool_hdr) + sizeofobject + ALIGN_SIZE - 1) > MAX_ALLOC_CHUNK)
@@ -420,7 +429,7 @@
   /* Make sure each row is properly aligned */
   if ((ALIGN_SIZE % SIZEOF(JSAMPLE)) != 0)
     out_of_memory(cinfo, 5);    /* safety check */
-  samplesperrow = (JDIMENSION)jround_up(samplesperrow, (2 * ALIGN_SIZE) / SIZEOF(JSAMPLE));
+  samplesperrow = (JDIMENSION)round_up_pow2(samplesperrow, (2 * ALIGN_SIZE) / SIZEOF(JSAMPLE));
 
   /* Calculate max # of rows allowed in one allocation chunk */
   ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
diff -r 3a99d7ff459c media/libjpeg/jmorecfg.h
--- a/media/libjpeg/jmorecfg.h    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jmorecfg.h    Tue Jan 24 23:47:27 2012 +0900
@@ -2,7 +2,7 @@
  * jmorecfg.h
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
- * Copyright (C) 2009, D. R. Commander.
+ * Copyright (C) 2009, 2011, D. R. Commander.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -11,7 +11,6 @@
  * optimizations.  Most users will not need to touch this file.
  */
 
-#include "prtypes.h"
 
 /*
  * Define BITS_IN_JSAMPLE as either
@@ -133,19 +132,38 @@
 
 /* UINT8 must hold at least the values 0..255. */
 
-typedef PRUint8 UINT8;
+#ifndef    _BASETSD_H_
+#ifdef HAVE_UNSIGNED_CHAR
+typedef unsigned char UINT8;
+#else /* not HAVE_UNSIGNED_CHAR */
+#ifdef __CHAR_UNSIGNED__
+typedef char UINT8;
+#else /* not __CHAR_UNSIGNED__ */
+typedef short UINT8;
+#endif /* __CHAR_UNSIGNED__ */
+#endif /* HAVE_UNSIGNED_CHAR */
 
 /* UINT16 must hold at least the values 0..65535. */
 
-typedef PRUint16 UINT16;
+#ifdef HAVE_UNSIGNED_SHORT
+typedef unsigned short UINT16;
+#else /* not HAVE_UNSIGNED_SHORT */
+typedef unsigned int UINT16;
+#endif /* HAVE_UNSIGNED_SHORT */
 
 /* INT16 must hold at least the values -32768..32767. */
 
-typedef PRInt16 INT16;
+#ifndef XMD_H            /* X11/xmd.h correctly defines INT16 */
+typedef short INT16;
+#endif
 
 /* INT32 must hold at least signed 32-bit values. */
 
-typedef PRInt32 INT32;
+#ifndef XMD_H            /* X11/xmd.h correctly defines INT32 */
+typedef long INT32;
+#endif
+#endif    // _BASETSD_H_
+
 
 /* Datatype used for image dimensions.  The JPEG standard only supports
  * images up to 64K*64K due to 16-bit fields in SOF markers.  Therefore
@@ -242,8 +260,6 @@
  * (You may HAVE to do that if your compiler doesn't like null source files.)
  */
 
-/* Arithmetic coding is unsupported for legal reasons.  Complaints to IBM. */
-
 /* Capability options common to encoder and decoder: */
 
 #define DCT_ISLOW_SUPPORTED    /* slow but accurate integer algorithm */
@@ -252,7 +268,6 @@
 
 /* Encoder capability options: */
 
-#undef  C_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
 #define C_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
 #define C_PROGRESSIVE_SUPPORTED        /* Progressive JPEG? (Requires MULTISCAN)*/
 #define ENTROPY_OPT_SUPPORTED        /* Optimization of entropy coding parms? */
@@ -268,7 +283,6 @@
 
 /* Decoder capability options: */
 
-#undef  D_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
 #define D_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
 #define D_PROGRESSIVE_SUPPORTED        /* Progressive JPEG? (Requires MULTISCAN)*/
 #define SAVE_MARKERS_SUPPORTED        /* jpeg_save_markers() needed? */
@@ -276,6 +290,7 @@
 #define IDCT_SCALING_SUPPORTED        /* Output rescaling via IDCT? */
 #undef  UPSAMPLE_SCALING_SUPPORTED  /* Output rescaling at upsample stage? */
 #define UPSAMPLE_MERGING_SUPPORTED  /* Fast path for sloppy upsampling? */
+#define UPSAMPLE_H1V2_SUPPORTED        /* Fast/fancy processing for 1h2v? */
 #define QUANT_1PASS_SUPPORTED        /* 1-pass color quantization? */
 #define QUANT_2PASS_SUPPORTED        /* 2-pass color quantization? */
 
@@ -302,22 +317,60 @@
 #define RGB_BLUE    2    /* Offset of Blue */
 #define RGB_PIXELSIZE    3    /* JSAMPLEs per RGB scanline element */
 
-#define JPEG_NUMCS 12
+#define JPEG_NUMCS 16
+
+#define EXT_RGB_RED        0
+#define EXT_RGB_GREEN      1
+#define EXT_RGB_BLUE       2
+#define EXT_RGB_PIXELSIZE  3
+
+#define EXT_RGBX_RED       0
+#define EXT_RGBX_GREEN     1
+#define EXT_RGBX_BLUE      2
+#define EXT_RGBX_PIXELSIZE 4
+
+#define EXT_BGR_RED        2
+#define EXT_BGR_GREEN      1
+#define EXT_BGR_BLUE       0
+#define EXT_BGR_PIXELSIZE  3
+
+#define EXT_BGRX_RED       2
+#define EXT_BGRX_GREEN     1
+#define EXT_BGRX_BLUE      0
+#define EXT_BGRX_PIXELSIZE 4
+
+#define EXT_XBGR_RED       3
+#define EXT_XBGR_GREEN     2
+#define EXT_XBGR_BLUE      1
+#define EXT_XBGR_PIXELSIZE 4
+
+#define EXT_XRGB_RED       1
+#define EXT_XRGB_GREEN     2
+#define EXT_XRGB_BLUE      3
+#define EXT_XRGB_PIXELSIZE 4
 
 static const int rgb_red[JPEG_NUMCS] = {
-    -1, -1, RGB_RED, -1, -1, -1, 0, 0, 2, 2, 3, 1
+  -1, -1, RGB_RED, -1, -1, -1, EXT_RGB_RED, EXT_RGBX_RED,
+  EXT_BGR_RED, EXT_BGRX_RED, EXT_XBGR_RED, EXT_XRGB_RED,
+  EXT_RGBX_RED, EXT_BGRX_RED, EXT_XBGR_RED, EXT_XRGB_RED
 };
 
 static const int rgb_green[JPEG_NUMCS] = {
-    -1, -1, RGB_GREEN, -1, -1, -1, 1, 1, 1, 1, 2, 2
+  -1, -1, RGB_GREEN, -1, -1, -1, EXT_RGB_GREEN, EXT_RGBX_GREEN,
+  EXT_BGR_GREEN, EXT_BGRX_GREEN, EXT_XBGR_GREEN, EXT_XRGB_GREEN,
+  EXT_RGBX_GREEN, EXT_BGRX_GREEN, EXT_XBGR_GREEN, EXT_XRGB_GREEN
 };
 
 static const int rgb_blue[JPEG_NUMCS] = {
-    -1, -1, RGB_BLUE, -1, -1, -1, 2, 2, 0, 0, 1, 3
+  -1, -1, RGB_BLUE, -1, -1, -1, EXT_RGB_BLUE, EXT_RGBX_BLUE,
+  EXT_BGR_BLUE, EXT_BGRX_BLUE, EXT_XBGR_BLUE, EXT_XRGB_BLUE,
+  EXT_RGBX_BLUE, EXT_BGRX_BLUE, EXT_XBGR_BLUE, EXT_XRGB_BLUE
 };
 
 static const int rgb_pixelsize[JPEG_NUMCS] = {
-    -1, -1, RGB_PIXELSIZE, -1, -1, -1, 3, 4, 3, 4, 4, 4
+  -1, -1, RGB_PIXELSIZE, -1, -1, -1, EXT_RGB_PIXELSIZE, EXT_RGBX_PIXELSIZE,
+  EXT_BGR_PIXELSIZE, EXT_BGRX_PIXELSIZE, EXT_XBGR_PIXELSIZE, EXT_XRGB_PIXELSIZE,
+  EXT_RGBX_PIXELSIZE, EXT_BGRX_PIXELSIZE, EXT_XBGR_PIXELSIZE, EXT_XRGB_PIXELSIZE
 };
 
 /* Definitions for speed-related optimizations. */
diff -r 3a99d7ff459c media/libjpeg/jpegint.h
--- a/media/libjpeg/jpegint.h    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jpegint.h    Tue Jan 24 23:47:27 2012 +0900
@@ -375,7 +375,7 @@
 
 /* Utility routines in jutils.c */
 EXTERN(long) jdiv_round_up JPP((long a, long b));
-EXTERN(size_t) jround_up JPP((size_t a, size_t b));
+EXTERN(long) jround_up JPP((long a, long b));
 EXTERN(void) jcopy_sample_rows JPP((JSAMPARRAY input_array, int source_row,
                     JSAMPARRAY output_array, int dest_row,
                     int num_rows, JDIMENSION num_cols));
diff -r 3a99d7ff459c media/libjpeg/jpeglib.h
--- a/media/libjpeg/jpeglib.h    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jpeglib.h    Tue Jan 24 23:47:27 2012 +0900
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 1991-1998, Thomas G. Lane.
  * Modified 2002-2009 by Guido Vollbeding.
- * Copyright (C) 2009-2010, D. R. Commander.
+ * Copyright (C) 2009-2011, D. R. Commander.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -211,12 +211,13 @@
 /* Known color spaces. */
 
 #define JCS_EXTENSIONS 1
+#define JCS_ALPHA_EXTENSIONS 1
 
 typedef enum {
     JCS_UNKNOWN,        /* error/unspecified */
     JCS_GRAYSCALE,        /* monochrome */
     JCS_RGB,        /* red/green/blue as specified by the RGB_RED, RGB_GREEN,
-                 RGB_BLUE, and RGB_PIXELSIZE macros */
+                   RGB_BLUE, and RGB_PIXELSIZE macros */
     JCS_YCbCr,        /* Y/Cb/Cr (also known as YUV) */
     JCS_CMYK,        /* C/M/Y/K */
     JCS_YCCK,        /* Y/Cb/Cr/K */
@@ -225,7 +226,18 @@
     JCS_EXT_BGR,        /* blue/green/red */
     JCS_EXT_BGRX,        /* blue/green/red/x */
     JCS_EXT_XBGR,        /* x/blue/green/red */
-    JCS_EXT_XRGB        /* x/red/green/blue */
+    JCS_EXT_XRGB,        /* x/red/green/blue */
+    /* When out_color_space it set to JCS_EXT_RGBX, JCS_EXT_BGRX,
+       JCS_EXT_XBGR, or JCS_EXT_XRGB during decompression, the X byte is
+       undefined, and in order to ensure the best performance,
+       libjpeg-turbo can set that byte to whatever value it wishes.  Use
+       the following colorspace constants to ensure that the X byte is set
+       to 0xFF, so that it can be interpreted as an opaque alpha
+       channel. */
+    JCS_EXT_RGBA,        /* red/green/blue/alpha */
+    JCS_EXT_BGRA,        /* blue/green/red/alpha */
+    JCS_EXT_ABGR,        /* alpha/blue/green/red */
+    JCS_EXT_ARGB        /* alpha/red/green/blue */
 } J_COLOR_SPACE;
 
 /* DCT/IDCT algorithm options. */
diff -r 3a99d7ff459c media/libjpeg/jsimd.h
--- a/media/libjpeg/jsimd.h    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jsimd.h    Tue Jan 24 23:47:27 2012 +0900
@@ -2,6 +2,7 @@
  * jsimd.h
  *
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+ * Copyright 2011 D. R. Commander
  * 
  * Based on the x86 SIMD extension for IJG JPEG library,
  * Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -13,8 +14,10 @@
 
 #ifdef NEED_SHORT_EXTERNAL_NAMES
 #define jsimd_can_rgb_ycc                 jSCanRgbYcc
+#define jsimd_can_rgb_gray                jSCanRgbGry
 #define jsimd_can_ycc_rgb                 jSCanYccRgb
 #define jsimd_rgb_ycc_convert             jSRgbYccConv
+#define jsimd_rgb_gray_convert            jSRgbGryConv
 #define jsimd_ycc_rgb_convert             jSYccRgbConv
 #define jsimd_can_h2v2_downsample         jSCanH2V2Down
 #define jsimd_can_h2v1_downsample         jSCanH2V1Down
@@ -35,12 +38,17 @@
 #endif /* NEED_SHORT_EXTERNAL_NAMES */
 
 EXTERN(int) jsimd_can_rgb_ycc JPP((void));
+EXTERN(int) jsimd_can_rgb_gray JPP((void));
 EXTERN(int) jsimd_can_ycc_rgb JPP((void));
 
 EXTERN(void) jsimd_rgb_ycc_convert
         JPP((j_compress_ptr cinfo,
              JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
              JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_rgb_gray_convert
+        JPP((j_compress_ptr cinfo,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
 EXTERN(void) jsimd_ycc_rgb_convert
         JPP((j_decompress_ptr cinfo,
              JSAMPIMAGE input_buf, JDIMENSION input_row,
@@ -58,6 +66,9 @@
 
 EXTERN(int) jsimd_can_h2v2_upsample JPP((void));
 EXTERN(int) jsimd_can_h2v1_upsample JPP((void));
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+EXTERN(int) jsimd_can_h1v2_upsample JPP((void));
+#endif // UPSAMPLE_H1V2_SUPPORTED
 
 EXTERN(void) jsimd_h2v2_upsample
         JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
@@ -65,9 +76,17 @@
 EXTERN(void) jsimd_h2v1_upsample
         JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
              JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+EXTERN(void) jsimd_h1v2_upsample
+        JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
+             JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
+#endif // UPSAMPLE_H1V2_SUPPORTED
 
 EXTERN(int) jsimd_can_h2v2_fancy_upsample JPP((void));
 EXTERN(int) jsimd_can_h2v1_fancy_upsample JPP((void));
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+EXTERN(int) jsimd_can_h1v2_fancy_upsample JPP((void));
+#endif // UPSAMPLE_H1V2_SUPPORTED
 
 EXTERN(void) jsimd_h2v2_fancy_upsample
         JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
@@ -75,6 +94,11 @@
 EXTERN(void) jsimd_h2v1_fancy_upsample
         JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
              JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+EXTERN(void) jsimd_h1v2_fancy_upsample
+        JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
+             JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
+#endif // UPSAMPLE_H1V2_SUPPORTED
 
 EXTERN(int) jsimd_can_h2v2_merged_upsample JPP((void));
 EXTERN(int) jsimd_can_h2v1_merged_upsample JPP((void));
diff -r 3a99d7ff459c media/libjpeg/jsimd_none.c
--- a/media/libjpeg/jsimd_none.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jsimd_none.c    Tue Jan 24 23:47:27 2012 +0900
@@ -2,7 +2,7 @@
  * jsimd_none.c
  *
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright 2009 D. R. Commander
+ * Copyright 2009-2011 D. R. Commander
  * 
  * Based on the x86 SIMD extension for IJG JPEG library,
  * Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -25,6 +25,12 @@
 }
 
 GLOBAL(int)
+jsimd_can_rgb_gray (void)
+{
+  return 0;
+}
+
+GLOBAL(int)
 jsimd_can_ycc_rgb (void)
 {
   return 0;
@@ -38,6 +44,13 @@
 }
 
 GLOBAL(void)
+jsimd_rgb_gray_convert (j_compress_ptr cinfo,
+                        JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+                        JDIMENSION output_row, int num_rows)
+{
+}
+
+GLOBAL(void)
 jsimd_ycc_rgb_convert (j_decompress_ptr cinfo,
                        JSAMPIMAGE input_buf, JDIMENSION input_row,
                        JSAMPARRAY output_buf, int num_rows)
@@ -96,6 +109,18 @@
 {
 }
 
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+
+GLOBAL(void)
+jsimd_h1v2_upsample (j_decompress_ptr cinfo,
+                     jpeg_component_info * compptr, 
+                     JSAMPARRAY input_data,
+                     JSAMPARRAY * output_data_ptr)
+{
+}
+
+#endif    // UPSAMPLE_H1V2_SUPPORTED
+
 GLOBAL(int)
 jsimd_can_h2v2_fancy_upsample (void)
 {
@@ -108,6 +133,16 @@
   return 0;
 }
 
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+
+GLOBAL(int)
+jsimd_can_h1v2_fancy_upsample (void)
+{
+  return 0;
+}
+
+#endif    // UPSAMPLE_H1V2_SUPPORTED
+
 GLOBAL(void)
 jsimd_h2v2_fancy_upsample (j_decompress_ptr cinfo,
                            jpeg_component_info * compptr, 
@@ -124,6 +159,18 @@
 {
 }
 
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+
+GLOBAL(int)
+jsimd_h1v2_fancy_upsample (j_decompress_ptr cinfo,
+                           jpeg_component_info * compptr, 
+                           JSAMPARRAY input_data,
+                           JSAMPARRAY * output_data_ptr)
+{
+}
+
+#endif    // UPSAMPLE_H1V2_SUPPORTED
+
 GLOBAL(int)
 jsimd_can_h2v2_merged_upsample (void)
 {
diff -r 3a99d7ff459c media/libjpeg/jutils.c
--- a/media/libjpeg/jutils.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jutils.c    Tue Jan 24 23:47:27 2012 +0900
@@ -77,8 +77,8 @@
 }
 
 
-GLOBAL(size_t)
-jround_up (size_t a, size_t b)
+GLOBAL(long)
+jround_up (long a, long b)
 /* Compute a rounded up to next multiple of b, ie, ceil(a/b)*b */
 /* Assumes a >= 0, b > 0 */
 {
diff -r 3a99d7ff459c media/libjpeg/jversion.h
--- a/media/libjpeg/jversion.h    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/jversion.h    Tue Jan 24 23:47:27 2012 +0900
@@ -31,7 +31,6 @@
 #endif
 
 #define LJTCOPYRIGHT    "Copyright (C) 1999-2006 MIYASAKA Masaru\n" \
-            "Copyright (C) 2004 Landmark Graphics Corporation\n" \
-            "Copyright (C) 2005-2007 Sun Microsystems, Inc.\n" \
             "Copyright (C) 2009 Pierre Ossman for Cendio AB\n" \
-            "Copyright (C) 2009-2011 D. R. Commander"
+            "Copyright (C) 2009-2011 D. R. Commander\n" \
+            "Copyright (C) 2009-2011 Nokia Corporation and/or its subsidiary(-ies)"
diff -r 3a99d7ff459c media/libjpeg/simd/jcclrmmx.asm
--- a/media/libjpeg/simd/jcclrmmx.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jcclrmmx.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -19,8 +19,6 @@
 %include "jcolsamp.inc"
 
 ; --------------------------------------------------------------------------
-    SECTION    SEG_TEXT
-    BITS    32
 ;
 ; Convert some rows of samples to the output colorspace.
 ;
diff -r 3a99d7ff459c media/libjpeg/simd/jcclrss2-64.asm
--- a/media/libjpeg/simd/jcclrss2-64.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jcclrss2-64.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -17,8 +17,6 @@
 %include "jcolsamp.inc"
 
 ; --------------------------------------------------------------------------
-    SECTION    SEG_TEXT
-    BITS    64
 ;
 ; Convert some rows of samples to the output colorspace.
 ;
diff -r 3a99d7ff459c media/libjpeg/simd/jcclrss2.asm
--- a/media/libjpeg/simd/jcclrss2.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jcclrss2.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -16,8 +16,6 @@
 %include "jcolsamp.inc"
 
 ; --------------------------------------------------------------------------
-    SECTION    SEG_TEXT
-    BITS    32
 ;
 ; Convert some rows of samples to the output colorspace.
 ;
diff -r 3a99d7ff459c media/libjpeg/simd/jccolmmx.asm
--- a/media/libjpeg/simd/jccolmmx.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jccolmmx.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -51,16 +51,19 @@
     alignz    16
 
 ; --------------------------------------------------------------------------
+    SECTION    SEG_TEXT
+    BITS    32
+
 %include "jcclrmmx.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
 %define jsimd_rgb_ycc_convert_mmx jsimd_extrgb_ycc_convert_mmx
 %include "jcclrmmx.asm"
 
@@ -68,10 +71,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
 %define jsimd_rgb_ycc_convert_mmx jsimd_extrgbx_ycc_convert_mmx
 %include "jcclrmmx.asm"
 
@@ -79,10 +82,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
 %define jsimd_rgb_ycc_convert_mmx jsimd_extbgr_ycc_convert_mmx
 %include "jcclrmmx.asm"
 
@@ -90,10 +93,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
 %define jsimd_rgb_ycc_convert_mmx jsimd_extbgrx_ycc_convert_mmx
 %include "jcclrmmx.asm"
 
@@ -101,10 +104,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 3
-%define RGB_GREEN 2
-%define RGB_BLUE 1
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
 %define jsimd_rgb_ycc_convert_mmx jsimd_extxbgr_ycc_convert_mmx
 %include "jcclrmmx.asm"
 
@@ -112,9 +115,9 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 1
-%define RGB_GREEN 2
-%define RGB_BLUE 3
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
 %define jsimd_rgb_ycc_convert_mmx jsimd_extxrgb_ycc_convert_mmx
 %include "jcclrmmx.asm"
diff -r 3a99d7ff459c media/libjpeg/simd/jccolss2-64.asm
--- a/media/libjpeg/simd/jccolss2-64.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jccolss2-64.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -48,16 +48,19 @@
     alignz    16
 
 ; --------------------------------------------------------------------------
+    SECTION    SEG_TEXT
+    BITS    64
+
 %include "jcclrss2-64.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extrgb_ycc_convert_sse2
 %include "jcclrss2-64.asm"
 
@@ -65,10 +68,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extrgbx_ycc_convert_sse2
 %include "jcclrss2-64.asm"
 
@@ -76,10 +79,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extbgr_ycc_convert_sse2
 %include "jcclrss2-64.asm"
 
@@ -87,10 +90,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extbgrx_ycc_convert_sse2
 %include "jcclrss2-64.asm"
 
@@ -98,10 +101,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 3
-%define RGB_GREEN 2
-%define RGB_BLUE 1
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extxbgr_ycc_convert_sse2
 %include "jcclrss2-64.asm"
 
@@ -109,9 +112,9 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 1
-%define RGB_GREEN 2
-%define RGB_BLUE 3
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extxrgb_ycc_convert_sse2
 %include "jcclrss2-64.asm"
diff -r 3a99d7ff459c media/libjpeg/simd/jccolss2.asm
--- a/media/libjpeg/simd/jccolss2.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jccolss2.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -48,16 +48,19 @@
     alignz    16
 
 ; --------------------------------------------------------------------------
+    SECTION    SEG_TEXT
+    BITS    32
+
 %include "jcclrss2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extrgb_ycc_convert_sse2
 %include "jcclrss2.asm"
 
@@ -65,10 +68,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extrgbx_ycc_convert_sse2
 %include "jcclrss2.asm"
 
@@ -76,10 +79,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extbgr_ycc_convert_sse2
 %include "jcclrss2.asm"
 
@@ -87,10 +90,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extbgrx_ycc_convert_sse2
 %include "jcclrss2.asm"
 
@@ -98,10 +101,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 3
-%define RGB_GREEN 2
-%define RGB_BLUE 1
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extxbgr_ycc_convert_sse2
 %include "jcclrss2.asm"
 
@@ -109,9 +112,9 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 1
-%define RGB_GREEN 2
-%define RGB_BLUE 3
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extxrgb_ycc_convert_sse2
 %include "jcclrss2.asm"
diff -r 3a99d7ff459c media/libjpeg/simd/jcgrammx.asm
--- /dev/null    Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libjpeg/simd/jcgrammx.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -0,0 +1,116 @@
+;
+; jcgrammx.asm - grayscale colorspace conversion (MMX)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright 2011 D. R. Commander
+;
+; Based on
+; x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+
+%define SCALEBITS    16
+
+F_0_114    equ     7471            ; FIX(0.11400)
+F_0_250    equ    16384            ; FIX(0.25000)
+F_0_299    equ    19595            ; FIX(0.29900)
+F_0_587    equ    38470            ; FIX(0.58700)
+F_0_337    equ    (F_0_587 - F_0_250)    ; FIX(0.58700) - FIX(0.25000)
+
+; --------------------------------------------------------------------------
+    SECTION    SEG_CONST
+
+    alignz    16
+    global    EXTN(jconst_rgb_gray_convert_mmx)
+
+EXTN(jconst_rgb_gray_convert_mmx):
+
+PW_F0299_F0337    times 2 dw  F_0_299, F_0_337
+PW_F0114_F0250    times 2 dw  F_0_114, F_0_250
+PD_ONEHALF    times 2 dd  (1 << (SCALEBITS-1))
+
+    alignz    16
+
+; --------------------------------------------------------------------------
+    SECTION    SEG_TEXT
+    BITS    32
+
+%include "jcgrymmx.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+%define jsimd_rgb_gray_convert_mmx jsimd_extrgb_gray_convert_mmx
+%include "jcgrymmx.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+%define jsimd_rgb_gray_convert_mmx jsimd_extrgbx_gray_convert_mmx
+%include "jcgrymmx.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+%define jsimd_rgb_gray_convert_mmx jsimd_extbgr_gray_convert_mmx
+%include "jcgrymmx.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+%define jsimd_rgb_gray_convert_mmx jsimd_extbgrx_gray_convert_mmx
+%include "jcgrymmx.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+%define jsimd_rgb_gray_convert_mmx jsimd_extxbgr_gray_convert_mmx
+%include "jcgrymmx.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+%define jsimd_rgb_gray_convert_mmx jsimd_extxrgb_gray_convert_mmx
+%include "jcgrymmx.asm"
diff -r 3a99d7ff459c media/libjpeg/simd/jcgrass2-64.asm
--- /dev/null    Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libjpeg/simd/jcgrass2-64.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -0,0 +1,113 @@
+;
+; jcgrass2-64.asm - grayscale colorspace conversion (64-bit SSE2)
+;
+; x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; Copyright (C) 2011, D. R. Commander.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+
+%define SCALEBITS    16
+
+F_0_114    equ     7471            ; FIX(0.11400)
+F_0_250    equ    16384            ; FIX(0.25000)
+F_0_299    equ    19595            ; FIX(0.29900)
+F_0_587    equ    38470            ; FIX(0.58700)
+F_0_337    equ    (F_0_587 - F_0_250)    ; FIX(0.58700) - FIX(0.25000)
+
+; --------------------------------------------------------------------------
+    SECTION    SEG_CONST
+
+    alignz    16
+    global    EXTN(jconst_rgb_gray_convert_sse2)
+
+EXTN(jconst_rgb_gray_convert_sse2):
+
+PW_F0299_F0337    times 4 dw  F_0_299, F_0_337
+PW_F0114_F0250    times 4 dw  F_0_114, F_0_250
+PD_ONEHALF    times 4 dd  (1 << (SCALEBITS-1))
+
+    alignz    16
+
+; --------------------------------------------------------------------------
+    SECTION    SEG_TEXT
+    BITS    64
+
+%include "jcgryss2-64.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+%define jsimd_rgb_gray_convert_sse2 jsimd_extrgb_gray_convert_sse2
+%include "jcgryss2-64.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+%define jsimd_rgb_gray_convert_sse2 jsimd_extrgbx_gray_convert_sse2
+%include "jcgryss2-64.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+%define jsimd_rgb_gray_convert_sse2 jsimd_extbgr_gray_convert_sse2
+%include "jcgryss2-64.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+%define jsimd_rgb_gray_convert_sse2 jsimd_extbgrx_gray_convert_sse2
+%include "jcgryss2-64.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+%define jsimd_rgb_gray_convert_sse2 jsimd_extxbgr_gray_convert_sse2
+%include "jcgryss2-64.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+%define jsimd_rgb_gray_convert_sse2 jsimd_extxrgb_gray_convert_sse2
+%include "jcgryss2-64.asm"
diff -r 3a99d7ff459c media/libjpeg/simd/jcgrass2.asm
--- /dev/null    Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libjpeg/simd/jcgrass2.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -0,0 +1,113 @@
+;
+; jcgrass2.asm - grayscale colorspace conversion (SSE2)
+;
+; x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; Copyright (C) 2011, D. R. Commander.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+
+%define SCALEBITS    16
+
+F_0_114    equ     7471            ; FIX(0.11400)
+F_0_250    equ    16384            ; FIX(0.25000)
+F_0_299    equ    19595            ; FIX(0.29900)
+F_0_587    equ    38470            ; FIX(0.58700)
+F_0_337    equ    (F_0_587 - F_0_250)    ; FIX(0.58700) - FIX(0.25000)
+
+; --------------------------------------------------------------------------
+    SECTION    SEG_CONST
+
+    alignz    16
+    global    EXTN(jconst_rgb_gray_convert_sse2)
+
+EXTN(jconst_rgb_gray_convert_sse2):
+
+PW_F0299_F0337    times 4 dw  F_0_299, F_0_337
+PW_F0114_F0250    times 4 dw  F_0_114, F_0_250
+PD_ONEHALF    times 4 dd  (1 << (SCALEBITS-1))
+
+    alignz    16
+
+; --------------------------------------------------------------------------
+    SECTION    SEG_TEXT
+    BITS    32
+
+%include "jcgryss2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+%define jsimd_rgb_gray_convert_sse2 jsimd_extrgb_gray_convert_sse2
+%include "jcgryss2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+%define jsimd_rgb_gray_convert_sse2 jsimd_extrgbx_gray_convert_sse2
+%include "jcgryss2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+%define jsimd_rgb_gray_convert_sse2 jsimd_extbgr_gray_convert_sse2
+%include "jcgryss2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+%define jsimd_rgb_gray_convert_sse2 jsimd_extbgrx_gray_convert_sse2
+%include "jcgryss2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+%define jsimd_rgb_gray_convert_sse2 jsimd_extxbgr_gray_convert_sse2
+%include "jcgryss2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+%define jsimd_rgb_gray_convert_sse2 jsimd_extxrgb_gray_convert_sse2
+%include "jcgryss2.asm"
diff -r 3a99d7ff459c media/libjpeg/simd/jcgrymmx.asm
--- /dev/null    Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libjpeg/simd/jcgrymmx.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -0,0 +1,357 @@
+;
+; jcgrymmx.asm - grayscale colorspace conversion (MMX)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright 2011 D. R. Commander
+;
+; Based on
+; x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_rgb_gray_convert_mmx (JDIMENSION img_width,
+;                             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+;                             JDIMENSION output_row, int num_rows);
+;
+
+%define img_width(b)    (b)+8            ; JDIMENSION img_width
+%define input_buf(b)    (b)+12        ; JSAMPARRAY input_buf
+%define output_buf(b)    (b)+16        ; JSAMPIMAGE output_buf
+%define output_row(b)    (b)+20        ; JDIMENSION output_row
+%define num_rows(b)    (b)+24        ; int num_rows
+
+%define original_ebp    ebp+0
+%define wk(i)        ebp-(WK_NUM-(i))*SIZEOF_MMWORD    ; mmword wk[WK_NUM]
+%define WK_NUM        2
+%define gotptr        wk(0)-SIZEOF_POINTER    ; void * gotptr
+
+    align    16
+    global    EXTN(jsimd_rgb_gray_convert_mmx)
+
+EXTN(jsimd_rgb_gray_convert_mmx):
+    push    ebp
+    mov    eax,esp                ; eax = original ebp
+    sub    esp, byte 4
+    and    esp, byte (-SIZEOF_MMWORD)    ; align to 64 bits
+    mov    [esp],eax
+    mov    ebp,esp                ; ebp = aligned ebp
+    lea    esp, [wk(0)]
+    pushpic    eax        ; make a room for GOT address
+    push    ebx
+;    push    ecx        ; need not be preserved
+;    push    edx        ; need not be preserved
+    push    esi
+    push    edi
+
+    get_GOT    ebx            ; get GOT address
+    movpic    POINTER [gotptr], ebx    ; save GOT address
+
+    mov    ecx, JDIMENSION [img_width(eax)]    ; num_cols
+    test    ecx,ecx
+    jz    near .return
+
+    push    ecx
+
+    mov    esi, JSAMPIMAGE [output_buf(eax)]
+    mov    ecx, JDIMENSION [output_row(eax)]
+    mov    edi, JSAMPARRAY [esi+0*SIZEOF_JSAMPARRAY]
+    lea    edi, [edi+ecx*SIZEOF_JSAMPROW]
+
+    pop    ecx
+
+    mov    esi, JSAMPARRAY [input_buf(eax)]
+    mov    eax, INT [num_rows(eax)]
+    test    eax,eax
+    jle    near .return
+    alignx    16,7
+.rowloop:
+    pushpic    eax
+    push    edi
+    push    esi
+    push    ecx            ; col
+
+    mov    esi, JSAMPROW [esi]    ; inptr
+    mov    edi, JSAMPROW [edi]    ; outptr0
+    movpic    eax, POINTER [gotptr]    ; load GOT address (eax)
+
+    cmp    ecx, byte SIZEOF_MMWORD
+    jae    short .columnloop
+    alignx    16,7
+
+%if RGB_PIXELSIZE == 3 ; ---------------
+
+.column_ld1:
+    push    eax
+    push    edx
+    lea    ecx,[ecx+ecx*2]        ; imul ecx,RGB_PIXELSIZE
+    test    cl, SIZEOF_BYTE
+    jz    short .column_ld2
+    sub    ecx, byte SIZEOF_BYTE
+    xor    eax,eax
+    mov    al, BYTE [esi+ecx]
+.column_ld2:
+    test    cl, SIZEOF_WORD
+    jz    short .column_ld4
+    sub    ecx, byte SIZEOF_WORD
+    xor    edx,edx
+    mov    dx, WORD [esi+ecx]
+    shl    eax, WORD_BIT
+    or    eax,edx
+.column_ld4:
+    movd    mmA,eax
+    pop    edx
+    pop    eax
+    test    cl, SIZEOF_DWORD
+    jz    short .column_ld8
+    sub    ecx, byte SIZEOF_DWORD
+    movd    mmG, DWORD [esi+ecx]
+    psllq    mmA, DWORD_BIT
+    por    mmA,mmG
+.column_ld8:
+    test    cl, SIZEOF_MMWORD
+    jz    short .column_ld16
+    movq    mmG,mmA
+    movq    mmA, MMWORD [esi+0*SIZEOF_MMWORD]
+    mov    ecx, SIZEOF_MMWORD
+    jmp    short .rgb_gray_cnv
+.column_ld16:
+    test    cl, 2*SIZEOF_MMWORD
+    mov    ecx, SIZEOF_MMWORD
+    jz    short .rgb_gray_cnv
+    movq    mmF,mmA
+    movq    mmA, MMWORD [esi+0*SIZEOF_MMWORD]
+    movq    mmG, MMWORD [esi+1*SIZEOF_MMWORD]
+    jmp    short .rgb_gray_cnv
+    alignx    16,7
+
+.columnloop:
+    movq    mmA, MMWORD [esi+0*SIZEOF_MMWORD]
+    movq    mmG, MMWORD [esi+1*SIZEOF_MMWORD]
+    movq    mmF, MMWORD [esi+2*SIZEOF_MMWORD]
+
+.rgb_gray_cnv:
+    ; mmA=(00 10 20 01 11 21 02 12)
+    ; mmG=(22 03 13 23 04 14 24 05)
+    ; mmF=(15 25 06 16 26 07 17 27)
+
+    movq      mmD,mmA
+    psllq     mmA,4*BYTE_BIT    ; mmA=(-- -- -- -- 00 10 20 01)
+    psrlq     mmD,4*BYTE_BIT    ; mmD=(11 21 02 12 -- -- -- --)
+
+    punpckhbw mmA,mmG        ; mmA=(00 04 10 14 20 24 01 05)
+    psllq     mmG,4*BYTE_BIT    ; mmG=(-- -- -- -- 22 03 13 23)
+
+    punpcklbw mmD,mmF        ; mmD=(11 15 21 25 02 06 12 16)
+    punpckhbw mmG,mmF        ; mmG=(22 26 03 07 13 17 23 27)
+
+    movq      mmE,mmA
+    psllq     mmA,4*BYTE_BIT    ; mmA=(-- -- -- -- 00 04 10 14)
+    psrlq     mmE,4*BYTE_BIT    ; mmE=(20 24 01 05 -- -- -- --)
+
+    punpckhbw mmA,mmD        ; mmA=(00 02 04 06 10 12 14 16)
+    psllq     mmD,4*BYTE_BIT    ; mmD=(-- -- -- -- 11 15 21 25)
+
+    punpcklbw mmE,mmG        ; mmE=(20 22 24 26 01 03 05 07)
+    punpckhbw mmD,mmG        ; mmD=(11 13 15 17 21 23 25 27)
+
+    pxor      mmH,mmH
+
+    movq      mmC,mmA
+    punpcklbw mmA,mmH        ; mmA=(00 02 04 06)
+    punpckhbw mmC,mmH        ; mmC=(10 12 14 16)
+
+    movq      mmB,mmE
+    punpcklbw mmE,mmH        ; mmE=(20 22 24 26)
+    punpckhbw mmB,mmH        ; mmB=(01 03 05 07)
+
+    movq      mmF,mmD
+    punpcklbw mmD,mmH        ; mmD=(11 13 15 17)
+    punpckhbw mmF,mmH        ; mmF=(21 23 25 27)
+
+%else ; RGB_PIXELSIZE == 4 ; -----------
+
+.column_ld1:
+    test    cl, SIZEOF_MMWORD/8
+    jz    short .column_ld2
+    sub    ecx, byte SIZEOF_MMWORD/8
+    movd    mmA, DWORD [esi+ecx*RGB_PIXELSIZE]
+.column_ld2:
+    test    cl, SIZEOF_MMWORD/4
+    jz    short .column_ld4
+    sub    ecx, byte SIZEOF_MMWORD/4
+    movq    mmF,mmA
+    movq    mmA, MMWORD [esi+ecx*RGB_PIXELSIZE]
+.column_ld4:
+    test    cl, SIZEOF_MMWORD/2
+    mov    ecx, SIZEOF_MMWORD
+    jz    short .rgb_gray_cnv
+    movq    mmD,mmA
+    movq    mmC,mmF
+    movq    mmA, MMWORD [esi+0*SIZEOF_MMWORD]
+    movq    mmF, MMWORD [esi+1*SIZEOF_MMWORD]
+    jmp    short .rgb_gray_cnv
+    alignx    16,7
+
+.columnloop:
+    movq    mmA, MMWORD [esi+0*SIZEOF_MMWORD]
+    movq    mmF, MMWORD [esi+1*SIZEOF_MMWORD]
+    movq    mmD, MMWORD [esi+2*SIZEOF_MMWORD]
+    movq    mmC, MMWORD [esi+3*SIZEOF_MMWORD]
+
+.rgb_gray_cnv:
+    ; mmA=(00 10 20 30 01 11 21 31)
+    ; mmF=(02 12 22 32 03 13 23 33)
+    ; mmD=(04 14 24 34 05 15 25 35)
+    ; mmC=(06 16 26 36 07 17 27 37)
+
+    movq      mmB,mmA
+    punpcklbw mmA,mmF        ; mmA=(00 02 10 12 20 22 30 32)
+    punpckhbw mmB,mmF        ; mmB=(01 03 11 13 21 23 31 33)
+
+    movq      mmG,mmD
+    punpcklbw mmD,mmC        ; mmD=(04 06 14 16 24 26 34 36)
+    punpckhbw mmG,mmC        ; mmG=(05 07 15 17 25 27 35 37)
+
+    movq      mmE,mmA
+    punpcklwd mmA,mmD        ; mmA=(00 02 04 06 10 12 14 16)
+    punpckhwd mmE,mmD        ; mmE=(20 22 24 26 30 32 34 36)
+
+    movq      mmH,mmB
+    punpcklwd mmB,mmG        ; mmB=(01 03 05 07 11 13 15 17)
+    punpckhwd mmH,mmG        ; mmH=(21 23 25 27 31 33 35 37)
+
+    pxor      mmF,mmF
+
+    movq      mmC,mmA
+    punpcklbw mmA,mmF        ; mmA=(00 02 04 06)
+    punpckhbw mmC,mmF        ; mmC=(10 12 14 16)
+
+    movq      mmD,mmB
+    punpcklbw mmB,mmF        ; mmB=(01 03 05 07)
+    punpckhbw mmD,mmF        ; mmD=(11 13 15 17)
+
+    movq      mmG,mmE
+    punpcklbw mmE,mmF        ; mmE=(20 22 24 26)
+    punpckhbw mmG,mmF        ; mmG=(30 32 34 36)
+
+    punpcklbw mmF,mmH
+    punpckhbw mmH,mmH
+    psrlw     mmF,BYTE_BIT        ; mmF=(21 23 25 27)
+    psrlw     mmH,BYTE_BIT        ; mmH=(31 33 35 37)
+
+%endif ; RGB_PIXELSIZE ; ---------------
+
+    ; mm0=(R0 R2 R4 R6)=RE, mm2=(G0 G2 G4 G6)=GE, mm4=(B0 B2 B4 B6)=BE
+    ; mm1=(R1 R3 R5 R7)=RO, mm3=(G1 G3 G5 G7)=GO, mm5=(B1 B3 B5 B7)=BO
+
+    ; (Original)
+    ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
+    ;
+    ; (This implementation)
+    ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
+
+    movq      mm6,mm1
+    punpcklwd mm1,mm3
+    punpckhwd mm6,mm3
+    pmaddwd   mm1,[GOTOFF(eax,PW_F0299_F0337)] ; mm1=ROL*FIX(0.299)+GOL*FIX(0.337)
+    pmaddwd   mm6,[GOTOFF(eax,PW_F0299_F0337)] ; mm6=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    movq      mm7, mm6    ; mm7=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    movq      mm6,mm0
+    punpcklwd mm0,mm2
+    punpckhwd mm6,mm2
+    pmaddwd   mm0,[GOTOFF(eax,PW_F0299_F0337)] ; mm0=REL*FIX(0.299)+GEL*FIX(0.337)
+    pmaddwd   mm6,[GOTOFF(eax,PW_F0299_F0337)] ; mm6=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    movq      MMWORD [wk(0)], mm0    ; wk(0)=REL*FIX(0.299)+GEL*FIX(0.337)
+    movq      MMWORD [wk(1)], mm6    ; wk(1)=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    movq      mm0, mm5    ; mm0=BO
+    movq      mm6, mm4    ; mm6=BE
+
+    movq      mm4,mm0
+    punpcklwd mm0,mm3
+    punpckhwd mm4,mm3
+    pmaddwd   mm0,[GOTOFF(eax,PW_F0114_F0250)] ; mm0=BOL*FIX(0.114)+GOL*FIX(0.250)
+    pmaddwd   mm4,[GOTOFF(eax,PW_F0114_F0250)] ; mm4=BOH*FIX(0.114)+GOH*FIX(0.250)
+
+    movq      mm3,[GOTOFF(eax,PD_ONEHALF)]    ; mm3=[PD_ONEHALF]
+
+    paddd     mm0, mm1
+    paddd     mm4, mm7
+    paddd     mm0,mm3
+    paddd     mm4,mm3
+    psrld     mm0,SCALEBITS        ; mm0=YOL
+    psrld     mm4,SCALEBITS        ; mm4=YOH
+    packssdw  mm0,mm4        ; mm0=YO
+
+    movq      mm4,mm6
+    punpcklwd mm6,mm2
+    punpckhwd mm4,mm2
+    pmaddwd   mm6,[GOTOFF(eax,PW_F0114_F0250)] ; mm6=BEL*FIX(0.114)+GEL*FIX(0.250)
+    pmaddwd   mm4,[GOTOFF(eax,PW_F0114_F0250)] ; mm4=BEH*FIX(0.114)+GEH*FIX(0.250)
+
+    movq      mm2,[GOTOFF(eax,PD_ONEHALF)]    ; mm2=[PD_ONEHALF]
+
+    paddd     mm6, MMWORD [wk(0)]
+    paddd     mm4, MMWORD [wk(1)]
+    paddd     mm6,mm2
+    paddd     mm4,mm2
+    psrld     mm6,SCALEBITS        ; mm6=YEL
+    psrld     mm4,SCALEBITS        ; mm4=YEH
+    packssdw  mm6,mm4        ; mm6=YE
+
+    psllw     mm0,BYTE_BIT
+    por       mm6,mm0        ; mm6=Y
+    movq      MMWORD [edi], mm6    ; Save Y
+
+    sub    ecx, byte SIZEOF_MMWORD
+    add    esi, byte RGB_PIXELSIZE*SIZEOF_MMWORD    ; inptr
+    add    edi, byte SIZEOF_MMWORD            ; outptr0
+    cmp    ecx, byte SIZEOF_MMWORD
+    jae    near .columnloop
+    test    ecx,ecx
+    jnz    near .column_ld1
+
+    pop    ecx            ; col
+    pop    esi
+    pop    edi
+    poppic    eax
+
+    add    esi, byte SIZEOF_JSAMPROW    ; input_buf
+    add    edi, byte SIZEOF_JSAMPROW
+    dec    eax                ; num_rows
+    jg    near .rowloop
+
+    emms        ; empty MMX state
+
+.return:
+    pop    edi
+    pop    esi
+;    pop    edx        ; need not be preserved
+;    pop    ecx        ; need not be preserved
+    pop    ebx
+    mov    esp,ebp        ; esp <- aligned ebp
+    pop    esp        ; esp <- original ebp
+    pop    ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align    16
diff -r 3a99d7ff459c media/libjpeg/simd/jcgryss2-64.asm
--- /dev/null    Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libjpeg/simd/jcgryss2-64.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -0,0 +1,364 @@
+;
+; jcgryss2-64.asm - grayscale colorspace conversion (64-bit SSE2)
+;
+; x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; Copyright (C) 2011, D. R. Commander.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_rgb_gray_convert_sse2 (JDIMENSION img_width,
+;                              JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+;                              JDIMENSION output_row, int num_rows);
+;
+
+; r10 = JDIMENSION img_width
+; r11 = JSAMPARRAY input_buf
+; r12 = JSAMPIMAGE output_buf
+; r13 = JDIMENSION output_row
+; r14 = int num_rows
+
+%define wk(i)        rbp-(WK_NUM-(i))*SIZEOF_XMMWORD    ; xmmword wk[WK_NUM]
+%define WK_NUM        2
+
+    align    16
+
+    global    EXTN(jsimd_rgb_gray_convert_sse2)
+
+EXTN(jsimd_rgb_gray_convert_sse2):
+    push    rbp
+    mov    rax,rsp                ; rax = original rbp
+    sub    rsp, byte 4
+    and    rsp, byte (-SIZEOF_XMMWORD)    ; align to 128 bits
+    mov    [rsp],rax
+    mov    rbp,rsp                ; rbp = aligned rbp
+    lea    rsp, [wk(0)]
+    collect_args
+    push    rbx
+
+    mov    rcx, r10
+    test    rcx,rcx
+    jz    near .return
+
+    push    rcx
+
+    mov rsi, r12
+    mov rcx, r13
+    mov    rdi, JSAMPARRAY [rsi+0*SIZEOF_JSAMPARRAY]
+    lea    rdi, [rdi+rcx*SIZEOF_JSAMPROW]
+
+    pop    rcx
+
+    mov rsi, r11
+    mov    eax, r14d
+    test    rax,rax
+    jle    near .return
+.rowloop:
+    push    rdi
+    push    rsi
+    push    rcx            ; col
+
+    mov    rsi, JSAMPROW [rsi]    ; inptr
+    mov    rdi, JSAMPROW [rdi]    ; outptr0
+
+    cmp    rcx, byte SIZEOF_XMMWORD
+    jae    near .columnloop
+
+%if RGB_PIXELSIZE == 3 ; ---------------
+
+.column_ld1:
+    push    rax
+    push    rdx
+    lea    rcx,[rcx+rcx*2]        ; imul ecx,RGB_PIXELSIZE
+    test    cl, SIZEOF_BYTE
+    jz    short .column_ld2
+    sub    rcx, byte SIZEOF_BYTE
+    movzx    rax, BYTE [rsi+rcx]
+.column_ld2:
+    test    cl, SIZEOF_WORD
+    jz    short .column_ld4
+    sub    rcx, byte SIZEOF_WORD
+    movzx    rdx, WORD [rsi+rcx]
+    shl    rax, WORD_BIT
+    or    rax,rdx
+.column_ld4:
+    movd    xmmA,eax
+    pop    rdx
+    pop    rax
+    test    cl, SIZEOF_DWORD
+    jz    short .column_ld8
+    sub    rcx, byte SIZEOF_DWORD
+    movd    xmmF, XMM_DWORD [rsi+rcx]
+    pslldq    xmmA, SIZEOF_DWORD
+    por    xmmA,xmmF
+.column_ld8:
+    test    cl, SIZEOF_MMWORD
+    jz    short .column_ld16
+    sub    rcx, byte SIZEOF_MMWORD
+    movq    xmmB, XMM_MMWORD [rsi+rcx]
+    pslldq    xmmA, SIZEOF_MMWORD
+    por    xmmA,xmmB
+.column_ld16:
+    test    cl, SIZEOF_XMMWORD
+    jz    short .column_ld32
+    movdqa    xmmF,xmmA
+    movdqu    xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    mov    rcx, SIZEOF_XMMWORD
+    jmp    short .rgb_gray_cnv
+.column_ld32:
+    test    cl, 2*SIZEOF_XMMWORD
+    mov    rcx, SIZEOF_XMMWORD
+    jz    short .rgb_gray_cnv
+    movdqa    xmmB,xmmA
+    movdqu    xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqu    xmmF, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+    jmp    short .rgb_gray_cnv
+
+.columnloop:
+    movdqu    xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqu    xmmF, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+    movdqu    xmmB, XMMWORD [rsi+2*SIZEOF_XMMWORD]
+
+.rgb_gray_cnv:
+    ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
+    ; xmmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    ; xmmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
+
+    movdqa    xmmG,xmmA
+    pslldq    xmmA,8    ; xmmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12)
+    psrldq    xmmG,8    ; xmmG=(22 03 13 23 04 14 24 05 -- -- -- -- -- -- -- --)
+
+    punpckhbw xmmA,xmmF    ; xmmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A)
+    pslldq    xmmF,8    ; xmmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27)
+
+    punpcklbw xmmG,xmmB    ; xmmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D)
+    punpckhbw xmmF,xmmB    ; xmmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F)
+
+    movdqa    xmmD,xmmA
+    pslldq    xmmA,8    ; xmmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09)
+    psrldq    xmmD,8    ; xmmD=(11 19 21 29 02 0A 12 1A -- -- -- -- -- -- -- --)
+
+    punpckhbw xmmA,xmmG    ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D)
+    pslldq    xmmG,8    ; xmmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B)
+
+    punpcklbw xmmD,xmmF    ; xmmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E)
+    punpckhbw xmmG,xmmF    ; xmmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F)
+
+    movdqa    xmmE,xmmA
+    pslldq    xmmA,8    ; xmmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C)
+    psrldq    xmmE,8    ; xmmE=(20 24 28 2C 01 05 09 0D -- -- -- -- -- -- -- --)
+
+    punpckhbw xmmA,xmmD    ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
+    pslldq    xmmD,8    ; xmmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D)
+
+    punpcklbw xmmE,xmmG    ; xmmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F)
+    punpckhbw xmmD,xmmG    ; xmmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F)
+
+    pxor      xmmH,xmmH
+
+    movdqa    xmmC,xmmA
+    punpcklbw xmmA,xmmH    ; xmmA=(00 02 04 06 08 0A 0C 0E)
+    punpckhbw xmmC,xmmH    ; xmmC=(10 12 14 16 18 1A 1C 1E)
+
+    movdqa    xmmB,xmmE
+    punpcklbw xmmE,xmmH    ; xmmE=(20 22 24 26 28 2A 2C 2E)
+    punpckhbw xmmB,xmmH    ; xmmB=(01 03 05 07 09 0B 0D 0F)
+
+    movdqa    xmmF,xmmD
+    punpcklbw xmmD,xmmH    ; xmmD=(11 13 15 17 19 1B 1D 1F)
+    punpckhbw xmmF,xmmH    ; xmmF=(21 23 25 27 29 2B 2D 2F)
+
+%else ; RGB_PIXELSIZE == 4 ; -----------
+
+.column_ld1:
+    test    cl, SIZEOF_XMMWORD/16
+    jz    short .column_ld2
+    sub    rcx, byte SIZEOF_XMMWORD/16
+    movd    xmmA, XMM_DWORD [rsi+rcx*RGB_PIXELSIZE]
+.column_ld2:
+    test    cl, SIZEOF_XMMWORD/8
+    jz    short .column_ld4
+    sub    rcx, byte SIZEOF_XMMWORD/8
+    movq    xmmE, XMM_MMWORD [rsi+rcx*RGB_PIXELSIZE]
+    pslldq    xmmA, SIZEOF_MMWORD
+    por    xmmA,xmmE
+.column_ld4:
+    test    cl, SIZEOF_XMMWORD/4
+    jz    short .column_ld8
+    sub    rcx, byte SIZEOF_XMMWORD/4
+    movdqa    xmmE,xmmA
+    movdqu    xmmA, XMMWORD [rsi+rcx*RGB_PIXELSIZE]
+.column_ld8:
+    test    cl, SIZEOF_XMMWORD/2
+    mov    rcx, SIZEOF_XMMWORD
+    jz    short .rgb_gray_cnv
+    movdqa    xmmF,xmmA
+    movdqa    xmmH,xmmE
+    movdqu    xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqu    xmmE, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+    jmp    short .rgb_gray_cnv
+
+.columnloop:
+    movdqu    xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqu    xmmE, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+    movdqu    xmmF, XMMWORD [rsi+2*SIZEOF_XMMWORD]
+    movdqu    xmmH, XMMWORD [rsi+3*SIZEOF_XMMWORD]
+
+.rgb_gray_cnv:
+    ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
+    ; xmmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    ; xmmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
+    ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+
+    movdqa    xmmD,xmmA
+    punpcklbw xmmA,xmmE    ; xmmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35)
+    punpckhbw xmmD,xmmE    ; xmmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37)
+
+    movdqa    xmmC,xmmF
+    punpcklbw xmmF,xmmH    ; xmmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D)
+    punpckhbw xmmC,xmmH    ; xmmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F)
+
+    movdqa    xmmB,xmmA
+    punpcklwd xmmA,xmmF    ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C)
+    punpckhwd xmmB,xmmF    ; xmmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D)
+
+    movdqa    xmmG,xmmD
+    punpcklwd xmmD,xmmC    ; xmmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E)
+    punpckhwd xmmG,xmmC    ; xmmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F)
+
+    movdqa    xmmE,xmmA
+    punpcklbw xmmA,xmmD    ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
+    punpckhbw xmmE,xmmD    ; xmmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E)
+
+    movdqa    xmmH,xmmB
+    punpcklbw xmmB,xmmG    ; xmmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F)
+    punpckhbw xmmH,xmmG    ; xmmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F)
+
+    pxor      xmmF,xmmF
+
+    movdqa    xmmC,xmmA
+    punpcklbw xmmA,xmmF    ; xmmA=(00 02 04 06 08 0A 0C 0E)
+    punpckhbw xmmC,xmmF    ; xmmC=(10 12 14 16 18 1A 1C 1E)
+
+    movdqa    xmmD,xmmB
+    punpcklbw xmmB,xmmF    ; xmmB=(01 03 05 07 09 0B 0D 0F)
+    punpckhbw xmmD,xmmF    ; xmmD=(11 13 15 17 19 1B 1D 1F)
+
+    movdqa    xmmG,xmmE
+    punpcklbw xmmE,xmmF    ; xmmE=(20 22 24 26 28 2A 2C 2E)
+    punpckhbw xmmG,xmmF    ; xmmG=(30 32 34 36 38 3A 3C 3E)
+
+    punpcklbw xmmF,xmmH
+    punpckhbw xmmH,xmmH
+    psrlw     xmmF,BYTE_BIT    ; xmmF=(21 23 25 27 29 2B 2D 2F)
+    psrlw     xmmH,BYTE_BIT    ; xmmH=(31 33 35 37 39 3B 3D 3F)
+
+%endif ; RGB_PIXELSIZE ; ---------------
+
+    ; xmm0=R(02468ACE)=RE, xmm2=G(02468ACE)=GE, xmm4=B(02468ACE)=BE
+    ; xmm1=R(13579BDF)=RO, xmm3=G(13579BDF)=GO, xmm5=B(13579BDF)=BO
+
+    ; (Original)
+    ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
+    ;
+    ; (This implementation)
+    ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
+
+    movdqa    xmm6,xmm1
+    punpcklwd xmm1,xmm3
+    punpckhwd xmm6,xmm3
+    pmaddwd   xmm1,[rel PW_F0299_F0337] ; xmm1=ROL*FIX(0.299)+GOL*FIX(0.337)
+    pmaddwd   xmm6,[rel PW_F0299_F0337] ; xmm6=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    movdqa    xmm7, xmm6    ; xmm7=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    movdqa    xmm6,xmm0
+    punpcklwd xmm0,xmm2
+    punpckhwd xmm6,xmm2
+    pmaddwd   xmm0,[rel PW_F0299_F0337] ; xmm0=REL*FIX(0.299)+GEL*FIX(0.337)
+    pmaddwd   xmm6,[rel PW_F0299_F0337] ; xmm6=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    movdqa    XMMWORD [wk(0)], xmm0    ; wk(0)=REL*FIX(0.299)+GEL*FIX(0.337)
+    movdqa    XMMWORD [wk(1)], xmm6    ; wk(1)=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    movdqa    xmm0, xmm5    ; xmm0=BO
+    movdqa    xmm6, xmm4    ; xmm6=BE
+
+    movdqa    xmm4,xmm0
+    punpcklwd xmm0,xmm3
+    punpckhwd xmm4,xmm3
+    pmaddwd   xmm0,[rel PW_F0114_F0250] ; xmm0=BOL*FIX(0.114)+GOL*FIX(0.250)
+    pmaddwd   xmm4,[rel PW_F0114_F0250] ; xmm4=BOH*FIX(0.114)+GOH*FIX(0.250)
+
+    movdqa    xmm3,[rel PD_ONEHALF]    ; xmm3=[PD_ONEHALF]
+
+    paddd     xmm0, xmm1
+    paddd     xmm4, xmm7
+    paddd     xmm0,xmm3
+    paddd     xmm4,xmm3
+    psrld     xmm0,SCALEBITS    ; xmm0=YOL
+    psrld     xmm4,SCALEBITS    ; xmm4=YOH
+    packssdw  xmm0,xmm4        ; xmm0=YO
+
+    movdqa    xmm4,xmm6
+    punpcklwd xmm6,xmm2
+    punpckhwd xmm4,xmm2
+    pmaddwd   xmm6,[rel PW_F0114_F0250] ; xmm6=BEL*FIX(0.114)+GEL*FIX(0.250)
+    pmaddwd   xmm4,[rel PW_F0114_F0250] ; xmm4=BEH*FIX(0.114)+GEH*FIX(0.250)
+
+    movdqa    xmm2,[rel PD_ONEHALF]    ; xmm2=[PD_ONEHALF]
+
+    paddd     xmm6, XMMWORD [wk(0)]
+    paddd     xmm4, XMMWORD [wk(1)]
+    paddd     xmm6,xmm2
+    paddd     xmm4,xmm2
+    psrld     xmm6,SCALEBITS    ; xmm6=YEL
+    psrld     xmm4,SCALEBITS    ; xmm4=YEH
+    packssdw  xmm6,xmm4        ; xmm6=YE
+
+    psllw     xmm0,BYTE_BIT
+    por       xmm6,xmm0        ; xmm6=Y
+    movdqa    XMMWORD [rdi], xmm6    ; Save Y
+
+    sub    rcx, byte SIZEOF_XMMWORD
+    add    rsi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD    ; inptr
+    add    rdi, byte SIZEOF_XMMWORD        ; outptr0
+    cmp    rcx, byte SIZEOF_XMMWORD
+    jae    near .columnloop
+    test    rcx,rcx
+    jnz    near .column_ld1
+
+    pop    rcx            ; col
+    pop    rsi
+    pop    rdi
+
+    add    rsi, byte SIZEOF_JSAMPROW    ; input_buf
+    add    rdi, byte SIZEOF_JSAMPROW
+    dec    rax                ; num_rows
+    jg    near .rowloop
+
+.return:
+    pop    rbx
+    uncollect_args
+    mov    rsp,rbp        ; rsp <- aligned rbp
+    pop    rsp        ; rsp <- original rbp
+    pop    rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align    16
diff -r 3a99d7ff459c media/libjpeg/simd/jcgryss2.asm
--- /dev/null    Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libjpeg/simd/jcgryss2.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -0,0 +1,383 @@
+;
+; jcgryss2.asm - grayscale colorspace conversion (SSE2)
+;
+; x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; Copyright (C) 2011, D. R. Commander.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_rgb_gray_convert_sse2 (JDIMENSION img_width,
+;                              JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+;                              JDIMENSION output_row, int num_rows);
+;
+
+%define img_width(b)    (b)+8            ; JDIMENSION img_width
+%define input_buf(b)    (b)+12        ; JSAMPARRAY input_buf
+%define output_buf(b)    (b)+16        ; JSAMPIMAGE output_buf
+%define output_row(b)    (b)+20        ; JDIMENSION output_row
+%define num_rows(b)    (b)+24        ; int num_rows
+
+%define original_ebp    ebp+0
+%define wk(i)        ebp-(WK_NUM-(i))*SIZEOF_XMMWORD    ; xmmword wk[WK_NUM]
+%define WK_NUM        2
+%define gotptr        wk(0)-SIZEOF_POINTER    ; void * gotptr
+
+    align    16
+
+    global    EXTN(jsimd_rgb_gray_convert_sse2)
+
+EXTN(jsimd_rgb_gray_convert_sse2):
+    push    ebp
+    mov    eax,esp                ; eax = original ebp
+    sub    esp, byte 4
+    and    esp, byte (-SIZEOF_XMMWORD)    ; align to 128 bits
+    mov    [esp],eax
+    mov    ebp,esp                ; ebp = aligned ebp
+    lea    esp, [wk(0)]
+    pushpic    eax        ; make a room for GOT address
+    push    ebx
+;    push    ecx        ; need not be preserved
+;    push    edx        ; need not be preserved
+    push    esi
+    push    edi
+
+    get_GOT    ebx            ; get GOT address
+    movpic    POINTER [gotptr], ebx    ; save GOT address
+
+    mov    ecx, JDIMENSION [img_width(eax)]
+    test    ecx,ecx
+    jz    near .return
+
+    push    ecx
+
+    mov    esi, JSAMPIMAGE [output_buf(eax)]
+    mov    ecx, JDIMENSION [output_row(eax)]
+    mov    edi, JSAMPARRAY [esi+0*SIZEOF_JSAMPARRAY]
+    lea    edi, [edi+ecx*SIZEOF_JSAMPROW]
+
+    pop    ecx
+
+    mov    esi, JSAMPARRAY [input_buf(eax)]
+    mov    eax, INT [num_rows(eax)]
+    test    eax,eax
+    jle    near .return
+    alignx    16,7
+.rowloop:
+    pushpic    eax
+    push    edi
+    push    esi
+    push    ecx            ; col
+
+    mov    esi, JSAMPROW [esi]    ; inptr
+    mov    edi, JSAMPROW [edi]    ; outptr0
+    movpic    eax, POINTER [gotptr]    ; load GOT address (eax)
+
+    cmp    ecx, byte SIZEOF_XMMWORD
+    jae    near .columnloop
+    alignx    16,7
+
+%if RGB_PIXELSIZE == 3 ; ---------------
+
+.column_ld1:
+    push    eax
+    push    edx
+    lea    ecx,[ecx+ecx*2]        ; imul ecx,RGB_PIXELSIZE
+    test    cl, SIZEOF_BYTE
+    jz    short .column_ld2
+    sub    ecx, byte SIZEOF_BYTE
+    movzx    eax, BYTE [esi+ecx]
+.column_ld2:
+    test    cl, SIZEOF_WORD
+    jz    short .column_ld4
+    sub    ecx, byte SIZEOF_WORD
+    movzx    edx, WORD [esi+ecx]
+    shl    eax, WORD_BIT
+    or    eax,edx
+.column_ld4:
+    movd    xmmA,eax
+    pop    edx
+    pop    eax
+    test    cl, SIZEOF_DWORD
+    jz    short .column_ld8
+    sub    ecx, byte SIZEOF_DWORD
+    movd    xmmF, XMM_DWORD [esi+ecx]
+    pslldq    xmmA, SIZEOF_DWORD
+    por    xmmA,xmmF
+.column_ld8:
+    test    cl, SIZEOF_MMWORD
+    jz    short .column_ld16
+    sub    ecx, byte SIZEOF_MMWORD
+    movq    xmmB, XMM_MMWORD [esi+ecx]
+    pslldq    xmmA, SIZEOF_MMWORD
+    por    xmmA,xmmB
+.column_ld16:
+    test    cl, SIZEOF_XMMWORD
+    jz    short .column_ld32
+    movdqa    xmmF,xmmA
+    movdqu    xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    mov    ecx, SIZEOF_XMMWORD
+    jmp    short .rgb_gray_cnv
+.column_ld32:
+    test    cl, 2*SIZEOF_XMMWORD
+    mov    ecx, SIZEOF_XMMWORD
+    jz    short .rgb_gray_cnv
+    movdqa    xmmB,xmmA
+    movdqu    xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqu    xmmF, XMMWORD [esi+1*SIZEOF_XMMWORD]
+    jmp    short .rgb_gray_cnv
+    alignx    16,7
+
+.columnloop:
+    movdqu    xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqu    xmmF, XMMWORD [esi+1*SIZEOF_XMMWORD]
+    movdqu    xmmB, XMMWORD [esi+2*SIZEOF_XMMWORD]
+
+.rgb_gray_cnv:
+    ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
+    ; xmmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    ; xmmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
+
+    movdqa    xmmG,xmmA
+    pslldq    xmmA,8    ; xmmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12)
+    psrldq    xmmG,8    ; xmmG=(22 03 13 23 04 14 24 05 -- -- -- -- -- -- -- --)
+
+    punpckhbw xmmA,xmmF    ; xmmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A)
+    pslldq    xmmF,8    ; xmmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27)
+
+    punpcklbw xmmG,xmmB    ; xmmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D)
+    punpckhbw xmmF,xmmB    ; xmmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F)
+
+    movdqa    xmmD,xmmA
+    pslldq    xmmA,8    ; xmmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09)
+    psrldq    xmmD,8    ; xmmD=(11 19 21 29 02 0A 12 1A -- -- -- -- -- -- -- --)
+
+    punpckhbw xmmA,xmmG    ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D)
+    pslldq    xmmG,8    ; xmmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B)
+
+    punpcklbw xmmD,xmmF    ; xmmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E)
+    punpckhbw xmmG,xmmF    ; xmmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F)
+
+    movdqa    xmmE,xmmA
+    pslldq    xmmA,8    ; xmmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C)
+    psrldq    xmmE,8    ; xmmE=(20 24 28 2C 01 05 09 0D -- -- -- -- -- -- -- --)
+
+    punpckhbw xmmA,xmmD    ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
+    pslldq    xmmD,8    ; xmmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D)
+
+    punpcklbw xmmE,xmmG    ; xmmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F)
+    punpckhbw xmmD,xmmG    ; xmmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F)
+
+    pxor      xmmH,xmmH
+
+    movdqa    xmmC,xmmA
+    punpcklbw xmmA,xmmH    ; xmmA=(00 02 04 06 08 0A 0C 0E)
+    punpckhbw xmmC,xmmH    ; xmmC=(10 12 14 16 18 1A 1C 1E)
+
+    movdqa    xmmB,xmmE
+    punpcklbw xmmE,xmmH    ; xmmE=(20 22 24 26 28 2A 2C 2E)
+    punpckhbw xmmB,xmmH    ; xmmB=(01 03 05 07 09 0B 0D 0F)
+
+    movdqa    xmmF,xmmD
+    punpcklbw xmmD,xmmH    ; xmmD=(11 13 15 17 19 1B 1D 1F)
+    punpckhbw xmmF,xmmH    ; xmmF=(21 23 25 27 29 2B 2D 2F)
+
+%else ; RGB_PIXELSIZE == 4 ; -----------
+
+.column_ld1:
+    test    cl, SIZEOF_XMMWORD/16
+    jz    short .column_ld2
+    sub    ecx, byte SIZEOF_XMMWORD/16
+    movd    xmmA, XMM_DWORD [esi+ecx*RGB_PIXELSIZE]
+.column_ld2:
+    test    cl, SIZEOF_XMMWORD/8
+    jz    short .column_ld4
+    sub    ecx, byte SIZEOF_XMMWORD/8
+    movq    xmmE, XMM_MMWORD [esi+ecx*RGB_PIXELSIZE]
+    pslldq    xmmA, SIZEOF_MMWORD
+    por    xmmA,xmmE
+.column_ld4:
+    test    cl, SIZEOF_XMMWORD/4
+    jz    short .column_ld8
+    sub    ecx, byte SIZEOF_XMMWORD/4
+    movdqa    xmmE,xmmA
+    movdqu    xmmA, XMMWORD [esi+ecx*RGB_PIXELSIZE]
+.column_ld8:
+    test    cl, SIZEOF_XMMWORD/2
+    mov    ecx, SIZEOF_XMMWORD
+    jz    short .rgb_gray_cnv
+    movdqa    xmmF,xmmA
+    movdqa    xmmH,xmmE
+    movdqu    xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqu    xmmE, XMMWORD [esi+1*SIZEOF_XMMWORD]
+    jmp    short .rgb_gray_cnv
+    alignx    16,7
+
+.columnloop:
+    movdqu    xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqu    xmmE, XMMWORD [esi+1*SIZEOF_XMMWORD]
+    movdqu    xmmF, XMMWORD [esi+2*SIZEOF_XMMWORD]
+    movdqu    xmmH, XMMWORD [esi+3*SIZEOF_XMMWORD]
+
+.rgb_gray_cnv:
+    ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
+    ; xmmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    ; xmmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
+    ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+
+    movdqa    xmmD,xmmA
+    punpcklbw xmmA,xmmE    ; xmmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35)
+    punpckhbw xmmD,xmmE    ; xmmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37)
+
+    movdqa    xmmC,xmmF
+    punpcklbw xmmF,xmmH    ; xmmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D)
+    punpckhbw xmmC,xmmH    ; xmmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F)
+
+    movdqa    xmmB,xmmA
+    punpcklwd xmmA,xmmF    ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C)
+    punpckhwd xmmB,xmmF    ; xmmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D)
+
+    movdqa    xmmG,xmmD
+    punpcklwd xmmD,xmmC    ; xmmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E)
+    punpckhwd xmmG,xmmC    ; xmmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F)
+
+    movdqa    xmmE,xmmA
+    punpcklbw xmmA,xmmD    ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
+    punpckhbw xmmE,xmmD    ; xmmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E)
+
+    movdqa    xmmH,xmmB
+    punpcklbw xmmB,xmmG    ; xmmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F)
+    punpckhbw xmmH,xmmG    ; xmmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F)
+
+    pxor      xmmF,xmmF
+
+    movdqa    xmmC,xmmA
+    punpcklbw xmmA,xmmF    ; xmmA=(00 02 04 06 08 0A 0C 0E)
+    punpckhbw xmmC,xmmF    ; xmmC=(10 12 14 16 18 1A 1C 1E)
+
+    movdqa    xmmD,xmmB
+    punpcklbw xmmB,xmmF    ; xmmB=(01 03 05 07 09 0B 0D 0F)
+    punpckhbw xmmD,xmmF    ; xmmD=(11 13 15 17 19 1B 1D 1F)
+
+    movdqa    xmmG,xmmE
+    punpcklbw xmmE,xmmF    ; xmmE=(20 22 24 26 28 2A 2C 2E)
+    punpckhbw xmmG,xmmF    ; xmmG=(30 32 34 36 38 3A 3C 3E)
+
+    punpcklbw xmmF,xmmH
+    punpckhbw xmmH,xmmH
+    psrlw     xmmF,BYTE_BIT    ; xmmF=(21 23 25 27 29 2B 2D 2F)
+    psrlw     xmmH,BYTE_BIT    ; xmmH=(31 33 35 37 39 3B 3D 3F)
+
+%endif ; RGB_PIXELSIZE ; ---------------
+
+    ; xmm0=R(02468ACE)=RE, xmm2=G(02468ACE)=GE, xmm4=B(02468ACE)=BE
+    ; xmm1=R(13579BDF)=RO, xmm3=G(13579BDF)=GO, xmm5=B(13579BDF)=BO
+
+    ; (Original)
+    ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
+    ;
+    ; (This implementation)
+    ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
+
+    movdqa    xmm6,xmm1
+    punpcklwd xmm1,xmm3
+    punpckhwd xmm6,xmm3
+    pmaddwd   xmm1,[GOTOFF(eax,PW_F0299_F0337)] ; xmm1=ROL*FIX(0.299)+GOL*FIX(0.337)
+    pmaddwd   xmm6,[GOTOFF(eax,PW_F0299_F0337)] ; xmm6=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    movdqa    xmm7, xmm6    ; xmm7=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    movdqa    xmm6,xmm0
+    punpcklwd xmm0,xmm2
+    punpckhwd xmm6,xmm2
+    pmaddwd   xmm0,[GOTOFF(eax,PW_F0299_F0337)] ; xmm0=REL*FIX(0.299)+GEL*FIX(0.337)
+    pmaddwd   xmm6,[GOTOFF(eax,PW_F0299_F0337)] ; xmm6=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    movdqa    XMMWORD [wk(0)], xmm0    ; wk(0)=REL*FIX(0.299)+GEL*FIX(0.337)
+    movdqa    XMMWORD [wk(1)], xmm6    ; wk(1)=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    movdqa    xmm0, xmm5    ; xmm0=BO
+    movdqa    xmm6, xmm4    ; xmm6=BE
+
+    movdqa    xmm4,xmm0
+    punpcklwd xmm0,xmm3
+    punpckhwd xmm4,xmm3
+    pmaddwd   xmm0,[GOTOFF(eax,PW_F0114_F0250)] ; xmm0=BOL*FIX(0.114)+GOL*FIX(0.250)
+    pmaddwd   xmm4,[GOTOFF(eax,PW_F0114_F0250)] ; xmm4=BOH*FIX(0.114)+GOH*FIX(0.250)
+
+    movdqa    xmm3,[GOTOFF(eax,PD_ONEHALF)]    ; xmm3=[PD_ONEHALF]
+
+    paddd     xmm0, xmm1
+    paddd     xmm4, xmm7
+    paddd     xmm0,xmm3
+    paddd     xmm4,xmm3
+    psrld     xmm0,SCALEBITS    ; xmm0=YOL
+    psrld     xmm4,SCALEBITS    ; xmm4=YOH
+    packssdw  xmm0,xmm4        ; xmm0=YO
+
+    movdqa    xmm4,xmm6
+    punpcklwd xmm6,xmm2
+    punpckhwd xmm4,xmm2
+    pmaddwd   xmm6,[GOTOFF(eax,PW_F0114_F0250)] ; xmm6=BEL*FIX(0.114)+GEL*FIX(0.250)
+    pmaddwd   xmm4,[GOTOFF(eax,PW_F0114_F0250)] ; xmm4=BEH*FIX(0.114)+GEH*FIX(0.250)
+
+    movdqa    xmm2,[GOTOFF(eax,PD_ONEHALF)]    ; xmm2=[PD_ONEHALF]
+
+    paddd     xmm6, XMMWORD [wk(0)]
+    paddd     xmm4, XMMWORD [wk(1)]
+    paddd     xmm6,xmm2
+    paddd     xmm4,xmm2
+    psrld     xmm6,SCALEBITS    ; xmm6=YEL
+    psrld     xmm4,SCALEBITS    ; xmm4=YEH
+    packssdw  xmm6,xmm4        ; xmm6=YE
+
+    psllw     xmm0,BYTE_BIT
+    por       xmm6,xmm0        ; xmm6=Y
+    movdqa    XMMWORD [edi], xmm6    ; Save Y
+
+    sub    ecx, byte SIZEOF_XMMWORD
+    add    esi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD    ; inptr
+    add    edi, byte SIZEOF_XMMWORD        ; outptr0
+    cmp    ecx, byte SIZEOF_XMMWORD
+    jae    near .columnloop
+    test    ecx,ecx
+    jnz    near .column_ld1
+
+    pop    ecx            ; col
+    pop    esi
+    pop    edi
+    poppic    eax
+
+    add    esi, byte SIZEOF_JSAMPROW    ; input_buf
+    add    edi, byte SIZEOF_JSAMPROW
+    dec    eax                ; num_rows
+    jg    near .rowloop
+
+.return:
+    pop    edi
+    pop    esi
+;    pop    edx        ; need not be preserved
+;    pop    ecx        ; need not be preserved
+    pop    ebx
+    mov    esp,ebp        ; esp <- aligned ebp
+    pop    esp        ; esp <- original ebp
+    pop    ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align    16
diff -r 3a99d7ff459c media/libjpeg/simd/jdclrmmx.asm
--- a/media/libjpeg/simd/jdclrmmx.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdclrmmx.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -19,8 +19,6 @@
 %include "jcolsamp.inc"
 
 ; --------------------------------------------------------------------------
-    SECTION    SEG_TEXT
-    BITS    32
 ;
 ; Convert some rows of samples to the output colorspace.
 ;
diff -r 3a99d7ff459c media/libjpeg/simd/jdclrss2-64.asm
--- a/media/libjpeg/simd/jdclrss2-64.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdclrss2-64.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -20,8 +20,6 @@
 %include "jcolsamp.inc"
                 
 ; --------------------------------------------------------------------------
-    SECTION    SEG_TEXT
-    BITS    64
 ;
 ; Convert some rows of samples to the output colorspace.
 ;
@@ -292,6 +290,41 @@
     movdqa    xmmA,xmmD
     sub    rcx, byte SIZEOF_XMMWORD
 .column_st15:
+%ifdef STRICT_MEMORY_ACCESS
+    ; Store the lower 8 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp    rcx, byte SIZEOF_MMWORD
+    jb    short .column_st7
+    movq    MMWORD [rdi], xmmA
+    add    rdi, byte SIZEOF_MMWORD
+    sub    rcx, byte SIZEOF_MMWORD
+    psrldq    xmmA, SIZEOF_MMWORD
+.column_st7:
+    ; Store the lower 4 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp    rcx, byte SIZEOF_DWORD
+    jb    short .column_st3
+    movd    DWORD [rdi], xmmA
+    add    rdi, byte SIZEOF_DWORD
+    sub    rcx, byte SIZEOF_DWORD
+    psrldq    xmmA, SIZEOF_DWORD
+.column_st3:
+    ; Store the lower 2 bytes of rax to the output when it has enough
+    ; space.
+    movd    eax, xmmA
+    cmp    rcx, byte SIZEOF_WORD
+    jb    short .column_st1
+    mov    WORD [rdi], ax
+    add    rdi, byte SIZEOF_WORD
+    sub    rcx, byte SIZEOF_WORD
+    shr    rax, 16
+.column_st1:
+    ; Store the lower 1 byte of rax to the output when it has enough
+    ; space.
+    test    rcx, rcx
+    jz    short .nextrow
+    mov    BYTE [rdi], al
+%else
     mov    rax,rcx
     xor    rcx, byte 0x0F
     shl    rcx, 2
@@ -331,6 +364,7 @@
     por    xmmE,xmmC
 .adj0:    ; ----------------
     maskmovdqu xmmA,xmmE            ; movntdqu XMMWORD [rdi], xmmA
+%endif ; STRICT_MEMORY_ACCESS ; ---------------
 
 %else ; RGB_PIXELSIZE == 4 ; -----------
 
@@ -415,6 +449,22 @@
     movdqa    xmmA,xmmD
     sub    rcx, byte SIZEOF_XMMWORD/4
 .column_st15:
+%ifdef STRICT_MEMORY_ACCESS
+    ; Store two pixels (8 bytes) of xmmA to the output when it has enough
+    ; space.
+    cmp    rcx, byte SIZEOF_XMMWORD/8
+    jb    short .column_st7
+    movq    MMWORD [rdi], xmmA
+    add    rdi, byte SIZEOF_XMMWORD/8*4
+    sub    rcx, byte SIZEOF_XMMWORD/8
+    psrldq    xmmA, SIZEOF_XMMWORD/8*4
+.column_st7:
+    ; Store one pixel (4 bytes) of xmmA to the output when it has enough
+    ; space.
+    test    rcx, rcx
+    jz    short .nextrow
+    movd    DWORD [rdi], xmmA
+%else
     cmp    rcx, byte SIZEOF_XMMWORD/16
     jb    near .nextrow
     mov    rax,rcx
@@ -454,6 +504,7 @@
     por    xmmE,xmmG
 .adj0:    ; ----------------
     maskmovdqu xmmA,xmmE            ; movntdqu XMMWORD [rdi], xmmA
+%endif ; STRICT_MEMORY_ACCESS ; ---------------
 
 %endif ; RGB_PIXELSIZE ; ---------------
 
diff -r 3a99d7ff459c media/libjpeg/simd/jdclrss2.asm
--- a/media/libjpeg/simd/jdclrss2.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdclrss2.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -19,8 +19,6 @@
 %include "jcolsamp.inc"
                 
 ; --------------------------------------------------------------------------
-    SECTION    SEG_TEXT
-    BITS    32
 ;
 ; Convert some rows of samples to the output colorspace.
 ;
@@ -304,6 +302,41 @@
     movdqa    xmmA,xmmD
     sub    ecx, byte SIZEOF_XMMWORD
 .column_st15:
+%ifdef STRICT_MEMORY_ACCESS
+    ; Store the lower 8 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp    ecx, byte SIZEOF_MMWORD
+    jb    short .column_st7
+    movq    MMWORD [edi], xmmA
+    add    edi, byte SIZEOF_MMWORD
+    sub    ecx, byte SIZEOF_MMWORD
+    psrldq    xmmA, SIZEOF_MMWORD
+.column_st7:
+    ; Store the lower 4 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp    ecx, byte SIZEOF_DWORD
+    jb    short .column_st3
+    movd    DWORD [edi], xmmA
+    add    edi, byte SIZEOF_DWORD
+    sub    ecx, byte SIZEOF_DWORD
+    psrldq    xmmA, SIZEOF_DWORD
+.column_st3:
+    ; Store the lower 2 bytes of eax to the output when it has enough
+    ; space.
+    movd    eax, xmmA
+    cmp    ecx, byte SIZEOF_WORD
+    jb    short .column_st1
+    mov    WORD [edi], ax
+    add    edi, byte SIZEOF_WORD
+    sub    ecx, byte SIZEOF_WORD
+    shr    eax, 16
+.column_st1:
+    ; Store the lower 1 byte of eax to the output when it has enough
+    ; space.
+    test    ecx, ecx
+    jz    short .nextrow
+    mov    BYTE [edi], al
+%else
     mov    eax,ecx
     xor    ecx, byte 0x0F
     shl    ecx, 2
@@ -343,6 +376,7 @@
     por    xmmE,xmmC
 .adj0:    ; ----------------
     maskmovdqu xmmA,xmmE            ; movntdqu XMMWORD [edi], xmmA
+%endif ; STRICT_MEMORY_ACCESS ; ---------------
 
 %else ; RGB_PIXELSIZE == 4 ; -----------
 
@@ -428,6 +462,22 @@
     movdqa    xmmA,xmmD
     sub    ecx, byte SIZEOF_XMMWORD/4
 .column_st15:
+%ifdef STRICT_MEMORY_ACCESS
+    ; Store two pixels (8 bytes) of xmmA to the output when it has enough
+    ; space.
+    cmp    ecx, byte SIZEOF_XMMWORD/8
+    jb    short .column_st7
+    movq    MMWORD [edi], xmmA
+    add    edi, byte SIZEOF_XMMWORD/8*4
+    sub    ecx, byte SIZEOF_XMMWORD/8
+    psrldq    xmmA, SIZEOF_XMMWORD/8*4
+.column_st7:
+    ; Store one pixel (4 bytes) of xmmA to the output when it has enough
+    ; space.
+    test    ecx, ecx
+    jz    short .nextrow
+    movd    DWORD [edi], xmmA
+%else
     cmp    ecx, byte SIZEOF_XMMWORD/16
     jb    short .nextrow
     mov    eax,ecx
@@ -467,6 +517,7 @@
     por    xmmE,xmmG
 .adj0:    ; ----------------
     maskmovdqu xmmA,xmmE            ; movntdqu XMMWORD [edi], xmmA
+%endif ; STRICT_MEMORY_ACCESS ; ---------------
 
 %endif ; RGB_PIXELSIZE ; ---------------
 
diff -r 3a99d7ff459c media/libjpeg/simd/jdcolmmx.asm
--- a/media/libjpeg/simd/jdcolmmx.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdcolmmx.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -48,16 +48,19 @@
     alignz    16
 
 ; --------------------------------------------------------------------------
+    SECTION    SEG_TEXT
+    BITS    32
+
 %include "jdclrmmx.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
 %define jsimd_ycc_rgb_convert_mmx jsimd_ycc_extrgb_convert_mmx
 %include "jdclrmmx.asm"
 
@@ -65,10 +68,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
 %define jsimd_ycc_rgb_convert_mmx jsimd_ycc_extrgbx_convert_mmx
 %include "jdclrmmx.asm"
 
@@ -76,10 +79,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
 %define jsimd_ycc_rgb_convert_mmx jsimd_ycc_extbgr_convert_mmx
 %include "jdclrmmx.asm"
 
@@ -87,10 +90,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
 %define jsimd_ycc_rgb_convert_mmx jsimd_ycc_extbgrx_convert_mmx
 %include "jdclrmmx.asm"
 
@@ -98,10 +101,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 3
-%define RGB_GREEN 2
-%define RGB_BLUE 1
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
 %define jsimd_ycc_rgb_convert_mmx jsimd_ycc_extxbgr_convert_mmx
 %include "jdclrmmx.asm"
 
@@ -109,9 +112,9 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 1
-%define RGB_GREEN 2
-%define RGB_BLUE 3
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
 %define jsimd_ycc_rgb_convert_mmx jsimd_ycc_extxrgb_convert_mmx
 %include "jdclrmmx.asm"
diff -r 3a99d7ff459c media/libjpeg/simd/jdcolss2-64.asm
--- a/media/libjpeg/simd/jdcolss2-64.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdcolss2-64.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -48,16 +48,19 @@
     alignz    16
 
 ; --------------------------------------------------------------------------
+    SECTION    SEG_TEXT
+    BITS    64
+
 %include "jdclrss2-64.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extrgb_convert_sse2
 %include "jdclrss2-64.asm"
 
@@ -65,10 +68,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extrgbx_convert_sse2
 %include "jdclrss2-64.asm"
 
@@ -76,10 +79,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extbgr_convert_sse2
 %include "jdclrss2-64.asm"
 
@@ -87,10 +90,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extbgrx_convert_sse2
 %include "jdclrss2-64.asm"
 
@@ -98,10 +101,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 3
-%define RGB_GREEN 2
-%define RGB_BLUE 1
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extxbgr_convert_sse2
 %include "jdclrss2-64.asm"
 
@@ -109,9 +112,9 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 1
-%define RGB_GREEN 2
-%define RGB_BLUE 3
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extxrgb_convert_sse2
 %include "jdclrss2-64.asm"
diff -r 3a99d7ff459c media/libjpeg/simd/jdcolss2.asm
--- a/media/libjpeg/simd/jdcolss2.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdcolss2.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -48,16 +48,19 @@
     alignz    16
 
 ; --------------------------------------------------------------------------
+    SECTION    SEG_TEXT
+    BITS    32
+
 %include "jdclrss2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extrgb_convert_sse2
 %include "jdclrss2.asm"
 
@@ -65,10 +68,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extrgbx_convert_sse2
 %include "jdclrss2.asm"
 
@@ -76,10 +79,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extbgr_convert_sse2
 %include "jdclrss2.asm"
 
@@ -87,10 +90,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extbgrx_convert_sse2
 %include "jdclrss2.asm"
 
@@ -98,10 +101,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 3
-%define RGB_GREEN 2
-%define RGB_BLUE 1
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extxbgr_convert_sse2
 %include "jdclrss2.asm"
 
@@ -109,9 +112,9 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 1
-%define RGB_GREEN 2
-%define RGB_BLUE 3
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extxrgb_convert_sse2
 %include "jdclrss2.asm"
diff -r 3a99d7ff459c media/libjpeg/simd/jdmermmx.asm
--- a/media/libjpeg/simd/jdmermmx.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdmermmx.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -48,16 +48,19 @@
     alignz    16
 
 ; --------------------------------------------------------------------------
+    SECTION    SEG_TEXT
+    BITS    32
+
 %include "jdmrgmmx.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_mmx jsimd_h2v1_extrgb_merged_upsample_mmx
 %define jsimd_h2v2_merged_upsample_mmx jsimd_h2v2_extrgb_merged_upsample_mmx
 %include "jdmrgmmx.asm"
@@ -66,10 +69,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_mmx jsimd_h2v1_extrgbx_merged_upsample_mmx
 %define jsimd_h2v2_merged_upsample_mmx jsimd_h2v2_extrgbx_merged_upsample_mmx
 %include "jdmrgmmx.asm"
@@ -78,10 +81,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_mmx jsimd_h2v1_extbgr_merged_upsample_mmx
 %define jsimd_h2v2_merged_upsample_mmx jsimd_h2v2_extbgr_merged_upsample_mmx
 %include "jdmrgmmx.asm"
@@ -90,10 +93,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_mmx jsimd_h2v1_extbgrx_merged_upsample_mmx
 %define jsimd_h2v2_merged_upsample_mmx jsimd_h2v2_extbgrx_merged_upsample_mmx
 %include "jdmrgmmx.asm"
@@ -102,10 +105,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 3
-%define RGB_GREEN 2
-%define RGB_BLUE 1
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_mmx jsimd_h2v1_extxbgr_merged_upsample_mmx
 %define jsimd_h2v2_merged_upsample_mmx jsimd_h2v2_extxbgr_merged_upsample_mmx
 %include "jdmrgmmx.asm"
@@ -114,10 +117,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 1
-%define RGB_GREEN 2
-%define RGB_BLUE 3
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_mmx jsimd_h2v1_extxrgb_merged_upsample_mmx
 %define jsimd_h2v2_merged_upsample_mmx jsimd_h2v2_extxrgb_merged_upsample_mmx
 %include "jdmrgmmx.asm"
diff -r 3a99d7ff459c media/libjpeg/simd/jdmerss2-64.asm
--- a/media/libjpeg/simd/jdmerss2-64.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdmerss2-64.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -48,16 +48,19 @@
     alignz    16
 
 ; --------------------------------------------------------------------------
+    SECTION    SEG_TEXT
+    BITS    64
+
 %include "jdmrgss2-64.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extrgb_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extrgb_merged_upsample_sse2
 %include "jdmrgss2-64.asm"
@@ -66,10 +69,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extrgbx_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extrgbx_merged_upsample_sse2
 %include "jdmrgss2-64.asm"
@@ -78,10 +81,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extbgr_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extbgr_merged_upsample_sse2
 %include "jdmrgss2-64.asm"
@@ -90,10 +93,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extbgrx_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extbgrx_merged_upsample_sse2
 %include "jdmrgss2-64.asm"
@@ -102,10 +105,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 3
-%define RGB_GREEN 2
-%define RGB_BLUE 1
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extxbgr_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extxbgr_merged_upsample_sse2
 %include "jdmrgss2-64.asm"
@@ -114,10 +117,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 1
-%define RGB_GREEN 2
-%define RGB_BLUE 3
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extxrgb_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extxrgb_merged_upsample_sse2
 %include "jdmrgss2-64.asm"
diff -r 3a99d7ff459c media/libjpeg/simd/jdmerss2.asm
--- a/media/libjpeg/simd/jdmerss2.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdmerss2.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -48,16 +48,19 @@
     alignz    16
 
 ; --------------------------------------------------------------------------
+    SECTION    SEG_TEXT
+    BITS    32
+
 %include "jdmrgss2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extrgb_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extrgb_merged_upsample_sse2
 %include "jdmrgss2.asm"
@@ -66,10 +69,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 0
-%define RGB_GREEN 1
-%define RGB_BLUE 2
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extrgbx_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extrgbx_merged_upsample_sse2
 %include "jdmrgss2.asm"
@@ -78,10 +81,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 3
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extbgr_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extbgr_merged_upsample_sse2
 %include "jdmrgss2.asm"
@@ -90,10 +93,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 2
-%define RGB_GREEN 1
-%define RGB_BLUE 0
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extbgrx_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extbgrx_merged_upsample_sse2
 %include "jdmrgss2.asm"
@@ -102,10 +105,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 3
-%define RGB_GREEN 2
-%define RGB_BLUE 1
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extxbgr_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extxbgr_merged_upsample_sse2
 %include "jdmrgss2.asm"
@@ -114,10 +117,10 @@
 %undef RGB_GREEN
 %undef RGB_BLUE
 %undef RGB_PIXELSIZE
-%define RGB_RED 1
-%define RGB_GREEN 2
-%define RGB_BLUE 3
-%define RGB_PIXELSIZE 4
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extxrgb_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extxrgb_merged_upsample_sse2
 %include "jdmrgss2.asm"
diff -r 3a99d7ff459c media/libjpeg/simd/jdmrgmmx.asm
--- a/media/libjpeg/simd/jdmrgmmx.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdmrgmmx.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -19,8 +19,6 @@
 %include "jcolsamp.inc"
 
 ; --------------------------------------------------------------------------
-    SECTION    SEG_TEXT
-    BITS    32
 ;
 ; Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
 ;
diff -r 3a99d7ff459c media/libjpeg/simd/jdmrgss2-64.asm
--- a/media/libjpeg/simd/jdmrgss2-64.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdmrgss2-64.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -20,8 +20,6 @@
 %include "jcolsamp.inc"
                 
 ; --------------------------------------------------------------------------
-    SECTION    SEG_TEXT
-    BITS    64
 ;
 ; Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
 ;
@@ -296,6 +294,41 @@
     movdqa    xmmA,xmmD
     sub    rcx, byte SIZEOF_XMMWORD
 .column_st15:
+%ifdef STRICT_MEMORY_ACCESS
+    ; Store the lower 8 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp    rcx, byte SIZEOF_MMWORD
+    jb    short .column_st7
+    movq    MMWORD [rdi], xmmA
+    add    rdi, byte SIZEOF_MMWORD
+    sub    rcx, byte SIZEOF_MMWORD
+    psrldq    xmmA, SIZEOF_MMWORD
+.column_st7:
+    ; Store the lower 4 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp    rcx, byte SIZEOF_DWORD
+    jb    short .column_st3
+    movd    DWORD [rdi], xmmA
+    add    rdi, byte SIZEOF_DWORD
+    sub    rcx, byte SIZEOF_DWORD
+    psrldq    xmmA, SIZEOF_DWORD
+.column_st3:
+    ; Store the lower 2 bytes of rax to the output when it has enough
+    ; space.
+    movd    eax, xmmA
+    cmp    rcx, byte SIZEOF_WORD
+    jb    short .column_st1
+    mov    WORD [rdi], ax
+    add    rdi, byte SIZEOF_WORD
+    sub    rcx, byte SIZEOF_WORD
+    shr    rax, 16
+.column_st1:
+    ; Store the lower 1 byte of rax to the output when it has enough
+    ; space.
+    test    rcx, rcx
+    jz    short .endcolumn
+    mov    BYTE [rdi], al
+%else
     mov    rax,rcx
     xor    rcx, byte 0x0F
     shl    rcx, 2
@@ -335,6 +368,7 @@
     por    xmmE,xmmC
 .adj0:    ; ----------------
     maskmovdqu xmmA,xmmE            ; movntdqu XMMWORD [edi], xmmA
+%endif ; STRICT_MEMORY_ACCESS ; ---------------
 
 %else ; RGB_PIXELSIZE == 4 ; -----------
 
@@ -422,6 +456,22 @@
     movdqa    xmmA,xmmD
     sub    rcx, byte SIZEOF_XMMWORD/4
 .column_st15:
+%ifdef STRICT_MEMORY_ACCESS
+    ; Store two pixels (8 bytes) of xmmA to the output when it has enough
+    ; space.
+    cmp    rcx, byte SIZEOF_XMMWORD/8
+    jb    short .column_st7
+    movq    MMWORD [rdi], xmmA
+    add    rdi, byte SIZEOF_XMMWORD/8*4
+    sub    rcx, byte SIZEOF_XMMWORD/8
+    psrldq    xmmA, SIZEOF_XMMWORD/8*4
+.column_st7:
+    ; Store one pixel (4 bytes) of xmmA to the output when it has enough
+    ; space.
+    test    rcx, rcx
+    jz    short .endcolumn
+    movd    DWORD [rdi], xmmA
+%else
     cmp    rcx, byte SIZEOF_XMMWORD/16
     jb    near .endcolumn
     mov    rax,rcx
@@ -461,6 +511,7 @@
     por    xmmE,xmmG
 .adj0:    ; ----------------
     maskmovdqu xmmA,xmmE            ; movntdqu XMMWORD [edi], xmmA
+%endif ; STRICT_MEMORY_ACCESS ; ---------------
 
 %endif ; RGB_PIXELSIZE ; ---------------
 
diff -r 3a99d7ff459c media/libjpeg/simd/jdmrgss2.asm
--- a/media/libjpeg/simd/jdmrgss2.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdmrgss2.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -19,8 +19,6 @@
 %include "jcolsamp.inc"
                 
 ; --------------------------------------------------------------------------
-    SECTION    SEG_TEXT
-    BITS    32
 ;
 ; Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
 ;
@@ -309,6 +307,41 @@
     movdqa    xmmA,xmmD
     sub    ecx, byte SIZEOF_XMMWORD
 .column_st15:
+%ifdef STRICT_MEMORY_ACCESS
+    ; Store the lower 8 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp    ecx, byte SIZEOF_MMWORD
+    jb    short .column_st7
+    movq    MMWORD [edi], xmmA
+    add    edi, byte SIZEOF_MMWORD
+    sub    ecx, byte SIZEOF_MMWORD
+    psrldq    xmmA, SIZEOF_MMWORD
+.column_st7:
+    ; Store the lower 4 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp    ecx, byte SIZEOF_DWORD
+    jb    short .column_st3
+    movd    DWORD [edi], xmmA
+    add    edi, byte SIZEOF_DWORD
+    sub    ecx, byte SIZEOF_DWORD
+    psrldq    xmmA, SIZEOF_DWORD
+.column_st3:
+    ; Store the lower 2 bytes of eax to the output when it has enough
+    ; space.
+    movd    eax, xmmA
+    cmp    ecx, byte SIZEOF_WORD
+    jb    short .column_st1
+    mov    WORD [edi], ax
+    add    edi, byte SIZEOF_WORD
+    sub    ecx, byte SIZEOF_WORD
+    shr    eax, 16
+.column_st1:
+    ; Store the lower 1 byte of eax to the output when it has enough
+    ; space.
+    test    ecx, ecx
+    jz    short .endcolumn
+    mov    BYTE [edi], al
+%else
     mov    eax,ecx
     xor    ecx, byte 0x0F
     shl    ecx, 2
@@ -348,6 +381,7 @@
     por    xmmE,xmmC
 .adj0:    ; ----------------
     maskmovdqu xmmA,xmmE            ; movntdqu XMMWORD [edi], xmmA
+%endif ; STRICT_MEMORY_ACCESS ; ---------------
 
 %else ; RGB_PIXELSIZE == 4 ; -----------
 
@@ -436,6 +470,22 @@
     movdqa    xmmA,xmmD
     sub    ecx, byte SIZEOF_XMMWORD/4
 .column_st15:
+%ifdef STRICT_MEMORY_ACCESS
+    ; Store two pixels (8 bytes) of xmmA to the output when it has enough
+    ; space.
+    cmp    ecx, byte SIZEOF_XMMWORD/8
+    jb    short .column_st7
+    movq    MMWORD [edi], xmmA
+    add    edi, byte SIZEOF_XMMWORD/2
+    sub    ecx, byte SIZEOF_XMMWORD/8
+    psrldq    xmmA, 64
+.column_st7:
+    ; Store one pixel (4 bytes) of xmmA to the output when it has enough
+    ; space.
+    test    ecx, ecx
+    jz    short .endcolumn
+    movd    DWORD [edi], xmmA
+%else
     cmp    ecx, byte SIZEOF_XMMWORD/16
     jb    short .endcolumn
     mov    eax,ecx
@@ -475,6 +525,7 @@
     por    xmmE,xmmG
 .adj0:    ; ----------------
     maskmovdqu xmmA,xmmE            ; movntdqu XMMWORD [edi], xmmA
+%endif ; STRICT_MEMORY_ACCESS ; ---------------
 
 %endif ; RGB_PIXELSIZE ; ---------------
 
diff -r 3a99d7ff459c media/libjpeg/simd/jdsammmx.asm
--- a/media/libjpeg/simd/jdsammmx.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdsammmx.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -732,6 +732,226 @@
     pop    ebp
     ret
 
+
+%ifdef UPSAMPLE_H1V2_SUPPORTED
+
+; --------------------------------------------------------------------------
+;
+; Fancy processing for the common case of 1:1 horizontal and 2:1 vertical.
+; Again a triangle filter; see comments for h2v1 case, above.
+;
+; GLOBAL(void)
+; jsimd_h1v2_fancy_upsample_mmx (j_decompress_ptr cinfo,
+;                               jpeg_component_info * compptr,
+;                               JSAMPARRAY input_data,
+;                               JSAMPARRAY * output_data_ptr);
+;
+
+%define cinfo(b)        (b)+8        ; j_decompress_ptr cinfo
+%define compptr(b)        (b)+12        ; jpeg_component_info * compptr
+%define input_data(b)        (b)+16        ; JSAMPARRAY input_data
+%define output_data_ptr(b)    (b)+20        ; JSAMPARRAY * output_data_ptr
+
+%define gotptr        ebp-SIZEOF_POINTER    ; void * gotptr
+
+    align    16
+    global    EXTN(jsimd_h1v2_fancy_upsample_mmx)
+
+EXTN(jsimd_h1v2_fancy_upsample_mmx):
+    push    ebp
+    mov    eax,esp                ; eax = original ebp
+    sub    esp, byte 4
+    and    esp, byte (-SIZEOF_MMWORD)    ; align to 64 bits
+    mov    [esp],eax
+    mov    ebp,esp                ; ebp = aligned ebp
+    lea    esp, [wk(0)]
+    pushpic    eax        ; make a room for GOT address
+    push    ebx
+;    push    ecx        ; need not be preserved
+;    push    edx        ; need not be preserved
+    push    esi
+    push    edi
+
+    get_GOT    ebx            ; get GOT address
+    movpic    POINTER [gotptr], ebx    ; save GOT address
+
+    mov    edx,eax                ; edx = original ebp
+    mov    eax, JDIMENSION [downsamp_width(edx)]  ; colctr
+    test    eax,eax
+    jz    near .return
+
+    mov    ecx, INT [max_v_samp(edx)]    ; rowctr
+    test    ecx,ecx
+    jz    near .return
+
+    mov    esi, JSAMPARRAY [input_data(ebp)]    ; input_data
+    mov    edi, POINTER [output_data_ptr(ebp)]
+    mov    edi, JSAMPARRAY [edi]            ; output_data
+    alignx    16,7
+.rowloop:
+    push    eax                    ; colctr
+    push    ecx
+    push    edi
+    push    esi
+
+    mov    ecx, JSAMPROW [esi-1*SIZEOF_JSAMPROW]    ; inptr1(above)
+    mov    ebx, JSAMPROW [esi+0*SIZEOF_JSAMPROW]    ; inptr0
+    mov    esi, JSAMPROW [esi+1*SIZEOF_JSAMPROW]    ; inptr1(below)
+    mov    edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]    ; outptr0
+    mov    edi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]    ; outptr1
+
+    pxor    mm0,mm0            ; mm0=(all 0's)
+    alignx    16,7
+
+.columnloop:
+    movq    mm1, MMWORD [ebx]    ; mm1=row[ 0]( 0 1 2 3 4 5 6 7)
+    movq    mm2, MMWORD [ecx]    ; mm2=row[-1]( 0 1 2 3 4 5 6 7)
+    movq    mm3, MMWORD [esi]    ; mm3=row[+1]( 0 1 2 3 4 5 6 7)
+
+    pushpic    ebx
+    movpic    ebx, POINTER [gotptr]    ; load GOT address
+
+    movq      mm4,mm1
+    punpcklbw mm1,mm0        ; mm1=row[ 0]( 0 1 2 3)
+    punpckhbw mm4,mm0        ; mm4=row[ 0]( 4 5 6 7)
+    movq      mm5,mm2
+    punpcklbw mm2,mm0        ; mm2=row[-1]( 0 1 2 3)
+    punpckhbw mm5,mm0        ; mm5=row[-1]( 4 5 6 7)
+    movq      mm6,mm3
+    punpcklbw mm3,mm0        ; mm3=row[+1]( 0 1 2 3)
+    punpckhbw mm6,mm0        ; mm6=row[+1]( 4 5 6 7)
+
+    pmullw    mm1,[GOTOFF(ebx,PW_THREE)]
+    pmullw    mm4,[GOTOFF(ebx,PW_THREE)]
+    paddw    mm2,[GOTOFF(ebx,PW_ONE)]
+    paddw    mm5,[GOTOFF(ebx,PW_ONE)]
+    paddw    mm3,[GOTOFF(ebx,PW_TWO)]
+    paddw    mm6,[GOTOFF(ebx,PW_TWO)]
+
+    paddw    mm2,mm1
+    paddw    mm5,mm4
+    psrlw    mm2,2            ; mm2=Out0L=( 0 1 2 3)
+    psrlw    mm5,2            ; mm5=Out0H=( 4 5 6 7)
+    paddw    mm3,mm1
+    paddw    mm6,mm4
+    psrlw    mm3,2            ; mm3=Out1L=( 0 1 2 3)
+    psrlw    mm6,2            ; mm6=Out1H=( 4 5 6 7)
+
+    packuswb  mm2,mm5        ; mm2=Out0=( 0 1 2 3 4 5 6 7)
+    packuswb  mm3,mm6        ; mm3=Out1=( 0 1 2 3 4 5 6 7)
+
+    movq    MMWORD [edx], mm2
+    movq    MMWORD [edi], mm3
+
+    poppic    ebx
+
+    add    ecx, byte 1*SIZEOF_MMWORD    ; inptr1(above)
+    add    ebx, byte 1*SIZEOF_MMWORD    ; inptr0
+    add    esi, byte 1*SIZEOF_MMWORD    ; inptr1(below)
+    add    edx, byte 1*SIZEOF_MMWORD    ; outptr0
+    add    edi, byte 1*SIZEOF_MMWORD    ; outptr1
+    sub    eax, byte SIZEOF_MMWORD
+    jnz    near .columnloop
+
+    pop    esi
+    pop    edi
+    pop    ecx
+    pop    eax
+
+    add    esi, byte 1*SIZEOF_JSAMPROW    ; input_data
+    add    edi, byte 2*SIZEOF_JSAMPROW    ; output_data
+    sub    ecx, byte 2            ; rowctr
+    jg    near .rowloop
+
+    emms        ; empty MMX state
+
+.return:
+    pop    edi
+    pop    esi
+;    pop    edx        ; need not be preserved
+;    pop    ecx        ; need not be preserved
+    pop    ebx
+    poppic    eax        ; remove gotptr
+    pop    ebp
+    ret
+
+
+;
+; Fast processing for the common case of 1:1 horizontal and 2:1 vertical.
+; It's still a box filter.
+;
+
+    align    16
+    global    EXTN(jsimd_h1v2_upsample_mmx)
+
+EXTN(jsimd_h1v2_upsample_mmx):
+    push    ebp
+    mov    ebp,esp
+;    push    ebx        ; unused
+;    push    ecx        ; need not be preserved
+;    push    edx        ; need not be preserved
+    push    esi
+    push    edi
+
+    mov    edx, JDIMENSION [output_width(ebp)]
+    add    edx, byte (SIZEOF_MMWORD)-1
+    and    edx, byte -(SIZEOF_MMWORD)
+    jz    short .return
+
+    mov    ecx, INT [max_v_samp(ebp)]    ; rowctr
+    test    ecx,ecx
+    jz    short .return
+
+    mov    esi, JSAMPARRAY [input_data(ebp)]    ; input_data
+    mov    edi, POINTER [output_data_ptr(ebp)]
+    mov    edi, JSAMPARRAY [edi]            ; output_data
+    alignx    16,7
+.rowloop:
+    push    edi
+    push    esi
+
+    mov    esi, JSAMPROW [esi]            ; inptr
+    mov    ebx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]    ; outptr0
+    mov    edi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]    ; outptr1
+    mov    eax,edx                    ; colctr
+    alignx    16,7
+.columnloop:
+
+    movq    xmm0, MMWORD [esi+0*SIZEOF_MMWORD]
+
+    movq    MMWORD [ebx+0*SIZEOF_MMWORD], xmm0
+    movq    MMWORD [edi+0*SIZEOF_MMWORD], xmm0
+
+    sub    eax, byte 2*SIZEOF_MMWORD
+    jz    short .nextrow
+
+    add    esi, byte SIZEOF_MMWORD    ; inptr
+    add    ebx, byte SIZEOF_MMWORD    ; outptr0
+    add    edi, byte SIZEOF_MMWORD    ; outptr1
+    jmp    short .columnloop
+    alignx    16,7
+
+.nextrow:
+    pop    esi
+    pop    edi
+
+    add    esi, byte 1*SIZEOF_JSAMPROW    ; input_data
+    add    edi, byte 2*SIZEOF_JSAMPROW    ; output_data
+    sub    ecx, byte 2            ; rowctr
+    jg    short .rowloop
+
+.return:
+    pop    edi
+    pop    esi
+;    pop    edx        ; need not be preserved
+;    pop    ecx        ; need not be preserved
+    pop    ebx
+    pop    ebp
+    ret
+
+%endif ; UPSAMPLE_H1V2_SUPPORTED
+
+
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
     align    16
diff -r 3a99d7ff459c media/libjpeg/simd/jdsamss2-64.asm
--- a/media/libjpeg/simd/jdsamss2-64.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdsamss2-64.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -22,7 +22,7 @@
 ; --------------------------------------------------------------------------
     SECTION    SEG_CONST
 
-    alignz    16
+    alignz    64
     global    EXTN(jconst_fancy_upsample_sse2)
 
 EXTN(jconst_fancy_upsample_sse2):
@@ -666,6 +666,214 @@
     pop    rbp
     ret
 
+%ifdef UPSAMPLE_H1V2_SUPPORTED
+
+;
+; Fancy processing for the common case of 1:1 horizontal and 2:1 vertical.
+; Again a triangle filter; see comments for h2v1 case, above.
+;
+; It is OK for us to reference the adjacent input rows because we demanded
+; context from the main buffer controller (see initialization code).
+;
+
+%define max_v_samp(b)        (b)+12            ; int max_v_samp_factor
+%define downsamp_width(b)    (b)+12    ; JDIMENSION downsampled_width
+%define input_data(b)        (b)+16        ; JSAMPARRAY input_data
+%define output_data_ptr(b)    (b)+20        ; JSAMPARRAY * output_data_ptr
+
+    align    16
+    global    EXTN(jsimd_h1v2_fancy_upsample_sse2)
+
+EXTN(jsimd_h1v2_fancy_upsample_sse2):
+    push    rbp
+    mov    rax,rsp                ; rax = original rbp
+    sub    rsp, byte 4
+    and    rsp, byte (-SIZEOF_XMMWORD)    ; align to 128 bits
+    mov    [rsp],rax
+    mov    rbp,rsp                ; rbp = aligned rbp
+    lea    rsp, [wk(0)]
+    collect_args
+    push    rbx
+
+    mov    rax, r11  ; colctr
+    test    rax,rax
+    jz    near .return
+
+    mov    rcx, r10    ; rowctr
+    test    rcx,rcx
+    jz    near .return
+
+    mov    rsi, r12    ; input_data
+    mov    rdi, r13
+    mov    rdi, JSAMPARRAY [rdi]            ; output_data
+.rowloop:
+    push    rax                    ; colctr
+    push    rcx
+    push    rdi
+    push    rsi
+
+    mov    rcx, JSAMPROW [rsi-1*SIZEOF_JSAMPROW]    ; inptr1(above)
+    mov    rbx, JSAMPROW [rsi+0*SIZEOF_JSAMPROW]    ; inptr0
+    mov    rsi, JSAMPROW [rsi+1*SIZEOF_JSAMPROW]    ; inptr1(below)
+    mov    rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]    ; outptr0
+    mov    rdi, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]    ; outptr1
+
+    test    rax, SIZEOF_XMMWORD-1
+    jz    short .skip
+
+    push    rdx
+    mov    dl, JSAMPLE [rcx+(rax-1)*SIZEOF_JSAMPLE]
+    mov    JSAMPLE [rcx+rax*SIZEOF_JSAMPLE], dl
+    mov    dl, JSAMPLE [rbx+(rax-1)*SIZEOF_JSAMPLE]
+    mov    JSAMPLE [rbx+rax*SIZEOF_JSAMPLE], dl
+    mov    dl, JSAMPLE [rsi+(rax-1)*SIZEOF_JSAMPLE]
+    mov    JSAMPLE [rsi+rax*SIZEOF_JSAMPLE], dl    ; insert a dummy sample
+    pop    rdx
+
+.skip:
+    pxor    xmm0,xmm0        ; xmm0=(all 0's)
+    jmp    short .columnloop
+
+.columnloop_last:
+    movdqa    xmm1, XMMWORD [rbx]    ; xmm1=row[ 0]( 0  1  2 ... 13 14 15)
+    movdqa    xmm2, XMMWORD [rcx]    ; xmm2=row[-1]( 0  1  2 ... 13 14 15)
+    movdqa    xmm3, XMMWORD [rbx]    ; xmm3=row[+1]( 0  1  2 ... 13 14 15)
+    jmp    short .upsample
+
+.columnloop:
+    movdqa    xmm1, XMMWORD [rbx]    ; xmm1=row[ 0]( 0  1  2 ... 13 14 15)
+    movdqa    xmm2, XMMWORD [rcx]    ; xmm2=row[-1]( 0  1  2 ... 13 14 15)
+    movdqa    xmm3, XMMWORD [rsi]    ; xmm3=row[+1]( 0  1  2 ... 13 14 15)
+
+.upsample:
+    movdqa    xmm4,xmm1
+    punpcklbw xmm1,xmm0        ; xmm1=row[ 0]( 0  1  2  3  4  5  6  7)
+    punpckhbw xmm4,xmm0        ; xmm4=row[ 0]( 8  9 10 11 12 13 14 15)
+    movdqa    xmm5,xmm2
+    punpcklbw xmm2,xmm0        ; xmm2=row[-1]( 0  1  2  3  4  5  6  7)
+    punpckhbw xmm5,xmm0        ; xmm5=row[-1]( 8  9 10 11 12 13 14 15)
+    movdqa    xmm6,xmm3
+    punpcklbw xmm3,xmm0        ; xmm3=row[+1]( 0  1  2  3  4  5  6  7)
+    punpckhbw xmm6,xmm0        ; xmm6=row[+1]( 8  9 10 11 12 13 14 15)
+
+    pmullw    xmm1,[rel PW_THREE]
+    pmullw    xmm4,[rel PW_THREE]
+    paddw    xmm2,[rel PW_ONE]
+    paddw    xmm5,[rel PW_ONE]
+    paddw    xmm3,[rel PW_TWO]
+    paddw    xmm6,[rel PW_TWO]
+
+    paddw    xmm2,xmm1
+    paddw    xmm5,xmm4
+    psrlw    xmm2,2            ; xmm2=Out0L=( 0  1  2  3  4  5  6  7)
+    psrlw    xmm5,2            ; xmm5=Out0H=( 8  9 10 11 12 13 14 15)
+    paddw    xmm3,xmm1
+    paddw    xmm6,xmm4
+    psrlw    xmm3,2            ; xmm3=Out1L=( 0  1  2  3  4  5  6  7)
+    psrlw    xmm6,2            ; xmm6=Out1H=( 8  9 10 11 12 13 14 15)
+
+    packuswb  xmm2,xmm5        ; xmm2=Out0=( 0  1  2 ... 13 14 15)
+    packuswb  xmm3,xmm6        ; xmm3=Out1=( 0  1  2 ... 13 14 15)
+
+    movdqa    XMMWORD [rdx], xmm2
+    movdqa    XMMWORD [rdi], xmm3
+
+    sub    rax, byte SIZEOF_XMMWORD
+    add    rcx, byte 1*SIZEOF_XMMWORD    ; inptr1(above)
+    add    rbx, byte 1*SIZEOF_XMMWORD    ; inptr0
+    add    rsi, byte 1*SIZEOF_XMMWORD    ; inptr1(below)
+    add    rdx, byte 1*SIZEOF_XMMWORD    ; outptr0
+    add    rdi, byte 1*SIZEOF_XMMWORD    ; outptr1
+    cmp    rax, byte SIZEOF_XMMWORD
+    ja    near .columnloop
+    test    rax,rax
+    jnz    near .columnloop_last
+
+    pop    rsi
+    pop    rdi
+    pop    rcx
+    pop    rax
+
+    add    rsi, byte 1*SIZEOF_JSAMPROW    ; input_data
+    add    rdi, byte 2*SIZEOF_JSAMPROW    ; output_data
+    sub    rcx, byte 2            ; rowctr
+    jg    near .rowloop
+
+.return:
+    pop    rbx
+    uncollect_args
+    mov    rsp,rbp        ; rsp <- aligned rbp
+    pop    rsp        ; rsp <- original rbp
+    pop    rbp
+    ret
+
+;
+; Fast processing for the common case of 1:1 horizontal and 2:1 vertical.
+; It's still a box filter.
+;
+
+    align    16
+    global    EXTN(jsimd_h1v2_upsample_sse2)
+
+EXTN(jsimd_h1v2_upsample_sse2):
+    push    rbp
+    mov    rax,rsp
+    mov    rbp,rsp
+    collect_args
+    push    rbx
+
+    mov    rdx, r11
+    add    rdx, byte (SIZEOF_XMMWORD)-1
+    and    rdx, byte -(SIZEOF_XMMWORD)
+    jz    near .return
+
+    mov    rcx, r10    ; rowctr
+    test    rcx,rcx
+    jz    near .return
+
+    mov    rsi, r12    ; input_data
+    mov    rdi, r13
+    mov    rdi, JSAMPARRAY [rdi]            ; output_data
+.rowloop:
+    push    rdi
+    push    rsi
+
+    mov    rsi, JSAMPROW [rsi]            ; inptr
+    mov    rbx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]    ; outptr0
+    mov    rdi, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]    ; outptr1
+    mov    rax,rdx                    ; colctr
+.columnloop:
+
+    movdqa    xmm0, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+
+    movdqa    XMMWORD [rbx+0*SIZEOF_XMMWORD], xmm0
+    movdqa    XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm0
+
+    sub    rax, byte SIZEOF_XMMWORD
+    jz    short .nextrow
+
+    add    rsi, byte SIZEOF_XMMWORD    ; inptr
+    add    rbx, byte SIZEOF_XMMWORD    ; outptr0
+    add    rdi, byte SIZEOF_XMMWORD    ; outptr1
+    jmp    short .columnloop
+
+.nextrow:
+    pop    rsi
+    pop    rdi
+
+    add    rsi, byte 1*SIZEOF_JSAMPROW    ; input_data
+    add    rdi, byte 2*SIZEOF_JSAMPROW    ; output_data
+    sub    rcx, byte 2            ; rowctr
+    jg    near .rowloop
+
+.return:
+    pop    rbx
+    uncollect_args
+    pop    rbp
+    ret
+
+%endif    ; UPSAMPLE_H1V2_SUPPORTED
+
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
     align    16
diff -r 3a99d7ff459c media/libjpeg/simd/jdsamss2.asm
--- a/media/libjpeg/simd/jdsamss2.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jdsamss2.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -520,6 +520,144 @@
     pop    ebp
     ret
 
+
+%ifdef UPSAMPLE_H1V2_SUPPORTED
+
+; --------------------------------------------------------------------------
+;
+; Fancy processing for the common case of 1:1 horizontal and 2:1 vertical.
+; Again a triangle filter; see comments for h2v1 case, above.
+;
+; GLOBAL(void)
+; jsimd_h1v2_fancy_upsample_sse2 (j_decompress_ptr cinfo,
+;                                jpeg_component_info * compptr,
+;                                JSAMPARRAY input_data,
+;                                JSAMPARRAY * output_data_ptr);
+;
+
+    align    16
+    global    EXTN(jsimd_h1v2_fancy_upsample_sse2)
+
+EXTN(jsimd_h1v2_fancy_upsample_sse2):
+    push    ebp
+    mov    eax,esp                ; eax = original ebp
+    sub    esp, byte 4
+    and    esp, byte (-SIZEOF_XMMWORD)    ; align to 128 bits
+    mov    [esp],eax
+    mov    ebp,esp                ; ebp = aligned ebp
+    lea    esp, [wk(0)]
+    pushpic    eax        ; make a room for GOT address
+    push    ebx
+;    push    ecx        ; need not be preserved
+;    push    edx        ; need not be preserved
+    push    esi
+    push    edi
+
+    get_GOT    ebx            ; get GOT address
+    movpic    POINTER [gotptr], ebx    ; save GOT address
+
+    mov    edx,eax                ; edx = original ebp
+    mov    eax, JDIMENSION [downsamp_width(edx)]  ; colctr
+    test    eax,eax
+    jz    near .return
+
+    mov    ecx, INT [max_v_samp(edx)]    ; rowctr
+    test    ecx,ecx
+    jz    near .return
+
+    mov    esi, JSAMPARRAY [input_data(edx)]    ; input_data
+    mov    edi, POINTER [output_data_ptr(edx)]
+    mov    edi, JSAMPARRAY [edi]            ; output_data
+    alignx    16,7
+.rowloop:
+    push    eax                    ; colctr
+    push    ecx
+    push    edi
+    push    esi
+
+    mov    ecx, JSAMPROW [esi-1*SIZEOF_JSAMPROW]    ; inptr1(above)
+    mov    ebx, JSAMPROW [esi+0*SIZEOF_JSAMPROW]    ; inptr0
+    mov    esi, JSAMPROW [esi+1*SIZEOF_JSAMPROW]    ; inptr1(below)
+    mov    edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]    ; outptr0
+    mov    edi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]    ; outptr1
+
+    pxor    xmm0,xmm0        ; xmm0=(all 0's)
+    alignx    16,7
+
+.columnloop:
+    movdqa    xmm1, XMMWORD [ebx]    ; xmm1=row[ 0]( 0  1  2 ... 13 14 15)
+    movdqa    xmm2, XMMWORD [ecx]    ; xmm2=row[-1]( 0  1  2 ... 13 14 15)
+    movdqa    xmm3, XMMWORD [esi]    ; xmm3=row[+1]( 0  1  2 ... 13 14 15)
+
+    pushpic    ebx
+    movpic    ebx, POINTER [gotptr]    ; load GOT address
+
+    movdqa    xmm4,xmm1
+    punpcklbw xmm1,xmm0        ; xmm1=row[ 0]( 0  1  2  3  4  5  6  7)
+    punpckhbw xmm4,xmm0        ; xmm4=row[ 0]( 8  9 10 11 12 13 14 15)
+    movdqa    xmm5,xmm2
+    punpcklbw xmm2,xmm0        ; xmm2=row[-1]( 0  1  2  3  4  5  6  7)
+    punpckhbw xmm5,xmm0        ; xmm5=row[-1]( 8  9 10 11 12 13 14 15)
+    movdqa    xmm6,xmm3
+    punpcklbw xmm3,xmm0        ; xmm3=row[+1]( 0  1  2  3  4  5  6  7)
+    punpckhbw xmm6,xmm0        ; xmm6=row[+1]( 8  9 10 11 12 13 14 15)
+
+    pmullw    xmm1,[GOTOFF(ebx,PW_THREE)]
+    pmullw    xmm4,[GOTOFF(ebx,PW_THREE)]
+    paddw    xmm2,[GOTOFF(ebx,PW_ONE)]
+    paddw    xmm5,[GOTOFF(ebx,PW_ONE)]
+    paddw    xmm3,[GOTOFF(ebx,PW_TWO)]
+    paddw    xmm6,[GOTOFF(ebx,PW_TWO)]
+
+    paddw    xmm2,xmm1
+    paddw    xmm5,xmm4
+    psrlw    xmm2,2            ; xmm2=Out0L=( 0  1  2  3  4  5  6  7)
+    psrlw    xmm5,2            ; xmm5=Out0H=( 8  9 10 11 12 13 14 15)
+    paddw    xmm3,xmm1
+    paddw    xmm6,xmm4
+    psrlw    xmm3,2            ; xmm3=Out1L=( 0  1  2  3  4  5  6  7)
+    psrlw    xmm6,2            ; xmm6=Out1H=( 8  9 10 11 12 13 14 15)
+
+    packuswb  xmm2,xmm5        ; xmm2=Out0=( 0  1  2 ... 13 14 15)
+    packuswb  xmm3,xmm6        ; xmm3=Out1=( 0  1  2 ... 13 14 15)
+
+    movdqa    XMMWORD [edx], xmm2
+    movdqa    XMMWORD [edi], xmm3
+
+    poppic    ebx
+
+    add    ecx, byte 1*SIZEOF_XMMWORD    ; inptr1(above)
+    add    ebx, byte 1*SIZEOF_XMMWORD    ; inptr0
+    add    esi, byte 1*SIZEOF_XMMWORD    ; inptr1(below)
+    add    edx, byte 1*SIZEOF_XMMWORD    ; outptr0
+    add    edi, byte 1*SIZEOF_XMMWORD    ; outptr1
+    sub    eax, byte SIZEOF_XMMWORD
+    jnz    near .columnloop
+
+    pop    esi
+    pop    edi
+    pop    ecx
+    pop    eax
+
+    add    esi, byte 1*SIZEOF_JSAMPROW    ; input_data
+    add    edi, byte 2*SIZEOF_JSAMPROW    ; output_data
+    sub    ecx, byte 2            ; rowctr
+    jg    near .rowloop
+
+.return:
+    pop    edi
+    pop    esi
+;    pop    edx        ; need not be preserved
+;    pop    ecx        ; need not be preserved
+    pop    ebx
+    mov    esp,ebp        ; esp <- aligned ebp
+    pop    esp        ; esp <- original ebp
+    pop    ebp
+    ret
+
+%endif ; UPSAMPLE_H1V2_SUPPORTED
+
+
 ; --------------------------------------------------------------------------
 ;
 ; Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
@@ -724,6 +862,85 @@
     pop    ebp
     ret
 
+
+%ifdef UPSAMPLE_H1V2_SUPPORTED
+
+;
+; Fast processing for the common case of 1:1 horizontal and 2:1 vertical.
+; It's still a box filter.
+;
+
+    align    16
+    global    EXTN(jsimd_h1v2_upsample_sse2)
+
+EXTN(jsimd_h1v2_upsample_sse2):
+    push    ebp
+    mov    ebp,esp
+;    push    ebx        ; unused
+;    push    ecx        ; need not be preserved
+;    push    edx        ; need not be preserved
+    push    esi
+    push    edi
+
+    mov    edx, JDIMENSION [output_width(ebp)]
+    add    edx, byte (SIZEOF_XMMWORD)-1
+    and    edx, byte -(SIZEOF_XMMWORD)
+    jz    short .return
+
+    mov    ecx, INT [max_v_samp(ebp)]    ; rowctr
+    test    ecx,ecx
+    jz    short .return
+
+    mov    esi, JSAMPARRAY [input_data(ebp)]    ; input_data
+    mov    edi, POINTER [output_data_ptr(ebp)]
+    mov    edi, JSAMPARRAY [edi]            ; output_data
+    alignx    16,7
+.rowloop:
+    push    edi
+    push    esi
+
+    mov    esi, JSAMPROW [esi]            ; inptr
+    mov    ebx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]    ; outptr0
+    mov    edi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]    ; outptr1
+    mov    eax,edx                    ; colctr
+    alignx    16,7
+.columnloop:
+
+    movdqa    xmm0, XMMWORD [esi+0*SIZEOF_XMMWORD]
+
+    movdqa    XMMWORD [ebx+0*SIZEOF_XMMWORD], xmm0
+    movdqa    XMMWORD [edi+0*SIZEOF_XMMWORD], xmm0
+
+    sub    eax, byte 2*SIZEOF_XMMWORD
+    jz    short .nextrow
+
+    add    esi, byte SIZEOF_XMMWORD    ; inptr
+    add    ebx, byte SIZEOF_XMMWORD    ; outptr0
+    add    edi, byte SIZEOF_XMMWORD    ; outptr1
+    jmp    short .columnloop
+    alignx    16,7
+
+.nextrow:
+    pop    esi
+    pop    edi
+
+    add    esi, byte 1*SIZEOF_JSAMPROW    ; input_data
+    add    edi, byte 2*SIZEOF_JSAMPROW    ; output_data
+    sub    ecx, byte 2            ; rowctr
+    jg    short .rowloop
+
+.return:
+    pop    edi
+    pop    esi
+;    pop    edx        ; need not be preserved
+;    pop    ecx        ; need not be preserved
+    pop    ebx
+    pop    ebp
+    ret
+
+%endif ; UPSAMPLE_H1V2_SUPPORTED
+
+
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
     align    16
diff -r 3a99d7ff459c media/libjpeg/simd/jiss2flt-64.asm
--- a/media/libjpeg/simd/jiss2flt-64.asm    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jiss2flt-64.asm    Tue Jan 24 23:47:27 2012 +0900
@@ -37,7 +37,7 @@
 ; --------------------------------------------------------------------------
     SECTION    SEG_CONST
 
-    alignz    16
+    alignz    64
     global    EXTN(jconst_idct_float_sse2)
 
 EXTN(jconst_idct_float_sse2):
diff -r 3a99d7ff459c media/libjpeg/simd/jsimd.h
--- a/media/libjpeg/simd/jsimd.h    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jsimd.h    Tue Jan 24 23:47:27 2012 +0900
@@ -2,6 +2,7 @@
  * simd/jsimd.h
  *
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+ * Copyright 2011 D. R. Commander
  * 
  * Based on the x86 SIMD extension for IJG JPEG library,
  * Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -11,11 +12,12 @@
 
 /* Bitmask for supported acceleration methods */
 
-#define JSIMD_NONE    0x00
-#define JSIMD_MMX     0x01
-#define JSIMD_3DNOW   0x02
-#define JSIMD_SSE     0x04
-#define JSIMD_SSE2    0x08
+#define JSIMD_NONE       0x00
+#define JSIMD_MMX        0x01
+#define JSIMD_3DNOW      0x02
+#define JSIMD_SSE        0x04
+#define JSIMD_SSE2       0x08
+#define JSIMD_ARM_NEON   0x10
 
 /* Short forms of external names for systems with brain-damaged linkers. */
 
@@ -28,6 +30,13 @@
 #define jsimd_extbgrx_ycc_convert_mmx         jSEXTBGRXYCCM
 #define jsimd_extxbgr_ycc_convert_mmx         jSEXTXBGRYCCM
 #define jsimd_extxrgb_ycc_convert_mmx         jSEXTXRGBYCCM
+#define jsimd_rgb_gray_convert_mmx            jSRGBGRYM
+#define jsimd_extrgb_gray_convert_mmx         jSEXTRGBGRYM
+#define jsimd_extrgbx_gray_convert_mmx        jSEXTRGBXGRYM
+#define jsimd_extbgr_gray_convert_mmx         jSEXTBGRGRYM
+#define jsimd_extbgrx_gray_convert_mmx        jSEXTBGRXGRYM
+#define jsimd_extxbgr_gray_convert_mmx        jSEXTXBGRGRYM
+#define jsimd_extxrgb_gray_convert_mmx        jSEXTXRGBGRYM
 #define jsimd_ycc_rgb_convert_mmx             jSYCCRGBM
 #define jsimd_ycc_extrgb_convert_mmx          jSYCCEXTRGBM
 #define jsimd_ycc_extrgbx_convert_mmx         jSYCCEXTRGBXM
@@ -43,6 +52,14 @@
 #define jsimd_extbgrx_ycc_convert_sse2        jSEXTBGRXYCCS2
 #define jsimd_extxbgr_ycc_convert_sse2        jSEXTXBGRYCCS2
 #define jsimd_extxrgb_ycc_convert_sse2        jSEXTXRGBYCCS2
+#define jconst_rgb_gray_convert_sse2          jSCRGBGRYS2
+#define jsimd_rgb_gray_convert_sse2           jSRGBGRYS2
+#define jsimd_extrgb_gray_convert_sse2        jSEXTRGBGRYS2
+#define jsimd_extrgbx_gray_convert_sse2       jSEXTRGBXGRYS2
+#define jsimd_extbgr_gray_convert_sse2        jSEXTBGRGRYS2
+#define jsimd_extbgrx_gray_convert_sse2       jSEXTBGRXGRYS2
+#define jsimd_extxbgr_gray_convert_sse2       jSEXTXBGRGRYS2
+#define jsimd_extxrgb_gray_convert_sse2       jSEXTXRGBGRYS2
 #define jconst_ycc_rgb_convert_sse2           jSCYCCRGBS2
 #define jsimd_ycc_rgb_convert_sse2            jSYCCRGBS2
 #define jsimd_ycc_extrgb_convert_sse2         jSYCCEXTRGBS2
@@ -163,6 +180,35 @@
              JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
              JDIMENSION output_row, int num_rows));
 
+EXTERN(void) jsimd_rgb_gray_convert_mmx
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extrgb_gray_convert_mmx
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extrgbx_gray_convert_mmx
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extbgr_gray_convert_mmx
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extbgrx_gray_convert_mmx
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extxbgr_gray_convert_mmx
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extxrgb_gray_convert_mmx
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+
 EXTERN(void) jsimd_ycc_rgb_convert_mmx
         JPP((JDIMENSION out_width,
              JSAMPIMAGE input_buf, JDIMENSION input_row,
@@ -222,6 +268,36 @@
              JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
              JDIMENSION output_row, int num_rows));
 
+extern const int jconst_rgb_gray_convert_sse2[];
+EXTERN(void) jsimd_rgb_gray_convert_sse2
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extrgb_gray_convert_sse2
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extrgbx_gray_convert_sse2
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extbgr_gray_convert_sse2
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extbgrx_gray_convert_sse2
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extxbgr_gray_convert_sse2
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extxrgb_gray_convert_sse2
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+
 extern const int jconst_ycc_rgb_convert_sse2[];
 EXTERN(void) jsimd_ycc_rgb_convert_sse2
         JPP((JDIMENSION out_width,
@@ -252,6 +328,64 @@
              JSAMPIMAGE input_buf, JDIMENSION input_row,
              JSAMPARRAY output_buf, int num_rows));
 
+EXTERN(void) jsimd_rgb_ycc_convert_neon
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extrgb_ycc_convert_neon
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extrgbx_ycc_convert_neon
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extbgr_ycc_convert_neon
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extbgrx_ycc_convert_neon
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extxbgr_ycc_convert_neon
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+EXTERN(void) jsimd_extxrgb_ycc_convert_neon
+        JPP((JDIMENSION img_width,
+             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+             JDIMENSION output_row, int num_rows));
+
+EXTERN(void) jsimd_ycc_rgb_convert_neon
+        JPP((JDIMENSION out_width,
+             JSAMPIMAGE input_buf, JDIMENSION input_row,
+             JSAMPARRAY output_buf, int num_rows));
+EXTERN(void) jsimd_ycc_extrgb_convert_neon
+        JPP((JDIMENSION out_width,
+             JSAMPIMAGE input_buf, JDIMENSION input_row,
+             JSAMPARRAY output_buf, int num_rows));
+EXTERN(void) jsimd_ycc_extrgbx_convert_neon
+        JPP((JDIMENSION out_width,
+             JSAMPIMAGE input_buf, JDIMENSION input_row,
+             JSAMPARRAY output_buf, int num_rows));
+EXTERN(void) jsimd_ycc_extbgr_convert_neon
+        JPP((JDIMENSION out_width,
+             JSAMPIMAGE input_buf, JDIMENSION input_row,
+             JSAMPARRAY output_buf, int num_rows));
+EXTERN(void) jsimd_ycc_extbgrx_convert_neon
+        JPP((JDIMENSION out_width,
+             JSAMPIMAGE input_buf, JDIMENSION input_row,
+             JSAMPARRAY output_buf, int num_rows));
+EXTERN(void) jsimd_ycc_extxbgr_convert_neon
+        JPP((JDIMENSION out_width,
+             JSAMPIMAGE input_buf, JDIMENSION input_row,
+             JSAMPARRAY output_buf, int num_rows));
+EXTERN(void) jsimd_ycc_extxrgb_convert_neon
+        JPP((JDIMENSION out_width,
+             JSAMPIMAGE input_buf, JDIMENSION input_row,
+             JSAMPARRAY output_buf, int num_rows));
+
 /* SIMD Downsample */
 EXTERN(void) jsimd_h2v2_downsample_mmx
         JPP((JDIMENSION image_width, int max_v_samp_factor,
@@ -278,6 +412,11 @@
 EXTERN(void) jsimd_h2v1_upsample_mmx
         JPP((int max_v_samp_factor, JDIMENSION output_width,
              JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+EXTERN(void) jsimd_h1v2_upsample_mmx
+        JPP((int max_v_samp_factor, JDIMENSION output_width,
+             JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
+#endif    // UPSAMPLE_H1V2_SUPPORTED
 
 EXTERN(void) jsimd_h2v2_fancy_upsample_mmx
         JPP((int max_v_samp_factor, JDIMENSION downsampled_width,
@@ -285,6 +424,11 @@
 EXTERN(void) jsimd_h2v1_fancy_upsample_mmx
         JPP((int max_v_samp_factor, JDIMENSION downsampled_width,
              JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+EXTERN(void) jsimd_h1v2_fancy_upsample_mmx
+        JPP((int max_v_samp_factor, JDIMENSION downsampled_width,
+             JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
+#endif    // UPSAMPLE_H1V2_SUPPORTED
 
 EXTERN(void) jsimd_h2v2_merged_upsample_mmx
         JPP((JDIMENSION output_width, JSAMPIMAGE input_buf,
@@ -335,6 +479,11 @@
 EXTERN(void) jsimd_h2v1_upsample_sse2
         JPP((int max_v_samp_factor, JDIMENSION output_width,
              JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+EXTERN(void) jsimd_h1v2_upsample_sse2
+        JPP((int max_v_samp_factor, JDIMENSION output_width,
+             JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
+#endif    // UPSAMPLE_H1V2_SUPPORTED
 
 extern const int jconst_fancy_upsample_sse2[];
 EXTERN(void) jsimd_h2v2_fancy_upsample_sse2
@@ -343,6 +492,11 @@
 EXTERN(void) jsimd_h2v1_fancy_upsample_sse2
         JPP((int max_v_samp_factor, JDIMENSION downsampled_width,
              JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+EXTERN(void) jsimd_h1v2_fancy_upsample_sse2
+        JPP((int max_v_samp_factor, JDIMENSION downsampled_width,
+             JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
+#endif    // UPSAMPLE_H1V2_SUPPORTED
 
 extern const int jconst_merged_upsample_sse2[];
 EXTERN(void) jsimd_h2v2_merged_upsample_sse2
@@ -397,6 +551,10 @@
                                       JDIMENSION start_col,
                                       DCTELEM * workspace));
 
+EXTERN(void) jsimd_convsamp_neon JPP((JSAMPARRAY sample_data,
+                                      JDIMENSION start_col,
+                                      DCTELEM * workspace));
+
 EXTERN(void) jsimd_convsamp_float_3dnow JPP((JSAMPARRAY sample_data,
                                              JDIMENSION start_col,
                                              FAST_FLOAT * workspace));
@@ -418,6 +576,8 @@
 extern const int jconst_fdct_islow_sse2[];
 EXTERN(void) jsimd_fdct_ifast_sse2 JPP((DCTELEM * data));
 
+EXTERN(void) jsimd_fdct_ifast_neon JPP((DCTELEM * data));
+
 EXTERN(void) jsimd_fdct_float_3dnow JPP((FAST_FLOAT * data));
 
 extern const int jconst_fdct_float_sse[];
@@ -432,6 +592,10 @@
                                       DCTELEM * divisors,
                                       DCTELEM * workspace));
 
+EXTERN(void) jsimd_quantize_neon JPP((JCOEFPTR coef_block,
+                                      DCTELEM * divisors,
+                                      DCTELEM * workspace));
+
 EXTERN(void) jsimd_quantize_float_3dnow JPP((JCOEFPTR coef_block,
                                              FAST_FLOAT * divisors,
                                              FAST_FLOAT * workspace));
@@ -464,6 +628,15 @@
                                       JSAMPARRAY output_buf,
                                       JDIMENSION output_col));
 
+EXTERN(void) jsimd_idct_2x2_neon JPP((void * dct_table,
+                                      JCOEFPTR coef_block,
+                                      JSAMPARRAY output_buf,
+                                      JDIMENSION output_col));
+EXTERN(void) jsimd_idct_4x4_neon JPP((void * dct_table,
+                                      JCOEFPTR coef_block,
+                                      JSAMPARRAY output_buf,
+                                      JDIMENSION output_col));
+
 /* SIMD Inverse DCT */
 EXTERN(void) jsimd_idct_islow_mmx JPP((void * dct_table,
                                        JCOEFPTR coef_block,
@@ -485,6 +658,15 @@
                                         JSAMPARRAY output_buf,
                                         JDIMENSION output_col));
 
+EXTERN(void) jsimd_idct_islow_neon JPP((void * dct_table,
+                                        JCOEFPTR coef_block,
+                                        JSAMPARRAY output_buf,
+                                        JDIMENSION output_col));
+EXTERN(void) jsimd_idct_ifast_neon JPP((void * dct_table,
+                                        JCOEFPTR coef_block,
+                                        JSAMPARRAY output_buf,
+                                        JDIMENSION output_col));
+
 EXTERN(void) jsimd_idct_float_3dnow JPP((void * dct_table,
                                          JCOEFPTR coef_block,
                                          JSAMPARRAY output_buf,
diff -r 3a99d7ff459c media/libjpeg/simd/jsimd_i386.c
--- a/media/libjpeg/simd/jsimd_i386.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jsimd_i386.c    Tue Jan 24 23:47:27 2012 +0900
@@ -2,7 +2,7 @@
  * jsimd_i386.c
  *
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright 2009 D. R. Commander
+ * Copyright 2009-2011 D. R. Commander
  * 
  * Based on the x86 SIMD extension for IJG JPEG library,
  * Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -84,6 +84,28 @@
 }
 
 GLOBAL(int)
+jsimd_can_rgb_gray (void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+  if ((RGB_PIXELSIZE != 3) && (RGB_PIXELSIZE != 4))
+    return 0;
+
+  if ((simd_support & JSIMD_SSE2) &&
+      IS_ALIGNED_SSE(jconst_rgb_gray_convert_sse2))
+    return 1;
+  if (simd_support & JSIMD_MMX)
+    return 1;
+
+  return 0;
+}
+
+GLOBAL(int)
 jsimd_can_ycc_rgb (void)
 {
   init_simd();
@@ -120,6 +142,7 @@
       mmxfct=jsimd_extrgb_ycc_convert_mmx;
       break;
     case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
       sse2fct=jsimd_extrgbx_ycc_convert_sse2;
       mmxfct=jsimd_extrgbx_ycc_convert_mmx;
       break;
@@ -128,14 +151,17 @@
       mmxfct=jsimd_extbgr_ycc_convert_mmx;
       break;
     case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
       sse2fct=jsimd_extbgrx_ycc_convert_sse2;
       mmxfct=jsimd_extbgrx_ycc_convert_mmx;
       break;
     case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
       sse2fct=jsimd_extxbgr_ycc_convert_sse2;
       mmxfct=jsimd_extxbgr_ycc_convert_mmx;
       break;
     case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
       sse2fct=jsimd_extxrgb_ycc_convert_sse2;
       mmxfct=jsimd_extxrgb_ycc_convert_mmx;
       break;
@@ -155,6 +181,59 @@
 }
 
 GLOBAL(void)
+jsimd_rgb_gray_convert (j_compress_ptr cinfo,
+                        JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+                        JDIMENSION output_row, int num_rows)
+{
+  void (*sse2fct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
+  void (*mmxfct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
+
+  switch(cinfo->in_color_space)
+  {
+    case JCS_EXT_RGB:
+      sse2fct=jsimd_extrgb_gray_convert_sse2;
+      mmxfct=jsimd_extrgb_gray_convert_mmx;
+      break;
+    case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
+      sse2fct=jsimd_extrgbx_gray_convert_sse2;
+      mmxfct=jsimd_extrgbx_gray_convert_mmx;
+      break;
+    case JCS_EXT_BGR:
+      sse2fct=jsimd_extbgr_gray_convert_sse2;
+      mmxfct=jsimd_extbgr_gray_convert_mmx;
+      break;
+    case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
+      sse2fct=jsimd_extbgrx_gray_convert_sse2;
+      mmxfct=jsimd_extbgrx_gray_convert_mmx;
+      break;
+    case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
+      sse2fct=jsimd_extxbgr_gray_convert_sse2;
+      mmxfct=jsimd_extxbgr_gray_convert_mmx;
+      break;
+    case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
+      sse2fct=jsimd_extxrgb_gray_convert_sse2;
+      mmxfct=jsimd_extxrgb_gray_convert_mmx;
+      break;
+    default:
+      sse2fct=jsimd_rgb_gray_convert_sse2;
+      mmxfct=jsimd_rgb_gray_convert_mmx;
+      break;
+  }
+
+  if ((simd_support & JSIMD_SSE2) &&
+      IS_ALIGNED_SSE(jconst_rgb_gray_convert_sse2))
+    sse2fct(cinfo->image_width, input_buf,
+        output_buf, output_row, num_rows);
+  else if (simd_support & JSIMD_MMX)
+    mmxfct(cinfo->image_width, input_buf,
+        output_buf, output_row, num_rows);
+}
+
+GLOBAL(void)
 jsimd_ycc_rgb_convert (j_decompress_ptr cinfo,
                        JSAMPIMAGE input_buf, JDIMENSION input_row,
                        JSAMPARRAY output_buf, int num_rows)
@@ -169,6 +248,7 @@
       mmxfct=jsimd_ycc_extrgb_convert_mmx;
       break;
     case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
       sse2fct=jsimd_ycc_extrgbx_convert_sse2;
       mmxfct=jsimd_ycc_extrgbx_convert_mmx;
       break;
@@ -177,14 +257,17 @@
       mmxfct=jsimd_ycc_extbgr_convert_mmx;
       break;
     case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
       sse2fct=jsimd_ycc_extbgrx_convert_sse2;
       mmxfct=jsimd_ycc_extbgrx_convert_mmx;
       break;
     case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
       sse2fct=jsimd_ycc_extxbgr_convert_sse2;
       mmxfct=jsimd_ycc_extxbgr_convert_mmx;
       break;
     case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
       sse2fct=jsimd_ycc_extxrgb_convert_sse2;
       mmxfct=jsimd_ycc_extxrgb_convert_mmx;
       break;
@@ -307,6 +390,28 @@
   return 0;
 }
 
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+
+GLOBAL(int)
+jsimd_can_h1v2_upsample (void)
+{
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  if (simd_support & JSIMD_SSE2)
+    return 1;
+  if (simd_support & JSIMD_MMX)
+    return 1;
+
+  return 0;
+}
+
+#endif // UPSAMPLE_H1V2_SUPPORTED
+
+
 GLOBAL(void)
 jsimd_h2v2_upsample (j_decompress_ptr cinfo,
                      jpeg_component_info * compptr, 
@@ -335,6 +440,24 @@
         cinfo->output_width, input_data, output_data_ptr);
 }
 
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+
+GLOBAL(void)
+jsimd_h1v2_upsample (j_decompress_ptr cinfo,
+                     jpeg_component_info * compptr, 
+                     JSAMPARRAY input_data,
+                     JSAMPARRAY * output_data_ptr)
+{
+  if (simd_support & JSIMD_SSE2)
+    jsimd_h1v2_upsample_sse2(cinfo->max_v_samp_factor,
+        cinfo->output_width, input_data, output_data_ptr);
+  else if (simd_support & JSIMD_MMX)
+    jsimd_h1v2_upsample_mmx(cinfo->max_v_samp_factor,
+        cinfo->output_width, input_data, output_data_ptr);
+}
+
+#endif    // UPSAMPLE_H1V2_SUPPORTED
+
 GLOBAL(int)
 jsimd_can_h2v2_fancy_upsample (void)
 {
@@ -375,6 +498,30 @@
   return 0;
 }
 
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+
+GLOBAL(int)
+jsimd_can_h1v2_fancy_upsample (void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  if ((simd_support & JSIMD_SSE2) &&
+      IS_ALIGNED_SSE(jconst_fancy_upsample_sse2))
+    return 1;
+  if (simd_support & JSIMD_MMX)
+    return 1;
+
+  return 0;
+}
+
+#endif // UPSAMPLE_H1V2_SUPPORTED
+
 GLOBAL(void)
 jsimd_h2v2_fancy_upsample (j_decompress_ptr cinfo,
                            jpeg_component_info * compptr, 
@@ -405,6 +552,26 @@
         compptr->downsampled_width, input_data, output_data_ptr);
 }
 
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+
+GLOBAL(void)
+jsimd_h1v2_fancy_upsample (j_decompress_ptr cinfo,
+                           jpeg_component_info * compptr, 
+                           JSAMPARRAY input_data,
+                           JSAMPARRAY * output_data_ptr)
+{
+  if ((simd_support & JSIMD_SSE2) &&
+      IS_ALIGNED_SSE(jconst_fancy_upsample_sse2))
+    jsimd_h1v2_fancy_upsample_sse2(cinfo->max_v_samp_factor,
+        compptr->downsampled_width, input_data, output_data_ptr);
+  else if (simd_support & JSIMD_MMX)
+    jsimd_h1v2_fancy_upsample_mmx(cinfo->max_v_samp_factor,
+        compptr->downsampled_width, input_data, output_data_ptr);
+}
+
+#endif // UPSAMPLE_H1V2_SUPPORTED
+
+
 GLOBAL(int)
 jsimd_can_h2v2_merged_upsample (void)
 {
@@ -461,6 +628,7 @@
       mmxfct=jsimd_h2v2_extrgb_merged_upsample_mmx;
       break;
     case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
       sse2fct=jsimd_h2v2_extrgbx_merged_upsample_sse2;
       mmxfct=jsimd_h2v2_extrgbx_merged_upsample_mmx;
       break;
@@ -469,14 +637,17 @@
       mmxfct=jsimd_h2v2_extbgr_merged_upsample_mmx;
       break;
     case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
       sse2fct=jsimd_h2v2_extbgrx_merged_upsample_sse2;
       mmxfct=jsimd_h2v2_extbgrx_merged_upsample_mmx;
       break;
     case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
       sse2fct=jsimd_h2v2_extxbgr_merged_upsample_sse2;
       mmxfct=jsimd_h2v2_extxbgr_merged_upsample_mmx;
       break;
     case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
       sse2fct=jsimd_h2v2_extxrgb_merged_upsample_sse2;
       mmxfct=jsimd_h2v2_extxrgb_merged_upsample_mmx;
       break;
@@ -511,6 +682,7 @@
       mmxfct=jsimd_h2v1_extrgb_merged_upsample_mmx;
       break;
     case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
       sse2fct=jsimd_h2v1_extrgbx_merged_upsample_sse2;
       mmxfct=jsimd_h2v1_extrgbx_merged_upsample_mmx;
       break;
@@ -519,14 +691,17 @@
       mmxfct=jsimd_h2v1_extbgr_merged_upsample_mmx;
       break;
     case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
       sse2fct=jsimd_h2v1_extbgrx_merged_upsample_sse2;
       mmxfct=jsimd_h2v1_extbgrx_merged_upsample_mmx;
       break;
     case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
       sse2fct=jsimd_h2v1_extxbgr_merged_upsample_sse2;
       mmxfct=jsimd_h2v1_extxbgr_merged_upsample_mmx;
       break;
     case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
       sse2fct=jsimd_h2v1_extxrgb_merged_upsample_sse2;
       mmxfct=jsimd_h2v1_extxrgb_merged_upsample_mmx;
       break;
diff -r 3a99d7ff459c media/libjpeg/simd/jsimd_x86_64.c
--- a/media/libjpeg/simd/jsimd_x86_64.c    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jsimd_x86_64.c    Tue Jan 24 23:47:27 2012 +0900
@@ -2,7 +2,7 @@
  * jsimd_x86_64.c
  *
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright 2009 D. R. Commander
+ * Copyright 2009-2011 D. R. Commander
  * 
  * Based on the x86 SIMD extension for IJG JPEG library,
  * Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -47,6 +47,23 @@
 }
 
 GLOBAL(int)
+jsimd_can_rgb_gray (void)
+{
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+  if ((RGB_PIXELSIZE != 3) && (RGB_PIXELSIZE != 4))
+    return 0;
+
+  if (!IS_ALIGNED_SSE(jconst_rgb_gray_convert_sse2))
+    return 0;
+
+  return 1;
+}
+
+GLOBAL(int)
 jsimd_can_ycc_rgb (void)
 {
   /* The code is optimised for these values only */
@@ -76,18 +93,22 @@
       sse2fct=jsimd_extrgb_ycc_convert_sse2;
       break;
     case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
       sse2fct=jsimd_extrgbx_ycc_convert_sse2;
       break;
     case JCS_EXT_BGR:
       sse2fct=jsimd_extbgr_ycc_convert_sse2;
       break;
     case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
       sse2fct=jsimd_extbgrx_ycc_convert_sse2;
       break;
     case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
       sse2fct=jsimd_extxbgr_ycc_convert_sse2;
       break;
     case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
       sse2fct=jsimd_extxrgb_ycc_convert_sse2;
       break;
     default:
@@ -99,6 +120,45 @@
 }
 
 GLOBAL(void)
+jsimd_rgb_gray_convert (j_compress_ptr cinfo,
+                        JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+                        JDIMENSION output_row, int num_rows)
+{
+  void (*sse2fct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
+
+  switch(cinfo->in_color_space)
+  {
+    case JCS_EXT_RGB:
+      sse2fct=jsimd_extrgb_gray_convert_sse2;
+      break;
+    case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
+      sse2fct=jsimd_extrgbx_gray_convert_sse2;
+      break;
+    case JCS_EXT_BGR:
+      sse2fct=jsimd_extbgr_gray_convert_sse2;
+      break;
+    case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
+      sse2fct=jsimd_extbgrx_gray_convert_sse2;
+      break;
+    case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
+      sse2fct=jsimd_extxbgr_gray_convert_sse2;
+      break;
+    case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
+      sse2fct=jsimd_extxrgb_gray_convert_sse2;
+      break;
+    default:
+      sse2fct=jsimd_rgb_gray_convert_sse2;
+      break;
+  }
+
+  sse2fct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
+}
+
+GLOBAL(void)
 jsimd_ycc_rgb_convert (j_decompress_ptr cinfo,
                        JSAMPIMAGE input_buf, JDIMENSION input_row,
                        JSAMPARRAY output_buf, int num_rows)
@@ -111,18 +171,22 @@
       sse2fct=jsimd_ycc_extrgb_convert_sse2;
       break;
     case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
       sse2fct=jsimd_ycc_extrgbx_convert_sse2;
       break;
     case JCS_EXT_BGR:
       sse2fct=jsimd_ycc_extbgr_convert_sse2;
       break;
     case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
       sse2fct=jsimd_ycc_extbgrx_convert_sse2;
       break;
     case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
       sse2fct=jsimd_ycc_extxbgr_convert_sse2;
       break;
     case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
       sse2fct=jsimd_ycc_extxrgb_convert_sse2;
       break;
     default:
@@ -203,6 +267,22 @@
   return 1;
 }
 
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+
+GLOBAL(int)
+jsimd_can_h1v2_upsample (void)
+{
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  return 1;
+}
+
+#endif // UPSAMPLE_H1V2_SUPPORTED
+
 GLOBAL(void)
 jsimd_h2v2_upsample (j_decompress_ptr cinfo,
                      jpeg_component_info * compptr, 
@@ -225,6 +305,22 @@
                            input_data, output_data_ptr);
 }
 
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+
+GLOBAL(void)
+jsimd_h1v2_upsample (j_decompress_ptr cinfo,
+                     jpeg_component_info * compptr, 
+                     JSAMPARRAY input_data,
+                     JSAMPARRAY * output_data_ptr)
+{
+  jsimd_h1v2_upsample_sse2(cinfo->max_v_samp_factor,
+                           cinfo->output_width,
+                           input_data, output_data_ptr);
+}
+
+
+#endif    // UPSAMPLE_H1V2_SUPPORTED
+
 GLOBAL(int)
 jsimd_can_h2v2_fancy_upsample (void)
 {
@@ -255,6 +351,25 @@
   return 1;
 }
 
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+
+GLOBAL(int)
+jsimd_can_h1v2_fancy_upsample (void)
+{
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  if (!IS_ALIGNED_SSE(jconst_fancy_upsample_sse2))
+    return 0;
+
+  return 1;
+}
+
+#endif // UPSAMPLE_H1V2_SUPPORTED
+
 GLOBAL(void)
 jsimd_h2v2_fancy_upsample (j_decompress_ptr cinfo,
                            jpeg_component_info * compptr, 
@@ -277,6 +392,21 @@
                                  input_data, output_data_ptr);
 }
 
+#ifdef UPSAMPLE_H1V2_SUPPORTED
+
+GLOBAL(void)
+jsimd_h1v2_fancy_upsample (j_decompress_ptr cinfo,
+                           jpeg_component_info * compptr, 
+                           JSAMPARRAY input_data,
+                           JSAMPARRAY * output_data_ptr)
+{
+  jsimd_h1v2_fancy_upsample_sse2(cinfo->max_v_samp_factor,
+                                 compptr->downsampled_width,
+                                 input_data, output_data_ptr);
+}
+
+#endif // UPSAMPLE_H1V2_SUPPORTED
+
 GLOBAL(int)
 jsimd_can_h2v2_merged_upsample (void)
 {
@@ -321,18 +451,22 @@
       sse2fct=jsimd_h2v2_extrgb_merged_upsample_sse2;
       break;
     case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
       sse2fct=jsimd_h2v2_extrgbx_merged_upsample_sse2;
       break;
     case JCS_EXT_BGR:
       sse2fct=jsimd_h2v2_extbgr_merged_upsample_sse2;
       break;
     case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
       sse2fct=jsimd_h2v2_extbgrx_merged_upsample_sse2;
       break;
     case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
       sse2fct=jsimd_h2v2_extxbgr_merged_upsample_sse2;
       break;
     case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
       sse2fct=jsimd_h2v2_extxrgb_merged_upsample_sse2;
       break;
     default:
@@ -357,18 +491,22 @@
       sse2fct=jsimd_h2v1_extrgb_merged_upsample_sse2;
       break;
     case JCS_EXT_RGBX:
+    case JCS_EXT_RGBA:
       sse2fct=jsimd_h2v1_extrgbx_merged_upsample_sse2;
       break;
     case JCS_EXT_BGR:
       sse2fct=jsimd_h2v1_extbgr_merged_upsample_sse2;
       break;
     case JCS_EXT_BGRX:
+    case JCS_EXT_BGRA:
       sse2fct=jsimd_h2v1_extbgrx_merged_upsample_sse2;
       break;
     case JCS_EXT_XBGR:
+    case JCS_EXT_ABGR:
       sse2fct=jsimd_h2v1_extxbgr_merged_upsample_sse2;
       break;
     case JCS_EXT_XRGB:
+    case JCS_EXT_ARGB:
       sse2fct=jsimd_h2v1_extxrgb_merged_upsample_sse2;
       break;
     default:
diff -r 3a99d7ff459c media/libjpeg/simd/jsimdcfg.inc
--- a/media/libjpeg/simd/jsimdcfg.inc    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jsimdcfg.inc    Tue Jan 24 23:47:27 2012 +0900
@@ -9,10 +9,47 @@
 ;
 ; -- jmorecfg.h
 ;
+; Capability options common to encoder and decoder:
+
+%define DCT_ISLOW_SUPPORTED    ; slow but accurate integer algorithm
+%define DCT_IFAST_SUPPORTED    ; faster, less accurate integer method
+%define DCT_FLOAT_SUPPORTED    ; floating-point: accurate, fast on fast HW
+
+; Decoder capability options:
+
+%define IDCT_SCALING_SUPPORTED        ; Output rescaling via IDCT?
+%define UPSAMPLE_MERGING_SUPPORTED    ; Fast path for sloppy upsampling?
+%define UPSAMPLE_H1V2_SUPPORTED        ; Fast/fancy processing for 1h2v?
+
 %define RGB_RED 0
 %define RGB_GREEN 1
 %define RGB_BLUE 2
 %define RGB_PIXELSIZE 3
+%define EXT_RGB_RED 0
+%define EXT_RGB_GREEN 1
+%define EXT_RGB_BLUE 2
+%define EXT_RGB_PIXELSIZE 3
+%define EXT_RGBX_RED 0
+%define EXT_RGBX_GREEN 1
+%define EXT_RGBX_BLUE 2
+%define EXT_RGBX_PIXELSIZE 4
+%define EXT_BGR_RED 2
+%define EXT_BGR_GREEN 1
+%define EXT_BGR_BLUE 0
+%define EXT_BGR_PIXELSIZE 3
+%define EXT_BGRX_RED 2
+%define EXT_BGRX_GREEN 1
+%define EXT_BGRX_BLUE 0
+%define EXT_BGRX_PIXELSIZE 4
+%define EXT_XBGR_RED 3
+%define EXT_XBGR_GREEN 2
+%define EXT_XBGR_BLUE 1
+%define EXT_XBGR_PIXELSIZE 4
+%define EXT_XRGB_RED 1
+%define EXT_XRGB_GREEN 2
+%define EXT_XRGB_BLUE 3
+%define EXT_XRGB_PIXELSIZE 4
+%define RGBX_FILLER_0XFF 1
 ; Representation of a single sample (pixel element value).
 ; On this SIMD implementation, this must be 'unsigned char'.
 ;
@@ -48,7 +85,7 @@
 %define SIZEOF_DCTELEM SIZEOF_WORD ; sizeof(DCTELEM)
 %define float FP32 ; float
 %define SIZEOF_FAST_FLOAT SIZEOF_FP32 ; sizeof(float)
-; To maximize parallelism, Type short is changed to short.
+; To maximize parallelism, Type int is changed to short.
 ;
 %define ISLOW_MULT_TYPE word ; must be short
 %define SIZEOF_ISLOW_MULT_TYPE SIZEOF_WORD ; sizeof(ISLOW_MULT_TYPE)
diff -r 3a99d7ff459c media/libjpeg/simd/jsimdcfg.inc.h
--- a/media/libjpeg/simd/jsimdcfg.inc.h    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jsimdcfg.inc.h    Tue Jan 24 23:47:27 2012 +0900
@@ -24,7 +24,6 @@
 
 definev(DCTSIZE)
 definev(DCTSIZE2)
-
 ;
 ; -- jmorecfg.h
 ;
@@ -32,8 +31,39 @@
 definev(RGB_RED)
 definev(RGB_GREEN)
 definev(RGB_BLUE)
+definev(RGB_PIXELSIZE)
 
-definev(RGB_PIXELSIZE)
+definev(EXT_RGB_RED)
+definev(EXT_RGB_GREEN)
+definev(EXT_RGB_BLUE)
+definev(EXT_RGB_PIXELSIZE)
+
+definev(EXT_RGBX_RED)
+definev(EXT_RGBX_GREEN)
+definev(EXT_RGBX_BLUE)
+definev(EXT_RGBX_PIXELSIZE)
+
+definev(EXT_BGR_RED)
+definev(EXT_BGR_GREEN)
+definev(EXT_BGR_BLUE)
+definev(EXT_BGR_PIXELSIZE)
+
+definev(EXT_BGRX_RED)
+definev(EXT_BGRX_GREEN)
+definev(EXT_BGRX_BLUE)
+definev(EXT_BGRX_PIXELSIZE)
+
+definev(EXT_XBGR_RED)
+definev(EXT_XBGR_GREEN)
+definev(EXT_XBGR_BLUE)
+definev(EXT_XBGR_PIXELSIZE)
+
+definev(EXT_XRGB_RED)
+definev(EXT_XRGB_GREEN)
+definev(EXT_XRGB_BLUE)
+definev(EXT_XRGB_PIXELSIZE)
+
+%define RGBX_FILLER_0XFF        1
 
 ; Representation of a single sample (pixel element value).
 ; On this SIMD implementation, this must be 'unsigned char'.
diff -r 3a99d7ff459c media/libjpeg/simd/jsimdext.inc
--- a/media/libjpeg/simd/jsimdext.inc    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/simd/jsimdext.inc    Tue Jan 24 23:47:27 2012 +0900
@@ -38,19 +38,27 @@
 
 ; -- segment definition --
 ;
+%ifdef __YASM_VER__
+%define SEG_TEXT    .text  align=16
+%define SEG_CONST   .rdata align=16
+%else
 %define SEG_TEXT    .text  align=16 public use32 class=CODE
 %define SEG_CONST   .rdata align=16 public use32 class=CONST
+%endif
 
 %elifdef WIN64    ; ----(nasm -fwin64 -DWIN64 ...)--------
 ; * Microsoft Visual C++
 
 ; -- segment definition --
 ;
+%ifdef __YASM_VER__
+%define SEG_TEXT    .text  align=16
+%define SEG_CONST   .rdata align=16
+%else
 %define SEG_TEXT    .text  align=16 public use64 class=CODE
 %define SEG_CONST   .rdata align=16 public use64 class=CONST
-%ifdef MSVC
+%endif
 %define EXTN(name)  name            ; foo() -> foo
-%endif
 
 %elifdef OBJ32    ; ----(nasm -fobj -DOBJ32 ...)----------
 ; * Borland C++ (Win32)
@@ -78,6 +86,8 @@
 %define SEG_CONST   .rodata progbits alloc noexec nowrite align=16
 %endif
 
+%define STRICT_MEMORY_ACCESS 1
+
 ; To make the code position-independent, append -DPIC to the commandline
 ;
 %define GOT_SYMBOL  _GLOBAL_OFFSET_TABLE_    ; ELF supports PIC
@@ -299,8 +309,6 @@
 %ifdef WIN64
 
 %imacro collect_args 0
-    push r10
-    push r11
     push r12
     push r13
     push r14
@@ -330,8 +338,6 @@
     pop r14
     pop r13
     pop r12
-    pop r11
-    pop r10
 %endmacro
 
 %else
diff -r 3a99d7ff459c media/libjpeg/transupp.h
--- a/media/libjpeg/transupp.h    Mon Jan 23 16:10:39 2012 -0800
+++ b/media/libjpeg/transupp.h    Tue Jan 24 23:47:27 2012 +0900
@@ -128,6 +128,13 @@
   boolean trim;            /* if TRUE, trim partial MCUs as needed */
   boolean force_grayscale;    /* if TRUE, convert color image to grayscale */
   boolean crop;            /* if TRUE, crop source image */
+  boolean slow_hflip;  /* For best performance, the JXFORM_FLIP_H transform
+                          normally modifies the source coefficients in place.
+                          Setting this to TRUE will instead use a slower,
+                          double-buffered algorithm, which leaves the source
+                          coefficients in tact (necessary if other transformed
+                          images must be generated from the same set of
+                          coefficients. */
 
   /* Crop parameters: application need not set these unless crop is TRUE.
    * These can be filled in by jtransform_parse_crop_spec().


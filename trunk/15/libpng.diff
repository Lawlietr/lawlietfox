diff -r eb421f1dd8ef media/libpng/CHANGES
--- a/media/libpng/CHANGES	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/CHANGES	Tue Jul 17 20:55:17 2012 +0900
@@ -3854,6 +3854,43 @@
   Revised png_set_text_2() to avoid potential memory corruption (fixes
     CVE-2011-3048).
 
+Version 1.5.11beta01 [April 28, 2012]
+  Revised scripts/makefile.darwin: use system zlib; remove quotes around
+    architecture list; add missing ppc architecture; add architecture options
+    to shared library link; don't try to create a shared lib based on missing
+    RELEASE variable.
+  Enable png_set_check_for_invalid_index() for both read and write.
+  Removed #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED/#endif in pngpriv.h around
+    declaration of png_handle_unknown().
+  Added -lssp_nonshared in a comment in scripts/makefile.freebsd
+    and changed deprecated NOOBJ and NOPROFILE to NO_OBJ and NO_PROFILE.
+
+Version 1.5.11rc01 [May 23, 2012]
+  No changes.
+
+Version 1.5.11rc02 [May 29, 2012]
+  Fixed some typos in comments.
+  Revised CMakeLists.txt to not attempt to make a symlink under mingw.
+  Added two images to contrib/pngsuite (1-bit and 2-bit transparent grayscale),
+    and renamed three whose names were inconsistent with those in
+    pngsuite/README.txt.
+
+Version 1.5.11rc03 [June 4, 2012]
+  Do not depend upon a GCC feature macro being available for use in generating
+    the linker mapfile symbol prefix.
+  Made fixes for new optimization warnings from gcc 4.7.0. The compiler
+    performed an optimization which is safe but then warned about it.
+    Changing the type of 'palette_number' in pngvalid.c removes the warning.
+
+Version 1.5.11rc04 [June 6, 2012]
+  Improved performance of new do_check_palette_indexes() function.
+
+Version 1.5.11rc05 [June 7, 2012]
+  Don't check palette indexes if num_palette is 0 (as it can be in MNG files).
+
+Version 1.5.11 [June 14, 2012]
+  Include zlib.h in contrib/gregbook and contrib/visupng examples.
+
 Send comments/corrections/commendations to png-mng-implement at lists.sf.net
 (subscription required; visit
 https://lists.sourceforge.net/lists/listinfo/png-mng-implement
diff -r eb421f1dd8ef media/libpng/LICENSE
--- a/media/libpng/LICENSE	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/LICENSE	Tue Jul 17 20:55:17 2012 +0900
@@ -10,8 +10,8 @@
 
 This code is released under the libpng license.
 
-libpng versions 1.2.6, August 15, 2004, through 1.5.10, March 29, 2012, are
-Copyright (c) 2004, 2006-2011 Glenn Randers-Pehrson, and are
+libpng versions 1.2.6, August 15, 2004, through 1.5.11, June 14, 2012, are
+Copyright (c) 2004, 2006-2012 Glenn Randers-Pehrson, and are
 distributed according to the same disclaimer and license as libpng-1.2.5
 with the following individual added to the list of Contributing Authors
 
@@ -108,4 +108,4 @@
 
 Glenn Randers-Pehrson
 glennrp at users.sourceforge.net
-March 29, 2012
+June 14, 2012
diff -r eb421f1dd8ef media/libpng/MOZCHANGES
--- a/media/libpng/MOZCHANGES	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/MOZCHANGES	Tue Jul 17 20:55:17 2012 +0900
@@ -1,6 +1,10 @@
 
 Changes made to pristine png source by mozilla.org developers.
 
+2012/07/16  -- Add an "APNG-aware app" flag (bug #759067).
+
+2012/07/04  -- Synced with libpng-1.5.11 (bug #771394).
+
 2012/04/13  -- Synced with libpng-1.5.10 (bug #745178).
 
 2012/02/19  -- Synced with libpng-1.5.9 (bug #648690).
diff -r eb421f1dd8ef media/libpng/Makefile.in
--- a/media/libpng/Makefile.in	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/Makefile.in	Tue Jul 17 20:55:17 2012 +0900
@@ -52,7 +52,6 @@
 include $(topsrcdir)/config/rules.mk
 
 ifeq ($(OS_ARCH),WINNT)
-DEFINES		+= -DZLIB_DLL
 ifdef BUILD_DEBUG_GC
 DEFINES		+= -DDEBUG_GC
 endif
diff -r eb421f1dd8ef media/libpng/README
--- a/media/libpng/README	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/README	Tue Jul 17 20:55:17 2012 +0900
@@ -1,4 +1,4 @@
-README for libpng version 1.5.10 - March 29, 2012 (shared library 15.0)
+README for libpng version 1.5.11 - June 14, 2012 (shared library 15.0)
 See the note about version numbers near the top of png.h
 
 See INSTALL for instructions on how to install libpng.
diff -r eb421f1dd8ef media/libpng/apng.patch
--- a/media/libpng/apng.patch	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/apng.patch	Tue Jul 17 20:55:17 2012 +0900
@@ -1,14 +1,14 @@
 diff -up8 png.h png.h
---- png.h	2012-02-18 15:31:14 -0500
-+++ png.h	2012-02-19 16:08:36 -0500
-@@ -417,24 +417,18 @@
+--- png.h	2012-06-14 07:28:00 -0400
++++ png.h	2012-07-07 10:21:31 -0400
+@@ -423,24 +423,18 @@
  /* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
   * We must not include leading zeros.
   * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
   * version 1.0.0 was mis-numbered 100 instead of 10000).  From
   * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
   */
- #define PNG_LIBPNG_VER 10509 /* 1.5.9 */
+ #define PNG_LIBPNG_VER 10511 /* 1.5.11 */
  
 -/* Library configuration: these options cannot be changed after
 - * the library has been built.
@@ -28,7 +28,7 @@
     *   Standard header files (not needed for the version info or while
     *   building symbol table -- see scripts/pnglibconf.dfa)
     */
-@@ -534,16 +528,27 @@ extern "C" {
+@@ -540,16 +534,27 @@ extern "C" {
   * Otherwise the calls are mapped to png_error.
   */
  
@@ -51,12 +51,12 @@
  /* This triggers a compiler error in png.c, if png.c and png.h
   * do not agree upon the version number.
   */
- typedef char* png_libpng_version_1_5_9;
+ typedef char* png_libpng_version_1_5_11;
  
  /* Three color definitions.  The order of the red, green, and blue, (and the
   * exact size) is not important, although the size of the fields need to
   * be png_byte or png_uint_16 (as defined below).
-@@ -817,16 +822,20 @@ typedef png_info FAR * FAR * png_infopp;
+@@ -823,16 +828,20 @@ typedef png_info FAR * FAR * png_infopp;
  #define PNG_INFO_oFFs 0x0100
  #define PNG_INFO_tIME 0x0200
  #define PNG_INFO_pCAL 0x0400
@@ -77,7 +77,7 @@
  typedef struct png_row_info_struct
  {
     png_uint_32 width;    /* width of row */
-@@ -862,16 +871,20 @@ typedef PNG_CALLBACK(void, *png_flush_pt
+@@ -868,16 +877,20 @@ typedef PNG_CALLBACK(void, *png_flush_pt
  typedef PNG_CALLBACK(void, *png_read_status_ptr, (png_structp, png_uint_32,
      int));
  typedef PNG_CALLBACK(void, *png_write_status_ptr, (png_structp, png_uint_32,
@@ -98,80 +98,80 @@
   * then reset to 0 for the next pass.
   *
   * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
-@@ -2632,26 +2645,99 @@ PNG_EXPORT(207, void, png_save_uint_16, 
-        ((unsigned int)(*((buf) + 1)))))
+@@ -2644,26 +2657,99 @@ PNG_EXPORT(207, void, png_save_uint_16, 
+ #endif
  
- #  define png_get_int_32(buf) \
-      ((png_int_32)((*(buf) & 0x80) \
-       ? -((png_int_32)((png_get_uint_32(buf) ^ 0xffffffffL) + 1)) \
-       : (png_int_32)png_get_uint_32(buf)))
+ #if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \
+     defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)
+ PNG_EXPORT(234, void, png_set_check_for_invalid_index, (png_structp png_ptr,
+     int allowed));
  #endif
  
 +#ifdef PNG_APNG_SUPPORTED
-+PNG_EXPORT(234, png_uint_32, png_get_acTL, (png_structp png_ptr,
++PNG_EXPORT(235, png_uint_32, png_get_acTL, (png_structp png_ptr,
 +   png_infop info_ptr, png_uint_32 *num_frames, png_uint_32 *num_plays));
 +
-+PNG_EXPORT(235, png_uint_32, png_set_acTL, (png_structp png_ptr,
++PNG_EXPORT(236, png_uint_32, png_set_acTL, (png_structp png_ptr,
 +   png_infop info_ptr, png_uint_32 num_frames, png_uint_32 num_plays));
 +
-+PNG_EXPORT(236, png_uint_32, png_get_num_frames, (png_structp png_ptr,
++PNG_EXPORT(237, png_uint_32, png_get_num_frames, (png_structp png_ptr,
 +   png_infop info_ptr));
 +
-+PNG_EXPORT(237, png_uint_32, png_get_num_plays, (png_structp png_ptr,
++PNG_EXPORT(238, png_uint_32, png_get_num_plays, (png_structp png_ptr,
 +   png_infop info_ptr));
 +
-+PNG_EXPORT(238, png_uint_32, png_get_next_frame_fcTL,
++PNG_EXPORT(239, png_uint_32, png_get_next_frame_fcTL,
 +   (png_structp png_ptr, png_infop info_ptr, png_uint_32 *width,
 +   png_uint_32 *height, png_uint_32 *x_offset, png_uint_32 *y_offset,
 +   png_uint_16 *delay_num, png_uint_16 *delay_den, png_byte *dispose_op,
 +   png_byte *blend_op));
 +
-+PNG_EXPORT(239, png_uint_32, png_set_next_frame_fcTL,
++PNG_EXPORT(240, png_uint_32, png_set_next_frame_fcTL,
 +   (png_structp png_ptr, png_infop info_ptr, png_uint_32 width,
 +   png_uint_32 height, png_uint_32 x_offset, png_uint_32 y_offset,
 +   png_uint_16 delay_num, png_uint_16 delay_den, png_byte dispose_op,
 +   png_byte blend_op));
 +
-+PNG_EXPORT(240, png_uint_32, png_get_next_frame_width,
++PNG_EXPORT(241, png_uint_32, png_get_next_frame_width,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(241, png_uint_32, png_get_next_frame_height,
++PNG_EXPORT(242, png_uint_32, png_get_next_frame_height,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(242, png_uint_32, png_get_next_frame_x_offset,
++PNG_EXPORT(243, png_uint_32, png_get_next_frame_x_offset,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(243, png_uint_32, png_get_next_frame_y_offset,
++PNG_EXPORT(244, png_uint_32, png_get_next_frame_y_offset,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(244, png_uint_16, png_get_next_frame_delay_num,
++PNG_EXPORT(245, png_uint_16, png_get_next_frame_delay_num,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(245, png_uint_16, png_get_next_frame_delay_den,
++PNG_EXPORT(246, png_uint_16, png_get_next_frame_delay_den,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(246, png_byte, png_get_next_frame_dispose_op,
++PNG_EXPORT(247, png_byte, png_get_next_frame_dispose_op,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(247, png_byte, png_get_next_frame_blend_op,
++PNG_EXPORT(248, png_byte, png_get_next_frame_blend_op,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(248, png_byte, png_get_first_frame_is_hidden,
++PNG_EXPORT(249, png_byte, png_get_first_frame_is_hidden,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(249, png_uint_32, png_set_first_frame_is_hidden,
++PNG_EXPORT(250, png_uint_32, png_set_first_frame_is_hidden,
 +   (png_structp png_ptr, png_infop info_ptr, png_byte is_hidden));
 +
 +#ifdef PNG_READ_APNG_SUPPORTED
-+PNG_EXPORT(250, void, png_read_frame_head, (png_structp png_ptr,
++PNG_EXPORT(251, void, png_read_frame_head, (png_structp png_ptr,
 +   png_infop info_ptr));
 +#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-+PNG_EXPORT(251, void, png_set_progressive_frame_fn, (png_structp png_ptr,
++PNG_EXPORT(252, void, png_set_progressive_frame_fn, (png_structp png_ptr,
 +   png_progressive_frame_ptr frame_info_fn,
 +   png_progressive_frame_ptr frame_end_fn));
 +#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
 +#endif /* PNG_READ_APNG_SUPPORTED */
 +
 +#ifdef PNG_WRITE_APNG_SUPPORTED
-+PNG_EXPORT(252, void, png_write_frame_head, (png_structp png_ptr,
++PNG_EXPORT(253, void, png_write_frame_head, (png_structp png_ptr,
 +   png_infop info_ptr, png_bytepp row_pointers,
 +   png_uint_32 width, png_uint_32 height,
 +   png_uint_32 x_offset, png_uint_32 y_offset,
 +   png_uint_16 delay_num, png_uint_16 delay_den, png_byte dispose_op,
 +   png_byte blend_op));
 +
-+PNG_EXPORT(253, void, png_write_frame_tail, (png_structp png_ptr,
++PNG_EXPORT(254, void, png_write_frame_tail, (png_structp png_ptr,
 +   png_infop info_ptr));
 +#endif /* PNG_WRITE_APNG_SUPPORTED */
 +#endif /* PNG_APNG_SUPPORTED */
@@ -186,9 +186,9 @@
   */
  #ifdef PNG_EXPORT_LAST_ORDINAL
 +#ifdef PNG_APNG_SUPPORTED
-+  PNG_EXPORT_LAST_ORDINAL(253);
++  PNG_EXPORT_LAST_ORDINAL(254);
 +#else
-   PNG_EXPORT_LAST_ORDINAL(233);
+   PNG_EXPORT_LAST_ORDINAL(234);
 +#endif /* PNG_APNG_SUPPORTED */
  #endif
  
@@ -199,8 +199,8 @@
  #endif /* PNG_VERSION_INFO_ONLY */
  /* Do not put anything past this line */
 diff -up8 pngget.c pngget.c
---- pngget.c	2012-02-18 15:31:14 -0500
-+++ pngget.c	2012-02-19 16:02:28 -0500
+--- pngget.c	2012-06-14 07:28:00 -0400
++++ pngget.c	2012-04-24 20:51:09 -0400
 @@ -1116,9 +1116,171 @@ png_get_io_chunk_type (png_const_structp
  png_const_bytep PNGAPI
  png_get_io_chunk_name (png_structp png_ptr)
@@ -261,7 +261,7 @@
 +    if (png_ptr != NULL && info_ptr != NULL &&
 +        (info_ptr->valid & PNG_INFO_fcTL) &&
 +        width != NULL && height != NULL &&
-+        x_offset != NULL && x_offset != NULL &&
++        x_offset != NULL && y_offset != NULL &&
 +        delay_num != NULL && delay_den != NULL &&
 +        dispose_op != NULL && blend_op != NULL)
 +    {
@@ -374,8 +374,8 @@
 +#endif /* PNG_APNG_SUPPORTED */
  #endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
 diff -up8 pnginfo.h pnginfo.h
---- pnginfo.h	2012-02-18 15:31:14 -0500
-+++ pnginfo.h	2012-02-19 16:02:28 -0500
+--- pnginfo.h	2012-06-14 07:28:00 -0400
++++ pnginfo.h	2012-03-03 22:17:56 -0500
 @@ -260,10 +260,23 @@ defined(PNG_READ_BACKGROUND_SUPPORTED)
  
  #ifdef PNG_INFO_IMAGE_SUPPORTED
@@ -401,9 +401,9 @@
  };
  #endif /* PNGINFO_H */
 diff -up8 pngpread.c pngpread.c
---- pngpread.c	2012-02-18 15:31:14 -0500
-+++ pngpread.c	2012-02-19 16:02:28 -0500
-@@ -233,16 +233,119 @@ png_push_read_chunk(png_structp png_ptr,
+--- pngpread.c	2012-06-14 07:28:00 -0400
++++ pngpread.c	2012-07-16 20:05:38 -0400
+@@ -210,16 +210,119 @@ png_push_read_chunk(png_structp png_ptr,
        png_crc_read(png_ptr, chunk_tag, 4);
        png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);
        png_check_chunk_name(png_ptr, png_ptr->chunk_name);
@@ -523,7 +523,7 @@
         *
         * TODO: there must be a better way of doing this.
         */
-@@ -336,16 +439,20 @@ png_push_read_chunk(png_structp png_ptr,
+@@ -313,16 +416,20 @@ png_push_read_chunk(png_structp png_ptr,
           if (!(png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))
              if (png_ptr->push_length == 0)
                 return;
@@ -544,16 +544,15 @@
            (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,
            png_ptr->iwidth) + 1;
        png_ptr->zstream.next_out = png_ptr->row_buf;
-@@ -568,16 +675,39 @@ png_push_read_chunk(png_structp png_ptr,
-          png_push_save_buffer(png_ptr);
+@@ -546,16 +653,38 @@ png_push_read_chunk(png_structp png_ptr,
           return;
        }
  
-       png_push_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
+       png_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
     }
  
  #endif
-+
+ 
 +#ifdef PNG_READ_APNG_SUPPORTED
 +   else if (chunk_name == png_acTL)
 +   {
@@ -583,8 +582,8 @@
           png_push_save_buffer(png_ptr);
           return;
        }
-       png_push_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
-@@ -767,40 +897,91 @@ void /* PRIVATE */
+       png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
+@@ -753,40 +882,91 @@ void /* PRIVATE */
  png_push_read_IDAT(png_structp png_ptr)
  {
     if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))
@@ -676,7 +675,33 @@
        png_uint_32 idat_size = png_ptr->idat_size;
  
        /* We want the smaller of 'idat_size' and 'current_buffer_size', but they
-@@ -1827,16 +2008,27 @@ png_set_progressive_read_fn(png_structp 
+@@ -854,16 +1034,25 @@ png_push_read_IDAT(png_structp png_ptr)
+ void /* PRIVATE */
+ png_process_IDAT_data(png_structp png_ptr, png_bytep buffer,
+    png_size_t buffer_length)
+ {
+    /* The caller checks for a non-zero buffer length. */
+    if (!(buffer_length > 0) || buffer == NULL)
+       png_error(png_ptr, "No IDAT data (internal error)");
+ 
++#ifdef PNG_READ_APNG_SUPPORTED
++   /* If the app is not APNG-aware, decode only the first frame */
++   if (!(png_ptr->apng_flags & PNG_APNG_APP) && png_ptr->num_frames_read > 0)
++   {
++     png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
++     return;
++   }
++#endif
++
+    /* This routine must process all the data it has been given
+     * before returning, calling the row callback as required to
+     * handle the uncompressed results.
+     */
+    png_ptr->zstream.next_in = buffer;
+    png_ptr->zstream.avail_in = (uInt)buffer_length;
+ 
+    /* Keep going until the decompressed data is all processed
+@@ -1299,16 +1488,28 @@ png_set_progressive_read_fn(png_structp 
  
     png_ptr->info_fn = info_fn;
     png_ptr->row_fn = row_fn;
@@ -693,6 +718,7 @@
 +{
 +   png_ptr->frame_info_fn = frame_info_fn;
 +   png_ptr->frame_end_fn = frame_end_fn;
++   png_ptr->apng_flags |= PNG_APNG_APP;
 +}
 +#endif
 +
@@ -705,10 +731,9 @@
     return png_ptr->io_ptr;
  }
 diff -up8 pngpriv.h pngpriv.h
---- pngpriv.h	2012-02-18 15:31:14 -0500
-+++ pngpriv.h	2012-02-19 16:02:28 -0500
-@@ -421,16 +421,20 @@ typedef PNG_CONST png_uint_16p FAR * png
- #define PNG_HAVE_cHRM               0x40
+--- pngpriv.h	2012-06-14 07:28:00 -0400
++++ pngpriv.h	2012-07-16 20:05:38 -0400
+@@ -462,16 +462,20 @@ typedef PNG_CONST png_uint_16p FAR * png
  #define PNG_HAVE_sRGB               0x80
  #define PNG_HAVE_CHUNK_HEADER      0x100
  #define PNG_WROTE_tIME             0x200
@@ -716,9 +741,10 @@
  #define PNG_BACKGROUND_IS_GRAY     0x800
  #define PNG_HAVE_PNG_SIGNATURE    0x1000
  #define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000 /* Have another chunk after IDAT */
+ #define PNG_HAVE_iCCP             0x4000
 +#ifdef PNG_APNG_SUPPORTED
-+#define PNG_HAVE_acTL             0x4000
-+#define PNG_HAVE_fcTL             0x8000
++#define PNG_HAVE_acTL             0x8000
++#define PNG_HAVE_fcTL            0x10000
 +#endif
  
  /* Flags for the transformations the PNG library does on the image data */
@@ -728,7 +754,7 @@
  #define PNG_SHIFT               0x0008
  #define PNG_SWAP_BYTES          0x0010
  #define PNG_INVERT_MONO         0x0020
-@@ -616,16 +620,25 @@ PNG_EXTERN png_fixed_point png_fixed PNG
+@@ -657,16 +661,26 @@ PNG_EXTERN png_fixed_point png_fixed PNG
  #define png_sPLT PNG_CHUNK(115,  80,  76,  84)
  #define png_sRGB PNG_CHUNK(115,  82,  71,  66)
  #define png_sTER PNG_CHUNK(115,  84,  69,  82)
@@ -744,6 +770,7 @@
 +
 +/* For png_struct.apng_flags: */
 +#define PNG_FIRST_FRAME_HIDDEN       0x0001
++#define PNG_APNG_APP                 0x0002
 +#endif
 +
  /* The following will work on (signed char*) strings, whereas the get_uint_32
@@ -754,7 +781,7 @@
  
  /* This uses (char), not (png_byte) to avoid warnings on systems where (char) is
   * signed and the argument is a (char[])  This macro will fail miserably on
-@@ -1299,16 +1312,55 @@ PNG_EXTERN void png_push_read_iTXt PNGAR
+@@ -1338,16 +1352,55 @@ PNG_EXTERN void png_push_read_iTXt PNGAR
  
  #ifdef PNG_MNG_FEATURES_SUPPORTED
  PNG_EXTERN void png_do_read_intrapixel PNGARG((png_row_infop row_info,
@@ -811,9 +838,9 @@
      png_fixed_point int_blue_y));
  #endif
 diff -up8 pngread.c pngread.c
---- pngread.c	2012-02-18 15:31:14 -0500
-+++ pngread.c	2012-02-19 16:03:41 -0500
-@@ -239,16 +239,19 @@ png_read_info(png_structp png_ptr, png_i
+--- pngread.c	2012-06-14 07:28:00 -0400
++++ pngread.c	2012-07-16 20:05:38 -0400
+@@ -235,16 +235,19 @@ png_read_info(png_structp png_ptr, png_i
        {
           if (!(png_ptr->mode & PNG_HAVE_IHDR))
              png_error(png_ptr, "Missing IHDR before IDAT");
@@ -833,7 +860,7 @@
  #ifdef PNG_READ_bKGD_SUPPORTED
        else if (chunk_name == png_bKGD)
           png_handle_bKGD(png_ptr, info_ptr, length);
-@@ -329,22 +332,100 @@ png_read_info(png_structp png_ptr, png_i
+@@ -325,22 +328,100 @@ png_read_info(png_structp png_ptr, png_i
           png_handle_zTXt(png_ptr, info_ptr, length);
  #endif
  
@@ -934,7 +961,7 @@
  
     if (png_ptr == NULL)
        return;
-@@ -536,24 +617,57 @@ png_read_row(png_structp png_ptr, png_by
+@@ -532,24 +613,57 @@ png_read_row(png_structp png_ptr, png_by
     png_ptr->zstream.avail_out =
         (uInt)(PNG_ROWBYTES(png_ptr->pixel_depth,
         png_ptr->iwidth) + 1);
@@ -992,7 +1019,7 @@
               (png_size_t)png_ptr->zstream.avail_in);
           png_ptr->idat_size -= png_ptr->zstream.avail_in;
        }
-@@ -562,16 +676,19 @@ png_read_row(png_structp png_ptr, png_by
+@@ -558,16 +672,19 @@ png_read_row(png_structp png_ptr, png_by
  
        if (ret == Z_STREAM_END)
        {
@@ -1012,36 +1039,10 @@
               "Decompression error");
  
     } while (png_ptr->zstream.avail_out);
-@@ -924,16 +1041,25 @@ png_read_end(png_structp png_ptr, png_in
-          png_handle_zTXt(png_ptr, info_ptr, length);
- #endif
- 
- #ifdef PNG_READ_iTXt_SUPPORTED
-       else if (chunk_name == png_iTXt)
-          png_handle_iTXt(png_ptr, info_ptr, length);
- #endif
- 
-+#ifdef PNG_READ_APNG_SUPPORTED
-+      else if (chunk_name == png_acTL)
-+         png_handle_acTL(png_ptr, info_ptr, length);
-+      else if (chunk_name == png_fcTL)
-+         png_handle_fcTL(png_ptr, info_ptr, length);
-+      else if (chunk_name == png_fdAT)
-+         png_handle_fdAT(png_ptr, info_ptr, length);
-+#endif
-+
-       else
-          png_handle_unknown(png_ptr, info_ptr, length);
-    } while (!(png_ptr->mode & PNG_HAVE_IEND));
- }
- #endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
- 
- /* Free all memory used by the read */
- void PNGAPI
 diff -up8 pngrutil.c pngrutil.c
---- pngrutil.c	2012-02-18 15:31:14 -0500
-+++ pngrutil.c	2012-02-19 16:02:28 -0500
-@@ -544,16 +544,21 @@ png_handle_IHDR(png_structp png_ptr, png
+--- pngrutil.c	2012-06-14 07:28:00 -0400
++++ pngrutil.c	2012-04-24 20:51:09 -0400
+@@ -542,16 +542,21 @@ png_handle_IHDR(png_structp png_ptr, png
     width = png_get_uint_31(png_ptr, buf);
     height = png_get_uint_31(png_ptr, buf + 4);
     bit_depth = buf[8];
@@ -1063,7 +1064,7 @@
     png_ptr->color_type = (png_byte)color_type;
  #ifdef PNG_MNG_FEATURES_SUPPORTED
     png_ptr->filter_type = (png_byte)filter_type;
-@@ -2608,16 +2613,189 @@ png_handle_iTXt(png_structp png_ptr, png
+@@ -2609,16 +2614,189 @@ png_handle_iTXt(png_structp png_ptr, png
     png_free(png_ptr, png_ptr->chunkdata);
     png_ptr->chunkdata = NULL;
  
@@ -1253,7 +1254,7 @@
   */
  void /* PRIVATE */
  png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-@@ -4150,9 +4328,86 @@ defined(PNG_USER_TRANSFORM_PTR_SUPPORTED
+@@ -4151,9 +4329,86 @@ defined(PNG_USER_TRANSFORM_PTR_SUPPORTED
     png_debug1(3, "iwidth = %u,", png_ptr->iwidth);
     png_debug1(3, "num_rows = %u,", png_ptr->num_rows);
     png_debug1(3, "rowbytes = %lu,", (unsigned long)png_ptr->rowbytes);
@@ -1341,8 +1342,8 @@
 +#endif /* PNG_READ_APNG_SUPPORTED */
  #endif /* PNG_READ_SUPPORTED */
 diff -up8 pngset.c pngset.c
---- pngset.c	2012-02-18 15:31:14 -0500
-+++ pngset.c	2012-02-19 16:02:28 -0500
+--- pngset.c	2012-06-14 07:28:00 -0400
++++ pngset.c	2012-07-07 10:21:31 -0400
 @@ -257,16 +257,21 @@ png_set_IHDR(png_structp png_ptr, png_in
         (PNG_UINT_32_MAX >> 3)      /* 8-byte RRGGBBAA pixels */
         - 48       /* bigrowbuf hack */
@@ -1365,7 +1366,7 @@
      png_int_32 offset_x, png_int_32 offset_y, int unit_type)
  {
     png_debug1(1, "in %s storage function", "oFFs");
-@@ -1008,16 +1013,157 @@ png_set_sPLT(png_structp png_ptr,
+@@ -1017,16 +1022,157 @@ png_set_sPLT(png_structp png_ptr,
  
     info_ptr->splt_palettes = np;
     info_ptr->splt_palettes_num += nentries;
@@ -1524,8 +1525,8 @@
     int i;
  
 diff -up8 pngstruct.h pngstruct.h
---- pngstruct.h	2012-02-18 15:31:14 -0500
-+++ pngstruct.h	2012-02-19 16:02:28 -0500
+--- pngstruct.h	2012-06-14 07:28:00 -0400
++++ pngstruct.h	2012-07-07 10:21:31 -0400
 @@ -288,16 +288,37 @@ struct png_struct_def
     png_uint_32 mng_features_permitted;
  #endif
@@ -1565,8 +1566,8 @@
     png_free_ptr free_fn;          /* function for freeing memory */
  #endif
 diff -up8 pngwrite.c pngwrite.c
---- pngwrite.c	2012-02-18 15:31:14 -0500
-+++ pngwrite.c	2012-02-19 16:02:28 -0500
+--- pngwrite.c	2012-06-14 07:28:00 -0400
++++ pngwrite.c	2012-07-07 10:21:31 -0400
 @@ -53,16 +53,20 @@ png_write_info_before_PLTE(png_structp p
  #ifdef PNG_WRITE_INTERLACING_SUPPORTED
         info_ptr->interlace_type);
@@ -1588,15 +1589,16 @@
     if (info_ptr->valid & PNG_INFO_sRGB)
        png_write_sRGB(png_ptr, (int)info_ptr->srgb_intent);
  #endif
-@@ -300,16 +304,21 @@ png_write_end(png_structp png_ptr, png_i
-    png_debug(1, "in png_write_end");
- 
-    if (png_ptr == NULL)
-       return;
- 
+@@ -305,16 +309,22 @@ png_write_end(png_structp png_ptr, png_i
     if (!(png_ptr->mode & PNG_HAVE_IDAT))
        png_error(png_ptr, "No IDATs written into file");
  
+ #ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
+    if (png_ptr->num_palette_max > png_ptr->num_palette)
+       png_benign_error(png_ptr, "Wrote palette index exceeding num_palette");
+ #endif
+ 
++    /* See if user wants us to write information chunks */
 +#ifdef PNG_WRITE_APNG_SUPPORTED
 +   if (png_ptr->num_frames_written != png_ptr->num_frames_to_write)
 +      png_error(png_ptr, "Not enough frames written");
@@ -1610,7 +1612,7 @@
  #endif
  #ifdef PNG_WRITE_tIME_SUPPORTED
        /* Check to see if user has supplied a time chunk */
-@@ -1647,9 +1656,47 @@ png_write_png(png_structp png_ptr, png_i
+@@ -1660,9 +1670,47 @@ png_write_png(png_structp png_ptr, png_i
  
     /* It is REQUIRED to call this to finish writing the rest of the file */
     png_write_end(png_ptr, info_ptr);
@@ -1659,9 +1661,9 @@
 +#endif /* PNG_WRITE_APNG_SUPPORTED */
  #endif /* PNG_WRITE_SUPPORTED */
 diff -up8 pngwutil.c pngwutil.c
---- pngwutil.c	2012-02-18 15:31:14 -0500
-+++ pngwutil.c	2012-02-19 16:02:28 -0500
-@@ -815,16 +815,21 @@ png_write_IHDR(png_structp png_ptr, png_
+--- pngwutil.c	2012-06-14 07:28:00 -0400
++++ pngwutil.c	2012-04-24 20:51:09 -0400
+@@ -816,16 +816,21 @@ png_write_IHDR(png_structp png_ptr, png_
     buf[9] = (png_byte)color_type;
     buf[10] = (png_byte)compression_type;
     buf[11] = (png_byte)filter_type;
@@ -1683,7 +1685,7 @@
     if (!(png_ptr->do_filter))
     {
        if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
-@@ -1029,17 +1034,38 @@ png_write_IDAT(png_structp png_ptr, png_
+@@ -1030,17 +1035,38 @@ png_write_IDAT(png_structp png_ptr, png_
        }
  
        else
@@ -1722,7 +1724,7 @@
      */
     png_ptr->zstream.next_out = png_ptr->zbuf;
     png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-@@ -1993,16 +2019,74 @@ png_write_tIME(png_structp png_ptr, png_
+@@ -1992,16 +2018,74 @@ png_write_tIME(png_structp png_ptr, png_
     buf[4] = mod_time->hour;
     buf[5] = mod_time->minute;
     buf[6] = mod_time->second;
@@ -1797,7 +1799,7 @@
     /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
  
     /* Start of interlace block */
-@@ -3172,9 +3256,44 @@ png_write_filtered_row(png_structp png_p
+@@ -3171,9 +3255,44 @@ png_write_filtered_row(png_structp png_p
  
     if (png_ptr->flush_dist > 0 &&
         png_ptr->flush_rows >= png_ptr->flush_dist)
diff -r eb421f1dd8ef media/libpng/libpng-manual.txt
--- a/media/libpng/libpng-manual.txt	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/libpng-manual.txt	Tue Jul 17 20:55:17 2012 +0900
@@ -1,6 +1,6 @@
-libpng-manual.txt - A description on how to use and modify libpng
-
- libpng version 1.5.10 - March 29, 2012
+Libpng-manual.txt - A description on how to use and modify libpng
+
+ libpng version 1.5.11 - June 14, 2012
  Updated and distributed by Glenn Randers-Pehrson
  <glennrp at users.sourceforge.net>
  Copyright (c) 1998-2011 Glenn Randers-Pehrson
@@ -11,7 +11,7 @@
 
  Based on:
 
- libpng versions 0.97, January 1998, through 1.5.10 - March 29, 2012
+ libpng versions 0.97, January 1998, through 1.5.11 - June 14, 2012
  Updated and distributed by Glenn Randers-Pehrson
  Copyright (c) 1998-2011 Glenn Randers-Pehrson
 
@@ -141,8 +141,8 @@
 to integers of particular sizes and types for passing color values.
 
 One exception is how non-integral numbers are handled.  For application
-convenience most APIs that take such numbers have C (double) arguments,
-however internally PNG, and libpng, use 32 bit signed integers and encode
+convenience most APIs that take such numbers have C (double) arguments;
+however, internally PNG, and libpng, use 32 bit signed integers and encode
 the value by multiplying by 100,000.  As of libpng 1.5.0 a convenience
 macro PNG_FP_1 is defined in png.h along with a type (png_fixed_point)
 which is simply (png_int_32).
@@ -799,7 +799,7 @@
 will still have linear components.
 
 Use this format if you have control over your
-compositing software and do don't do other arithmetic
+compositing software and so don't do other arithmetic
 (such as scaling) on the data you get from libpng.  Your
 compositing software can simply copy opaque pixels to
 the output but still has linear values for the
@@ -1130,6 +1130,11 @@
 png_get_<chunk> are set directly if they are simple data types, or a
 pointer into the info_ptr is returned for any complex types.
 
+The colorspace data from gAMA, cHRM, sRGB, iCCP, and sBIT chunks
+is simply returned to give the application information about how the
+image was encoded.  Libpng itself only does transformations using the file
+gamma when combining semitransparent pixels with the background color.
+
     png_get_PLTE(png_ptr, info_ptr, &palette,
                      &num_palette);
 
@@ -1141,7 +1146,7 @@
     png_get_gAMA(png_ptr, info_ptr, &file_gamma);
     png_get_gAMA_fixed(png_ptr, info_ptr, &int_file_gamma);
 
-    file_gamma     - the gamma at which the file is
+    file_gamma     - the gamma at which the file was
                      written (PNG_INFO_gAMA)
 
     int_file_gamma - 100,000 times the gamma at which the
@@ -1733,7 +1738,7 @@
 need to tell libpng how the color is represented, both the format of the
 component values in the color (the number of bits) and the gamma encoding of the
 color.  The function takes two arguments, background_gamma_mode and need_expand
-to convey this information, however only two combinations are likely to be
+to convey this information; however, only two combinations are likely to be
 useful:
 
     png_color_16 my_background;
@@ -2027,7 +2032,7 @@
 
 If you don't want libpng to handle the interlacing details, just call
 png_read_rows() PNG_INTERLACE_ADAM7_PASSES times to read in all the images.
-Each of the images is a valid image by itself, however you will almost
+Each of the images is a valid image by itself; however, you will almost
 certainly need to distribute the pixels from each sub-image to the
 correct place.  This is where everything gets very tricky.
 
@@ -3685,7 +3690,7 @@
 compressed chunks such as zTXt, iTXt, and iCCP:
 
     #include zlib.h
-    #if PNG_LIBPNG_VER <= 10504
+    #if PNG_LIBPNG_VER >= 10504
     png_set_text_compression_level(png_ptr, level);
 
     png_set_text_compression_mem_level(png_ptr, level);
@@ -4155,7 +4160,7 @@
 A. Changes that affect users of libpng
 
 There are no substantial API changes between the non-deprecated parts of
-the 1.4.5 API and the 1.5.0 API, however the ability to directly access
+the 1.4.5 API and the 1.5.0 API; however, the ability to directly access
 the main libpng control structures, png_struct and png_info, deprecated
 in earlier versions of libpng, has been completely removed from
 libpng 1.5.
@@ -4288,12 +4293,12 @@
 
 Details of internal changes to the library code can be found in the CHANGES
 file and in the GIT repository logs.  These will be of no concern to the vast
-majority of library users or builders, however the few who configure libpng
+majority of library users or builders; however, the few who configure libpng
 to a non-default feature set may need to change how this is done.
 
 There should be no need for library builders to alter build scripts if
 these use the distributed build support - configure or the makefiles -
-however users of the makefiles may care to update their build scripts
+however, users of the makefiles may care to update their build scripts
 to build pnglibconf.h where the corresponding makefile does not do so.
 
 Building libpng with a non-default configuration has changed completely.
@@ -4399,7 +4404,7 @@
 PNG_FLOATING_ARITHMETIC_SUPPORTED chooses between the internal floating
 point implementation or the fixed point one.  Typically the fixed point
 implementation is larger and slower than the floating point implementation
-on a system that supports floating point, however it may be faster on a
+on a system that supports floating point; however, it may be faster on a
 system which lacks floating point hardware and therefore uses a software
 emulation.
 
@@ -4428,7 +4433,7 @@
 build of pnglibconf.h and it is never included in an application build.
 
 The rarely used alternative of adding a list of feature macros to the
-CFLAGS setting in the build also still works, however the macros will be
+CFLAGS setting in the build also still works; however, the macros will be
 copied to pnglibconf.h and this may produce macro redefinition warnings
 when the individual C files are compiled.
 
@@ -4597,25 +4602,25 @@
 
 XIV. Y2K Compliance in libpng
 
-March 29, 2012
+June 14, 2012
 
 Since the PNG Development group is an ad-hoc body, we can't make
 an official declaration.
 
 This is your unofficial assurance that libpng from version 0.71 and
-upward through 1.5.10 are Y2K compliant.  It is my belief that earlier
+upward through 1.5.11 are Y2K compliant.  It is my belief that earlier
 versions were also Y2K compliant.
 
-Libpng only has three year fields.  One is a 2-byte unsigned integer that
-will hold years up to 65535.  The other two hold the date in text
+Libpng only has two year fields.  One is a 2-byte unsigned integer that
+will hold years up to 65535.  The other holds the date in text
 format, and will hold years up to 9999.
 
 The integer is
     "png_uint_16 year" in png_time_struct.
 
-The strings are
-    "png_charp time_buffer" in png_struct and
-    "near_time_buffer", which is a local character string in png.c.
+The string is
+    "char time_buffer[29]" in png_struct.  This will no
+longer be used in libpng-1.6.x and will be removed from libpng-1.7.0.
 
 There are seven time-related functions:
 
diff -r eb421f1dd8ef media/libpng/png.c
--- a/media/libpng/png.c	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/png.c	Tue Jul 17 20:55:17 2012 +0900
@@ -1,7 +1,7 @@
 
 /* png.c - location for general purpose libpng functions
  *
- * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Last changed in libpng 1.5.11 [June 14, 2012]
  * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
@@ -14,7 +14,7 @@
 #include "pngpriv.h"
 
 /* Generate a compiler error if there is an old png.h in the search path. */
-typedef png_libpng_version_1_5_10 Your_png_h_is_not_version_1_5_10;
+typedef png_libpng_version_1_5_11 Your_png_h_is_not_version_1_5_11;
 
 /* Tells libpng that we have already handled the first "num_bytes" bytes
  * of the PNG file signature.  If the PNG data is embedded into another
@@ -655,14 +655,14 @@
 #else
 #  ifdef __STDC__
    return PNG_STRING_NEWLINE \
-     "libpng version 1.5.10 - March 29, 2012" PNG_STRING_NEWLINE \
-     "Copyright (c) 1998-2011 Glenn Randers-Pehrson" PNG_STRING_NEWLINE \
+     "libpng version 1.5.11 - June 14, 2012" PNG_STRING_NEWLINE \
+     "Copyright (c) 1998-2012 Glenn Randers-Pehrson" PNG_STRING_NEWLINE \
      "Copyright (c) 1996-1997 Andreas Dilger" PNG_STRING_NEWLINE \
      "Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc." \
      PNG_STRING_NEWLINE;
 #  else
-      return "libpng version 1.5.10 - March 29, 2012\
-      Copyright (c) 1998-2011 Glenn Randers-Pehrson\
+      return "libpng version 1.5.11 - June 14, 2012\
+      Copyright (c) 1998-2012 Glenn Randers-Pehrson\
       Copyright (c) 1996-1997 Andreas Dilger\
       Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.";
 #  endif
@@ -969,8 +969,8 @@
     * and it is certain that it becomes unstable where the end points are close
     * together.
     *
-    * So this code uses the perhaps slighly less optimal but more understandable
-    * and totally obvious approach of calculating color-scale.
+    * So this code uses the perhaps slightly less optimal but more
+    * understandable and totally obvious approach of calculating color-scale.
     *
     * This algorithm depends on the precision in white-scale and that is
     * (1/white-y), so we can immediately see that as white-y approaches 0 the
@@ -2044,7 +2044,7 @@
 }
 #endif
 
-#ifdef PNG_READ_GAMMA_SUPPORTED /* more fixed point functions for gammma */
+#ifdef PNG_READ_GAMMA_SUPPORTED /* more fixed point functions for gamma */
 /* Calculate a reciprocal, return 0 on div-by-zero or overflow. */
 png_fixed_point
 png_reciprocal(png_fixed_point a)
diff -r eb421f1dd8ef media/libpng/png.h
--- a/media/libpng/png.h	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/png.h	Tue Jul 17 20:55:17 2012 +0900
@@ -1,7 +1,7 @@
 
 /* png.h - header file for PNG reference library
  *
- * libpng version 1.5.10 - March 29, 2012
+ * libpng version 1.5.11 - June 14, 2012
  * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
@@ -11,7 +11,7 @@
  * Authors and maintainers:
  *   libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
  *   libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger
- *   libpng versions 0.97, January 1998, through 1.5.10 - March 29, 2012: Glenn
+ *   libpng versions 0.97, January 1998, through 1.5.11 - June 14, 2012: Glenn
  *   See also "Contributing Authors", below.
  *
  * Note about libpng version numbers:
@@ -174,6 +174,10 @@
  *    1.5.9                   15    10509  15.so.15.9[.0]
  *    1.5.10beta01-05         15    10510  15.so.15.10[.0]
  *    1.5.10                  15    10510  15.so.15.10[.0]
+ *    1.5.11beta01            15    10511  15.so.15.11[.0]
+ *    1.5.11rc01-05           15    10511  15.so.15.11[.0]
+ *    1.5.11                  15    10511  15.so.15.11[.0]
+ *    1.5.12                  15    10512  15.so.15.12[.0]
  *
  *   Henceforth the source version will match the shared-library major
  *   and minor numbers; the shared-library major version number will be
@@ -205,7 +209,7 @@
  *
  * This code is released under the libpng license.
  *
- * libpng versions 1.2.6, August 15, 2004, through 1.5.10, March 29, 2012, are
+ * libpng versions 1.2.6, August 15, 2004, through 1.5.11, June 14, 2012, are
  * Copyright (c) 2004, 2006-2012 Glenn Randers-Pehrson, and are
  * distributed according to the same disclaimer and license as libpng-1.2.5
  * with the following individual added to the list of Contributing Authors:
@@ -317,13 +321,13 @@
  * Y2K compliance in libpng:
  * =========================
  *
- *    March 29, 2012
+ *    June 14, 2012
  *
  *    Since the PNG Development group is an ad-hoc body, we can't make
  *    an official declaration.
  *
  *    This is your unofficial assurance that libpng from version 0.71 and
- *    upward through 1.5.10 are Y2K compliant.  It is my belief that
+ *    upward through 1.5.11 are Y2K compliant.  It is my belief that
  *    earlier versions were also Y2K compliant.
  *
  *    Libpng only has two year fields.  One is a 2-byte unsigned integer
@@ -334,7 +338,8 @@
  *        "png_uint_16 year" in png_time_struct.
  *
  *    The string is
- *        "png_char time_buffer" in png_struct
+ *        "char time_buffer[29]" in png_struct.  This will be no
+ *    longer used in libpng-1.6.0 and will be removed from libpng-1.7.0.
  *
  *    There are seven time-related functions:
  *        png.c: png_convert_to_rfc_1123() in png.c
@@ -381,9 +386,9 @@
  */
 
 /* Version information for png.h - this should match the version in png.c */
-#define PNG_LIBPNG_VER_STRING "1.5.10"
+#define PNG_LIBPNG_VER_STRING "1.5.11"
 #define PNG_HEADER_VERSION_STRING \
-     " libpng version 1.5.10 - March 29, 2012\n"
+     " libpng version 1.5.11 - June 14, 2012\n"
 
 #define PNG_LIBPNG_VER_SONUM   15
 #define PNG_LIBPNG_VER_DLLNUM  15
@@ -391,7 +396,7 @@
 /* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
 #define PNG_LIBPNG_VER_MAJOR   1
 #define PNG_LIBPNG_VER_MINOR   5
-#define PNG_LIBPNG_VER_RELEASE 10
+#define PNG_LIBPNG_VER_RELEASE 11
 
 /* This should match the numeric part of the final component of
  * PNG_LIBPNG_VER_STRING, omitting any leading zero:
@@ -422,7 +427,7 @@
  * version 1.0.0 was mis-numbered 100 instead of 10000).  From
  * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
  */
-#define PNG_LIBPNG_VER 10510 /* 1.5.10 */
+#define PNG_LIBPNG_VER 10511 /* 1.5.11 */
 
 #ifndef MOZPNGCONF_H
 #   include "mozpngconf.h"
@@ -549,7 +554,7 @@
 /* This triggers a compiler error in png.c, if png.c and png.h
  * do not agree upon the version number.
  */
-typedef char* png_libpng_version_1_5_10;
+typedef char* png_libpng_version_1_5_11;
 
 /* Three color definitions.  The order of the red, green, and blue, (and the
  * exact size) is not important, although the size of the fields need to
diff -r eb421f1dd8ef media/libpng/pngconf.h
--- a/media/libpng/pngconf.h	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/pngconf.h	Tue Jul 17 20:55:17 2012 +0900
@@ -1,7 +1,7 @@
 
 /* pngconf.h - machine configurable file for libpng
  *
- * libpng version 1.5.10 - March 29, 2012
+ * libpng version 1.5.11 - June 14, 2012
  *
  * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
@@ -25,7 +25,7 @@
 #ifndef PNG_BUILDING_SYMBOL_TABLE
 /* PNG_NO_LIMITS_H may be used to turn off the use of the standard C
  * definition file for  machine specific limits, this may impact the
- * correctness of the definitons below (see uses of INT_MAX).
+ * correctness of the definitions below (see uses of INT_MAX).
  */
 #  ifndef PNG_NO_LIMITS_H
 #    include <limits.h>
diff -r eb421f1dd8ef media/libpng/pngerror.c
--- a/media/libpng/pngerror.c	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/pngerror.c	Tue Jul 17 20:55:17 2012 +0900
@@ -2,7 +2,7 @@
 /* pngerror.c - stub functions for i/o and memory allocation
  *
  * Last changed in libpng 1.5.8 [February 1, 2011]
- * Copyright (c) 1998-2012 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2011 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
diff -r eb421f1dd8ef media/libpng/pngpread.c
--- a/media/libpng/pngpread.c	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/pngpread.c	Tue Jul 17 20:55:17 2012 +0900
@@ -1,7 +1,7 @@
 
 /* pngpread.c - read a png file in push mode
  *
- * Last changed in libpng 1.5.9 [February 18, 2012]
+ * Last changed in libpng 1.5.11 [June 14, 2012]
  * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
@@ -385,8 +385,8 @@
             png_error(png_ptr, "Missing PLTE before IDAT");
       }
    }
+#endif
 
-#endif
    else if (chunk_name == png_PLTE)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -1039,6 +1039,15 @@
    if (!(buffer_length > 0) || buffer == NULL)
       png_error(png_ptr, "No IDAT data (internal error)");
 
+#ifdef PNG_READ_APNG_SUPPORTED
+   /* If the app is not APNG-aware, decode only the first frame */
+   if (!(png_ptr->apng_flags & PNG_APNG_APP) && png_ptr->num_frames_read > 0)
+   {
+     png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
+     return;
+   }
+#endif
+
    /* This routine must process all the data it has been given
     * before returning, calling the row callback as required to
     * handle the uncompressed results.
@@ -1492,6 +1501,7 @@
 {
    png_ptr->frame_info_fn = frame_info_fn;
    png_ptr->frame_end_fn = frame_end_fn;
+   png_ptr->apng_flags |= PNG_APNG_APP;
 }
 #endif
 
diff -r eb421f1dd8ef media/libpng/pngpriv.h
--- a/media/libpng/pngpriv.h	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/pngpriv.h	Tue Jul 17 20:55:17 2012 +0900
@@ -673,6 +673,7 @@
 
 /* For png_struct.apng_flags: */
 #define PNG_FIRST_FRAME_HIDDEN       0x0001
+#define PNG_APNG_APP                 0x0002
 #endif
 
 /* The following will work on (signed char*) strings, whereas the get_uint_32
diff -r eb421f1dd8ef media/libpng/pngread.c
--- a/media/libpng/pngread.c	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/pngread.c	Tue Jul 17 20:55:17 2012 +0900
@@ -1049,15 +1049,6 @@
          png_handle_iTXt(png_ptr, info_ptr, length);
 #endif
 
-#ifdef PNG_READ_APNG_SUPPORTED
-      else if (chunk_name == png_acTL)
-         png_handle_acTL(png_ptr, info_ptr, length);
-      else if (chunk_name == png_fcTL)
-         png_handle_fcTL(png_ptr, info_ptr, length);
-      else if (chunk_name == png_fdAT)
-         png_handle_fdAT(png_ptr, info_ptr, length);
-#endif
-
       else
          png_handle_unknown(png_ptr, info_ptr, length);
    } while (!(png_ptr->mode & PNG_HAVE_IEND));
diff -r eb421f1dd8ef media/libpng/pngrtran.c
--- a/media/libpng/pngrtran.c	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/pngrtran.c	Tue Jul 17 20:55:17 2012 +0900
@@ -1,7 +1,7 @@
 
 /* pngrtran.c - transforms the data in a row for PNG readers
  *
- * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Last changed in libpng 1.5.11 [June 14, 2012]
  * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
@@ -1770,8 +1770,8 @@
          int num_palette = png_ptr->num_palette;
          int i;
 
-         /*NOTE: there are other transformations that should probably be in here
-          * too.
+         /* NOTE: there are other transformations that should probably be in
+          * here too.
           */
          for (i = 0; i < num_palette; i++)
          {
@@ -2277,7 +2277,7 @@
 #endif
 
 #ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-   /*NOTE: moved here in 1.5.4 (from much later in this list.) */
+   /* NOTE: moved here in 1.5.4 (from much later in this list.) */
    if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
        (png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
       png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);
@@ -2301,7 +2301,8 @@
 
 #ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
    /* Added at libpng-1.5.10 */
-   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)
+   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&
+       png_ptr->num_palette_max >= 0)
       png_do_check_palette_indexes(png_ptr, row_info);
 #endif
 
@@ -3302,7 +3303,7 @@
                if (red != green || red != blue)
                {
                   rgb_error |= 1;
-                  /*NOTE: this is the historical approach which simply
+                  /* NOTE: this is the historical approach which simply
                    * truncates the results.
                    */
                   *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);
diff -r eb421f1dd8ef media/libpng/pngset.c
--- a/media/libpng/pngset.c	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/pngset.c	Tue Jul 17 20:55:17 2012 +0900
@@ -1,7 +1,7 @@
 
 /* pngset.c - storage of image information into info struct
  *
- * Last changed in libpng 1.5.10 [(PENDING RELEASE)]
+ * Last changed in libpng 1.5.11 [June 14, 2012]
  * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
@@ -149,7 +149,7 @@
     * possible for 1/gamma to overflow the limit of 21474 and this means the
     * gamma value must be at least 5/100000 and hence at most 20000.0.  For
     * safety the limits here are a little narrower.  The values are 0.00016 to
-    * 6250.0, which are truly ridiculous gammma values (and will produce
+    * 6250.0, which are truly ridiculous gamma values (and will produce
     * displays that are all black or all white.)
     */
    if (file_gamma < 16 || file_gamma > 625000000)
@@ -1437,8 +1437,10 @@
 }
 #endif /* PNG_BENIGN_ERRORS_SUPPORTED */
 
-#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
-   /* Do not report invalid palette index; added at libng-1.5.10 */
+#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
+/* Whether to report invalid palette index; added at libng-1.5.10
+ *   allowed  - one of 0: disable; 1: enable
+ */
 void PNGAPI
 png_set_check_for_invalid_index(png_structp png_ptr, int allowed)
 {
diff -r eb421f1dd8ef media/libpng/pngstruct.h
--- a/media/libpng/pngstruct.h	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/pngstruct.h	Tue Jul 17 20:55:17 2012 +0900
@@ -1,11 +1,11 @@
 
 /* pngstruct.h - header file for PNG reference library
  *
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
- * Last changed in libpng 1.5.9 [March 29, 2012]
+ * Last changed in libpng 1.5.9 [February 18, 2012]
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -248,6 +248,7 @@
 #endif
 
 #ifdef PNG_TIME_RFC1123_SUPPORTED
+   /* This is going to be unused in libpng16 and removed from libpng17 */
    char time_buffer[29]; /* String to hold RFC 1123 time text */
 #endif
 
diff -r eb421f1dd8ef media/libpng/pngtrans.c
--- a/media/libpng/pngtrans.c	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/pngtrans.c	Tue Jul 17 20:55:17 2012 +0900
@@ -1,7 +1,7 @@
 
 /* pngtrans.c - transforms the data in a row (used by both readers and writers)
  *
- * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Last changed in libpng 1.5.11 [June 14, 2012]
  * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
@@ -626,7 +626,7 @@
 png_do_check_palette_indexes(png_structp png_ptr, png_row_infop row_info)
 {
    if (png_ptr->num_palette < (1 << row_info->bit_depth) &&
-      png_ptr->num_palette_max >= 0)
+      png_ptr->num_palette > 0) /* num_palette can be 0 in MNG files */
    {
       /* Calculations moved outside switch in an attempt to stop different
        * compiler warnings.  'padding' is in *bits* within the last byte, it is
@@ -708,7 +708,7 @@
          {
             for (; rp > png_ptr->row_buf; rp--)
             {
-               if (*rp >= png_ptr->num_palette_max)
+               if (*rp > png_ptr->num_palette_max)
                   png_ptr->num_palette_max = (int) *rp;
             }
 
diff -r eb421f1dd8ef media/libpng/pngwrite.c
--- a/media/libpng/pngwrite.c	Thu Jul 12 14:19:16 2012 -0700
+++ b/media/libpng/pngwrite.c	Tue Jul 17 20:55:17 2012 +0900
@@ -1,7 +1,7 @@
 
 /* pngwrite.c - general routines to write a PNG file
  *
- * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Last changed in libpng 1.5.11 [June 14, 2012]
  * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
@@ -816,7 +816,8 @@
 /* Added at libpng-1.5.10 */
 #ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
    /* Check for out-of-range palette index */
-   if(row_info.color_type == PNG_COLOR_TYPE_PALETTE)
+   if (row_info.color_type == PNG_COLOR_TYPE_PALETTE &&
+       png_ptr->num_palette_max >= 0)
       png_do_check_palette_indexes(png_ptr, &row_info);
 #endif
 

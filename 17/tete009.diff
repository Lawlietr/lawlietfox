diff --git a/gfx/2d/moz-d2d1-1.h b/gfx/2d/moz-d2d1-1.h
--- a/gfx/2d/moz-d2d1-1.h
+++ b/gfx/2d/moz-d2d1-1.h
@@ -12,6 +12,11 @@
 #include <d2d1.h>
 #endif // #ifndef _D2D1_H_
 
+#if _MSC_VER == 1400
+#define _In_
+#define _In_opt_
+#endif
+
 //+-----------------------------------------------------------------------------
 //
 //  Flag:

diff -r 99930dd98444 security/nss/lib/freebl/Makefile
--- a/security/nss/lib/freebl/Makefile	Thu Feb 23 06:23:32 2012 +0900
+++ b/security/nss/lib/freebl/Makefile	Thu Feb 23 06:33:44 2012 +0900
@@ -163,11 +163,10 @@
     DEFINES += -DMP_NO_MP_WORD -DMP_USE_UINT_DIGIT
 else
 # MSVC
-    MPI_SRCS += mpi_x86_asm.c
     DEFINES += -DMP_ASSEMBLY_MULTIPLY -DMP_ASSEMBLY_SQUARE 
     DEFINES += -DMP_ASSEMBLY_DIV_2DX1D -DMP_USE_UINT_DIGIT -DMP_NO_MP_WORD
     ifdef BUILD_OPT
-	OPTIMIZER += -Ox  # maximum optimization for freebl
+	OPTIMIZER += -O2  # maximum optimization for freebl
     endif
 endif
 else

diff -r 6a3897dad583 nsprpub/pr/include/md/_win95.h
--- a/nsprpub/pr/include/md/_win95.h	Sat Oct 06 15:30:41 2012 +0900
+++ b/nsprpub/pr/include/md/_win95.h	Sat Oct 06 15:42:56 2012 +0900
@@ -474,16 +474,27 @@ extern __declspec(thread) struct PRThrea
 extern __declspec(thread) struct PRThread *_pr_thread_last_run;
 #define _MD_LAST_THREAD() _pr_thread_last_run
 #define _MD_SET_LAST_THREAD(_thread) (_pr_thread_last_run = 0)
 
 extern __declspec(thread) struct _PRCPU *_pr_currentCPU;
 #define _MD_CURRENT_CPU() _pr_currentCPU
 #define _MD_SET_CURRENT_CPU(_cpu) (_pr_currentCPU = 0)
 #else /* _PR_USE_STATIC_TLS */
+#if _MSC_VER >= 1400
+#ifdef _WIN64
+unsigned __int64 __readgsqword(unsigned long Offset);
+#pragma intrinsic(__readgsqword)
+#define TlsGetValue(x) (LPVOID)(__readgsqword((x) * 8 + 0x1480))
+#else /* _WIN64 */
+unsigned long __readfsdword(unsigned long Offset);
+#pragma intrinsic(__readfsdword)
+#define TlsGetValue(x) (LPVOID)(*(unsigned long *)(__readfsdword(0x18) + (x) * 4 + 3600))
+#endif /* _WIN64 */
+#endif /* _MSC_VER >= 1400 */
 extern DWORD _pr_currentThreadIndex;
 #define _MD_GET_ATTACHED_THREAD() ((PRThread *) TlsGetValue(_pr_currentThreadIndex))
 #define _MD_SET_CURRENT_THREAD(_thread) TlsSetValue(_pr_currentThreadIndex, (_thread))
 
 extern DWORD _pr_lastThreadIndex;
 #define _MD_LAST_THREAD() ((PRThread *) TlsGetValue(_pr_lastThreadIndex))
 #define _MD_SET_LAST_THREAD(_thread) TlsSetValue(_pr_lastThreadIndex, 0)
 

diff --git a/gfx/2d/2D.h b/gfx/2d/2D.h
--- a/gfx/2d/2D.h
+++ b/gfx/2d/2D.h
@@ -804,16 +804,17 @@ protected:
 
   SurfaceFormat mFormat;
 };
 
 class GFX2D_API Factory
 {
 public:
   static bool HasSSE2();
+  static bool HasSSSE3();
 
   static TemporaryRef<DrawTarget> CreateDrawTargetForCairoSurface(cairo_surface_t* aSurface, const IntSize& aSize);
 
   static TemporaryRef<DrawTarget>
     CreateDrawTarget(BackendType aBackend, const IntSize &aSize, SurfaceFormat aFormat);
   
   static TemporaryRef<DrawTarget>
     CreateDrawTargetForData(BackendType aBackend, unsigned char* aData, const IntSize &aSize, int32_t aStride, SurfaceFormat aFormat);

diff -r 6a3897dad583 mfbt/Attributes.h
--- a/mfbt/Attributes.h	Sat Oct 06 15:30:41 2012 +0900
+++ b/mfbt/Attributes.h	Sat Oct 06 15:38:57 2012 +0900
@@ -8,16 +8,22 @@
 #ifndef mozilla_Attributes_h_
 #define mozilla_Attributes_h_
 
 /*
  * This header does not include any other headers so that it can be included by
  * code that is (only currently) mfbt-incompatible.
  */
 
+#if defined(WIN32) || defined(__SYMBIAN32__)
+#  define TT_RESTRICTED_PTR     __restrict
+#else
+#  define TT_RESTRICTED_PTR     __restrict__
+#endif
+
 /*
  * MOZ_INLINE is a macro which expands to tell the compiler that the method
  * decorated with it should be inlined.  This macro is usable from C and C++
  * code, even though C89 does not support the |inline| keyword.  The compiler
  * may ignore this directive if it chooses.
  */
 #if defined(__cplusplus)
 #  define MOZ_INLINE            inline

diff --git a/gfx/2d/BaseRect.h b/gfx/2d/BaseRect.h
--- a/gfx/2d/BaseRect.h
+++ b/gfx/2d/BaseRect.h
@@ -4,16 +4,19 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef MOZILLA_GFX_BASERECT_H_
 #define MOZILLA_GFX_BASERECT_H_
 
 #include <cmath>
 #include <mozilla/Assertions.h>
 
+#include <stddef.h>
+#include <emmintrin.h>
+
 namespace mozilla {
 namespace gfx {
 
 // XXX - <algorithm> conflicts with exceptions on 10.6. Define our own gfx_min/gfx_max
 // functions here. Avoid min/max to avoid conflicts with existing #defines on windows.
 template<typename T>
 T gfx_min(T aVal1, T aVal2)
 {
@@ -58,16 +61,55 @@ struct BaseRect {
   BaseRect(const Point& aOrigin, const SizeT &aSize) :
       x(aOrigin.x), y(aOrigin.y), width(aSize.width), height(aSize.height)
   {
   }
   BaseRect(T aX, T aY, T aWidth, T aHeight) :
       x(aX), y(aY), width(aWidth), height(aHeight)
   {
   }
+  BaseRect(const __m128i& a128i)
+  {
+    _mm_storeu_si128((__m128i *)&x, a128i);
+  }
+
+  bool IsInt32x4() const {
+    return _is_int32<T>::value &&
+           offsetof(Sub, x) == offsetof(Sub, y) - 4 &&
+           offsetof(Sub, x) == offsetof(Sub, width) - 8 &&
+           offsetof(Sub, x) == offsetof(Sub, height) - 12;
+  }
+  template <typename T>
+  struct _is_int32 {
+    enum { value = false };
+  };
+  template <>
+  struct _is_int32<long> {
+    enum { value = (sizeof(long) == 4) };
+  };
+  template <>
+  struct _is_int32<long const> {
+    enum { value = (sizeof(long) == 4) };
+  };
+  template <>
+  struct _is_int32<int> {
+    enum { value = (sizeof(int) == 4) };
+  };
+  template <>
+  struct _is_int32<int const> {
+    enum { value = (sizeof(int) == 4) };
+  };
+  template <>
+  struct _is_int32<long long> {
+    enum { value = (sizeof(long long) == 4) };
+  };
+  template <>
+  struct _is_int32<long long const> {
+    enum { value = (sizeof(long long) == 4) };
+  };
 
   // Emptiness. An empty rect is one that has no area, i.e. its height or width
   // is <= 0
   bool IsEmpty() const { return height <= 0 || width <= 0; }
   void SetEmpty() { width = height = 0; }
 
   // Returns true if this rectangle contains the interior of aRect. Always
   // returns true if aRect is empty, and always returns false is aRect is

diff --git a/gfx/2d/Blur.cpp b/gfx/2d/Blur.cpp
--- a/gfx/2d/Blur.cpp
+++ b/gfx/2d/Blur.cpp
@@ -6,16 +6,17 @@
 
 #include <algorithm>
 #include <math.h>
 #include <string.h>
 
 #include "mozilla/CheckedInt.h"
 #include "mozilla/Constants.h"
 #include "mozilla/Util.h"
+#include "nsAutoPtr.h"
 
 using namespace std;
 
 namespace mozilla {
 namespace gfx {
 
 /**
  * Box blur involves looking at one pixel, and setting its value to the average
@@ -25,35 +26,43 @@ namespace gfx {
  * @param aLeftLobe The number of pixels to blend on the left.
  * @param aRightLobe The number of pixels to blend on the right.
  * @param aWidth The number of columns in the buffers.
  * @param aRows The number of rows in the buffers.
  * @param aSkipRect An area to skip blurring in.
  * XXX shouldn't we pass stride in separately here?
  */
 static void
-BoxBlurHorizontal(unsigned char* aInput,
-                  unsigned char* aOutput,
+BoxBlurHorizontal(unsigned char* TT_RESTRICTED_PTR aInput,
+                  unsigned char* TT_RESTRICTED_PTR aOutput,
                   int32_t aLeftLobe,
                   int32_t aRightLobe,
                   int32_t aWidth,
                   int32_t aRows,
-                  const IntRect& aSkipRect)
+                  const IntRect& aSkipRect,
+                  int32_t* TT_RESTRICTED_PTR aLasts,
+                  int32_t* TT_RESTRICTED_PTR aNexts)
 {
     MOZ_ASSERT(aWidth > 0);
 
     int32_t boxSize = aLeftLobe + aRightLobe + 1;
     bool skipRectCoversWholeRow = 0 >= aSkipRect.x &&
                                   aWidth <= aSkipRect.XMost();
     if (boxSize == 1) {
         memcpy(aOutput, aInput, aWidth*aRows);
         return;
     }
     uint32_t reciprocal = (uint64_t(1) << 32) / boxSize;
 
+    for (int32_t x = 0; x < aWidth; x++) {
+        int32_t tmp = x - aLeftLobe;
+        aLasts[x] = max(tmp, 0);
+        aNexts[x] = min(tmp + boxSize, aWidth - 1);
+    }
+
     for (int32_t y = 0; y < aRows; y++) {
         // Check whether the skip rect intersects this row. If the skip
         // rect covers the whole surface in this row, we can avoid
         // this row entirely (and any others along the skip rect).
         bool inSkipRectY = y >= aSkipRect.y &&
                            y < aSkipRect.YMost();
         if (inSkipRectY && skipRectCoversWholeRow) {
             y = aSkipRect.YMost() - 1;
@@ -85,53 +94,58 @@ BoxBlurHorizontal(unsigned char* aInput,
                     int32_t pos = x + i - aLeftLobe;
                     // See assertion above; if aWidth is zero, then we would have no
                     // valid position to clamp to.
                     pos = max(pos, 0);
                     pos = min(pos, aWidth - 1);
                     alphaSum += aInput[aWidth * y + pos];
                 }
             }
-            int32_t tmp = x - aLeftLobe;
-            int32_t last = max(tmp, 0);
-            int32_t next = min(tmp + boxSize, aWidth - 1);
 
             aOutput[aWidth * y + x] = (uint64_t(alphaSum) * reciprocal) >> 32;
 
-            alphaSum += aInput[aWidth * y + next] -
-                        aInput[aWidth * y + last];
+            alphaSum += aInput[aWidth * y + aNexts[x]] -
+                        aInput[aWidth * y + aLasts[x]];
         }
     }
 }
 
 /**
  * Identical to BoxBlurHorizontal, except it blurs top and bottom instead of
  * left and right.
  * XXX shouldn't we pass stride in separately here?
  */
 static void
-BoxBlurVertical(unsigned char* aInput,
-                unsigned char* aOutput,
+BoxBlurVertical(unsigned char* TT_RESTRICTED_PTR aInput,
+                unsigned char* TT_RESTRICTED_PTR aOutput,
                 int32_t aTopLobe,
                 int32_t aBottomLobe,
                 int32_t aWidth,
                 int32_t aRows,
-                const IntRect& aSkipRect)
+                const IntRect& aSkipRect,
+                int32_t* TT_RESTRICTED_PTR aLasts,
+                int32_t* TT_RESTRICTED_PTR aNexts)
 {
     MOZ_ASSERT(aRows > 0);
 
     int32_t boxSize = aTopLobe + aBottomLobe + 1;
     bool skipRectCoversWholeColumn = 0 >= aSkipRect.y &&
                                      aRows <= aSkipRect.YMost();
     if (boxSize == 1) {
         memcpy(aOutput, aInput, aWidth*aRows);
         return;
     }
     uint32_t reciprocal = (uint64_t(1) << 32) / boxSize;
 
+    for (int32_t y = 0; y < aRows; y++) {
+        int32_t tmp = y - aTopLobe;
+        aLasts[y] = max(tmp, 0);
+        aNexts[y] = min(tmp + boxSize, aRows - 1);
+    }
+
     for (int32_t x = 0; x < aWidth; x++) {
         bool inSkipRectX = x >= aSkipRect.x &&
                            x < aSkipRect.XMost();
         if (inSkipRectX && skipRectCoversWholeColumn) {
             x = aSkipRect.XMost() - 1;
             continue;
         }
 
@@ -156,24 +170,21 @@ BoxBlurVertical(unsigned char* aInput,
                     int32_t pos = y + i - aTopLobe;
                     // See assertion above; if aRows is zero, then we would have no
                     // valid position to clamp to.
                     pos = max(pos, 0);
                     pos = min(pos, aRows - 1);
                     alphaSum += aInput[aWidth * pos + x];
                 }
             }
-            int32_t tmp = y - aTopLobe;
-            int32_t last = max(tmp, 0);
-            int32_t next = min(tmp + boxSize, aRows - 1);
 
             aOutput[aWidth * y + x] = (uint64_t(alphaSum) * reciprocal) >> 32;
 
-            alphaSum += aInput[aWidth * next + x] -
-                        aInput[aWidth * last + x];
+            alphaSum += aInput[aWidth * aNexts[y] + x] -
+                        aInput[aWidth * aLasts[y] + x];
         }
     }
 }
 
 static void ComputeLobes(int32_t aRadius, int32_t aLobes[3][2])
 {
     int32_t major, minor, final;
 
@@ -431,51 +442,55 @@ AlphaBoxBlur::Blur()
     return;
   }
 
   // no need to do all this if not blurring or spreading
   if (mBlurRadius != IntSize(0,0) || mSpreadRadius != IntSize(0,0)) {
     int32_t stride = GetStride();
 
     // No need to use CheckedInt here - we have validated it in the constructor.
-    size_t szB = stride * GetSize().height * sizeof(unsigned char);
-    unsigned char* tmpData = static_cast<unsigned char*>(malloc(szB));
-    if (!tmpData)
-      return; // OOM
+    size_t szB = stride * GetSize().height;
+    nsAutoArrayPtr<unsigned char> tmpData(new unsigned char[szB]);
+    memset(tmpData, 0, szB * sizeof(unsigned char));
 
-    memset(tmpData, 0, szB);
+    size_t szLastsNexts = 0;
+    if (mBlurRadius.width > 0) {
+      szLastsNexts = stride;
+    }
+    if (mBlurRadius.height > 0) {
+      szLastsNexts = max<size_t>(szLastsNexts, GetSize().height);
+    }
+    nsAutoArrayPtr<int32_t> tmpLasts(new int32_t[szLastsNexts]);
+    nsAutoArrayPtr<int32_t> tmpNexts(new int32_t[szLastsNexts]);
 
     if (mSpreadRadius.width > 0 || mSpreadRadius.height > 0) {
       SpreadHorizontal(mData, tmpData, mSpreadRadius.width, GetSize().width, GetSize().height, stride, mSkipRect);
       SpreadVertical(tmpData, mData, mSpreadRadius.height, GetSize().width, GetSize().height, stride, mSkipRect);
     }
 
     if (mBlurRadius.width > 0) {
       int32_t lobes[3][2];
       ComputeLobes(mBlurRadius.width, lobes);
-      BoxBlurHorizontal(mData, tmpData, lobes[0][0], lobes[0][1], stride, GetSize().height, mSkipRect);
-      BoxBlurHorizontal(tmpData, mData, lobes[1][0], lobes[1][1], stride, GetSize().height, mSkipRect);
-      BoxBlurHorizontal(mData, tmpData, lobes[2][0], lobes[2][1], stride, GetSize().height, mSkipRect);
+      BoxBlurHorizontal(mData, tmpData, lobes[0][0], lobes[0][1], stride, GetSize().height, mSkipRect, tmpLasts, tmpNexts);
+      BoxBlurHorizontal(tmpData, mData, lobes[1][0], lobes[1][1], stride, GetSize().height, mSkipRect, tmpLasts, tmpNexts);
+      BoxBlurHorizontal(mData, tmpData, lobes[2][0], lobes[2][1], stride, GetSize().height, mSkipRect, tmpLasts, tmpNexts);
     } else {
       memcpy(tmpData, mData, stride * GetSize().height);
     }
 
     if (mBlurRadius.height > 0) {
       int32_t lobes[3][2];
       ComputeLobes(mBlurRadius.height, lobes);
-      BoxBlurVertical(tmpData, mData, lobes[0][0], lobes[0][1], stride, GetSize().height, mSkipRect);
-      BoxBlurVertical(mData, tmpData, lobes[1][0], lobes[1][1], stride, GetSize().height, mSkipRect);
-      BoxBlurVertical(tmpData, mData, lobes[2][0], lobes[2][1], stride, GetSize().height, mSkipRect);
+      BoxBlurVertical(tmpData, mData, lobes[0][0], lobes[0][1], stride, GetSize().height, mSkipRect, tmpLasts, tmpNexts);
+      BoxBlurVertical(mData, tmpData, lobes[1][0], lobes[1][1], stride, GetSize().height, mSkipRect, tmpLasts, tmpNexts);
+      BoxBlurVertical(tmpData, mData, lobes[2][0], lobes[2][1], stride, GetSize().height, mSkipRect, tmpLasts, tmpNexts);
     } else {
       memcpy(mData, tmpData, stride * GetSize().height);
     }
-
-    free(tmpData);
   }
-
 }
 
 /**
  * Compute the box blur size (which we're calling the blur radius) from
  * the standard deviation.
  *
  * Much of this, the 3 * sqrt(2 * pi) / 4, is the known value for
  * approximating a Gaussian using box blurs.  This yields quite a good

diff -r 6a3897dad583 browser/installer/Makefile.in
--- a/browser/installer/Makefile.in	Sat Oct 06 15:30:41 2012 +0900
+++ b/browser/installer/Makefile.in	Sat Oct 06 16:20:40 2012 +0900
@@ -75,20 +75,16 @@ endif
 include $(topsrcdir)/ipc/app/defs.mk
 DEFINES += -DMOZ_CHILD_PROCESS_NAME=$(MOZ_CHILD_PROCESS_NAME)
 
 # Set MSVC dlls version to package, if any.
 ifdef WIN32_REDIST_DIR
 DEFINES += -DMOZ_MSVC_REDIST=$(_MSC_VER)
 endif
 
-ifneq (,$(filter aurora beta,$(MOZ_UPDATE_CHANNEL)))
-DEFINES += -DSHIP_FEEDBACK=1
-endif
-
 ifneq (,$(filter WINNT Darwin Android,$(OS_TARGET)))
 DEFINES += -DMOZ_SHARED_MOZGLUE=1
 endif
 
 ifdef MOZ_JSDEBUGGER
 DEFINES += -DMOZ_JSDEBUGGER
 endif
 

diff -r 00f36792c9e9 gfx/cairo/cairo/src/cairo-d2d-private.h
--- a/gfx/cairo/cairo/src/cairo-d2d-private.h	Wed Nov 16 17:34:18 2011 +0900
+++ b/gfx/cairo/cairo/src/cairo-d2d-private.h	Sat Nov 19 16:45:23 2011 +0900
@@ -37,16 +37,17 @@
 #define CAIRO_D2D_PRIVATE_H
 
 #ifdef CAIRO_HAS_D2D_SURFACE
 
 #include <windows.h>
 #include <d2d1.h>
 #include <d3d10.h>
 #include <dxgi.h>
+#include <list>
 
 #include "cairoint.h"
 #include "cairo-surface-clipper-private.h"
 
 #include "cairo-win32-refptr.h"
 #include "cairo-d2d-private-fx.h"
 #include "cairo-win32.h"
 #include "cairo-list-private.h"
@@ -68,16 +69,28 @@ struct _cairo_d2d_device
     RefPtr<ID3D10RasterizerState> mRasterizerState;
     RefPtr<ID3D10BlendState> mBlendStates[MAX_OPERATORS];
     /** Texture used for manual glyph rendering */
     RefPtr<ID3D10Texture2D> mTextTexture;
     RefPtr<ID3D10ShaderResourceView> mTextTextureView;
     int mVRAMUsage;
 };
 
+typedef struct
+{
+    RefPtr<ID2D1RadialGradientBrush> radialGradientBrush;
+    RefPtr<ID2D1GradientStopCollection> radialGradientStopCollection;
+} radial_gradient;
+
+typedef struct
+{
+    RefPtr<ID2D1LinearGradientBrush> linearGradientBrush;
+    RefPtr<ID2D1GradientStopCollection> linearGradientStopCollection;
+} linear_gradient;
+
 const unsigned int TEXT_TEXTURE_WIDTH = 2048;
 const unsigned int TEXT_TEXTURE_HEIGHT = 512;
 typedef struct _cairo_d2d_device cairo_d2d_device_t;
 
 struct _cairo_d2d_surface {
     _cairo_d2d_surface() : d2d_clip(NULL), clipping(false), isDrawing(false),
             textRenderingState(TEXT_RENDERING_UNINITIALIZED)
     {
@@ -125,16 +138,22 @@ struct _cairo_d2d_surface {
      */
     RefPtr<ID2D1Layer> helperLayer;
     /** If this layer currently is clipping, used to prevent excessive push/pops */
     bool clipping;
     /** Brush used for bitmaps */
     RefPtr<ID2D1BitmapBrush> bitmapBrush;
     /** Brush used for solid colors */
     RefPtr<ID2D1SolidColorBrush> solidColorBrush;
+
+    /** Brush used for radial gradients */
+    std::list<radial_gradient> mRadialGradientCache;
+    /** Brush used for linear gradients */
+    std::list<linear_gradient> mLinearGradientCache;
+
     /** Indicates if our render target is currently in drawing mode */
     bool isDrawing;
     /** Indicates if text rendering is initialized */
     enum TextRenderingState {
         TEXT_RENDERING_UNINITIALIZED,
         TEXT_RENDERING_NO_CLEARTYPE,
         TEXT_RENDERING_NORMAL,
         TEXT_RENDERING_GDI_CLASSIC

diff --git a/gfx/cairo/cairo/src/cairo-d2d-surface.cpp b/gfx/cairo/cairo/src/cairo-d2d-surface.cpp
--- a/gfx/cairo/cairo/src/cairo-d2d-surface.cpp
+++ b/gfx/cairo/cairo/src/cairo-d2d-surface.cpp
@@ -1514,29 +1514,64 @@ static RefPtr<ID2D1Brush>
 	    stops[i].color = _cairo_d2d_color_from_cairo_color_stop(stop->color);
 	}
 	stops[i].position = 1.0f;
 	stops[i].color = D2D1::ColorF(0, 0);
     } else {
 	return NULL;
     }
 
-    RefPtr<ID2D1GradientStopCollection> stopCollection;
-    d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &stopCollection);
-    RefPtr<ID2D1RadialGradientBrush> brush;
-
-    d2dsurf->rt->CreateRadialGradientBrush(D2D1::RadialGradientBrushProperties(center,
-									       origin,
-									       outer_radius,
-									       outer_radius),
-					   brushProps,
-					   stopCollection,
-					   &brush);
+    std::list<radial_gradient>::iterator iterRadialGradient = d2dsurf->mRadialGradientCache.end();
+
+    if (d2dsurf->mRadialGradientCache.size() > 0) {
+        for (std::list<radial_gradient>::iterator iter = d2dsurf->mRadialGradientCache.begin();
+             iter != d2dsurf->mRadialGradientCache.end(); iter++) {
+            UINT32 nCount = (*iter).radialGradientStopCollection->GetGradientStopCount();
+
+            if (nCount == num_stops &&
+                nCount > 0) {
+                D2D1_GRADIENT_STOP *gradientStopsOld = new D2D1_GRADIENT_STOP[nCount];
+
+                (*iter).radialGradientStopCollection->GetGradientStops(gradientStopsOld, nCount);
+                bool stopCollectionEqual = (memcmp(gradientStopsOld, stops, sizeof(D2D1_GRADIENT_STOP) * nCount) == 0);
+                delete [] gradientStopsOld;
+                if (stopCollectionEqual) {
+                    iterRadialGradient = iter;
+                    break;
+                }
+            }
+        }
+    }
+
+    if (iterRadialGradient != d2dsurf->mRadialGradientCache.end()) {
+        (*iterRadialGradient).radialGradientBrush->SetOpacity(brushProps.opacity);
+        (*iterRadialGradient).radialGradientBrush->SetTransform(&brushProps.transform);
+        (*iterRadialGradient).radialGradientBrush->SetCenter(center);
+        (*iterRadialGradient).radialGradientBrush->SetGradientOriginOffset(origin);
+        (*iterRadialGradient).radialGradientBrush->SetRadiusX(outer_radius);
+        (*iterRadialGradient).radialGradientBrush->SetRadiusY(outer_radius);
+    } else {
+        radial_gradient rg;
+
+        d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &rg.radialGradientStopCollection);
+        d2dsurf->rt->CreateRadialGradientBrush(D2D1::RadialGradientBrushProperties(center,
+            origin,
+            outer_radius,
+            outer_radius),
+            brushProps,
+            rg.radialGradientStopCollection,
+            &rg.radialGradientBrush);
+
+        iterRadialGradient = d2dsurf->mRadialGradientCache.insert(d2dsurf->mRadialGradientCache.begin(), rg);
+        if (d2dsurf->mRadialGradientCache.size() > 50) {
+            d2dsurf->mRadialGradientCache.pop_back();
+        }
+    }
     delete [] stops;
-    return brush;
+    return (*iterRadialGradient).radialGradientBrush;
 }
 
 static RefPtr<ID2D1Brush>
 _cairo_d2d_create_linear_gradient_brush(cairo_d2d_surface_t *d2dsurf,
 					cairo_path_fixed_t *fill_path,
 					cairo_linear_pattern_t *source_pattern)
 {
     if (source_pattern->p1.x == source_pattern->p2.x &&
@@ -1691,26 +1726,60 @@ static RefPtr<ID2D1Brush>
 	for (unsigned int i = 1; i < source_pattern->base.n_stops + 1; i++) {
 	    cairo_gradient_stop_t *stop = &source_pattern->base.stops[i - 1];
 	    stops[i].position = (FLOAT)stop->offset;
 	    stops[i].color = _cairo_d2d_color_from_cairo_color_stop(stop->color);
 	}
 	stops[source_pattern->base.n_stops + 1].position = 1.0f;
 	stops[source_pattern->base.n_stops + 1].color = D2D1::ColorF(0, 0);
     }
-    RefPtr<ID2D1GradientStopCollection> stopCollection;
-    d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &stopCollection);
-    RefPtr<ID2D1LinearGradientBrush> brush;
-    d2dsurf->rt->CreateLinearGradientBrush(D2D1::LinearGradientBrushProperties(D2D1::Point2F((FLOAT)p1.x, (FLOAT)p1.y),
-									       D2D1::Point2F((FLOAT)p2.x, (FLOAT)p2.y)),
-					   brushProps,
-					   stopCollection,
-					   &brush);
+
+    std::list<linear_gradient>::iterator iterLinearGradient = d2dsurf->mLinearGradientCache.end();
+
+    if (d2dsurf->mLinearGradientCache.size() > 0) {
+        for (std::list<linear_gradient>::iterator iter = d2dsurf->mLinearGradientCache.begin();
+             iter != d2dsurf->mLinearGradientCache.end(); iter++) {
+            UINT32 nCount = (*iter).linearGradientStopCollection->GetGradientStopCount();
+
+            if (nCount == num_stops &&
+                nCount > 0) {
+                D2D1_GRADIENT_STOP *gradientStopsOld = new D2D1_GRADIENT_STOP[nCount];
+
+                (*iter).linearGradientStopCollection->GetGradientStops(gradientStopsOld, nCount);
+                bool stopCollectionEqual = (memcmp(gradientStopsOld, stops, sizeof(D2D1_GRADIENT_STOP) * nCount) == 0);
+                delete [] gradientStopsOld;
+                if (stopCollectionEqual) {
+                    iterLinearGradient = iter;
+                    break;
+                }
+            }
+        }
+    }
+
+    if (iterLinearGradient != d2dsurf->mLinearGradientCache.end()) {
+        (*iterLinearGradient).linearGradientBrush->SetOpacity(brushProps.opacity);
+        (*iterLinearGradient).linearGradientBrush->SetTransform(&brushProps.transform);
+        (*iterLinearGradient).linearGradientBrush->SetStartPoint(D2D1::Point2F((FLOAT)p1.x, (FLOAT)p1.y));
+        (*iterLinearGradient).linearGradientBrush->SetEndPoint(D2D1::Point2F((FLOAT)p2.x, (FLOAT)p2.y));
+    } else {
+        linear_gradient lg;
+
+        d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &lg.linearGradientStopCollection);
+        d2dsurf->rt->CreateLinearGradientBrush(D2D1::LinearGradientBrushProperties(D2D1::Point2F((FLOAT)p1.x, (FLOAT)p1.y), D2D1::Point2F((FLOAT)p2.x, (FLOAT)p2.y)),
+            brushProps,
+            lg.linearGradientStopCollection,
+            &lg.linearGradientBrush);
+
+        iterLinearGradient = d2dsurf->mLinearGradientCache.insert(d2dsurf->mLinearGradientCache.begin(), lg);
+        if (d2dsurf->mLinearGradientCache.size() > 100) {
+            d2dsurf->mLinearGradientCache.pop_back();
+        }
+    }
     delete [] stops;
-    return brush;
+    return (*iterLinearGradient).linearGradientBrush;
 }
 
 /**
  * This creates an ID2D1Brush that will fill with the correct pattern.
  * This function passes a -strong- reference to the caller, the brush
  * needs to be released, even if it is not unique.
  *
  * \param d2dsurf Surface to create a brush for

diff --git a/content/canvas/src/Makefile.in b/content/canvas/src/Makefile.in
--- a/content/canvas/src/Makefile.in
+++ b/content/canvas/src/Makefile.in
@@ -78,8 +78,14 @@ INCLUDES	+= \
 		-I$(srcdir)/../../../layout/generic \
 		-I$(srcdir)/../../base/src \
 		-I$(srcdir)/../../html/content/src \
 		-I$(srcdir)/../../../js/xpconnect/src \
 		-I$(srcdir)/../../../dom/base \
 		$(NULL)
 
 DEFINES += -D_IMPL_NS_LAYOUT
+
+ifdef _MSC_VER
+ifneq (,$(filter -DTT_MEMUTIL,$(MOZ_OPTIMIZE_FLAGS)))
+CanvasUtils.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL- -openmp
+endif
+endif

diff -r 6a3897dad583 content/canvas/src/CanvasUtils.cpp
--- a/content/canvas/src/CanvasUtils.cpp	Sat Oct 06 15:30:41 2012 +0900
+++ b/content/canvas/src/CanvasUtils.cpp	Sat Oct 06 16:13:28 2012 +0900
@@ -1,13 +1,28 @@
 /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+#include <omp.h>
+#endif
+
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+extern "C" {
+  extern __m128i _mm_shuffle_epi8(__m128i a, __m128i b);
+  extern __m128i _mm_alignr_epi8(__m128i a, __m128i b, const int ralign);
+}
+#else
+#include <tmmintrin.h>
+#endif
+#include "mozilla/SSE.h"
+
 #include <stdlib.h>
 #include <stdarg.h>
 
 #include "prmem.h"
 #include "prprf.h"
 
 #include "nsIServiceManager.h"
 
@@ -171,10 +186,265 @@ MatrixToJSVal(const Matrix& matrix, JSCo
     jsval elts[] = {
         DOUBLE_TO_JSVAL(matrix._11), DOUBLE_TO_JSVAL(matrix._12),
         DOUBLE_TO_JSVAL(matrix._21), DOUBLE_TO_JSVAL(matrix._22),
         DOUBLE_TO_JSVAL(matrix._31), DOUBLE_TO_JSVAL(matrix._32)
     };
     return MatrixEltsToJSVal(elts, cx, val);
 }
 
+void
+GetImageData_component(PRUint8* _src, PRUint8* _dst,
+                       PRUint32 width, PRUint32 height,
+                       PRUint32 srcStride, PRUint32 dstStride,
+                       PRUint8 (*sUnpremultiplyTable)[256])
+{
+    PRUint8 *srcFirst = _src;
+    PRUint8 *dstFirst = _dst;
+
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+    int omp_thread_counts = omp_get_max_threads();
+
+#pragma omp parallel for schedule(guided) default(none) \
+shared(srcFirst, dstFirst, width, height, srcStride, dstStride, sUnpremultiplyTable) \
+if (omp_thread_counts >= 2 && \
+    height >= (PRUint32)omp_thread_counts && \
+    width * height >= 4096)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
+    for (PRInt64 j = 0; j < height; j++) {
+        PRUint8 *src = srcFirst + (srcStride * j);
+        PRUint8 *dst = dstFirst + (dstStride * j);
+
+        for (PRUint32 i = 0; i < width; i++) {
+            // XXX Is there some useful swizzle MMX we can use here?
+#ifdef IS_LITTLE_ENDIAN
+            PRUint8 b = *src++;
+            PRUint8 g = *src++;
+            PRUint8 r = *src++;
+            PRUint8 a = *src++;
+#else
+            PRUint8 a = *src++;
+            PRUint8 r = *src++;
+            PRUint8 g = *src++;
+            PRUint8 b = *src++;
+#endif
+            // Convert to non-premultiplied color
+            *dst++ = sUnpremultiplyTable[a][r];
+            *dst++ = sUnpremultiplyTable[a][g];
+            *dst++ = sUnpremultiplyTable[a][b];
+            *dst++ = a;
+        }
+    }
+}
+
+void
+PutImageData_component(PRUint8* _src, PRUint8* _dst,
+                       PRUint32 width, PRUint32 height,
+                       PRUint32 srcStride, PRUint32 dstStride,
+                       PRUint8 (*sPremultiplyTable)[256])
+{
+    PRUint8 *srcFirst = _src;
+    PRUint8 *dstFirst = _dst;
+
+#if (_MSC_VER != 1400) || !defined(_M_AMD64)
+    if (mozilla::supports_ssse3()) {
+        static const __m128i msk_alpha = _mm_set1_epi32(0xFF000000);
+        static const __m128i sfl_alphaLo = _mm_set_epi8(0x80, 7, 0x80, 7, 0x80, 7, 0x80, 7, 0x80, 3, 0x80, 3, 0x80, 3, 0x80, 3);
+        static const __m128i sfl_alphaHi = _mm_set_epi8(0x80, 15, 0x80, 15, 0x80, 15, 0x80, 15, 0x80, 11, 0x80, 11, 0x80, 11, 0x80, 11);
+        static const __m128i word_add = _mm_set1_epi16(0x00FF);
+        static const __m128i word_mul = _mm_set_epi16(0, 257, 257, 257, 0, 257, 257, 257);
+        static const __m128i sfl_bgra = _mm_set_epi8(15, 12, 13, 14, 11, 8, 9, 10, 7, 4, 5, 6, 3, 0, 1, 2);
+
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+        int omp_thread_counts = omp_get_max_threads();
+
+#pragma omp parallel for schedule(guided) default(none) \
+shared(srcFirst, dstFirst, width, height, srcStride, dstStride, sPremultiplyTable) \
+if (omp_thread_counts >= 2 && \
+    height >= (PRUint32)omp_thread_counts && \
+    width * height >= 12000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
+        for (int j = 0; j < height; j++) {
+            PRUint8 *src = srcFirst + (srcStride * j);
+            PRUint8 *dst = dstFirst + (dstStride * j);
+            PRUint32 i = width;
+
+            while (i >= 1 && ((unsigned)dst & 15)) {
+                PRUint8 r = *src++;
+                PRUint8 g = *src++;
+                PRUint8 b = *src++;
+                PRUint8 a = *src++;
+
+                // Convert to premultiplied color (losslessly if the input came from getImageData)
+                *dst++ = sPremultiplyTable[a][b];
+                *dst++ = sPremultiplyTable[a][g];
+                *dst++ = sPremultiplyTable[a][r];
+                *dst++ = a;
+                i -= 1;
+            }
+
+            const int srcMissalignedBytes = ((unsigned)src & 15);
+
+            if (srcMissalignedBytes == 0) {
+                while (i >= 4) {
+                    __m128i xmb = _mm_load_si128((__m128i*)src);
+                    __m128i xmwLo = _mm_unpacklo_epi8(xmb, _mm_setzero_si128());
+                    __m128i xmwHi = _mm_unpackhi_epi8(xmb, _mm_setzero_si128());
+
+                    __m128i xmwAlpha = _mm_and_si128(xmb, msk_alpha);
+                    __m128i xmwAlphaLo = _mm_shuffle_epi8(xmb, sfl_alphaLo);
+                    __m128i xmwAlphaHi = _mm_shuffle_epi8(xmb, sfl_alphaHi);
+
+                    xmwLo = _mm_mullo_epi16(xmwLo, xmwAlphaLo);
+                    xmwLo = _mm_adds_epu16(xmwLo, word_add);
+                    xmwLo = _mm_mulhi_epu16(xmwLo, word_mul);
+
+                    xmwHi = _mm_mullo_epi16(xmwHi, xmwAlphaHi);
+                    xmwHi = _mm_adds_epu16(xmwHi, word_add);
+                    xmwHi = _mm_mulhi_epu16(xmwHi, word_mul);
+
+                    __m128i xmRes = _mm_packus_epi16(xmwLo, xmwHi);
+                    xmRes = _mm_or_si128(xmRes, xmwAlpha);
+                    xmRes = _mm_shuffle_epi8(xmRes, sfl_bgra);
+                    _mm_store_si128((__m128i*)dst, xmRes);
+
+                    src += 16;
+                    dst += 16;
+                    i -= 4;
+                }
+            } else {
+                __m128i xmLoadPre = _mm_load_si128((__m128i*)(src - srcMissalignedBytes));
+
+                while (i >= 4) {
+                    __m128i xmLoadNext = _mm_load_si128((__m128i*)(src - srcMissalignedBytes + 16));
+                    __m128i xmb;
+
+                    switch (srcMissalignedBytes) {
+                    case 1:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 1);
+                        break;
+                    case 2:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 2);
+                        break;
+                    case 3:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 3);
+                        break;
+                    case 4:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 4);
+                        break;
+                    case 5:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 5);
+                        break;
+                    case 6:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 6);
+                        break;
+                    case 7:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 7);
+                        break;
+                    case 8:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 8);
+                        break;
+                    case 9:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 9);
+                        break;
+                    case 10:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 10);
+                        break;
+                    case 11:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 11);
+                        break;
+                    case 12:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 12);
+                        break;
+                    case 13:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 13);
+                        break;
+                    case 14:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 14);
+                        break;
+                    case 15:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 15);
+                        break;
+                    }
+                    xmLoadPre = xmLoadNext;
+
+                    __m128i xmwLo = _mm_unpacklo_epi8(xmb, _mm_setzero_si128());
+                    __m128i xmwHi = _mm_unpackhi_epi8(xmb, _mm_setzero_si128());
+
+                    __m128i xmwAlpha = _mm_and_si128(xmb, msk_alpha);
+                    __m128i xmwAlphaLo = _mm_shuffle_epi8(xmb, sfl_alphaLo);
+                    __m128i xmwAlphaHi = _mm_shuffle_epi8(xmb, sfl_alphaHi);
+
+                    xmwLo = _mm_mullo_epi16(xmwLo, xmwAlphaLo);
+                    xmwLo = _mm_adds_epu16(xmwLo, word_add);
+                    xmwLo = _mm_mulhi_epu16(xmwLo, word_mul);
+
+                    xmwHi = _mm_mullo_epi16(xmwHi, xmwAlphaHi);
+                    xmwHi = _mm_adds_epu16(xmwHi, word_add);
+                    xmwHi = _mm_mulhi_epu16(xmwHi, word_mul);
+
+                    __m128i xmRes = _mm_packus_epi16(xmwLo, xmwHi);
+                    xmRes = _mm_or_si128(xmRes, xmwAlpha);
+                    xmRes = _mm_shuffle_epi8(xmRes, sfl_bgra);
+                    _mm_store_si128((__m128i*)dst, xmRes);
+
+                    src += 16;
+                    dst += 16;
+                    i -= 4;
+                }
+            }
+
+            while (i >= 1) {
+                PRUint8 r = *src++;
+                PRUint8 g = *src++;
+                PRUint8 b = *src++;
+                PRUint8 a = *src++;
+
+                // Convert to premultiplied color (losslessly if the input came from getImageData)
+                *dst++ = sPremultiplyTable[a][b];
+                *dst++ = sPremultiplyTable[a][g];
+                *dst++ = sPremultiplyTable[a][r];
+                *dst++ = a;
+                i -= 1;
+            }
+        }
+    } else
+#endif // (_MSC_VER != 1400) || !defined(_M_AMD64)
+    {
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+        int omp_thread_counts = omp_get_max_threads();
+
+#pragma omp parallel for schedule(guided) default(none) \
+shared(srcFirst, dstFirst, width, height, srcStride, dstStride, sPremultiplyTable) \
+if (omp_thread_counts >= 2 && \
+    height >= (PRUint32)omp_thread_counts && \
+    width * height >= 4096)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
+        for (PRInt64 j = 0; j < height; j++) {
+            PRUint8 *src = srcFirst + (srcStride * j);
+            PRUint8 *dst = dstFirst + (dstStride * j);
+
+            for (PRUint32 i = 0; i < width; i++) {
+                // XXX Is there some useful swizzle MMX we can use here?
+                PRUint8 r = *src++;
+                PRUint8 g = *src++;
+                PRUint8 b = *src++;
+                PRUint8 a = *src++;
+
+                // Convert to premultiplied color (losslessly if the input came from getImageData)
+#ifdef IS_LITTLE_ENDIAN
+                *dst++ = sPremultiplyTable[a][b];
+                *dst++ = sPremultiplyTable[a][g];
+                *dst++ = sPremultiplyTable[a][r];
+                *dst++ = a;
+#else
+                *dst++ = a;
+                *dst++ = sPremultiplyTable[a][r];
+                *dst++ = sPremultiplyTable[a][g];
+                *dst++ = sPremultiplyTable[a][b];
+#endif
+            }
+        }
+    }
+}
+
 } // namespace CanvasUtils
 } // namespace mozilla

diff --git a/content/canvas/src/CanvasUtils.h b/content/canvas/src/CanvasUtils.h
--- a/content/canvas/src/CanvasUtils.h
+++ b/content/canvas/src/CanvasUtils.h
@@ -18,16 +18,26 @@ namespace mozilla {
 namespace gfx {
 class Matrix;
 }
 
 namespace CanvasUtils {
 
 using namespace gfx;
 
+void GetImageData_component(PRUint8* _src, PRUint8* _dst,
+                            PRUint32 width, PRUint32 height,
+                            PRUint32 srcStride, PRUint32 dstStride,
+                            PRUint8 (*sUnpremultiplyTable)[256]);
+
+void PutImageData_component(PRUint8* _src, PRUint8* _dst,
+                            PRUint32 width, PRUint32 height,
+                            PRUint32 srcStride, PRUint32 dstStride,
+                            PRUint8 (*sPremultiplyTable)[256]);
+
 // Check that the rectangle [x,y,w,h] is a subrectangle of [0,0,realWidth,realHeight]
 
 inline bool CheckSaneSubrectSize(int32_t x, int32_t y, int32_t w, int32_t h,
                             int32_t realWidth, int32_t realHeight) {
     CheckedInt32 checked_xmost  = CheckedInt32(x) + w;
     CheckedInt32 checked_ymost  = CheckedInt32(y) + h;
 
     return w >= 0 && h >= 0 && x >= 0 && y >= 0 &&

diff --git a/js/src/methodjit/Compiler.cpp b/js/src/methodjit/Compiler.cpp
--- a/js/src/methodjit/Compiler.cpp
+++ b/js/src/methodjit/Compiler.cpp
@@ -926,16 +926,20 @@ MakeJITScript(JSContext *cx, JSScript *s
     for (unsigned i = 0; i < jit->nedges; i++) {
         CrossChunkEdge &edge = jitEdges[i];
         edge.shimLabel = shimCode + (size_t) edge.shimLabel;
     }
 
     return jit;
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
+
 CompileStatus
 mjit::CanMethodJIT(JSContext *cx, JSScript *script, jsbytecode *pc,
                    bool construct, CompileRequest request, StackFrame *frame)
 {
   restart:
     if (!cx->methodJitEnabled)
         return Compile_Abort;
 
@@ -1032,16 +1036,20 @@ mjit::CanMethodJIT(JSContext *cx, JSScri
 
     /* Non-OOM errors should have an associated exception. */
     JS_ASSERT_IF(status == Compile_Error,
                  cx->isExceptionPending() || cx->runtime->hadOutOfMemory);
 
     return status;
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
+
 CompileStatus
 mjit::Compiler::generatePrologue()
 {
     fastEntryLabel = masm.label();
 
     /*
      * If there is no function, then this can only be called via JaegerShot(),
      * which expects an existing frame to be initialized like the interpreter.
@@ -4657,32 +4665,40 @@ mjit::Compiler::inlineScriptedFunction(u
  * being set. This includes any API callbacks and any scripted or native call.
  */
 void
 mjit::Compiler::addCallSite(const InternalCallSite &site)
 {
     callSites.append(site);
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
+
 void
 mjit::Compiler::inlineStubCall(void *stub, RejoinState rejoin, Uses uses)
 {
     DataLabelPtr inlinePatch;
     Call cl = emitStubCall(stub, &inlinePatch);
     InternalCallSite site(masm.callReturnOffset(cl), a->inlineIndex, PC,
                           rejoin, false);
     site.inlinePatch = inlinePatch;
     if (loop && loop->generatingInvariants()) {
         Jump j = masm.jump();
         Label l = masm.label();
         loop->addInvariantCall(j, l, false, false, callSites.length(), uses);
     }
     addCallSite(site);
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
+
 bool
 mjit::Compiler::compareTwoValues(JSContext *cx, JSOp op, const Value &lhs, const Value &rhs)
 {
     JS_ASSERT(lhs.isPrimitive());
     JS_ASSERT(rhs.isPrimitive());
 
     if (lhs.isString() && rhs.isString()) {
         int32_t cmp;

diff --git a/content/media/Makefile.in b/content/media/Makefile.in
--- a/content/media/Makefile.in
+++ b/content/media/Makefile.in
@@ -92,8 +92,20 @@ TEST_DIRS += test
 
 FORCE_STATIC_LIB = 1
 
 include $(topsrcdir)/config/config.mk
 include $(topsrcdir)/ipc/chromium/chromium-config.mk
 include $(topsrcdir)/config/rules.mk
 
 DEFINES += -D_IMPL_NS_LAYOUT
+
+# Optimizer bug with MSVC PGO
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+nsMediaCache.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL-
+endif
+
+ifdef MOZ_THUNDERBIRD
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# avoid the fatal error C1001 of compiler when applying PGO to Thunderbird
+COMPILE_CXXFLAGS += -GL-
+endif
+endif

diff -r 284837bbf631 toolkit/content/debug.js
--- a/toolkit/content/debug.js	Sat Aug 25 07:23:12 2012 +0900
+++ b/toolkit/content/debug.js	Sat Aug 25 11:13:23 2012 +0900
@@ -36,17 +36,17 @@ function NS_ASSERT(condition, message) {
   var releaseBuild = true;
   var defB = Components.classes["@mozilla.org/preferences-service;1"]
                        .getService(Components.interfaces.nsIPrefService)
                        .getDefaultBranch(null);
   try {
     switch (defB.getCharPref("app.update.channel")) {
       case "nightly":
       case "beta":
-      case "default":
+      // case "default":
         releaseBuild = false;
     }
   } catch(ex) {}
 
   var caller = arguments.callee.caller;
   var assertionText = "ASSERT: " + message + "\n";
 
   if (releaseBuild) {

diff --git a/dom/ipc/Makefile.in b/dom/ipc/Makefile.in
--- a/dom/ipc/Makefile.in
+++ b/dom/ipc/Makefile.in
@@ -108,8 +108,15 @@ ifeq ($(MOZ_WIDGET_TOOLKIT),$(findstring
 DEFINES += -DMOZ_ENABLE_FREETYPE
 endif
 
 ifdef MOZ_PERMISSIONS
 DEFINES += -DMOZ_PERMISSIONS
 endif
 
 CXXFLAGS += $(TK_CFLAGS)
+
+ifdef MOZ_THUNDERBIRD
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# avoid the fatal error C1001 of compiler when applying PGO to Thunderbird
+COMPILE_CXXFLAGS += -GL-
+endif
+endif

diff --git a/dom/plugins/ipc/Makefile.in b/dom/plugins/ipc/Makefile.in
--- a/dom/plugins/ipc/Makefile.in
+++ b/dom/plugins/ipc/Makefile.in
@@ -130,8 +130,15 @@ include $(topsrcdir)/ipc/chromium/chromi
 
 include $(topsrcdir)/config/rules.mk
 
 CXXFLAGS += $(TK_CFLAGS)
 
 DEFINES += -DFORCE_PR_LOG
 
 CXXFLAGS += $(MOZ_CAIRO_CFLAGS)
+
+ifdef MOZ_THUNDERBIRD
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# avoid the fatal error C1001 of compiler when applying PGO to Thunderbird
+COMPILE_CXXFLAGS += -GL-
+endif
+endif

diff --git a/gfx/2d/DrawTargetD2D.cpp b/gfx/2d/DrawTargetD2D.cpp
--- a/gfx/2d/DrawTargetD2D.cpp
+++ b/gfx/2d/DrawTargetD2D.cpp
@@ -13,16 +13,25 @@
 #include "ImageScaling.h"
 #include "Logging.h"
 #include "Tools.h"
 #include <algorithm>
 #include "mozilla/Constants.h"
 
 #include <dwrite.h>
 
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+extern "C" {
+  extern __m128i _mm_shuffle_epi8(__m128i a, __m128i b);
+}
+#else
+#include <tmmintrin.h>
+#endif
+
 typedef HRESULT (WINAPI*D2D1CreateFactoryFunc)(
     D2D1_FACTORY_TYPE factoryType,
     REFIID iid,
     CONST D2D1_FACTORY_OPTIONS *pFactoryOptions,
     void **factory
 );
 
 typedef HRESULT (WINAPI*D3D10CreateEffectFromMemoryFunc)(
@@ -2175,29 +2184,95 @@ DrawTargetD2D::CreateStrokeStyleForOptio
 
   if (FAILED(hr)) {
     gfxWarning() << "Failed to create Direct2D stroke style.";
   }
 
   return style;
 }
 
+static const float f_zero = 0;
+static const float f_one = 1.0f;
+static const __m128 xm_4095_rcp_mul = _mm_set_ss(1.0f / 4095);
+static const __m128 xm_255x4 = _mm_set1_ps(255.0f);
+static const __m128i sfl_pack4 = _mm_set_epi8(0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 12, 0, 4, 8);
+
 TemporaryRef<ID3D10Texture2D>
 DrawTargetD2D::CreateGradientTexture(const GradientStopsD2D *aStops)
 {
   CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM, 4096, 1, 1, 1);
 
   std::vector<D2D1_GRADIENT_STOP> rawStops;
   rawStops.resize(aStops->mStopCollection->GetGradientStopCount());
   aStops->mStopCollection->GetGradientStops(&rawStops.front(), rawStops.size());
 
-  std::vector<unsigned char> textureData;
-  textureData.resize(4096 * 4);
-  unsigned char *texData = &textureData.front();
-
+  unsigned char *textureData = new unsigned char [4096 * 4];
+  unsigned char *texData = textureData;
+
+if (Factory::HasSSE2()) {
+#if (_MSC_VER != 1400) || !defined(_M_AMD64)
+  bool has_ssse3 = Factory::HasSSSE3();
+#endif
+  __m128 prevColorPos = _mm_load_ss(&f_zero);
+  __m128 nextColorPos = _mm_load_ss(&f_one);
+  __m128 prevColor = _mm_loadu_ps((float*)&rawStops[0].color);
+  __m128 nextColor = prevColor;
+
+  if (rawStops.size() >= 2) {
+    nextColor = _mm_loadu_ps((float*)&rawStops[1].color);
+    nextColorPos = _mm_load_ss(&rawStops[1].position);
+  }
+
+  uint32_t stopPosition = 2;
+  __m128 interp_rcp_mul = _mm_div_ss(_mm_load_ss(&f_one), _mm_sub_ss(nextColorPos, prevColorPos));
+
+  // Not the most optimized way but this will do for now.
+  for (int i = 0; i < 4096; i++) {
+    // The 4095 seems a little counter intuitive, but we want the gradient
+    // color at offset 0 at the first pixel, and at offset 1.0f at the last
+    // pixel.
+    __m128 pos;
+    pos = _mm_cvtsi32_ss(pos, i);
+    pos = _mm_mul_ss(pos, xm_4095_rcp_mul);
+
+    if (_mm_comigt_ss(pos, nextColorPos)) {
+      prevColor = nextColor;
+      prevColorPos = nextColorPos;
+      if (rawStops.size() > stopPosition) {
+        nextColor = _mm_loadu_ps((float*)&rawStops[stopPosition].color);
+        nextColorPos = _mm_load_ss(&rawStops[stopPosition++].position);
+      } else {
+        nextColorPos = _mm_load_ss(&f_one);
+      }
+      interp_rcp_mul = _mm_div_ss(_mm_load_ss(&f_one), _mm_sub_ss(nextColorPos, prevColorPos));
+    }
+
+    __m128 interp = _mm_mul_ss(_mm_sub_ss(pos, prevColorPos), interp_rcp_mul);
+    interp = _mm_shuffle_ps(interp, interp, _MM_SHUFFLE(0, 0, 0, 0));
+
+    __m128 newColor = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(nextColor, prevColor), interp), prevColor);
+    newColor = _mm_mul_ps(newColor, xm_255x4);
+
+/* Don't use SSSE3 intrinsics when using VC8-x64 compiler, which has optimizer bugs. */
+#if (_MSC_VER != 1400) || !defined(_M_AMD64)
+    if (has_ssse3) {
+      __m128i xmResult = _mm_cvttps_epi32(newColor);
+      xmResult = _mm_shuffle_epi8(xmResult, sfl_pack4);
+      *((uint32_t*)&texData[i * 4]) = _mm_cvtsi128_si32(xmResult);
+    } else
+#endif
+    {
+      newColor = _mm_shuffle_ps(newColor, newColor, _MM_SHUFFLE(3, 0, 1, 2));
+      __m128i xmResult = _mm_cvttps_epi32(newColor);
+      xmResult = _mm_packs_epi32(xmResult, _mm_setzero_si128());
+      xmResult = _mm_packus_epi16(xmResult, _mm_setzero_si128());
+      *((uint32_t*)&texData[i * 4]) = _mm_cvtsi128_si32(xmResult);
+    }
+  }
+} else {
   float prevColorPos = 0;
   float nextColorPos = 1.0f;
   D2D1_COLOR_F prevColor = rawStops[0].color;
   D2D1_COLOR_F nextColor = prevColor;
 
   if (rawStops.size() >= 2) {
     nextColor = rawStops[1].color;
     nextColorPos = rawStops[1].position;
@@ -2236,24 +2311,27 @@ DrawTargetD2D::CreateGradientTexture(con
                     prevColor.b + (nextColor.b - prevColor.b) * interp,
                     prevColor.a + (nextColor.a - prevColor.a) * interp);
 
     texData[i * 4] = (char)(255.0f * newColor.b);
     texData[i * 4 + 1] = (char)(255.0f * newColor.g);
     texData[i * 4 + 2] = (char)(255.0f * newColor.r);
     texData[i * 4 + 3] = (char)(255.0f * newColor.a);
   }
+}
 
   D3D10_SUBRESOURCE_DATA data;
-  data.pSysMem = &textureData.front();
+  data.pSysMem = textureData;
   data.SysMemPitch = 4096 * 4;
 
   RefPtr<ID3D10Texture2D> tex;
   mDevice->CreateTexture2D(&desc, &data, byRef(tex));
 
+  delete [] textureData;
+
   return tex;
 }
 
 TemporaryRef<ID3D10Texture2D>
 DrawTargetD2D::CreateTextureForAnalysis(IDWriteGlyphRunAnalysis *aAnalysis, const IntRect &aBounds)
 {
   HRESULT hr;
 

diff -r 4c866814904f gfx/2d/Factory.cpp
--- a/gfx/2d/Factory.cpp	Sun Aug 26 05:58:11 2012 +0900
+++ b/gfx/2d/Factory.cpp	Sun Aug 26 07:18:32 2012 +0900
@@ -152,16 +152,29 @@ Factory::HasSSE2()
   return true;
 #elif defined(HAVE_CPU_DETECTION)
   return HasCPUIDBit(1u, edx, (1u<<26));
 #else
   return false;
 #endif
 }
 
+bool
+Factory::HasSSSE3()
+{
+#if defined(__SSSE3__)
+  // gcc with -mssse3
+  return true;
+#elif defined(HAVE_CPU_DETECTION)
+  return HasCPUIDBit(1u, ecx, (1u<<9));
+#else
+  return false;
+#endif
+}
+
 TemporaryRef<DrawTarget>
 Factory::CreateDrawTarget(BackendType aBackend, const IntSize &aSize, SurfaceFormat aFormat)
 {
   switch (aBackend) {
 #ifdef WIN32
   case BACKEND_DIRECT2D:
     {
       RefPtr<DrawTargetD2D> newTarget;

diff --git a/layout/base/FrameLayerBuilder.cpp b/layout/base/FrameLayerBuilder.cpp
--- a/layout/base/FrameLayerBuilder.cpp
+++ b/layout/base/FrameLayerBuilder.cpp
@@ -194,37 +194,55 @@ public:
 
   nscoord GetAppUnitsPerDevPixel() { return mAppUnitsPerDevPixel; }
 
   nsIntRect ScaleToNearestPixels(const nsRect& aRect)
   {
     return aRect.ScaleToNearestPixels(mParameters.mXScale, mParameters.mYScale,
                                       mAppUnitsPerDevPixel);
   }
+  nsIntRect ToNearestPixels(const nsRect& aRect)
+  {
+    return aRect.ToNearestPixels(mAppUnitsPerDevPixel);
+  }
   nsIntRegion ScaleRegionToNearestPixels(const nsRegion& aRegion)
   {
     return aRegion.ScaleToNearestPixels(mParameters.mXScale, mParameters.mYScale,
                                         mAppUnitsPerDevPixel);
   }
   nsIntRect ScaleToOutsidePixels(const nsRect& aRect, bool aSnap)
   {
     if (aSnap && mSnappingEnabled) {
       return ScaleToNearestPixels(aRect);
     }
     return aRect.ScaleToOutsidePixels(mParameters.mXScale, mParameters.mYScale,
                                       mAppUnitsPerDevPixel);
   }
+  nsIntRect ToOutsidePixels(const nsRect& aRect, bool aSnap)
+  {
+    if (aSnap && mSnappingEnabled) {
+      return ToNearestPixels(aRect);
+    }
+    return aRect.ToOutsidePixels(mAppUnitsPerDevPixel);
+  }
   nsIntRect ScaleToInsidePixels(const nsRect& aRect, bool aSnap)
   {
     if (aSnap && mSnappingEnabled) {
       return ScaleToNearestPixels(aRect);
     }
     return aRect.ScaleToInsidePixels(mParameters.mXScale, mParameters.mYScale,
                                      mAppUnitsPerDevPixel);
   }
+  nsIntRect ToInsidePixels(const nsRect& aRect, bool aSnap)
+  {
+    if (aSnap && mSnappingEnabled) {
+      return ToNearestPixels(aRect);
+    }
+    return aRect.ToInsidePixels(mAppUnitsPerDevPixel);
+  }
 
   nsIntRegion ScaleRegionToInsidePixels(const nsRegion& aRegion, bool aSnap)
   {
     if (aSnap && mSnappingEnabled) {
       return ScaleRegionToNearestPixels(aRegion);
     }
     return aRegion.ScaleToInsidePixels(mParameters.mXScale, mParameters.mYScale,
                                         mAppUnitsPerDevPixel);
@@ -1781,36 +1799,40 @@ PaintInactiveLayer(nsDisplayListBuilder*
  * of ContainerState::Finish.
  */
 void
 ContainerState::ProcessDisplayItems(const nsDisplayList& aList,
                                     FrameLayerBuilder::Clip& aClip,
                                     uint32_t aFlags)
 {
   SAMPLE_LABEL("ContainerState", "ProcessDisplayItems");
+  const bool scaled = mParameters.Scaled();
   for (nsDisplayItem* item = aList.GetBottom(); item; item = item->GetAbove()) {
     nsDisplayItem::Type type = item->GetType();
     if (type == nsDisplayItem::TYPE_CLIP ||
         type == nsDisplayItem::TYPE_CLIP_ROUNDED_RECT) {
       FrameLayerBuilder::Clip childClip(aClip, item);
       ProcessDisplayItems(*item->GetList(), childClip, aFlags);
       continue;
     }
 
     NS_ASSERTION(mAppUnitsPerDevPixel == AppUnitsPerDevPixel(item),
       "items in a container layer should all have the same app units per dev pixel");
 
     nsIntRect itemVisibleRect =
-      ScaleToOutsidePixels(item->GetVisibleRect(), false);
+      scaled ? ScaleToOutsidePixels(item->GetVisibleRect(), false) :
+               ToOutsidePixels(item->GetVisibleRect(), false);
     bool snap;
     nsRect itemContent = item->GetBounds(mBuilder, &snap);
-    nsIntRect itemDrawRect = ScaleToOutsidePixels(itemContent, snap);
+    nsIntRect itemDrawRect = scaled ? ScaleToOutsidePixels(itemContent, snap) :
+                                      ToOutsidePixels(itemContent, snap);
     if (aClip.mHaveClipRect) {
       itemContent.IntersectRect(itemContent, aClip.mClipRect);
-      nsIntRect clipRect = ScaleToNearestPixels(aClip.mClipRect);
+      nsIntRect clipRect = scaled ? ScaleToNearestPixels(aClip.mClipRect) :
+                                    ToNearestPixels(aClip.mClipRect);
       itemDrawRect.IntersectRect(itemDrawRect, clipRect);
     }
     mBounds.UnionRect(mBounds, itemContent);
     itemVisibleRect.IntersectRect(itemVisibleRect, itemDrawRect);
 
     LayerState layerState = item->GetLayerState(mBuilder, mManager, mParameters);
 
     nsIFrame* activeScrolledRoot;
@@ -1874,17 +1896,18 @@ ContainerState::ProcessDisplayItems(cons
       NS_ASSERTION(!ownLayer->HasUserData(&gLayerManagerUserData),
                    "We shouldn't have a FrameLayerBuilder-managed layer here!");
       NS_ASSERTION(aClip.mHaveClipRect ||
                      aClip.mRoundedClipRects.IsEmpty(),
                    "If we have rounded rects, we must have a clip rect");
       // It has its own layer. Update that layer's clip and visible rects.
       if (aClip.mHaveClipRect) {
         ownLayer->IntersectClipRect(
-          ScaleToNearestPixels(aClip.NonRoundedIntersection()));
+          scaled ? ScaleToNearestPixels(aClip.NonRoundedIntersection()) :
+                   ToNearestPixels(aClip.NonRoundedIntersection()));
       }
       ThebesLayerData* data = GetTopThebesLayerData();
       if (data) {
         data->mVisibleAboveRegion.Or(data->mVisibleAboveRegion, itemVisibleRect);
         data->mVisibleAboveRegion.SimplifyOutward(4);
         // Add the entire bounds rect to the mDrawAboveRegion.
         // The visible region may be excluding opaque content above the
         // item, and we need to ensure that that content is not placed

diff --git a/layout/base/FrameLayerBuilder.h b/layout/base/FrameLayerBuilder.h
--- a/layout/base/FrameLayerBuilder.h
+++ b/layout/base/FrameLayerBuilder.h
@@ -146,16 +146,21 @@ public:
     {}
     ContainerParameters(float aXScale, float aYScale,
                         const ContainerParameters& aParent) :
       mXScale(aXScale), mYScale(aYScale),
       mInTransformedSubtree(aParent.mInTransformedSubtree),
       mInActiveTransformedSubtree(aParent.mInActiveTransformedSubtree),
       mDisableSubpixelAntialiasingInDescendants(aParent.mDisableSubpixelAntialiasingInDescendants)
     {}
+    bool Scaled()
+    {
+      return (0x3f800000 != *(PRUint32 *)&mXScale) ||
+             (0x3f800000 != *(PRUint32 *)&mYScale);
+    }
     float mXScale, mYScale;
     bool mInTransformedSubtree;
     bool mInActiveTransformedSubtree;
     bool mDisableSubpixelAntialiasingInDescendants;
     /**
      * When this is false, ThebesLayer coordinates are drawn to with an integer
      * translation and the scale in mXScale/mYScale.
      */

diff -r 7bb142a96aae security/nss/lib/freebl/manifest.mn
--- a/security/nss/lib/freebl/manifest.mn	Fri Sep 30 20:05:12 2011 +0900
+++ b/security/nss/lib/freebl/manifest.mn	Fri Sep 30 22:55:42 2011 +0900
@@ -95,17 +95,21 @@ PRIVATE_EXPORTS = \
 	secmpi.h \
 	secrng.h \
 	ec.h \
 	ecl.h \
 	ecl-curve.h \
 	$(NULL)
 
 MPI_HDRS = mpi-config.h mpi.h mpi-priv.h mplogic.h mpprime.h logtab.h mp_gf2m.h
+ifdef USE_64
 MPI_SRCS = mpprime.c mpmontg.c mplogic.c mpi.c mp_gf2m.c
+else
+MPI_SRCS = mpprime.c mpmontg.c mplogic.c mpi.c mp_gf2m.c mpi_x86_asm.c
+endif
 
 
 ECL_HDRS = ecl-exp.h ecl.h ec2.h ecp.h ecl-priv.h
 ifdef NSS_ENABLE_ECC
 ECL_SRCS = ecl.c ecl_curve.c ecl_mult.c ecl_gf.c \
 	ecp_aff.c ecp_jac.c ecp_mont.c \
 	ec_naf.c ecp_jm.c
 ifdef NSS_ECC_MORE_THAN_SUITE_B

diff --git a/gfx/2d/Makefile.in b/gfx/2d/Makefile.in
--- a/gfx/2d/Makefile.in
+++ b/gfx/2d/Makefile.in
@@ -99,22 +99,19 @@ endif
 DEFINES += -DSK_A32_SHIFT=24 -DSK_R32_SHIFT=16 -DSK_G32_SHIFT=8 -DSK_B32_SHIFT=0
 
 ifdef MOZ_DEBUG
 DEFINES += -DGFX_LOG_DEBUG -DGFX_LOG_WARNING
 endif
 
 # Are we targeting x86 or x64?  If so, build SSE2 files.
 ifneq (,$(INTEL_ARCHITECTURE))
-# VC2005 doesn't support _mm_castsi128_ps, so SSE2 is turned off
-ifneq (1400,$(_MSC_VER))
 CPPSRCS += ImageScalingSSE2.cpp
 DEFINES += -DUSE_SSE2
 endif
-endif
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),windows)
 CPPSRCS	+= \
         DrawTargetD2D.cpp \
         SourceSurfaceD2D.cpp \
         SourceSurfaceD2DTarget.cpp \
         PathD2D.cpp \
         ScaledFontDWrite.cpp \

diff --git a/gfx/thebes/gfxContext.h b/gfx/thebes/gfxContext.h
--- a/gfx/thebes/gfxContext.h
+++ b/gfx/thebes/gfxContext.h
@@ -648,17 +648,21 @@ public:
         /**
          * When this flag is set, snapping to device pixels is disabled.
          * It simply never does anything.
          */
         FLAG_DISABLE_SNAPPING = (1 << 1),
         /**
          * Disable copying of backgrounds in PushGroupAndCopyBackground.
          */
-        FLAG_DISABLE_COPY_BACKGROUND = (1 << 2)
+        FLAG_DISABLE_COPY_BACKGROUND = (1 << 2),
+        /**
+         * tete009 extension
+         */
+        FLAG_DRAW_SINGLE_IMAGE_TT = (1 << 20)
     };
 
     void SetFlag(int32_t aFlag) { mFlags |= aFlag; }
     void ClearFlag(int32_t aFlag) { mFlags &= ~aFlag; }
     int32_t GetFlags() const { return mFlags; }
 
     bool IsCairo() const { return !mDT; }
 

diff --git a/gfx/thebes/gfxUtils.cpp b/gfx/thebes/gfxUtils.cpp
--- a/gfx/thebes/gfxUtils.cpp
+++ b/gfx/thebes/gfxUtils.cpp
@@ -457,18 +457,22 @@ gfxUtils::DrawPixelSnapped(gfxContext*  
                            const gfxRect&   aSourceRect,
                            const gfxRect&   aImageRect,
                            const gfxRect&   aFill,
                            const gfxImageSurface::gfxImageFormat aFormat,
                            gfxPattern::GraphicsFilter aFilter,
                            uint32_t         aImageFlags)
 {
     SAMPLE_LABEL("gfxUtils", "DrawPixelSnapped");
-    bool doTile = !aImageRect.Contains(aSourceRect) &&
-                  !(aImageFlags & imgIContainer::FLAG_CLAMP);
+
+    bool drawSingleImage = (aContext->GetFlags() & gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+    aContext->ClearFlag(gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+
+    bool doTile = (drawSingleImage ? false : (!aImageRect.Contains(aSourceRect) &&
+                  !(aImageFlags & imgIContainer::FLAG_CLAMP)));
 
     nsRefPtr<gfxASurface> currentTarget = aContext->CurrentSurface();
     gfxMatrix deviceSpaceToImageSpace =
         DeviceToImageTransform(aContext, aUserSpaceToImageSpace);
 
     AutoCairoPixmanBugWorkaround workaround(aContext, deviceSpaceToImageSpace,
                                             aFill, currentTarget);
     if (!workaround.Succeeded())

diff -r 42edc8f4c9c6 gfx/2d/ImageScalingSSE2.cpp
--- a/gfx/2d/ImageScalingSSE2.cpp	Sat Aug 25 11:51:05 2012 +0900
+++ b/gfx/2d/ImageScalingSSE2.cpp	Sat Aug 25 17:48:42 2012 +0900
@@ -4,16 +4,37 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ImageScaling.h"
 #include "mozilla/Attributes.h"
 
 #include <xmmintrin.h>
 #include <emmintrin.h>
 
+/* VC8 doesn't support some SSE2 built-in functions, so we define them here. */
+#if defined(_MSC_VER) && (_MSC_VER < 1500)
+static __forceinline __m128
+_mm_castsi128_ps(__m128i a)
+{
+    return *(__m128 *)&a;
+}
+
+static __forceinline __m128i
+_mm_castpd_si128(__m128d a)
+{
+    return *(__m128i *)&a;
+}
+
+static __forceinline __m128i
+_mm_castps_si128(__m128 a)
+{
+    return *(__m128i *)&a;
+}
+#endif
+
 /* The functions below use the following system for averaging 4 pixels:
  *
  * The first observation is that a half-adder is implemented as follows:
  * R = S + 2C or in the case of a and b (a ^ b) + ((a & b) << 1);
  *
  * This can be trivially extended to three pixels by observaring that when
  * doing (a ^ b ^ c) as the sum, the carry is simply the bitwise-or of the
  * carries of the individual numbers, since the sum of 3 bits can only ever

diff --git a/image/src/imgFrame.cpp b/image/src/imgFrame.cpp
--- a/image/src/imgFrame.cpp
+++ b/image/src/imgFrame.cpp
@@ -437,16 +437,19 @@ void imgFrame::Draw(gfxContext *aContext
                     const nsIntMargin &aPadding, const nsIntRect &aSubimage,
                     uint32_t aImageFlags)
 {
   SAMPLE_LABEL("image", "imgFrame::Draw");
   NS_ASSERTION(!aFill.IsEmpty(), "zero dest size --- fix caller");
   NS_ASSERTION(!aSubimage.IsEmpty(), "zero source size --- fix caller");
   NS_ASSERTION(!mPalettedImageData, "Directly drawing a paletted image!");
 
+  bool drawSingleImage = (aContext->GetFlags() & gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+  aContext->ClearFlag(gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+
   bool doPadding = aPadding != nsIntMargin(0,0,0,0);
   bool doPartialDecode = !ImageComplete();
 
   if (mSinglePixel && !doPadding && !doPartialDecode) {
     DoSingleColorFastPath(aContext, mSinglePixelColor, aFill);
     return;
   }
 
@@ -455,24 +458,27 @@ void imgFrame::Draw(gfxContext *aContext
   gfxRect imageRect(0, 0, mSize.width + aPadding.LeftRight(),
                     mSize.height + aPadding.TopBottom());
   gfxRect subimage(aSubimage.x, aSubimage.y, aSubimage.width, aSubimage.height);
   gfxRect fill = aFill;
 
   NS_ASSERTION(!sourceRect.Intersect(subimage).IsEmpty(),
                "We must be allowed to sample *some* source pixels!");
 
-  bool doTile = !imageRect.Contains(sourceRect) &&
-                !(aImageFlags & imgIContainer::FLAG_CLAMP);
+  bool doTile = (drawSingleImage ? false : (!imageRect.Contains(sourceRect) &&
+                !(aImageFlags & imgIContainer::FLAG_CLAMP)));
   SurfaceWithFormat surfaceResult =
     SurfaceForDrawing(doPadding, doPartialDecode, doTile, aPadding,
                       userSpaceToImageSpace, fill, subimage, sourceRect,
                       imageRect);
 
   if (surfaceResult.IsValid()) {
+    if (drawSingleImage) {
+      aContext->SetFlag(gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+    }
     gfxUtils::DrawPixelSnapped(aContext, surfaceResult.mDrawable,
                                userSpaceToImageSpace,
                                subimage, sourceRect, imageRect, fill,
                                surfaceResult.mFormat, aFilter, aImageFlags);
   }
 }
 
 nsresult imgFrame::Extract(const nsIntRect& aRegion, imgFrame** aResult)


diff --git a/image/src/imgLoader.cpp b/image/src/imgLoader.cpp
--- a/image/src/imgLoader.cpp
+++ b/image/src/imgLoader.cpp
@@ -1108,23 +1108,25 @@ void imgLoader::CheckCacheLimits(imgCach
   // Remove entries from the cache until we're back under our desired size.
   while (queue.GetSize() >= sCacheMaxSize) {
     // Remove the first entry in the queue.
     nsRefPtr<imgCacheEntry> entry(queue.Pop());
 
     NS_ASSERTION(entry, "imgLoader::CheckCacheLimits -- NULL entry pointer");
 
 #if defined(PR_LOGGING)
-    nsRefPtr<imgRequest> req(entry->GetRequest());
-    if (req) {
-      nsCOMPtr<nsIURI> uri;
-      req->GetURI(getter_AddRefs(uri));
-      nsCAutoString spec;
-      uri->GetSpec(spec);
-      LOG_STATIC_FUNC_WITH_PARAM(gImgLog, "imgLoader::CheckCacheLimits", "entry", spec.get());
+    if (entry) {
+      nsRefPtr<imgRequest> req(entry->GetRequest());
+      if (req) {
+        nsCOMPtr<nsIURI> uri;
+        req->GetURI(getter_AddRefs(uri));
+        nsCAutoString spec;
+        uri->GetSpec(spec);
+        LOG_STATIC_FUNC_WITH_PARAM(gImgLog, "imgLoader::CheckCacheLimits", "entry", spec.get());
+      }
     }
 #endif
 
     if (entry)
       RemoveFromCache(entry);
   }
 }
 
diff --git a/ipc/ipdl/Makefile.in b/ipc/ipdl/Makefile.in
--- a/ipc/ipdl/Makefile.in
+++ b/ipc/ipdl/Makefile.in
@@ -95,8 +95,15 @@ export:: $(ALL_IPDLSRCS)
 	  --outheaders-dir=_ipdlheaders \
 	  --outcpp-dir=. \
 	  $(IPDLDIRS:%=-I$(topsrcdir)/%) \
 	  $^
 
 # We #include some things in the dom/plugins/ directory that rely on
 # toolkit libraries.
 CXXFLAGS    += $(TK_CFLAGS)
+
+ifdef MOZ_THUNDERBIRD
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# avoid the fatal error C1001 of compiler when applying PGO to Thunderbird
+COMPILE_CXXFLAGS += -GL-
+endif
+endif

diff --git a/memory/mozjemalloc/jemalloc.c b/memory/mozjemalloc/jemalloc.c
--- a/memory/mozjemalloc/jemalloc.c
+++ b/memory/mozjemalloc/jemalloc.c
@@ -230,32 +230,62 @@
 
 #ifdef MOZ_MEMORY_WINDOWS
 
 /* Some defines from the CRT internal headers that we need here. */
 #define _CRT_SPINCOUNT 5000
 #define __crtInitCritSecAndSpinCount InitializeCriticalSectionAndSpinCount
 #include <io.h>
 #include <windows.h>
+#include <intrin.h>
+#if defined _M_IX86 || defined _M_AMD64
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+#else  /* _MSC_VER == 1400 */
+#include <smmintrin.h>
+#endif /* _MSC_VER == 1400 */
+#endif /* defined _M_IX86 || defined _M_AMD64 */
+
+#if _MSC_VER >= 1400
+#ifdef _WIN64
+unsigned __int64 __readgsqword(unsigned long Offset);
+#pragma intrinsic(__readgsqword)
+#define TlsGetValue(x) (LPVOID)(__readgsqword((x) * 8 + 0x1480))
+#else /* _WIN64 */
+unsigned long __readfsdword(unsigned long Offset);
+#pragma intrinsic(__readfsdword)
+#define TlsGetValue(x) (LPVOID)(*(unsigned long *)(__readfsdword(0x18) + (x) * 4 + 3600))
+#endif /* _WIN64 */
+#endif /* _MSC_VER >= 1400 */
 
 #pragma warning( disable: 4267 4996 4146 )
 
 #define	bool BOOL
 #define	false FALSE
 #define	true TRUE
 #define	inline __inline
 #define	SIZE_T_MAX SIZE_MAX
 #define	STDERR_FILENO 2
 #define	PATH_MAX MAX_PATH
 #define	vsnprintf _vsnprintf
 
 #ifndef NO_TLS
 static unsigned long tlsIndex = 0xffffffff;
 #endif 
 
+BOOL ReplaceAPICode(FARPROC lpProcAddr, LPBYTE lpCodeData, int nCodeDataSize);
+static BOOL sse4_1_supported = FALSE;
+typedef struct
+{
+  int EAX;
+  int EBX;
+  int ECX;
+  int EDX;
+} CPU_INFO;
+
 #define	__thread
 #define	_pthread_self() __threadid()
 #define	issetugid() 0
 
 /* use MSVC intrinsics */
 #pragma intrinsic(_BitScanForward)
 static __forceinline int
 ffs(int x)
@@ -5637,16 +5667,30 @@ malloc_init_hard(void)
 		malloc_mutex_unlock(&init_lock);
 #endif
 		return (false);
 	}
 
 #ifdef MOZ_MEMORY_WINDOWS
 	/* get a thread local storage index */
 	tlsIndex = TlsAlloc();
+
+	{
+		CPU_INFO CPUInfo;
+
+		__cpuid((int*)&CPUInfo, 0);
+		if (CPUInfo.EAX >= 1)
+		{
+			__cpuid((int*)&CPUInfo, 1);
+			if (CPUInfo.ECX & (1 << 19))
+			{
+				sse4_1_supported = TRUE;
+			}
+		}
+	}
 #endif
 
 	/* Get page size and number of CPUs */
 #ifdef MOZ_MEMORY_WINDOWS
 	{
 		SYSTEM_INFO info;
 
 		GetSystemInfo(&info);
@@ -7177,8 +7221,81 @@ BOOL APIENTRY DllMain(HINSTANCE hModule,
     case DLL_PROCESS_DETACH:
       break;
 
   }
 
   return TRUE;
 }
 #endif
+
+#ifdef MOZ_MEMORY_WINDOWS
+#include <math.h>
+
+double __cdecl floor_tt(double x)
+{
+#if defined _M_IX86 || defined _M_AMD64
+  if (sse4_1_supported)
+  {
+#if _MSC_VER != 1400
+    __m128d xd = _mm_load_sd(&x);
+    double d;
+
+    xd = _mm_floor_sd(xd, xd);
+    _mm_store_sd(&d, xd);
+    return d;
+#elif defined _M_IX86
+    double d;
+
+    __asm
+    {
+      movsd       xmm0, x
+      /* roundsd  xmm0, xmm0, 1 */
+      __asm _emit 0x66
+      __asm _emit 0x0F
+      __asm _emit 0x3A
+      __asm _emit 0x0B
+      __asm _emit 0xC0
+      __asm _emit 0x01
+      movsd       d, xmm0
+    }
+    return d;
+#endif
+  }
+#endif /* defined _M_IX86 || defined _M_AMD64 */
+  return floor(x);
+}
+
+double __cdecl ceil_tt(double x)
+{
+#if defined _M_IX86 || defined _M_AMD64
+  if (sse4_1_supported)
+  {
+#if _MSC_VER != 1400
+    __m128d xd = _mm_load_sd(&x);
+    double d;
+
+    xd = _mm_ceil_sd(xd, xd);
+    _mm_store_sd(&d, xd);
+    return d;
+#elif defined _M_IX86
+    double d;
+
+    __asm
+    {
+      movsd       xmm0, x
+      /* roundsd  xmm0, xmm0, 2 */
+      __asm _emit 0x66
+      __asm _emit 0x0F
+      __asm _emit 0x3A
+      __asm _emit 0x0B
+      __asm _emit 0xC0
+      __asm _emit 0x02
+      movsd       d, xmm0
+    }
+    return d;
+#endif
+  }
+#endif /* defined _M_IX86 || defined _M_AMD64 */
+  return ceil(x);
+}
+
+#endif

diff --git a/js/src/Makefile.in b/js/src/Makefile.in
--- a/js/src/Makefile.in
+++ b/js/src/Makefile.in
@@ -879,8 +879,23 @@ endif
 TestMain$(HOST_BIN_SUFFIX): $(TESTMAIN_OBJS)
 	$(CXX) -o TestMain$(HOST_BIN_SUFFIX) $(TESTMAIN_OBJS)
 endif
 
 #
 # END kludges for the Nitro assembler
 ###############################################
 
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# Optimizer bug with MSVC PGO (Bug 595653)
+YarrPattern.$(OBJ_SUFFIX): COMPILE_CXXFLAGS := $(COMPILE_CXXFLAGS:arch:SSE2=arch:SSE)
+
+# -LTCG:PGINSTRUMENT bug of MSVC PGO
+PolyIC.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL-
+
+# -LTCG:PGINSTRUMENT bug of MSVC PGO
+MonoIC.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL-
+
+# Optimizer bug with MSVC PGO
+FrameState.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL-
+
+FastOps.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL-
+endif

diff --git a/js/src/jsapi.cpp b/js/src/jsapi.cpp
--- a/js/src/jsapi.cpp
+++ b/js/src/jsapi.cpp
@@ -2035,17 +2035,17 @@ JS_EnumerateStandardClasses(JSContext *c
 
     /*
      * Check whether we need to bind 'undefined' and define it if so.
      * Since ES5 15.1.1.3 undefined can't be deleted.
      */
     RootedPropertyName undefinedName(cx, cx->runtime->atomState.typeAtoms[JSTYPE_VOID]);
     RootedId undefinedId(cx, NameToId(undefinedName));
     RootedValue undefinedValue(cx, UndefinedValue());
-    if (!obj->nativeContains(cx, undefinedId) &&
+    if (!obj->nativeContains(cx, (HandleId)undefinedId) &&
         !JSObject::defineProperty(cx, obj, undefinedName, undefinedValue,
                                   JS_PropertyStub, JS_StrictPropertyStub,
                                   JSPROP_PERMANENT | JSPROP_READONLY)) {
         return false;
     }
 
     /* Initialize any classes that have not been initialized yet. */
     for (unsigned i = 0; standard_class_atoms[i].init; i++) {
@@ -2114,17 +2114,17 @@ AddNameToArray(JSContext *cx, PropertyNa
     return ida;
 }
 
 static JSIdArray *
 EnumerateIfResolved(JSContext *cx, JSHandleObject obj, PropertyName *name, JSIdArray *ida,
                     int *ip, JSBool *foundp)
 {
     RootedId id(cx, NameToId(name));
-    *foundp = obj->nativeContains(cx, id);
+    *foundp = obj->nativeContains(cx, (HandleId)id);
     if (*foundp)
         ida = AddNameToArray(cx, name, ida, ip);
     return ida;
 }
 
 JS_PUBLIC_API(JSIdArray *)
 JS_EnumerateResolvedStandardClasses(JSContext *cx, JSObject *objArg, JSIdArray *ida)
 {
@@ -3714,17 +3714,17 @@ JS_AlreadyHasOwnPropertyById(JSContext *
         if (!LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
                                 &obj2, &prop)) {
             return JS_FALSE;
         }
         *foundp = (obj == obj2);
         return JS_TRUE;
     }
 
-    *foundp = obj->nativeContains(cx, id);
+    *foundp = obj->nativeContains(cx, (HandleId)id);
     return JS_TRUE;
 }
 
 JS_PUBLIC_API(JSBool)
 JS_AlreadyHasOwnElement(JSContext *cx, JSObject *objArg, uint32_t index, JSBool *foundp)
 {
     RootedObject obj(cx, objArg);
     AssertHeapIsIdle(cx);

diff -r 284837bbf631 js/src/jsdhash.cpp
--- a/js/src/jsdhash.cpp	Sat Aug 25 07:23:12 2012 +0900
+++ b/js/src/jsdhash.cpp	Sat Aug 25 09:58:19 2012 +0900
@@ -3,16 +3,19 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /*
  * Double hashing implementation.
  *
  * Try to keep this file in sync with xpcom/glue/pldhash.cpp.
  */
+#if _MSC_VER >= 1400
+#include <intrin.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include "jsdhash.h"
 #include "jsutil.h"
 
 using namespace js;
 
@@ -128,23 +131,39 @@ JS_DHashMatchStringKey(JSDHashTable *tab
             strcmp((const char *) stub->key, (const char *) key) == 0);
 }
 
 JS_PUBLIC_API(void)
 JS_DHashMoveEntryStub(JSDHashTable *table,
                       const JSDHashEntryHdr *from,
                       JSDHashEntryHdr *to)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __movsd((unsigned long*)to, (unsigned long*)from, table->entrySize >> 2);
+    } else {
+        js_memcpy(to, from, table->entrySize);
+    }
+#else
     js_memcpy(to, from, table->entrySize);
+#endif
 }
 
 JS_PUBLIC_API(void)
 JS_DHashClearEntryStub(JSDHashTable *table, JSDHashEntryHdr *entry)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __stosd((unsigned long*)entry, 0, table->entrySize >> 2);
+    } else {
+        memset(entry, 0, table->entrySize);
+    }
+#else
     memset(entry, 0, table->entrySize);
+#endif
 }
 
 JS_PUBLIC_API(void)
 JS_DHashFreeStringKey(JSDHashTable *table, JSDHashEntryHdr *entry)
 {
     const JSDHashEntryStub *stub = (const JSDHashEntryStub *)entry;
 
     UnwantedForeground::free_((void *) stub->key);
@@ -529,17 +548,39 @@ ChangeTable(JSDHashTable *table, int del
 #ifdef DEBUG
     recursionLevel = RECURSION_LEVEL(table);
 #endif
     table->hashShift = JS_DHASH_BITS - newLog2;
     table->removedCount = 0;
     table->generation++;
 
     /* Assign the new entry store to table. */
+#ifdef TT_MEMUTIL
+    {
+        static JSBool initialized = JS_FALSE;
+        static uint32_t dwNonTemporalDataSizeMin = NON_TEMPORAL_STORES_NOT_SUPPORTED;
+
+        if (!initialized) {
+            dwNonTemporalDataSizeMin = GetNonTemporalDataSizeMin_tt();
+            initialized = JS_TRUE;
+        }
+
+        if (nbytes < dwNonTemporalDataSizeMin ||
+            NON_TEMPORAL_STORES_NOT_SUPPORTED == dwNonTemporalDataSizeMin)
+        {
+            memset(newEntryStore, 0, nbytes);
+        }
+        else
+        {
+            memset_nontemporal_tt(newEntryStore, 0, nbytes);
+        }
+    }
+#else
     memset(newEntryStore, 0, nbytes);
+#endif
     oldEntryAddr = oldEntryStore = table->entryStore;
     table->entryStore = newEntryStore;
     moveEntry = table->ops->moveEntry;
 #ifdef DEBUG
     RECURSION_LEVEL(table) = recursionLevel;
 #endif
 
     /* Copy only live entries, leaving removed ones behind. */

diff --git a/js/src/jsiter.cpp b/js/src/jsiter.cpp
--- a/js/src/jsiter.cpp
+++ b/js/src/jsiter.cpp
@@ -350,17 +350,17 @@ size_t sCustomIteratorCount = 0;
 
 static inline bool
 GetCustomIterator(JSContext *cx, HandleObject obj, unsigned flags, MutableHandleValue vp)
 {
     JS_CHECK_RECURSION(cx, return false);
 
     /* Check whether we have a valid __iterator__ method. */
     RootedPropertyName name(cx, cx->runtime->atomState.iteratorIntrinsicAtom);
-    if (!GetMethod(cx, obj, name, 0, vp))
+    if (!GetMethod(cx, obj, (PropertyName *)name, 0, vp))
         return false;
 
     /* If there is no custom __iterator__ method, we are done here. */
     if (!vp.isObject()) {
         vp.setUndefined();
         return true;
     }
 

diff --git a/js/src/jsmath.cpp b/js/src/jsmath.cpp
--- a/js/src/jsmath.cpp
+++ b/js/src/jsmath.cpp
@@ -22,16 +22,30 @@
 #include "jsmath.h"
 #include "jsnum.h"
 #include "jslibmath.h"
 #include "jscompartment.h"
 
 #include "jsinferinlines.h"
 #include "jsobjinlines.h"
 
+#if defined JS_CPU_X86 || defined JS_CPU_X64
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+#else  /* _MSC_VER == 1400 */
+#include <smmintrin.h>
+#endif /* _MSC_VER == 1400 */
+#endif /* defined JS_CPU_X86 || defined JS_CPU_X64 */
+
+# include "assembler/assembler/MacroAssembler.h"
+
+#if (_M_IX86_FP >= 2)
+#pragma function(floor)
+#endif
+
 using namespace js;
 
 #ifndef M_E
 #define M_E             2.7182818284590452354
 #endif
 #ifndef M_LOG2E
 #define M_LOG2E         1.4426950408889634074
 #endif
@@ -216,23 +230,52 @@ math_atan2(JSContext *cx, unsigned argc,
     }
     if (!ToNumber(cx, vp[2], &x) || !ToNumber(cx, vp[3], &y))
         return JS_FALSE;
     z = math_atan2_kernel(x, y);
     vp->setDouble(z);
     return JS_TRUE;
 }
 
-double
+JS_ALWAYS_INLINE double
 js_math_ceil_impl(double x)
 {
 #ifdef __APPLE__
     if (x < 0 && x > -1.0)
         return js_copysign(0, -1);
 #endif
+
+#if defined JS_CPU_X86 || defined JS_CPU_X64
+    if (JSC::MacroAssemblerX86Common::getSSEState() >=
+        JSC::MacroAssemblerX86Common::HasSSE4_1) {
+#if _MSC_VER != 1400
+        __m128d xd = _mm_load_sd(&x);
+        double d;
+
+        xd = _mm_ceil_sd(xd, xd);
+        _mm_store_sd(&d, xd);
+        return d;
+#elif defined JS_CPU_X86
+        double d;
+
+        __asm {
+            movsd       xmm0, x
+            /* roundsd  xmm0, xmm0, 2 */
+            __asm _emit 0x66
+            __asm _emit 0x0F
+            __asm _emit 0x3A
+            __asm _emit 0x0B
+            __asm _emit 0xC0
+            __asm _emit 0x02
+            movsd       d, xmm0
+        }
+        return d;
+#endif
+    }
+#endif /* defined JS_CPU_X86 || defined JS_CPU_X64 */
     return ceil(x);
 }
 
 JSBool
 js_math_ceil(JSContext *cx, unsigned argc, Value *vp)
 {
     double x, z;
 
@@ -294,19 +337,47 @@ math_exp(JSContext *cx, unsigned argc, V
     MathCache *mathCache = cx->runtime->getMathCache(cx);
     if (!mathCache)
         return JS_FALSE;
     z = mathCache->lookup(math_exp_body, x);
     vp->setNumber(z);
     return JS_TRUE;
 }
 
-double
+JS_ALWAYS_INLINE double
 js_math_floor_impl(double x)
 {
+#if defined JS_CPU_X86 || defined JS_CPU_X64
+    if (JSC::MacroAssemblerX86Common::getSSEState() >=
+        JSC::MacroAssemblerX86Common::HasSSE4_1) {
+#if _MSC_VER != 1400
+        __m128d xd = _mm_load_sd(&x);
+        double d;
+
+        xd = _mm_floor_sd(xd, xd);
+        _mm_store_sd(&d, xd);
+        return d;
+#elif defined JS_CPU_X86
+        double d;
+
+        __asm {
+            movsd       xmm0, x
+            /* roundsd  xmm0, xmm0, 1 */
+            __asm _emit 0x66
+            __asm _emit 0x0F
+            __asm _emit 0x3A
+            __asm _emit 0x0B
+            __asm _emit 0xC0
+            __asm _emit 0x01
+            movsd       d, xmm0
+        }
+        return d;
+#endif
+    }
+#endif /* defined JS_CPU_X86 || defined JS_CPU_X64 */
     return floor(x);
 }
 
 JSBool
 js_math_floor(JSContext *cx, unsigned argc, Value *vp)
 {
     double x, z;
 
@@ -533,16 +604,71 @@ random_nextDouble(JSContext *cx)
 static JSBool
 math_random(JSContext *cx, unsigned argc, Value *vp)
 {
     double z = random_nextDouble(cx);
     vp->setDouble(z);
     return JS_TRUE;
 }
 
+#if defined JS_CPU_X86 && _MSC_VER
+static const double  dbhalf =  0.5;
+__declspec(align(16)) static const __int64 mask_sign[2] = { 0x8000000000000000 };
+#endif
+
+JS_ALWAYS_INLINE double
+js_math_round_impl(double x)
+{
+#if defined JS_CPU_X86 || defined JS_CPU_X64
+    if (JSC::MacroAssemblerX86Common::getSSEState() >=
+        JSC::MacroAssemblerX86Common::HasSSE4_1) {
+#if _MSC_VER != 1400
+        __m128d xmm1d = _mm_load_sd(&x);
+        __m128d xmm0d = xmm1d;
+        double d;
+
+        xmm0d = _mm_add_sd(xmm0d, *(__m128d *)&dbhalf);
+        xmm0d = _mm_floor_sd(xmm0d, xmm0d);
+
+        __m128i xmm2i = _mm_load_si128((__m128i *)mask_sign);
+        __m128i xmm1i = _mm_castpd_si128(xmm1d);
+
+        xmm1i = _mm_and_si128(xmm1i, xmm2i);
+        xmm2i = _mm_andnot_si128(xmm2i, _mm_castpd_si128(xmm0d));
+        xmm1i = _mm_or_si128(xmm1i, xmm2i);
+
+        _mm_store_sd(&d, _mm_castsi128_pd(xmm1i));
+        return d;
+#elif defined JS_CPU_X86
+        double d;
+
+        __asm {
+            movsd       xmm1, x
+            movdqa      xmm2, mask_sign
+            movaps      xmm0, xmm1
+            addsd       xmm0, dbhalf
+            pand        xmm1, xmm2
+            /* roundsd  xmm0, xmm0, 1 */
+            __asm _emit 0x66
+            __asm _emit 0x0F
+            __asm _emit 0x3A
+            __asm _emit 0x0B
+            __asm _emit 0xC0
+            __asm _emit 0x01
+            pandn       xmm2, xmm0
+            por         xmm1, xmm2
+            movsd       d, xmm1
+        }
+        return d;
+#endif
+    }
+#endif /* defined JS_CPU_X86 || defined JS_CPU_X64 */
+    return js_copysign(js_math_floor_impl(x + 0.5), x);
+}
+
 JSBool /* ES5 15.8.2.15. */
 js_math_round(JSContext *cx, unsigned argc, Value *vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
 
     if (args.length() == 0) {
         args.rval().setDouble(js_NaN);
         return true;
@@ -559,17 +685,17 @@ js_math_round(JSContext *cx, unsigned ar
     }
 
     /* Some numbers are so big that adding 0.5 would give the wrong number */
     if (MOZ_DOUBLE_EXPONENT(x) >= 52) {
         args.rval().setNumber(x);
         return true;
     }
 
-    args.rval().setNumber(js_copysign(floor(x + 0.5), x));
+    args.rval().setNumber(js_math_round_impl(x));
     return true;
 }
 
 static JSBool
 math_sin(JSContext *cx, unsigned argc, Value *vp)
 {
     double x, z;
 

diff --git a/js/src/jsobj.cpp b/js/src/jsobj.cpp
--- a/js/src/jsobj.cpp
+++ b/js/src/jsobj.cpp
@@ -4458,17 +4458,17 @@ js_NativeGetInline(JSContext *cx, Handle
     Rooted<Shape*> shapeRoot(cx, shape);
     RootedObject pobjRoot(cx, pobj);
     RootedValue nvp(cx, *vp);
 
     if (!shape->get(cx, receiver, obj, pobj, &nvp))
         return false;
 
     /* Update slotful shapes according to the value produced by the getter. */
-    if (shapeRoot->hasSlot() && pobjRoot->nativeContains(cx, shapeRoot))
+    if (shapeRoot->hasSlot() && pobjRoot->nativeContains(cx, (HandleShape)shapeRoot))
         pobjRoot->nativeSetSlot(shapeRoot->slot(), nvp);
 
     *vp = nvp;
     return true;
 }
 
 JSBool
 js_NativeGet(JSContext *cx, Handle<JSObject*> obj, Handle<JSObject*> pobj, Shape *shape,
@@ -4511,17 +4511,17 @@ js_NativeSet(JSContext *cx, Handle<JSObj
         return false;
 
     /*
      * Update any slot for the shape with the value produced by the setter,
      * unless the setter deleted the shape.
      */
     if (shapeRoot->hasSlot() &&
         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
-         obj->nativeContains(cx, shapeRoot))) {
+         obj->nativeContains(cx, (HandleShape)shapeRoot))) {
         AddTypePropertyId(cx, obj, shape->propid(), *vp);
         obj->setSlot(shapeRoot->slot(), nvp);
     }
 
     *vp = nvp;
     return true;
 }
 

diff --git a/js/src/jsobjinlines.h b/js/src/jsobjinlines.h
--- a/js/src/jsobjinlines.h
+++ b/js/src/jsobjinlines.h
@@ -3,16 +3,20 @@
  *
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef jsobjinlines_h___
 #define jsobjinlines_h___
 
+#if (_M_IX86_FP >= 2) || defined(__SSE2__) || defined(_M_AMD64) || defined(__amd64__)
+#include <emmintrin.h>
+#endif
+
 #include <new>
 
 #include "jsapi.h"
 #include "jsarray.h"
 #include "jsbool.h"
 #include "jscntxt.h"
 #include "jsfun.h"
 #include "jsiter.h"
@@ -1355,17 +1359,35 @@ class AutoPropertyDescriptorRooter : pri
     }
 
     friend void AutoGCRooter::trace(JSTracer *trc);
 };
 
 inline void
 NewObjectCache::copyCachedToObject(JSObject *dst, JSObject *src)
 {
+#if (_M_IX86_FP >= 2) || defined(__SSE2__) || defined(_M_AMD64) || defined(__amd64__)
+    if ((dst->sizeOfThis() & 15) == 0 &&
+        ((unsigned)dst & 15) == 0) {
+        char *s = (char *)src;
+        char *d = (char *)dst;
+        int count = (dst->sizeOfThis() >> 4);
+
+        for (int i = 0; i < count; i++) {
+            _mm_store_si128((__m128i *)d, _mm_loadu_si128((__m128i const*)s));
+            s += 16;
+            d += 16;
+        }
+    } else {
+        js_memcpy(dst, src, dst->sizeOfThis());
+    }
+#else
     js_memcpy(dst, src, dst->sizeOfThis());
+#endif
+
 #ifdef JSGC_GENERATIONAL
     Shape::writeBarrierPost(dst->shape_, &dst->shape_);
     types::TypeObject::writeBarrierPost(dst->type_, &dst->type_);
 #endif
 }
 
 static inline bool
 CanBeFinalizedInBackground(gc::AllocKind kind, Class *clasp)

diff -r 6a3897dad583 gfx/cairo/libpixman/src/Makefile.in
--- a/gfx/cairo/libpixman/src/Makefile.in	Sat Oct 06 15:30:41 2012 +0900
+++ b/gfx/cairo/libpixman/src/Makefile.in	Sat Oct 06 15:47:11 2012 +0900
@@ -21,17 +21,18 @@ DEFINES += -DPIXMAN_NO_TLS
 
 # Build MMX code either with VC or with gcc-on-x86
 ifdef _MSC_VER
 ifeq (86,$(findstring 86,$(OS_TEST)))
 ifneq (64,$(findstring 64,$(OS_TEST)))
 USE_MMX=1
 endif
 USE_SSE2=1
-MMX_CFLAGS=
+# avoid the bug of PGO
+MMX_CFLAGS=-GL-
 ifneq (,$(filter 1400 1500, $(_MSC_VER)))
 # MSVC 2005 and 2008 generate code that breaks alignment
 # restrictions in debug mode so always optimize.
 # See bug 640250 for more info.
 SSE2_CFLAGS=-O2
 else
 SSE2_CFLAGS=
 endif
@@ -145,14 +146,27 @@ include $(topsrcdir)/config/rules.mk
 
 CFLAGS += -DPACKAGE="mozpixman" -D_USE_MATH_DEFINES
 
 # Disable spammy "missing initializer" GCC warning
 ifdef GNU_CC
 CFLAGS += -Wno-missing-field-initializers
 endif # GNU_CC
 
+ifdef _MSC_VER
+ifneq (,$(filter -DTT_MEMUTIL,$(MOZ_OPTIMIZE_FLAGS)))
+OPENMP_FLAGS_TT = -GL- -openmp
+else
+OPENMP_FLAGS_TT =
+endif
+pixman-cpu.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(OPENMP_FLAGS_TT)
+
+pixman-general.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(OPENMP_FLAGS_TT)
+
+pixman-trap.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(OPENMP_FLAGS_TT)
+endif
+
 # special rule for pixman-mmx to get the right cflags
 pixman-mmx.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(MMX_CFLAGS)
 
-pixman-sse2.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(SSE2_CFLAGS)
+pixman-sse2.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(SSE2_CFLAGS) $(OPENMP_FLAGS_TT)
 
 pixman-arm-neon.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(ARM_NEON_CFLAGS)

diff -r 6a3897dad583 mozglue/build/mozglue.def.in
--- a/mozglue/build/mozglue.def.in	Sat Oct 06 15:30:41 2012 +0900
+++ b/mozglue/build/mozglue.def.in	Sat Oct 06 16:20:09 2012 +0900
@@ -21,9 +21,12 @@ EXPORTS
 #ifdef MOZ_JEMALLOC
   je_nallocm
 #else
   je_malloc_good_size
 #endif
   jemalloc_stats
   ; A hack to work around the CRT (see giant comment in Makefile.in)
   frex=je_dumb_free_thunk
+
+  floor=floor_tt
+  ceil=ceil_tt
 #endif

diff --git a/netwerk/base/src/Makefile.in b/netwerk/base/src/Makefile.in
--- a/netwerk/base/src/Makefile.in
+++ b/netwerk/base/src/Makefile.in
@@ -118,8 +118,15 @@ ifeq ($(OS_TARGET),Android)
 nsURLParsers.$(OBJ_SUFFIX): MOZ_OPTIMIZE_FLAGS=
 endif
 
 DEFINES += -DIMPL_NS_NET
 
 ifdef MOZ_ENABLE_LIBCONIC
 	OS_INCLUDES += $(GLIB_CFLAGS) $(LIBCONIC_CFLAGS)
 endif
+
+ifdef MOZ_THUNDERBIRD
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# avoid the fatal error C1001 of compiler when applying PGO to Thunderbird
+COMPILE_CXXFLAGS += -GL-
+endif
+endif

diff --git a/content/media/nsAudioStream.cpp b/content/media/nsAudioStream.cpp
--- a/content/media/nsAudioStream.cpp
+++ b/content/media/nsAudioStream.cpp
@@ -5,16 +5,20 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/dom/PAudioChild.h"
 #include "mozilla/dom/AudioChild.h"
 #include "nsXULAppAPI.h"
 using namespace mozilla::dom;
 
+#if (_M_IX86_FP >= 1) || defined(__SSE__)
+#include <xmmintrin.h>
+#include "mozilla/Util.h"
+#endif
 #include <stdio.h>
 #include <math.h>
 #include "prlog.h"
 #include "prmem.h"
 #include "prdtoa.h"
 #include "nsAutoPtr.h"
 #include "nsAudioStream.h"
 #include "nsAlgorithm.h"
@@ -481,28 +485,79 @@ nsresult nsNativeAudioStream::Write(cons
       short s = buf[i];
 #if defined(IS_BIG_ENDIAN)
       s = ((s & 0x00ff) << 8) | ((s & 0xff00) >> 8);
 #endif
       s_data[i] = short((int32_t(s) * volume) >> 16);
     }
 #else /* MOZ_SAMPLE_TYPE_FLOAT32 */
     const SampleType* buf = static_cast<const SampleType*>(aBuf);
+#if (_M_IX86_FP >= 1) || defined(__SSE__)
+    static const __m128 sMin = _mm_set_ps1(-32768.0);
+    static const __m128 sMax = _mm_set_ps1(32767.0);
+    const __m128 xmmMin = sMin;
+    const __m128 xmmMax = sMax;
+    float* b = (float*)buf;
+    const __m128 xmmMul = _mm_set_ps1((float)(32768 * scaled_volume));
+    __m128 xmmTmp = _mm_setzero_ps();
+    uint32_t i = 0;
+    uint32_t n = samples;
+    MOZ_ALIGNED_DECL(int32_t r_dest[4], 16);
+
+    while (n >= 1 && ((unsigned long)b & 15)) {
+      __m128 scaled_value = _mm_mul_ss(xmmMul, _mm_load_ss(b));
+      scaled_value = _mm_max_ss(scaled_value, xmmMin);
+      scaled_value = _mm_min_ss(scaled_value, xmmMax);
+      s_data[i] = (short)_mm_cvtss_si32(scaled_value);
+
+      b++;
+      i++;
+      n--;
+    }
+
+    while (n >= 4) {
+      __m128 scaled_value = _mm_mul_ps(xmmMul, _mm_load_ps(b));
+      scaled_value = _mm_max_ps(scaled_value, xmmMin);
+      scaled_value = _mm_min_ps(scaled_value, xmmMax);
+      *((__m64*)&r_dest[0]) = _mm_cvtps_pi32(scaled_value);
+      *((__m64*)&r_dest[2]) = _mm_cvtps_pi32(_mm_movehl_ps(xmmTmp, scaled_value));
+      s_data[i++] = r_dest[0];
+      s_data[i++] = r_dest[1];
+      s_data[i++] = r_dest[2];
+      s_data[i++] = r_dest[3];
+
+      b += 4;
+      n -= 4;
+    }
+    _mm_empty();
+
+    while (n >= 1) {
+      __m128 scaled_value = _mm_mul_ss(xmmMul, _mm_load_ss(b));
+      scaled_value = _mm_max_ss(scaled_value, xmmMin);
+      scaled_value = _mm_min_ss(scaled_value, xmmMax);
+      s_data[i] = (short)_mm_cvtss_si32(scaled_value);
+
+      b++;
+      i++;
+      n--;
+    }
+#else // (_M_IX86_FP >= 1) || defined(__SSE__)
     for (uint32_t i = 0; i <  samples; ++i) {
       float scaled_value = floorf(0.5 + 32768 * buf[i] * scaled_volume);
       if (buf[i] < 0.0) {
         s_data[i] = (scaled_value < -32768.0) ?
           -32768 :
           short(scaled_value);
       } else {
         s_data[i] = (scaled_value > 32767.0) ?
           32767 :
           short(scaled_value);
       }
     }
+#endif // (_M_IX86_FP >= 1) || defined(__SSE__)
 #endif
   }
 
   if (sa_stream_write(static_cast<sa_stream_t*>(mAudioHandle),
                       s_data.get(),
                       samples * sizeof(short)) != SA_SUCCESS)
   {
     PR_LOG(gAudioStreamLog, PR_LOG_ERROR, ("nsNativeAudioStream: sa_stream_write error"));


diff --git a/content/canvas/src/nsCanvasRenderingContext2D.cpp b/content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp
@@ -3988,37 +3988,18 @@ nsCanvasRenderingContext2D::GetImageData
     // make sure sUnpremultiplyTable has been created
     EnsureUnpremultiplyTable();
 
     // NOTE! dst is the same as src, and this relies on reading
     // from src and advancing that ptr before writing to dst.
     uint8_t *src = data;
     uint8_t *dst = data;
 
-    for (uint32_t j = 0; j < aHeight; ++j) {
-        for (uint32_t i = 0; i < aWidth; ++i) {
-            // XXX Is there some useful swizzle MMX we can use here?
-#ifdef IS_LITTLE_ENDIAN
-            uint8_t b = *src++;
-            uint8_t g = *src++;
-            uint8_t r = *src++;
-            uint8_t a = *src++;
-#else
-            uint8_t a = *src++;
-            uint8_t r = *src++;
-            uint8_t g = *src++;
-            uint8_t b = *src++;
-#endif
-            // Convert to non-premultiplied color
-            *dst++ = sUnpremultiplyTable[a][r];
-            *dst++ = sUnpremultiplyTable[a][g];
-            *dst++ = sUnpremultiplyTable[a][b];
-            *dst++ = a;
-        }
-    }
+    GetImageData_component(src, dst, aWidth, aHeight,
+      aWidth * 4, aWidth * 4, sUnpremultiplyTable);
 
     *aRetval = darray;
     return NS_OK;
 }
 
 void
 nsCanvasRenderingContext2D::EnsurePremultiplyTable() {
   if (sPremultiplyTable)
@@ -4152,47 +4133,29 @@ nsCanvasRenderingContext2D::PutImageData
     if (dirtyRect.Width() <= 0 || dirtyRect.Height() <= 0)
         return NS_OK;
 
     uint32_t len = w * h * 4;
     if (aDataLen != len)
         return NS_ERROR_DOM_SYNTAX_ERR;
 
     nsRefPtr<gfxImageSurface> imgsurf = new gfxImageSurface(gfxIntSize(w, h),
-                                                            gfxASurface::ImageFormatARGB32);
+                                                            gfxASurface::ImageFormatARGB32,
+                                                            false);
     if (!imgsurf || imgsurf->CairoStatus())
         return NS_ERROR_FAILURE;
 
     // ensure premultiply table has been created
     EnsurePremultiplyTable();
 
     uint8_t *src = aData;
     uint8_t *dst = imgsurf->Data();
 
-    for (uint32_t j = 0; j < h; j++) {
-        for (uint32_t i = 0; i < w; i++) {
-            uint8_t r = *src++;
-            uint8_t g = *src++;
-            uint8_t b = *src++;
-            uint8_t a = *src++;
-
-            // Convert to premultiplied color (losslessly if the input came from getImageData)
-#ifdef IS_LITTLE_ENDIAN
-            *dst++ = sPremultiplyTable[a][b];
-            *dst++ = sPremultiplyTable[a][g];
-            *dst++ = sPremultiplyTable[a][r];
-            *dst++ = a;
-#else
-            *dst++ = a;
-            *dst++ = sPremultiplyTable[a][r];
-            *dst++ = sPremultiplyTable[a][g];
-            *dst++ = sPremultiplyTable[a][b];
-#endif
-        }
-    }
+    PutImageData_component(src, dst, w, h,
+                           w * 4, w * 4, sPremultiplyTable);
 
     PathAutoSaveRestore pathSR(this);
     gfxContextAutoSaveRestore autoSR(mThebes);
 
     // ignore clipping region, as per spec
     mThebes->ResetClip();
 
     mThebes->IdentityMatrix();

diff --git a/content/canvas/src/nsCanvasRenderingContext2DAzure.cpp b/content/canvas/src/nsCanvasRenderingContext2DAzure.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2DAzure.cpp
+++ b/content/canvas/src/nsCanvasRenderingContext2DAzure.cpp
@@ -4276,39 +4276,18 @@ nsCanvasRenderingContext2DAzure::GetImag
   EnsureUnpremultiplyTable();
 
   // NOTE! dst is the same as src, and this relies on reading
   // from src and advancing that ptr before writing to dst.
   // NOTE! I'm not sure that it is, I think this comment might have been
   // inherited from Thebes canvas and is no longer true
   uint8_t* dst = data + dstWriteRect.y * (aWidth * 4) + dstWriteRect.x * 4;
 
-  for (int32_t j = 0; j < dstWriteRect.height; ++j) {
-    for (int32_t i = 0; i < dstWriteRect.width; ++i) {
-      // XXX Is there some useful swizzle MMX we can use here?
-#ifdef IS_LITTLE_ENDIAN
-      uint8_t b = *src++;
-      uint8_t g = *src++;
-      uint8_t r = *src++;
-      uint8_t a = *src++;
-#else
-      uint8_t a = *src++;
-      uint8_t r = *src++;
-      uint8_t g = *src++;
-      uint8_t b = *src++;
-#endif
-      // Convert to non-premultiplied color
-      *dst++ = sUnpremultiplyTable[a][r];
-      *dst++ = sUnpremultiplyTable[a][g];
-      *dst++ = sUnpremultiplyTable[a][b];
-      *dst++ = a;
-    }
-    src += srcStride - (dstWriteRect.width * 4);
-    dst += (aWidth * 4) - (dstWriteRect.width * 4);
-  }
+  GetImageData_component(src, dst, dstWriteRect.width, dstWriteRect.height,
+                         srcStride, aWidth * 4, sUnpremultiplyTable);
 
   *aRetval = darray;
   return NS_OK;
 }
 
 void
 nsCanvasRenderingContext2DAzure::EnsurePremultiplyTable() {
   if (sPremultiplyTable)
@@ -4450,48 +4429,30 @@ nsCanvasRenderingContext2DAzure::PutImag
   }
 
   uint32_t len = w * h * 4;
   if (aDataLen != len) {
     return NS_ERROR_DOM_SYNTAX_ERR;
   }
 
   nsRefPtr<gfxImageSurface> imgsurf = new gfxImageSurface(gfxIntSize(w, h),
-                                                          gfxASurface::ImageFormatARGB32);
+                                                          gfxASurface::ImageFormatARGB32,
+                                                          false);
   if (!imgsurf || imgsurf->CairoStatus()) {
     return NS_ERROR_FAILURE;
   }
 
   // ensure premultiply table has been created
   EnsurePremultiplyTable();
 
   uint8_t *src = aData;
   uint8_t *dst = imgsurf->Data();
 
-  for (uint32_t j = 0; j < h; j++) {
-    for (uint32_t i = 0; i < w; i++) {
-      uint8_t r = *src++;
-      uint8_t g = *src++;
-      uint8_t b = *src++;
-      uint8_t a = *src++;
-
-      // Convert to premultiplied color (losslessly if the input came from getImageData)
-#ifdef IS_LITTLE_ENDIAN
-      *dst++ = sPremultiplyTable[a][b];
-      *dst++ = sPremultiplyTable[a][g];
-      *dst++ = sPremultiplyTable[a][r];
-      *dst++ = a;
-#else
-      *dst++ = a;
-      *dst++ = sPremultiplyTable[a][r];
-      *dst++ = sPremultiplyTable[a][g];
-      *dst++ = sPremultiplyTable[a][b];
-#endif
-    }
-  }
+  PutImageData_component(src, dst, w, h,
+                         w * 4, w * 4, sPremultiplyTable);
 
   RefPtr<SourceSurface> sourceSurface =
     mTarget->CreateSourceSurfaceFromData(imgsurf->Data(), IntSize(w, h), imgsurf->Stride(), FORMAT_B8G8R8A8);
 
 
   mTarget->CopySurface(sourceSurface,
                        IntRect(dirtyRect.x - x, dirtyRect.y - y,
                                dirtyRect.width, dirtyRect.height),

diff -r 284837bbf631 xpcom/string/public/nsCharTraits.h
--- a/xpcom/string/public/nsCharTraits.h	Sat Aug 25 07:23:12 2012 +0900
+++ b/xpcom/string/public/nsCharTraits.h	Sat Aug 25 09:42:32 2012 +0900
@@ -177,16 +177,20 @@ struct nsCharTraits<PRUnichar>
       {
         return static_cast<char_type*>(memmove(s1, s2, n * sizeof(char_type)));
       }
 
     static
     char_type*
     copy( char_type* s1, const char_type* s2, size_t n )
       {
+        if (1 == n) {
+          *s1 = *s2;
+          return s1;
+        }
         return static_cast<char_type*>(memcpy(s1, s2, n * sizeof(char_type)));
       }
 
     static
     char_type*
     copyASCII( char_type* s1, const char* s2, size_t n )
       {
         for (char_type* s = s1; n--; ++s, ++s2) {

diff --git a/layout/generic/nsContainerFrame.cpp b/layout/generic/nsContainerFrame.cpp
--- a/layout/generic/nsContainerFrame.cpp
+++ b/layout/generic/nsContainerFrame.cpp
@@ -235,16 +235,20 @@ nsContainerFrame::DestroyFrom(nsIFrame* 
 
   // Destroy the frame and remove the flow pointers
   nsSplittableFrame::DestroyFrom(aDestructRoot);
 }
 
 /////////////////////////////////////////////////////////////////////////////
 // Child frame enumeration
 
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
+
 const nsFrameList&
 nsContainerFrame::GetChildList(ChildListID aListID) const
 {
   // We only know about the principal child list and the overflow lists.
   switch (aListID) {
     case kPrincipalList:
       return mFrames;
     case kOverflowList: {
@@ -261,16 +265,20 @@ nsContainerFrame::GetChildList(ChildList
         GetPropTableFrames(PresContext(), ExcessOverflowContainersProperty());
       return list ? *list : nsFrameList::EmptyList();
     }
     default:
       return nsSplittableFrame::GetChildList(aListID);
   }
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
+
 static void AppendIfNonempty(const nsIFrame* aFrame,
                             FramePropertyTable* aPropTable,
                             const FramePropertyDescriptor* aProperty,
                             nsTArray<nsIFrame::ChildList>* aLists,
                             nsIFrame::ChildListID aListID)
 {
   nsFrameList* list = static_cast<nsFrameList*>(
     aPropTable->Get(aFrame, aProperty));

diff --git a/content/base/src/nsContentUtils.cpp b/content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp
+++ b/content/base/src/nsContentUtils.cpp
@@ -3261,29 +3261,37 @@ nsContentUtils::ReportToConsole(uint32_t
                                      aLineNumber, aColumnNumber,
                                      aErrorFlags, aCategory,
                                      innerWindowID);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return sConsoleService->LogMessage(errorObject);
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
+
 bool
 nsContentUtils::IsChromeDoc(nsIDocument *aDocument)
 {
   if (!aDocument) {
     return false;
   }
   
   nsCOMPtr<nsIPrincipal> systemPrincipal;
   sSecurityManager->GetSystemPrincipal(getter_AddRefs(systemPrincipal));
 
   return aDocument->NodePrincipal() == systemPrincipal;
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
+
 bool
 nsContentUtils::IsChildOfSameType(nsIDocument* aDoc)
 {
   nsCOMPtr<nsISupports> container = aDoc->GetContainer();
   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(container));
   nsCOMPtr<nsIDocShellTreeItem> sameTypeParent;
   if (docShellAsItem) {
     docShellAsItem->GetSameTypeParent(getter_AddRefs(sameTypeParent));
@@ -3536,45 +3544,57 @@ nsContentUtils::DispatchChromeEvent(nsID
   rv = piTarget->DispatchDOMEvent(nullptr, event, nullptr, &status);
   if (aDefaultAction) {
     *aDefaultAction = (status != nsEventStatus_eConsumeNoDefault);
   }
   return rv;
 }
 
 /* static */
+#ifdef _MSC_VER
+#pragma inline_recursion(on)
+#endif
 Element*
 nsContentUtils::MatchElementId(nsIContent *aContent, const nsIAtom* aId)
 {
   for (nsIContent* cur = aContent;
        cur;
        cur = cur->GetNextNode(aContent)) {
     if (aId == cur->GetID()) {
       return cur->AsElement();
     }
   }
 
   return nullptr;
 }
+#ifdef _MSC_VER
+#pragma inline_recursion(off)
+#endif
 
 /* static */
+#ifdef _MSC_VER
+#pragma inline_recursion(on)
+#endif
 Element *
 nsContentUtils::MatchElementId(nsIContent *aContent, const nsAString& aId)
 {
   NS_PRECONDITION(!aId.IsEmpty(), "Will match random elements");
   
   // ID attrs are generally stored as atoms, so just atomize this up front
   nsCOMPtr<nsIAtom> id(do_GetAtom(aId));
   if (!id) {
     // OOM, so just bail
     return nullptr;
   }
 
   return MatchElementId(aContent, id);
 }
+#ifdef _MSC_VER
+#pragma inline_recursion(off)
+#endif
 
 // Convert the string from the given charset to Unicode.
 /* static */
 nsresult
 nsContentUtils::ConvertStringFromCharset(const nsACString& aCharset,
                                          const nsACString& aInput,
                                          nsAString& aOutput)
 {

diff --git a/layout/style/nsCSSDataBlock.cpp b/layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp
+++ b/layout/style/nsCSSDataBlock.cpp
@@ -349,16 +349,20 @@ nsCSSExpandedDataBlock::ComputeNumProps(
             if (mPropertiesImportant.HasPropertyAt(iHigh, iLow))
                 (*aNumPropsImportant)++;
             else
                 (*aNumPropsNormal)++;
         }
     }
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
+
 void
 nsCSSExpandedDataBlock::Compress(nsCSSCompressedDataBlock **aNormalBlock,
                                  nsCSSCompressedDataBlock **aImportantBlock)
 {
     nsAutoPtr<nsCSSCompressedDataBlock> result_normal, result_important;
     uint32_t i_normal = 0, i_important = 0;
 
     uint32_t numPropsNormal, numPropsImportant;
@@ -411,16 +415,20 @@ nsCSSExpandedDataBlock::Compress(nsCSSCo
     }
 
     ClearSets();
     AssertInitialState();
     *aNormalBlock = result_normal.forget();
     *aImportantBlock = result_important.forget();
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
+
 void
 nsCSSExpandedDataBlock::AddLonghandProperty(nsCSSProperty aProperty,
                                             const nsCSSValue& aValue)
 {
     NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
                       "property out of range");
     nsCSSValue& storage = *static_cast<nsCSSValue*>(PropertyAt(aProperty));
     storage = aValue;

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1566,17 +1566,24 @@ MOZ_STATIC_ASSERT(NS_ARRAY_LENGTH(sPseud
                   "ePseudoClass_NotPseudoClass is no longer at the end of"
                   "sPseudoClassStates");
 
 // |aDependence| has two functions:
 //  * when non-null, it indicates that we're processing a negation,
 //    which is done only when SelectorMatches calls itself recursively
 //  * what it points to should be set to true whenever a test is skipped
 //    because of aNodeMatchContent.mStateMask
-static bool SelectorMatches(Element* aElement,
+bool SelectorMatchesComponent(Element* aElement,
+                              nsCSSSelector* aSelector,
+                              NodeMatchContext& aNodeMatchContext,
+                              TreeMatchContext& aTreeMatchContext,
+                              bool* const aDependence);
+
+inline
+bool SelectorMatches(Element* aElement,
                               nsCSSSelector* aSelector,
                               NodeMatchContext& aNodeMatchContext,
                               TreeMatchContext& aTreeMatchContext,
                               bool* const aDependence = nullptr)
 
 {
   NS_PRECONDITION(!aSelector->IsPseudoElement(),
                   "Pseudo-element snuck into SelectorMatches?");
@@ -1596,16 +1603,29 @@ static bool SelectorMatches(Element* aEl
     nsIAtom* selectorTag =
       (aTreeMatchContext.mIsHTMLDocument && aElement->IsHTML()) ?
         aSelector->mLowercaseTag : aSelector->mCasedTag;
     if (selectorTag != aElement->Tag()) {
       return false;
     }
   }
 
+  return SelectorMatchesComponent(aElement,
+                                  aSelector,
+                                  aNodeMatchContext,
+                                  aTreeMatchContext,
+                                  aDependence);
+}
+
+static bool SelectorMatchesComponent(Element* aElement,
+                                       nsCSSSelector* aSelector,
+                                       NodeMatchContext& aNodeMatchContext,
+                                       TreeMatchContext& aTreeMatchContext,
+                                       bool* const aDependence)
+{
   nsAtomList* IDList = aSelector->mIDList;
   if (IDList) {
     nsIAtom* id = aElement->GetID();
     if (id) {
       // case sensitivity: bug 93371
       const bool isCaseSensitive =
         aTreeMatchContext.mCompatMode != eCompatibility_NavQuirks;
 

diff -r 284837bbf631 xpcom/glue/nsDeque.cpp
--- a/xpcom/glue/nsDeque.cpp	Sat Aug 25 07:23:12 2012 +0900
+++ b/xpcom/glue/nsDeque.cpp	Sat Aug 25 09:43:13 2012 +0900
@@ -103,17 +103,32 @@ void nsDeque::SetDeallocator(nsDequeFunc
 
 /**
  * Remove all items from container without destroying them.
  *
  * @return  *this
  */
 nsDeque& nsDeque::Empty() {
   if (mSize && mData) {
+#ifdef TT_MEMUTIL
+    static const PRUint32 dwNonTemporalDataSizeMin = GetNonTemporalDataSizeMin_tt();
+    const PRUint32 dwDataSize = mCapacity*sizeof(mData);
+
+    if (dwDataSize < dwNonTemporalDataSizeMin ||
+        NON_TEMPORAL_STORES_NOT_SUPPORTED == dwNonTemporalDataSizeMin)
+    {
+        memset(mData, 0, mCapacity*sizeof(mData));
+    }
+    else
+    {
+        memset_nontemporal_tt(mData, 0, mCapacity*sizeof(mData));
+    }
+#else
     memset(mData, 0, mCapacity*sizeof(mData));
+#endif
   }
   mSize=0;
   mOrigin=0;
   return *this;
 }
 
 /**
  * Remove and delete all items from container

diff --git a/layout/base/nsDisplayList.cpp b/layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp
+++ b/layout/base/nsDisplayList.cpp
@@ -5,16 +5,21 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
  */
 
 /*
  * structures that represent things to be painted (ordered in z-order),
  * used during painting and hit testing
  */
 
+#if !defined(NS_COORD_IS_FLOAT) && defined(_M_IX86_FP) && _M_IX86_FP >= 2
+#include <mmintrin.h>
+#include <emmintrin.h>
+#endif
+
 #include "mozilla/layers/PLayers.h"
 
 #include "nsDisplayList.h"
 
 #include "nsCSSRendering.h"
 #include "nsRenderingContext.h"
 #include "nsISelectionController.h"
 #include "nsIPresShell.h"
@@ -629,23 +634,39 @@ nsDisplayListBuilder::GetBackgroundPaint
   if (mIsPaintingToWindow) {
     flags |= nsCSSRendering::PAINTBG_TO_WINDOW;
   }
   return flags;
 }
 
 static uint64_t RegionArea(const nsRegion& aRegion)
 {
+#if !defined(NS_COORD_IS_FLOAT) && defined(_M_IX86_FP) && _M_IX86_FP >= 2
+  __m64 area = _mm_setzero_si64();
+#else
   uint64_t area = 0;
+#endif
   nsRegionRectIterator iter(aRegion);
   const nsRect* r;
   while ((r = iter.Next()) != nullptr) {
+#if !defined(NS_COORD_IS_FLOAT) && defined(_M_IX86_FP) && _M_IX86_FP >= 2
+    __m64 mw = *(__m64 *)&r->width;
+    __m64 mh = _mm_srli_si64(mw, 32);
+    area = _mm_add_si64(area, _mm_mul_su32(mw, mh));
+#else
     area += uint64_t(r->width)*r->height;
+#endif
   }
+#if !defined(NS_COORD_IS_FLOAT) && defined(_M_IX86_FP) && _M_IX86_FP >= 2
+  uint64_t tmp;
+  *(__m64 *)&tmp = area;
+  return tmp;
+#else
   return area;
+#endif
 }
 
 void
 nsDisplayListBuilder::SubtractFromVisibleRegion(nsRegion* aVisibleRegion,
                                                 const nsRegion& aRegion)
 {
   if (aRegion.IsEmpty())
     return;
@@ -655,16 +676,19 @@ nsDisplayListBuilder::SubtractFromVisibl
   // Don't let *aVisibleRegion get too complex, but don't let it fluff out
   // to its bounds either, which can be very bad (see bug 516740).
   // Do let aVisibleRegion get more complex if by doing so we reduce its
   // area by at least half.
   if (GetAccurateVisibleRegions() || tmp.GetNumRects() <= 15 ||
       RegionArea(tmp) <= RegionArea(*aVisibleRegion)/2) {
     *aVisibleRegion = tmp;
   }
+#if !defined(NS_COORD_IS_FLOAT) && defined(_M_IX86_FP) && _M_IX86_FP >= 2
+  _m_empty();
+#endif
 }
 
 nsCaret *
 nsDisplayListBuilder::GetCaret() {
   nsRefPtr<nsCaret> caret = CurrentPresShellState()->mPresShell->GetCaret();
   return caret;
 }
 

diff --git a/layout/generic/nsHTMLReflowState.cpp b/layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp
+++ b/layout/generic/nsHTMLReflowState.cpp
@@ -20,16 +20,17 @@
 #include "nsTableFrame.h"
 #include "nsTableCellFrame.h"
 #include "nsIServiceManager.h"
 #include "nsIPercentHeightObserver.h"
 #include "nsLayoutUtils.h"
 #include "mozilla/Preferences.h"
 #include "nsBidiUtils.h"
 #include "nsFontInflationData.h"
+#include "mozilla/Attributes.h"
 
 #ifdef DEBUG
 #undef NOISY_VERTICAL_ALIGN
 #else
 #undef NOISY_VERTICAL_ALIGN
 #endif
 
 using namespace mozilla;
@@ -976,16 +977,17 @@ nsHTMLReflowState::CalculateHorizBorderP
   *aOutsideBoxSizing = outside;
   return;
 }
 
 /**
  * Returns true iff a pre-order traversal of the normal child
  * frames rooted at aFrame finds no non-empty frame before aDescendant.
  */
+MOZ_ALWAYS_INLINE
 static bool AreAllEarlierInFlowFramesEmpty(nsIFrame* aFrame,
   nsIFrame* aDescendant, bool* aFound) {
   if (aFrame == aDescendant) {
     *aFound = true;
     return true;
   }
   if (!aFrame->IsSelfEmpty()) {
     *aFound = false;


diff -r 284837bbf631 image/decoders/icon/win/nsIconChannel.cpp
--- a/image/decoders/icon/win/nsIconChannel.cpp	Sat Aug 25 07:23:12 2012 +0900
+++ b/image/decoders/icon/win/nsIconChannel.cpp	Sat Aug 25 11:13:45 2012 +0900
@@ -445,16 +445,19 @@ static BITMAPINFO* CreateBitmapInfo(BITM
                                                  mozilla::fallible_t());
   if (bmi) {
     memcpy(bmi, aHeader, sizeof(BITMAPINFOHEADER));
     memset(bmi->bmiColors, 0, aColorTableSize);
   }
   return bmi;
 }
 
+#ifdef _MSC_VER
+#pragma function(memcpy)
+#endif
 nsresult nsIconChannel::MakeInputStream(nsIInputStream** _retval, bool nonBlocking)
 {
   // Check whether the icon requested's a file icon or a stock icon
   nsresult rv = NS_ERROR_NOT_AVAILABLE;
 
   // GetDIBits does not exist on windows mobile.
   HICON hIcon = NULL;
 
@@ -579,16 +582,19 @@ nsresult nsIconChannel::MakeInputStream(
     DestroyIcon(hIcon);
   } // if we got an hIcon
 
   // If we didn't make a stream, then fail.
   if (!*_retval && NS_SUCCEEDED(rv))
     rv = NS_ERROR_NOT_AVAILABLE;
   return rv;
 }
+#ifdef _MSC_VER
+#pragma intrinsic(memcpy)
+#endif
 
 NS_IMETHODIMP nsIconChannel::GetContentType(nsACString &aContentType) 
 {
   aContentType.AssignLiteral("image/x-icon");
   return NS_OK;
 }
 
 NS_IMETHODIMP

diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -3663,17 +3663,18 @@ static nsresult
 DrawImageInternal(nsRenderingContext* aRenderingContext,
                   imgIContainer*       aImage,
                   GraphicsFilter       aGraphicsFilter,
                   const nsRect&        aDest,
                   const nsRect&        aFill,
                   const nsPoint&       aAnchor,
                   const nsRect&        aDirty,
                   const nsIntSize&     aImageSize,
-                  uint32_t             aImageFlags)
+                  uint32_t             aImageFlags,
+                  const bool           aSingleImage = false)
 {
   if (aDest.Contains(aFill)) {
     aImageFlags |= imgIContainer::FLAG_CLAMP;
   }
   int32_t appUnitsPerDevPixel = aRenderingContext->AppUnitsPerDevPixel();
   gfxContext* ctx = aRenderingContext->ThebesContext();
 
   SnappedImageDrawingParameters drawingParams =
@@ -3683,16 +3684,20 @@ DrawImageInternal(nsRenderingContext* aR
   if (!drawingParams.mShouldDraw)
     return NS_OK;
 
   gfxContextMatrixAutoSaveRestore saveMatrix(ctx);
   if (drawingParams.mResetCTM) {
     ctx->IdentityMatrix();
   }
 
+  if (aSingleImage) {
+    ctx->SetFlag(gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+  }
+
   aImage->Draw(ctx, aGraphicsFilter, drawingParams.mUserSpaceToImageSpace,
                drawingParams.mFillRect, drawingParams.mSubimage, aImageSize,
                aImageFlags);
   return NS_OK;
 }
 
 /* static */ void
 nsLayoutUtils::DrawPixelSnapped(nsRenderingContext* aRenderingContext,
@@ -3763,17 +3768,17 @@ nsLayoutUtils::DrawSingleUnscaledImage(n
   nsRect dest(aDest - source.TopLeft(), size);
   nsRect fill(aDest, source.Size());
   // Ensure that only a single image tile is drawn. If aSourceArea extends
   // outside the image bounds, we want to honor the aSourceArea-to-aDest
   // translation but we don't want to actually tile the image.
   fill.IntersectRect(fill, dest);
   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter,
                            dest, fill, aDest, aDirty ? *aDirty : dest,
-                           imageSize, aImageFlags);
+                           imageSize, aImageFlags, true);
 }
 
 /* static */ nsresult
 nsLayoutUtils::DrawSingleImage(nsRenderingContext* aRenderingContext,
                                imgIContainer*       aImage,
                                GraphicsFilter       aGraphicsFilter,
                                const nsRect&        aDest,
                                const nsRect&        aDirty,
@@ -3802,17 +3807,17 @@ nsLayoutUtils::DrawSingleImage(nsRenderi
   nsRect dest = nsLayoutUtils::GetWholeImageDestination(imageSize, source,
                                                         aDest);
   // Ensure that only a single image tile is drawn. If aSourceArea extends
   // outside the image bounds, we want to honor the aSourceArea-to-aDest
   // transform but we don't want to actually tile the image.
   nsRect fill;
   fill.IntersectRect(aDest, dest);
   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter, dest, fill,
-                           fill.TopLeft(), aDirty, imageSize, aImageFlags);
+                           fill.TopLeft(), aDirty, imageSize, aImageFlags, true);
 }
 
 /* static */ void
 nsLayoutUtils::ComputeSizeForDrawing(imgIContainer *aImage,
                                      nsIntSize&     aImageSize, /*outparam*/
                                      nsSize&        aIntrinsicRatio, /*outparam*/
                                      bool&          aGotWidth,  /*outparam*/
                                      bool&          aGotHeight  /*outparam*/)

diff --git a/dom/plugins/base/nsPluginNativeWindowWin.cpp b/dom/plugins/base/nsPluginNativeWindowWin.cpp
--- a/dom/plugins/base/nsPluginNativeWindowWin.cpp
+++ b/dom/plugins/base/nsPluginNativeWindowWin.cpp
@@ -30,17 +30,28 @@ using namespace mozilla;
 
 #define nsMajorVersion(v)       (((int32_t)(v) >> 16) & 0xffff)
 #define nsMinorVersion(v)       ((int32_t)(v) & 0xffff)
 #define versionOK(suppliedV, requiredV)                   \
   (nsMajorVersion(suppliedV) == nsMajorVersion(requiredV) \
    && nsMinorVersion(suppliedV) >= nsMinorVersion(requiredV))
 
 
-#define NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION TEXT("MozillaPluginWindowPropertyAssociation")
+class CAtom_MozillaPluginWindowPropertyAssociation {
+public:
+  CAtom_MozillaPluginWindowPropertyAssociation() {
+    atom = ::GlobalAddAtomW(L"MozillaPluginWindowPropertyAssociation");
+  }
+  ~CAtom_MozillaPluginWindowPropertyAssociation() {
+    ::GlobalDeleteAtom(atom);
+  }
+  ATOM atom;
+};
+static CAtom_MozillaPluginWindowPropertyAssociation gaMpwpa;
+#define NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION ((LPCWSTR)(DWORD)gaMpwpa.atom)
 #define NS_PLUGIN_CUSTOM_MSG_ID TEXT("MozFlashUserRelay")
 #define WM_USER_FLASH WM_USER+1
 static UINT sWM_FLASHBOUNCEMSG = 0;
 
 typedef nsTWeakRef<class nsPluginNativeWindowWin> PluginWindowWeakRef;
 
 /**
  *  PLEvent handling code
@@ -187,17 +198,17 @@ NS_IMETHODIMP nsDelayedPopupsEnabledEven
 
 static LRESULT CALLBACK PluginWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
 
 /**
  *   New plugin window procedure
  */
 static LRESULT CALLBACK PluginWndProcInternal(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 {
-  nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+  nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
   if (!win)
     return TRUE;
 
   // The DispatchEvent(NS_PLUGIN_ACTIVATE) below can trigger a reentrant focus
   // event which might destroy us.  Hold a strong ref on the plugin instance
   // to prevent that, bug 374229.
   nsRefPtr<nsNPAPIPluginInstance> inst;
   win->GetPluginInstance(inst);
@@ -389,17 +400,17 @@ static User32SetWindowLongA sUser32SetWi
 static User32SetWindowLongW sUser32SetWindowLongWHookStub = NULL;
 #endif
 static inline bool
 SetWindowLongHookCheck(HWND hWnd,
                        int nIndex,
                        LONG_PTR newLong)
 {
   nsPluginNativeWindowWin * win =
-    (nsPluginNativeWindowWin *)GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+    (nsPluginNativeWindowWin *)GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
   if (!win || (win && win->mPluginType != nsPluginType_Flash) ||
       (nIndex == GWLP_WNDPROC &&
        newLong == reinterpret_cast<LONG_PTR>(PluginWndProc)))
     return true;
   return false;
 }
 
 #ifdef _WIN64
@@ -417,17 +428,17 @@ SetWindowLongAHook(HWND hWnd,
   if (SetWindowLongHookCheck(hWnd, nIndex, newLong))
       return sUser32SetWindowLongAHookStub(hWnd, nIndex, newLong);
 
   // Set flash's new subclass to get the result. 
   LONG_PTR proc = sUser32SetWindowLongAHookStub(hWnd, nIndex, newLong);
 
   // We already checked this in SetWindowLongHookCheck
   nsPluginNativeWindowWin * win =
-    (nsPluginNativeWindowWin *)GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+    (nsPluginNativeWindowWin *)GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
 
   // Hook our subclass back up, just like we do on setwindow.
   win->SetPrevWindowProc(
     reinterpret_cast<WNDPROC>(sUser32SetWindowLongWHookStub(hWnd, nIndex,
       reinterpret_cast<LONG_PTR>(PluginWndProc))));
   return proc;
 }
 
@@ -446,17 +457,17 @@ SetWindowLongWHook(HWND hWnd,
   if (SetWindowLongHookCheck(hWnd, nIndex, newLong))
       return sUser32SetWindowLongWHookStub(hWnd, nIndex, newLong);
 
   // Set flash's new subclass to get the result. 
   LONG_PTR proc = sUser32SetWindowLongWHookStub(hWnd, nIndex, newLong);
 
   // We already checked this in SetWindowLongHookCheck
   nsPluginNativeWindowWin * win =
-    (nsPluginNativeWindowWin *)GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+    (nsPluginNativeWindowWin *)GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
 
   // Hook our subclass back up, just like we do on setwindow.   
   win->SetPrevWindowProc(
     reinterpret_cast<WNDPROC>(sUser32SetWindowLongWHookStub(hWnd, nIndex,
       reinterpret_cast<LONG_PTR>(PluginWndProc))));
   return proc;
 }
 
@@ -689,34 +700,34 @@ nsresult nsPluginNativeWindowWin::Subcla
   else
     style |= WS_CLIPCHILDREN;
   SetWindowLongPtr(hWnd, GWL_STYLE, style);
 
   mPluginWinProc = (WNDPROC)SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)PluginWndProc);
   if (!mPluginWinProc)
     return NS_ERROR_FAILURE;
 
-  nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+  nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
   NS_ASSERTION(!win || (win == this), "plugin window already has property and this is not us");
   
-  if (!::SetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION, (HANDLE)this))
+  if (!::SetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION, (HANDLE)this))
     return NS_ERROR_FAILURE;
 
   return NS_OK;
 }
 
 nsresult nsPluginNativeWindowWin::UndoSubclassAndAssociateWindow()
 {
   // release plugin instance
   SetPluginInstance(nullptr);
 
   // remove window property
   HWND hWnd = (HWND)window;
   if (IsWindow(hWnd))
-    ::RemoveProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+    ::RemovePropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
 
   // restore the original win proc
   // but only do this if this were us last time
   if (mPluginWinProc) {
     WNDPROC currentWndProc = (WNDPROC)::GetWindowLongPtr(hWnd, GWLP_WNDPROC);
     if (currentWndProc == PluginWndProc)
       SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)mPluginWinProc);
     mPluginWinProc = NULL;

diff --git a/gfx/src/nsRect.h b/gfx/src/nsRect.h
--- a/gfx/src/nsRect.h
+++ b/gfx/src/nsRect.h
@@ -11,16 +11,72 @@
 #include "nsCoord.h"
 #include "nsPoint.h"
 #include "nsSize.h"
 #include "nsMargin.h"
 #include "gfxCore.h"
 #include "nsTraceRefcnt.h"
 #include "mozilla/gfx/BaseRect.h"
 
+#include "mozilla/Util.h"
+#include "mozilla/SSE.h"
+
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+#else
+#include <smmintrin.h>
+#endif
+
+#if (_MSC_VER == 1400) && !defined(_M_AMD64)
+__declspec(naked) __declspec(noinline)
+static __m128d mm_floor_pd_BaseRect(__m128d a)
+{
+  __asm {
+    // roundpd  xmm0, xmm0, 1
+    __asm _emit 0x66
+    __asm _emit 0x0F
+    __asm _emit 0x3A
+    __asm _emit 0x09
+    __asm _emit 0xC0
+    __asm _emit 0x01
+    ret
+  }
+}
+#define _mm_floor_pd(a) mm_floor_pd_BaseRect(a)
+
+__declspec(naked) __declspec(noinline)
+static __m128d mm_ceil_pd_BaseRect(__m128d a)
+{
+  __asm {
+    // roundpd  xmm0, xmm0, 2
+    __asm _emit 0x66
+    __asm _emit 0x0F
+    __asm _emit 0x3A
+    __asm _emit 0x09
+    __asm _emit 0xC0
+    __asm _emit 0x02
+    ret
+  }
+}
+#define _mm_ceil_pd(a) mm_ceil_pd_BaseRect(a)
+
+/* VC8 doesn't support some SSE2 built-in functions, so we define them here. */
+static __forceinline __m128
+_mm_castsi128_ps(__m128i a)
+{
+    return *(__m128 *)&a;
+}
+
+static __forceinline __m128i
+_mm_castps_si128(__m128 a)
+{
+    return *(__m128i *)&a;
+}
+#endif
+
 struct nsIntRect;
 
 struct NS_GFX nsRect :
   public mozilla::gfx::BaseRect<nscoord, nsRect, nsPoint, nsSize, nsMargin> {
   typedef mozilla::gfx::BaseRect<nscoord, nsRect, nsPoint, nsSize, nsMargin> Super;
 
   static void VERIFY_COORD(nscoord aValue) { ::VERIFY_COORD(aValue); }
 
@@ -37,16 +93,20 @@ struct NS_GFX nsRect :
   {
     MOZ_COUNT_CTOR(nsRect);
   }
   nsRect(nscoord aX, nscoord aY, nscoord aWidth, nscoord aHeight) :
       Super(aX, aY, aWidth, aHeight)
   {
     MOZ_COUNT_CTOR(nsRect);
   }
+  nsRect(const __m128i& a128i) : Super(a128i)
+  {
+    MOZ_COUNT_CTOR(nsRect);
+  }
 
 #ifdef NS_BUILD_REFCNT_LOGGING
   ~nsRect() {
     MOZ_COUNT_DTOR(nsRect);
   }
 #endif
 
   // A version of Inflate that caps the values to the nscoord range.
@@ -220,16 +280,19 @@ struct NS_GFX nsIntRect :
   }
   nsIntRect(const nsIntPoint& aOrigin, const nsIntSize &aSize) : Super(aOrigin, aSize)
   {
   }
   nsIntRect(int32_t aX, int32_t aY, int32_t aWidth, int32_t aHeight) :
       Super(aX, aY, aWidth, aHeight)
   {
   }
+  nsIntRect(const __m128i& a128i) : Super(a128i)
+  {
+  }
 
   inline nsRect ToAppUnits(nscoord aAppUnitsPerPixel) const;
 
   // Returns a special nsIntRect that's used in some places to signify
   // "all available space".
   static const nsIntRect& GetMaxSizedIntRect() { return kMaxSizedIntRect; }
 
   // This is here only to keep IPDL-generated code happy. DO NOT USE.
@@ -277,76 +340,173 @@ nsRect::ConvertAppUnitsRoundIn(int32_t a
   rect.x = NSToCoordCeil(NSCoordScale(x, aFromAPP, aToAPP));
   rect.y = NSToCoordCeil(NSCoordScale(y, aFromAPP, aToAPP));
   rect.width = (right - rect.x);
   rect.height = (bottom - rect.y);
 
   return rect;
 }
 
+static const MOZ_ALIGNED_DECL(double d_half[2], 16) = { 0.5, 0.5 };
+
 // scale the rect but round to preserve centers
 inline nsIntRect
 nsRect::ScaleToNearestPixels(float aXScale, float aYScale,
                              nscoord aAppUnitsPerPixel) const
 {
+#if !defined(NS_COORD_IS_FLOAT) && ((_MSC_VER != 1400) || !defined(_M_AMD64))
+  if (IsInt32x4() && mozilla::supports_sse4_1()) {
+    __m128d appUnitsPerPixel_x2 = _mm_cvtepi32_pd(_mm_set1_epi32(aAppUnitsPerPixel));
+    __m128i src_x4 = _mm_loadu_si128((__m128i *)&x);
+    __m128d xy = _mm_cvtepi32_pd(src_x4);
+    __m128d xyMost = _mm_cvtepi32_pd(_mm_add_epi32(src_x4, _mm_srli_si128(src_x4, 8)));
+    __m128d xyScale = _mm_cvtps_pd(_mm_unpacklo_ps(_mm_load_ss(&aXScale), _mm_load_ss(&aYScale)));
+
+    __m128i rectXY = _mm_cvttpd_epi32(_mm_floor_pd(_mm_add_pd(_mm_mul_pd(_mm_div_pd(xy, appUnitsPerPixel_x2), xyScale), *(__m128d *)&d_half)));
+    __m128i rectWH = _mm_sub_epi32(_mm_cvttpd_epi32(_mm_floor_pd(_mm_add_pd(_mm_mul_pd(_mm_div_pd(xyMost, appUnitsPerPixel_x2), xyScale), *(__m128d *)&d_half))), rectXY);
+    __m128i rect = _mm_unpacklo_epi64(rectXY, rectWH);
+
+    return nsIntRect(rect);
+  }
+#endif
+
   nsIntRect rect;
   rect.x = NSToIntRoundUp(NSAppUnitsToDoublePixels(x, aAppUnitsPerPixel) * aXScale);
   rect.y = NSToIntRoundUp(NSAppUnitsToDoublePixels(y, aAppUnitsPerPixel) * aYScale);
   rect.width  = NSToIntRoundUp(NSAppUnitsToDoublePixels(XMost(),
                                aAppUnitsPerPixel) * aXScale) - rect.x;
   rect.height = NSToIntRoundUp(NSAppUnitsToDoublePixels(YMost(),
                                aAppUnitsPerPixel) * aYScale) - rect.y;
   return rect;
 }
 
 // scale the rect but round to smallest containing rect
 inline nsIntRect
 nsRect::ScaleToOutsidePixels(float aXScale, float aYScale,
                              nscoord aAppUnitsPerPixel) const
 {
+#if !defined(NS_COORD_IS_FLOAT) && ((_MSC_VER != 1400) || !defined(_M_AMD64))
+  if (IsInt32x4() && mozilla::supports_sse4_1()) {
+    __m128 appUnitsPerPixel_x4 = _mm_cvtepi32_ps(_mm_set1_epi32(aAppUnitsPerPixel));
+    __m128i src_x4 = _mm_loadu_si128((__m128i *)&x);
+    __m128 xy_xyMost = _mm_cvtepi32_ps(_mm_add_epi32(src_x4, _mm_slli_si128(src_x4, 8)));
+    __m128 xyScale_x2 = _mm_unpacklo_ps(_mm_load_ss(&aXScale), _mm_load_ss(&aYScale));
+    xyScale_x2 = _mm_movelh_ps(xyScale_x2, xyScale_x2);
+
+    __m128 a = _mm_mul_ps(_mm_div_ps(xy_xyMost, appUnitsPerPixel_x4), xyScale_x2);
+    __m128i rectXY = _mm_cvttpd_epi32(_mm_floor_pd(_mm_cvtps_pd(a)));
+    __m128i rectWH = _mm_sub_epi32(_mm_cvttpd_epi32(_mm_ceil_pd(_mm_cvtps_pd(_mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(a), 8))))), rectXY);
+    __m128i rect = _mm_unpacklo_epi64(rectXY, rectWH);
+
+    return nsIntRect(rect);
+  }
+#endif
+
   nsIntRect rect;
   rect.x = NSToIntFloor(NSAppUnitsToFloatPixels(x, float(aAppUnitsPerPixel)) * aXScale);
   rect.y = NSToIntFloor(NSAppUnitsToFloatPixels(y, float(aAppUnitsPerPixel)) * aYScale);
   rect.width  = NSToIntCeil(NSAppUnitsToFloatPixels(XMost(),
                             float(aAppUnitsPerPixel)) * aXScale) - rect.x;
   rect.height = NSToIntCeil(NSAppUnitsToFloatPixels(YMost(),
                             float(aAppUnitsPerPixel)) * aYScale) - rect.y;
   return rect;
 }
 
 // scale the rect but round to largest contained rect
 inline nsIntRect
 nsRect::ScaleToInsidePixels(float aXScale, float aYScale,
                             nscoord aAppUnitsPerPixel) const
 {
+#if !defined(NS_COORD_IS_FLOAT) && ((_MSC_VER != 1400) || !defined(_M_AMD64))
+  if (IsInt32x4() && mozilla::supports_sse4_1()) {
+    __m128 appUnitsPerPixel_x4 = _mm_cvtepi32_ps(_mm_set1_epi32(aAppUnitsPerPixel));
+    __m128i src_x4 = _mm_loadu_si128((__m128i *)&x);
+    __m128 xy_xyMost = _mm_cvtepi32_ps(_mm_add_epi32(src_x4, _mm_slli_si128(src_x4, 8)));
+    __m128 xyScale_x2 = _mm_unpacklo_ps(_mm_load_ss(&aXScale), _mm_load_ss(&aYScale));
+    xyScale_x2 = _mm_movelh_ps(xyScale_x2, xyScale_x2);
+
+    __m128 a = _mm_mul_ps(_mm_div_ps(xy_xyMost, appUnitsPerPixel_x4), xyScale_x2);
+    __m128i rectXY = _mm_cvttpd_epi32(_mm_ceil_pd(_mm_cvtps_pd(a)));
+    __m128i rectWH = _mm_sub_epi32(_mm_cvttpd_epi32(_mm_floor_pd(_mm_cvtps_pd(_mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(a), 8))))), rectXY);
+    __m128i rect = _mm_unpacklo_epi64(rectXY, rectWH);
+
+    return nsIntRect(rect);
+  }
+#endif
+
   nsIntRect rect;
   rect.x = NSToIntCeil(NSAppUnitsToFloatPixels(x, float(aAppUnitsPerPixel)) * aXScale);
   rect.y = NSToIntCeil(NSAppUnitsToFloatPixels(y, float(aAppUnitsPerPixel)) * aYScale);
   rect.width  = NSToIntFloor(NSAppUnitsToFloatPixels(XMost(),
                              float(aAppUnitsPerPixel)) * aXScale) - rect.x;
   rect.height = NSToIntFloor(NSAppUnitsToFloatPixels(YMost(),
                              float(aAppUnitsPerPixel)) * aYScale) - rect.y;
   return rect;
 }
 
 inline nsIntRect
 nsRect::ToNearestPixels(nscoord aAppUnitsPerPixel) const
 {
+#if !defined(NS_COORD_IS_FLOAT) && ((_MSC_VER != 1400) || !defined(_M_AMD64))
+  if (IsInt32x4() && mozilla::supports_sse4_1()) {
+    __m128d appUnitsPerPixel_x2 = _mm_cvtepi32_pd(_mm_set1_epi32(aAppUnitsPerPixel));
+    __m128i src_x4 = _mm_loadu_si128((__m128i *)&x);
+    __m128d xy = _mm_cvtepi32_pd(src_x4);
+    __m128d xyMost = _mm_cvtepi32_pd(_mm_add_epi32(src_x4, _mm_srli_si128(src_x4, 8)));
+
+    __m128i rectXY = _mm_cvttpd_epi32(_mm_floor_pd(_mm_add_pd(_mm_div_pd(xy, appUnitsPerPixel_x2), *(__m128d *)&d_half)));
+    __m128i rectWH = _mm_sub_epi32(_mm_cvttpd_epi32(_mm_floor_pd(_mm_add_pd(_mm_div_pd(xyMost, appUnitsPerPixel_x2), *(__m128d *)&d_half))), rectXY);
+    __m128i rect = _mm_unpacklo_epi64(rectXY, rectWH);
+
+    return nsIntRect(rect);
+  }
+#endif
+
   return ScaleToNearestPixels(1.0f, 1.0f, aAppUnitsPerPixel);
 }
 
 inline nsIntRect
 nsRect::ToOutsidePixels(nscoord aAppUnitsPerPixel) const
 {
+#if !defined(NS_COORD_IS_FLOAT) && ((_MSC_VER != 1400) || !defined(_M_AMD64))
+  if (IsInt32x4() && mozilla::supports_sse4_1()) {
+    __m128 appUnitsPerPixel_x4 = _mm_cvtepi32_ps(_mm_set1_epi32(aAppUnitsPerPixel));
+    __m128i src_x4 = _mm_loadu_si128((__m128i *)&x);
+    __m128 xy_xyMost = _mm_cvtepi32_ps(_mm_add_epi32(src_x4, _mm_slli_si128(src_x4, 8)));
+
+    __m128 a = _mm_div_ps(xy_xyMost, appUnitsPerPixel_x4);
+    __m128i rectXY = _mm_cvttpd_epi32(_mm_floor_pd(_mm_cvtps_pd(a)));
+    __m128i rectWH = _mm_sub_epi32(_mm_cvttpd_epi32(_mm_ceil_pd(_mm_cvtps_pd(_mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(a), 8))))), rectXY);
+    __m128i rect = _mm_unpacklo_epi64(rectXY, rectWH);
+
+    return nsIntRect(rect);
+  }
+#endif
+
   return ScaleToOutsidePixels(1.0f, 1.0f, aAppUnitsPerPixel);
 }
 
 inline nsIntRect
 nsRect::ToInsidePixels(nscoord aAppUnitsPerPixel) const
 {
+#if !defined(NS_COORD_IS_FLOAT) && ((_MSC_VER != 1400) || !defined(_M_AMD64))
+  if (IsInt32x4() && mozilla::supports_sse4_1()) {
+    __m128 appUnitsPerPixel_x4 = _mm_cvtepi32_ps(_mm_set1_epi32(aAppUnitsPerPixel));
+    __m128i src_x4 = _mm_loadu_si128((__m128i *)&x);
+    __m128 xy_xyMost = _mm_cvtepi32_ps(_mm_add_epi32(src_x4, _mm_slli_si128(src_x4, 8)));
+
+    __m128 a = _mm_div_ps(xy_xyMost, appUnitsPerPixel_x4);
+    __m128i rectXY = _mm_cvttpd_epi32(_mm_ceil_pd(_mm_cvtps_pd(a)));
+    __m128i rectWH = _mm_sub_epi32(_mm_cvttpd_epi32(_mm_floor_pd(_mm_cvtps_pd(_mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(a), 8))))), rectXY);
+    __m128i rect = _mm_unpacklo_epi64(rectXY, rectWH);
+
+    return nsIntRect(rect);
+  }
+#endif
+
   return ScaleToInsidePixels(1.0f, 1.0f, aAppUnitsPerPixel);
 }
 
 // app units are integer multiples of pixels, so no rounding needed
 inline nsRect
 nsIntRect::ToAppUnits(nscoord aAppUnitsPerPixel) const
 {
   return nsRect(NSIntPixelsToAppUnits(x, aAppUnitsPerPixel),

diff --git a/content/svg/content/src/nsSVGFilters.cpp b/content/svg/content/src/nsSVGFilters.cpp
--- a/content/svg/content/src/nsSVGFilters.cpp
+++ b/content/svg/content/src/nsSVGFilters.cpp
@@ -1,13 +1,17 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+#include <omp.h>
+#endif
+
 #include "mozilla/Util.h"
 
 #include "nsSVGElement.h"
 #include "nsGkAtoms.h"
 #include "nsSVGNumber2.h"
 #include "nsSVGNumberPair.h"
 #include "nsSVGInteger.h"
 #include "nsSVGIntegerPair.h"
@@ -934,16 +938,36 @@ nsSVGFEBlendElement::Filter(nsSVGFilterI
   CopyRect(aTarget, aSources[0], rect);
 
   uint8_t* sourceData = aSources[1]->mImage->Data();
   uint8_t* targetData = aTarget->mImage->Data();
   uint32_t stride = aTarget->mImage->Stride();
 
   uint16_t mode = mEnumAttributes[MODE].GetAnimValue();
 
+  switch (mode) {
+    case nsSVGFEBlendElement::SVG_MODE_NORMAL:
+    case nsSVGFEBlendElement::SVG_MODE_MULTIPLY:
+    case nsSVGFEBlendElement::SVG_MODE_SCREEN:
+    case nsSVGFEBlendElement::SVG_MODE_DARKEN:
+    case nsSVGFEBlendElement::SVG_MODE_LIGHTEN:
+      break;
+    default:
+      return NS_ERROR_FAILURE;
+      break;
+  }
+
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, targetData, sourceData, mode) \
+if (omp_thread_counts >= 2 && \
+   (rect.XMost() - rect.x) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 7000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t x = rect.x; x < rect.XMost(); x++) {
     for (int32_t y = rect.y; y < rect.YMost(); y++) {
       uint32_t targIndex = y * stride + 4 * x;
       uint32_t qa = targetData[targIndex + GFX_ARGB32_OFFSET_A];
       uint32_t qb = sourceData[targIndex + GFX_ARGB32_OFFSET_A];
       for (int32_t i = NS_MIN(GFX_ARGB32_OFFSET_B, GFX_ARGB32_OFFSET_R);
            i <= NS_MAX(GFX_ARGB32_OFFSET_B, GFX_ARGB32_OFFSET_R); i++) {
         uint32_t ca = targetData[targIndex + i];
@@ -962,21 +986,19 @@ nsSVGFEBlendElement::Filter(nsSVGFilterI
           case nsSVGFEBlendElement::SVG_MODE_DARKEN:
             val = NS_MIN((255 - qa) * cb + 255 * ca,
                          (255 - qb) * ca + 255 * cb);
             break;
           case nsSVGFEBlendElement::SVG_MODE_LIGHTEN:
             val = NS_MAX((255 - qa) * cb + 255 * ca,
                          (255 - qb) * ca + 255 * cb);
             break;
-          default:
-            return NS_ERROR_FAILURE;
-            break;
         }
-        val = NS_MIN(val / 255, 255U);
+        FAST_DIVIDE_BY_255(val, val);
+        val = NS_MIN(val, 255U);
         targetData[targIndex + i] =  static_cast<uint8_t>(val);
       }
       uint32_t alpha = 255 * 255 - (255 - qa) * (255 - qb);
       FAST_DIVIDE_BY_255(targetData[targIndex + GFX_ARGB32_OFFSET_A], alpha);
     }
   }
   return NS_OK;
 }
@@ -1267,16 +1289,24 @@ nsSVGFEColorMatrixElement::Filter(nsSVGF
 
     memcpy(colorMatrix, luminanceToAlphaMatrix, sizeof(colorMatrix));
     break;
 
   default:
     return NS_ERROR_FAILURE;
   }
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, sourceData, colorMatrix, targetData) \
+if (omp_thread_counts >= 2 && \
+   (rect.XMost() - rect.x) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 2300)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t x = rect.x; x < rect.XMost(); x++) {
     for (int32_t y = rect.y; y < rect.YMost(); y++) {
       uint32_t targIndex = y * stride + 4 * x;
 
       float col[4];
       for (int i = 0, row = 0; i < 4; i++, row += 5) {
         col[i] =
           sourceData[targIndex + GFX_ARGB32_OFFSET_R] * colorMatrix[row + 0] +
@@ -1528,16 +1558,25 @@ nsSVGFECompositeElement::Filter(nsSVGFil
 
     uint8_t* sourceData = aSources[1]->mImage->Data();
     uint8_t* targetData = aTarget->mImage->Data();
     uint32_t stride = aTarget->mImage->Stride();
 
     // Blend in the second source image
     float k1Scaled = k1 / 255.0f;
     float k4Scaled = k4*255.0f;
+
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+    int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, targetData, sourceData, stride, k1Scaled, k2, k3, k4Scaled) \
+if (omp_thread_counts >= 2 && \
+    (rect.XMost() - rect.x) >= (uint32_t)omp_thread_counts && \
+    (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 1000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       for (int32_t y = rect.y; y < rect.YMost(); y++) {
         uint32_t targIndex = y * stride + 4 * x;
         for (int32_t i = 0; i < 4; i++) {
           uint8_t i1 = targetData[targIndex + i];
           uint8_t i2 = sourceData[targIndex + i];
           float result = k1Scaled*i1*i2 + k2*i1 + k3*i2 + k4Scaled;
           targetData[targIndex + i] =
@@ -1819,16 +1858,24 @@ nsSVGFEComponentTransferElement::Filter(
     nsRefPtr<nsSVGComponentTransferFunctionElement> child;
     CallQueryInterface(childContent,
             (nsSVGComponentTransferFunctionElement**)getter_AddRefs(child));
     if (child) {
       child->GenerateLookupTable(tables[child->GetChannel()]);
     }
   }
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, targetData, sourceData, tableB, tableG, tableR, tableA) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 10000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       int32_t targIndex = y * stride + x * 4;
       targetData[targIndex + GFX_ARGB32_OFFSET_B] =
         tableB[sourceData[targIndex + GFX_ARGB32_OFFSET_B]];
       targetData[targIndex + GFX_ARGB32_OFFSET_G] =
         tableG[sourceData[targIndex + GFX_ARGB32_OFFSET_G]];
       targetData[targIndex + GFX_ARGB32_OFFSET_R] =
@@ -1989,17 +2036,18 @@ nsSVGComponentTransferFunctionElement::G
 
   switch (type) {
   case nsIDOMSVGComponentTransferFunctionElement::SVG_FECOMPONENTTRANSFER_TYPE_TABLE:
   {
     if (tableValues.Length() <= 1)
       break;
 
     for (i = 0; i < 256; i++) {
-      uint32_t k = (i * (tvLength - 1)) / 255;
+      uint32_t k;
+      FAST_DIVIDE_BY_255(k, (i * (tvLength - 1)));
       float v1 = tableValues[k];
       float v2 = tableValues[NS_MIN(k + 1, tvLength - 1)];
       int32_t val =
         int32_t(255 * (v1 + (i/255.0f - k/float(tvLength-1))*(tvLength - 1)*(v2 - v1)));
       val = NS_MIN(255, val);
       val = NS_MAX(0, val);
       aTable[i] = val;
     }
@@ -2007,17 +2055,18 @@ nsSVGComponentTransferFunctionElement::G
   }
 
   case nsIDOMSVGComponentTransferFunctionElement::SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE:
   {
     if (tableValues.Length() <= 1)
       break;
 
     for (i = 0; i < 256; i++) {
-      uint32_t k = (i * tvLength) / 255;
+      uint32_t k;
+      FAST_DIVIDE_BY_255(k, (i * tvLength));
       k = NS_MIN(k, tvLength - 1);
       float v = tableValues[k];
       int32_t val = int32_t(255 * v);
       val = NS_MIN(255, val);
       val = NS_MAX(0, val);
       aTable[i] = val;
     }
     break;
@@ -3002,16 +3051,24 @@ nsSVGFETileElement::Filter(nsSVGFilterIn
   uint8_t* sourceData = aSources[0]->mImage->Data();
   uint8_t* targetData = aTarget->mImage->Data();
   uint32_t stride = aTarget->mImage->Stride();
 
   // the offset to add to our x/y coordinates (which are relative to the
   // temporary surface data) to get coordinates relative to the origin
   // of the tile
   nsIntPoint offset(-tile.x + tile.width, -tile.y + tile.height);
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, tile, surfaceRect, sourceData, targetData, stride, offset) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts  && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 10000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
     uint32_t tileY = tile.y + WrapInterval(y + offset.y, tile.height);
     if (tileY < (uint32_t)surfaceRect.height) {
       for (int32_t x = rect.x; x < rect.XMost(); x++) {
         uint32_t tileX = tile.x + WrapInterval(x + offset.x, tile.width);
         if (tileX < (uint32_t)surfaceRect.width) {
           *(uint32_t*)(targetData + y * stride + 4 * x) =
             *(uint32_t*)(sourceData + tileY * stride + 4 * tileX);
@@ -3332,16 +3389,25 @@ nsSVGFETurbulenceElement::Filter(nsSVGFi
 
     lowFreq = floor(filterHeight * fY) / filterHeight;
     hiFreq = ceil(filterHeight * fY) / filterHeight;
     if (fY / lowFreq < hiFreq / fY)
       fY = lowFreq;
     else
       fY = hiFreq;
   }
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, instance, filterSubregion, type, doStitch, \
+  filterX, filterY, filterWidth, filterHeight, fX, fY, octaves, targetData) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 130)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       int32_t targIndex = y * stride + x * 4;
       double point[2];
       point[0] = filterX + (filterWidth * (x + instance->GetSurfaceRect().x)) / (filterSubregion.width - 1);
       point[1] = filterY + (filterHeight * (y + instance->GetSurfaceRect().y)) / (filterSubregion.height - 1);
 
       float col[4];
@@ -3355,17 +3421,17 @@ nsSVGFETurbulenceElement::Filter(nsSVGFi
                                doStitch, filterX, filterY, filterWidth, filterHeight) * 255 + 255) / 2;
       }
       for (int i = 0; i < 4; i++) {
         col[i] = NS_MIN(col[i], 255.f);
         col[i] = NS_MAX(col[i], 0.f);
       }
 
       uint8_t r, g, b, a;
-      a = uint8_t(col[3]);
+      a = (uint8_t)(col[3]);
       FAST_DIVIDE_BY_255(r, unsigned(col[0]) * a);
       FAST_DIVIDE_BY_255(g, unsigned(col[1]) * a);
       FAST_DIVIDE_BY_255(b, unsigned(col[2]) * a);
 
       targetData[targIndex + GFX_ARGB32_OFFSET_B] = b;
       targetData[targIndex + GFX_ARGB32_OFFSET_G] = g;
       targetData[targIndex + GFX_ARGB32_OFFSET_R] = r;
       targetData[targIndex + GFX_ARGB32_OFFSET_A] = a;
@@ -3820,21 +3886,29 @@ nsSVGFEMorphologyElement::Filter(nsSVGFi
 
   // Clamp radii to prevent completely insane values:
   rx = NS_MIN(rx, 100000);
   ry = NS_MIN(ry, 100000);
 
   uint8_t* sourceData = aSources[0]->mImage->Data();
   uint8_t* targetData = aTarget->mImage->Data();
   int32_t stride = aTarget->mImage->Stride();
-  uint8_t extrema[4];         // RGBA magnitude of extrema
   uint16_t op = mEnumAttributes[OPERATOR].GetAnimValue();
 
   // Scan the kernel for each pixel to determine max/min RGBA values.
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, rx, ry, instance, sourceData, targetData, stride, op) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts &&\
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 1800)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
+    uint8_t extrema[4];         // RGBA magnitude of extrema
     int32_t startY = NS_MAX(0, y - ry);
     // We need to read pixels not just in 'rect', which is limited to
     // the dirty part of our filter primitive subregion, but all pixels in
     // the given radii from the source surface, so use the surface size here.
     int32_t endY = NS_MIN(y + ry, instance->GetSurfaceHeight() - 1);
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       int32_t startX = NS_MAX(0, x - rx);
       int32_t endX = NS_MIN(x + rx, instance->GetSurfaceWidth() - 1);
@@ -4318,16 +4392,25 @@ nsSVGFEConvolveMatrixElement::Filter(nsS
 
   const nsIntRect& dataRect = info.mDataRect;
   int32_t stride = info.mSource->Stride();
   int32_t width = info.mSource->GetSize().width;
   int32_t height = info.mSource->GetSize().height;
   uint8_t *sourceData = info.mSource->Data();
   uint8_t *targetData = info.mTarget->Data();
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(dataRect, sourceData, targetData, width, height, stride, edgeMode, \
+  kernel, divisor, bias, preserveAlpha, orderX, orderY, targetX, targetY) \
+if (omp_thread_counts >= 2 && \
+   (dataRect.YMost() - dataRect.y) >= (uint32_t)omp_thread_counts && \
+   (dataRect.YMost() - dataRect.y) * (dataRect.XMost() - dataRect.x) >= 200)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = dataRect.y; y < dataRect.YMost(); y++) {
     for (int32_t x = dataRect.x; x < dataRect.XMost(); x++) {
       ConvolvePixel(sourceData, targetData,
                     width, height, stride,
                     x, y,
                     edgeMode, kernel, divisor, bias, preserveAlpha,
                     orderX, orderY, targetX, targetY);
     }
@@ -5038,26 +5121,26 @@ nsSVGFELightingElement::Filter(nsSVGFilt
       break;
   }
 
   if (!distantLight && !pointLight && !spotLight)
     return NS_ERROR_FAILURE;
 
   const float radPerDeg = M_PI/180.0;
 
-  float L[3];
+  float L_orig[3];
   if (distantLight) {
     float azimuth, elevation;
     static_cast<nsSVGFEDistantLightElement*>
       (distantLight.get())->GetAnimatedNumberValues(&azimuth,
                                                     &elevation,
                                                     nullptr);
-    L[0] = cos(azimuth * radPerDeg) * cos(elevation * radPerDeg);
-    L[1] = sin(azimuth * radPerDeg) * cos(elevation * radPerDeg);
-    L[2] = sin(elevation * radPerDeg);
+    L_orig[0] = cos(azimuth * radPerDeg) * cos(elevation * radPerDeg);
+    L_orig[1] = sin(azimuth * radPerDeg) * cos(elevation * radPerDeg);
+    L_orig[2] = sin(elevation * radPerDeg);
   }
   float lightPos[3], pointsAt[3], specularExponent;
   float cosConeAngle = 0;
   if (pointLight) {
     static_cast<nsSVGFEPointLightElement*>
       (pointLight.get())->GetAnimatedNumberValues(lightPos,
                                                   lightPos + 1,
                                                   lightPos + 2,
@@ -5090,21 +5173,31 @@ nsSVGFELightingElement::Filter(nsSVGFilt
 
   const nsIntRect& dataRect = info.mDataRect;
   int32_t stride = info.mSource->Stride();
   uint8_t *sourceData = info.mSource->Data();
   uint8_t *targetData = info.mTarget->Data();
   int32_t surfaceWidth = info.mSource->Width();
   int32_t surfaceHeight = info.mSource->Height();
   
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(dataRect, stride, sourceData, surfaceWidth, surfaceHeight, surfaceScale, pointLight, spotLight, lightPos, L_orig, pointsAt, lightColor, targetData, cosConeAngle, specularExponent, instance) \
+if (omp_thread_counts >= 2 && \
+   (dataRect.YMost() - dataRect.y) >= (uint32_t)omp_thread_counts && \
+   (dataRect.XMost() - dataRect.x) * (dataRect.YMost() - dataRect.y) >= 200)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = dataRect.y; y < dataRect.YMost(); y++) {
     for (int32_t x = dataRect.x; x < dataRect.XMost(); x++) {
       int32_t index = y * stride + x * 4;
 
       float N[3];
+      float L[3];
+      memcpy(L, L_orig, sizeof(L));
       GenerateNormal(N, sourceData, stride, surfaceWidth, surfaceHeight,
                      x, y, surfaceScale);
 
       if (pointLight || spotLight) {
         gfxPoint pt = instance->FilterSpaceToUserSpace(
                 gfxPoint(x + instance->GetSurfaceRect().x,
                          y + instance->GetSurfaceRect().y));
         float Z = surfaceScale * sourceData[index + GFX_ARGB32_OFFSET_A] / 255;
@@ -6009,16 +6102,25 @@ nsSVGFEDisplacementMapElement::Filter(ns
                              GFX_ARGB32_OFFSET_B,
                              GFX_ARGB32_OFFSET_A };
   uint16_t xChannel = channelMap[mEnumAttributes[CHANNEL_X].GetAnimValue()];
   uint16_t yChannel = channelMap[mEnumAttributes[CHANNEL_Y].GetAnimValue()];
 
   double scaleOver255 = scale / 255.0;
   double scaleAdjustment = 0.5 - 0.5 * scale;
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, scaleOver255, displacementData, xChannel, yChannel, \
+  scaleAdjustment, width, height, targetData, sourceData, dummyData) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 1500)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       uint32_t targIndex = y * stride + 4 * x;
       // At some point we might want to replace this with a bilinear sample.
       int32_t sourceX = x +
         NSToIntFloor(scaleOver255 * displacementData[targIndex + xChannel] +
                 scaleAdjustment);
       int32_t sourceY = y +

diff --git a/layout/svg/base/src/nsSVGMaskFrame.cpp b/layout/svg/base/src/nsSVGMaskFrame.cpp
--- a/layout/svg/base/src/nsSVGMaskFrame.cpp
+++ b/layout/svg/base/src/nsSVGMaskFrame.cpp
@@ -1,13 +1,17 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+#include <omp.h>
+#endif
+
 // Main header first:
 #include "nsSVGMaskFrame.h"
 
 // Keep others in (case-insensitive) order:
 #include "gfxContext.h"
 #include "gfxImageSurface.h"
 #include "nsRenderingContext.h"
 #include "nsSVGEffects.h"
@@ -114,27 +118,36 @@ nsSVGMaskFrame::ComputeMaskAlpha(nsRende
 
   nsIntRect rect(0, 0, surfaceSize.width, surfaceSize.height);
   nsSVGUtils::UnPremultiplyImageDataAlpha(data, stride, rect);
   if (GetStyleSVG()->mColorInterpolation ==
       NS_STYLE_COLOR_INTERPOLATION_LINEARRGB) {
     nsSVGUtils::ConvertImageDataToLinearRGB(data, stride, rect);
   }
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+
+#pragma omp parallel for schedule(guided) default(none) \
+shared(surfaceSize, data, stride, aOpacity) \
+if (omp_thread_counts >= 2 && \
+    surfaceSize.height >= (PRUint32)omp_thread_counts && \
+    surfaceSize.width * surfaceSize.height >= 10000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = 0; y < surfaceSize.height; y++)
     for (int32_t x = 0; x < surfaceSize.width; x++) {
       uint8_t *pixel = data + stride * y + 4 * x;
 
       /* linearRGB -> intensity */
       uint8_t alpha =
         static_cast<uint8_t>
                    ((pixel[GFX_ARGB32_OFFSET_R] * 0.2125 +
                         pixel[GFX_ARGB32_OFFSET_G] * 0.7154 +
                         pixel[GFX_ARGB32_OFFSET_B] * 0.0721) *
-                       (pixel[GFX_ARGB32_OFFSET_A] / 255.0) * aOpacity);
+                       (pixel[GFX_ARGB32_OFFSET_A] * 0.003921568627451) * aOpacity);
 
       memset(pixel, alpha, 4);
     }
 
   gfxPattern *retval = new gfxPattern(image);
   retval->SetMatrix(matrix);
   NS_IF_ADDREF(retval);
   return retval;

diff --git a/xpcom/glue/nsThreadUtils.cpp b/xpcom/glue/nsThreadUtils.cpp
--- a/xpcom/glue/nsThreadUtils.cpp
+++ b/xpcom/glue/nsThreadUtils.cpp
@@ -13,16 +13,27 @@
 # include "nsXPCOMCIDInternal.h"
 # include "nsIThreadManager.h"
 # include "nsServiceManagerUtils.h"
 #endif
 
 #ifdef XP_WIN
 #include <windows.h>
 #include "nsWindowsHelpers.h"
+#if _MSC_VER >= 1400
+#ifdef _WIN64
+unsigned __int64 __readgsqword(unsigned long Offset);
+#pragma intrinsic(__readgsqword)
+#define TlsGetValue(x) (LPVOID)(__readgsqword((x) * 8 + 0x1480))
+#else /* _WIN64 */
+unsigned long __readfsdword(unsigned long Offset);
+#pragma intrinsic(__readfsdword)
+#define TlsGetValue(x) (LPVOID)(*(unsigned long *)(__readfsdword(0x18) + (x) * 4 + 3600))
+#endif /* _WIN64 */
+#endif /* _MSC_VER >= 1400 */
 #elif defined(XP_MACOSX)
 #include <sys/resource.h>
 #endif
 
 #include <pratom.h>
 #include <prthread.h>
 
 #ifndef XPCOM_GLUE_AVOID_NSPR

diff --git a/widget/windows/nsWindow.cpp b/widget/windows/nsWindow.cpp
--- a/widget/windows/nsWindow.cpp
+++ b/widget/windows/nsWindow.cpp
@@ -1936,17 +1936,28 @@ nsWindow::ResetLayout()
 
   // Invalidate and update
   Invalidate();
 }
 
 // Internally track the caption status via a window property. Required
 // due to our internal handling of WM_NCACTIVATE when custom client
 // margins are set.
-static const PRUnichar kManageWindowInfoProperty[] = L"ManageWindowInfoProperty";
+class CAtom_ManageWindowInfoProperty {
+public:
+  CAtom_ManageWindowInfoProperty() {
+    atom = ::GlobalAddAtomW(L"ManageWindowInfoProperty");
+  }
+  ~CAtom_ManageWindowInfoProperty() {
+    ::GlobalDeleteAtom(atom);
+  }
+  ATOM atom;
+};
+static CAtom_ManageWindowInfoProperty gaMwip;
+#define kManageWindowInfoProperty ((LPCWSTR)(UINT_PTR)gaMwip.atom)
 typedef BOOL (WINAPI *GetWindowInfoPtr)(HWND hwnd, PWINDOWINFO pwi);
 static GetWindowInfoPtr sGetWindowInfoPtrStub = NULL;
 
 BOOL WINAPI
 GetWindowInfoHook(HWND hWnd, PWINDOWINFO pwi)
 {
   if (!sGetWindowInfoPtrStub) {
     NS_ASSERTION(FALSE, "Something is horribly wrong in GetWindowInfoHook!");

diff --git a/toolkit/xre/nsWindowsWMain.cpp b/toolkit/xre/nsWindowsWMain.cpp
--- a/toolkit/xre/nsWindowsWMain.cpp
+++ b/toolkit/xre/nsWindowsWMain.cpp
@@ -5,16 +5,20 @@
 // This file is a .cpp file meant to be included in nsBrowserApp.cpp and other
 // similar bootstrap code. It converts wide-character windows wmain into UTF-8
 // narrow-character strings.
 
 #ifndef XP_WIN
 #error This file only makes sense on Windows.
 #endif
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+#include <omp.h>
+#endif
+
 #include "nsUTF8Utils.h"
 
 #ifndef XRE_DONT_PROTECT_DLL_LOAD
 #include "nsSetDllDirectory.h"
 #endif
 
 #ifdef __MINGW32__
 

diff -r 28eff799c22e gfx/cairo/libpixman/src/pixman-cpu.c
--- a/gfx/cairo/libpixman/src/pixman-cpu.c	Thu Sep 06 17:23:00 2012 +0900
+++ b/gfx/cairo/libpixman/src/pixman-cpu.c	Sat Sep 29 14:24:53 2012 +0900
@@ -26,16 +26,24 @@
 #include <string.h>
 #include <stdlib.h>
 
 #if defined(USE_ARM_SIMD) && defined(_MSC_VER)
 /* Needed for EXCEPTION_ILLEGAL_INSTRUCTION */
 #include <windows.h>
 #endif
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+#include <omp.h>
+#endif
+
+#ifdef _MSC_VER
+#include <windows.h>
+#endif
+
 #if defined(__APPLE__)
 #include "TargetConditionals.h"
 #endif
 
 #include "pixman-private.h"
 
 #ifdef USE_VMX
 
@@ -742,21 +750,194 @@ disabled (const char *name)
 	    env += len;
 	}
 	while (*env++);
     }
 
     return FALSE;
 }
 
+#ifdef _MSC_VER
+
+#ifdef TT_MEMUTIL
+uint32_t dwNonTemporalDataSizeMin = NON_TEMPORAL_STORES_NOT_SUPPORTED;
+uint32_t dwNonTemporalMemcpySizeMin = NON_TEMPORAL_STORES_NOT_SUPPORTED;
+#endif
+typedef BOOL (WINAPI *LPFN_GLPI)(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION, PDWORD);
+
+int Initialize_TT()
+{
+#ifdef TT_MEMUTIL
+    int omp_thread_counts = 0;
+    DWORD pam, sam;
+
+    long env_omp_num_threads = 0;
+    wchar_t *lpwz_env = _wgetenv(L"OMP_NUM_THREADS");
+    if (lpwz_env)
+    {
+      env_omp_num_threads = _wtol(lpwz_env);
+    }
+
+    omp_set_dynamic(0);
+    omp_set_num_threads(1);
+
+    if (GetProcessAffinityMask(GetCurrentProcess(), &pam, &sam))
+    {
+        LPFN_GLPI glpi =
+            (LPFN_GLPI)GetProcAddress(GetModuleHandle("kernel32.dll"),
+            "GetLogicalProcessorInformation");
+        DWORD returnLength = 0;
+        int *pThreadBindIndex = NULL;
+
+        if (NULL != glpi &&
+            !glpi(NULL, &returnLength) &&
+            GetLastError() == ERROR_INSUFFICIENT_BUFFER)
+        {
+            PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer =
+                (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)malloc(returnLength);
+
+            if (glpi(buffer, &returnLength))
+            {
+                DWORD byteOffset;
+                PSYSTEM_LOGICAL_PROCESSOR_INFORMATION ptr;
+                int i;
+                size_t threadBindIndexSize;
+
+                byteOffset = 0;
+                ptr = buffer;
+                while (byteOffset < returnLength)
+                {
+                    if (RelationProcessorCore == ptr->Relationship)
+                    {
+                        omp_thread_counts++;
+                    }
+                    byteOffset += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
+                    ptr++;
+                }
+
+                threadBindIndexSize = sizeof(int) * omp_thread_counts;
+                pThreadBindIndex = (int *)malloc(threadBindIndexSize);
+                memset(pThreadBindIndex, 0xFF, threadBindIndexSize);
+
+                i = 0;
+                byteOffset = 0;
+                ptr = buffer;
+                while (byteOffset < returnLength)
+                {
+                    if (RelationProcessorCore == ptr->Relationship)
+                    {
+                        if (i < omp_thread_counts)
+                        {
+                            int b;
+
+                            for (b = 0; b <= 31; b++)
+                            {
+                                if ((pam & ptr->ProcessorMask) & (1 << b))
+                                {
+                                    pThreadBindIndex[i++] = b;
+                                    break;
+                                }
+                            }
+                        }
+                        else
+                        {
+                            break;
+                        }
+                    }
+                    byteOffset += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
+                    ptr++;
+                }
+            }
+            free(buffer);
+        }
+
+        if (NULL == pThreadBindIndex)
+        {
+            int b;
+            int i;
+            size_t threadBindIndexSize;
+
+            for (b = 0; b <= 31; b++)
+            {
+                if (pam & (1 << b)) omp_thread_counts++;
+            }
+
+            threadBindIndexSize = sizeof(int) * omp_thread_counts;
+            pThreadBindIndex = (int *)malloc(threadBindIndexSize);
+            memset(pThreadBindIndex, 0xFF, threadBindIndexSize);
+
+            for (i = 0; i < omp_thread_counts; i++)
+            {
+                pThreadBindIndex[i] = i;
+            }
+        }
+
+        if (NULL != pThreadBindIndex)
+        {
+            if (omp_thread_counts >= 1)
+            {
+                OSVERSIONINFO osvi = { sizeof(OSVERSIONINFO) };
+                BOOL bIsWindows7orLater = FALSE;
+
+                omp_set_dynamic(0);
+                if (0 != env_omp_num_threads)
+                {
+                    omp_thread_counts = env_omp_num_threads;
+                }
+                omp_set_num_threads(omp_thread_counts);
+                omp_thread_counts = omp_get_max_threads();
+
+                GetVersionEx(&osvi);
+                bIsWindows7orLater =
+                    (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId) &&
+                    ((6 == osvi.dwMajorVersion && osvi.dwMinorVersion >= 1) || (osvi.dwMajorVersion >= 7));
+                if (!bIsWindows7orLater)
+                {
+#pragma omp parallel
+                    {
+                        SetThreadIdealProcessor(GetCurrentThread(),
+                            pThreadBindIndex[omp_get_thread_num()]);
+                    }
+                }
+            }
+            free(pThreadBindIndex);
+        }
+    }
+#endif /* TT_MEMUTIL */
+
+#ifdef TT_MEMUTIL
+    dwNonTemporalMemcpySizeMin = dwNonTemporalDataSizeMin = GetNonTemporalDataSizeMin_tt();
+    if (dwNonTemporalMemcpySizeMin != NON_TEMPORAL_STORES_NOT_SUPPORTED)
+    {
+        dwNonTemporalMemcpySizeMin = dwNonTemporalDataSizeMin / 2;
+    }
+#endif
+
+    return 0;
+}
+
+#endif /* _MSC_VER */
+
 pixman_implementation_t *
 _pixman_choose_implementation (void)
 {
     pixman_implementation_t *imp;
 
+#ifdef _MSC_VER
+    {
+        static pixman_bool_t initialized = FALSE;
+
+        if (!initialized)
+        {
+            Initialize_TT();
+            initialized = TRUE;
+        }
+    }
+#endif
+
     imp = _pixman_implementation_create_general();
 
     if (!disabled ("fast"))
 	imp = _pixman_implementation_create_fast_path (imp);
 
 #ifdef USE_X86_MMX
     if (!disabled ("mmx") && pixman_have_mmx ())
 	imp = _pixman_implementation_create_mmx (imp);

diff -r 130a6a134e0c gfx/cairo/libpixman/src/pixman-edge.c
--- a/gfx/cairo/libpixman/src/pixman-edge.c	Sat Jul 03 07:19:26 2010 +0900
+++ b/gfx/cairo/libpixman/src/pixman-edge.c	Wed Jul 07 06:49:12 2010 +0900
@@ -161,16 +161,18 @@ rasterize_edges_8 (pixman_image_t *image
 {
     pixman_fixed_t y = t;
     uint32_t  *line;
     int fill_start = -1, fill_end = -1;
     int fill_size = 0;
     uint32_t *buf = (image)->bits.bits;
     int stride = (image)->bits.rowstride;
     int width = (image)->bits.width;
+    pixman_fixed_t rx_old = 0;
+    int rxs_old = 0, rxi_old = 0;
 
     line = buf + pixman_fixed_to_int (y) * stride;
 
     for (;;)
     {
         uint8_t *ap = (uint8_t *) line;
         pixman_fixed_t lx, rx;
         int lxi, rxi;
@@ -192,22 +194,39 @@ rasterize_edges_8 (pixman_image_t *image
 	}
 
         /* Skip empty (or backwards) sections */
         if (rx > lx)
         {
             int lxs, rxs;
 
             /* Find pixel bounds for span. */
-            lxi = pixman_fixed_to_int (lx);
-            rxi = pixman_fixed_to_int (rx);
+            /* Sample coverage for edge pixels */
+            if (lx == 0)
+            {
+                lxi = 0;
+                lxs = 0;
+            }
+            else
+            {
+                lxi = pixman_fixed_to_int (lx);
+                lxs = RENDER_SAMPLES_X (lx, 8);
+            }
 
-            /* Sample coverage for edge pixels */
-            lxs = RENDER_SAMPLES_X (lx, 8);
-            rxs = RENDER_SAMPLES_X (rx, 8);
+            if (rx == rx_old)
+            {
+                rxi = rxi_old;
+                rxs = rxs_old;
+            }
+            else
+            {
+                rxi_old = rxi = pixman_fixed_to_int (rx);
+                rxs_old = rxs = RENDER_SAMPLES_X (rx, 8);
+                rx_old = rx;
+            }
 
             /* Add coverage across row */
             if (lxi == rxi)
             {
                 WRITE (image, ap + lxi,
 		       clip255 (READ (image, ap + lxi) + rxs - lxs));
 	    }
             else

diff -r 6a3897dad583 gfx/cairo/libpixman/src/pixman-private.h
--- a/gfx/cairo/libpixman/src/pixman-private.h	Sat Oct 06 15:30:41 2012 +0900
+++ b/gfx/cairo/libpixman/src/pixman-private.h	Sat Oct 06 15:47:32 2012 +0900
@@ -991,9 +991,16 @@ void pixman_timer_register (pixman_timer
 	begin ## tname = OIL_STAMP ();
 
 #define TIMER_END(tname)                                                \
     timer ## tname.total += OIL_STAMP () - begin ## tname;		\
     }
 
 #endif /* PIXMAN_TIMERS */
 
+#ifdef TT_MEMUTIL
+extern pixman_bool_t nt_initialized;
+extern uint32_t dwNonTemporalDataSizeMin;
+extern uint32_t dwNonTemporalMemcpySizeMin;
+void InitializeNonTemporalData();
+#endif /* TT_MEMUTIL */
+
 #endif /* PIXMAN_PRIVATE_H */

diff -r 7f26aac55b28 gfx/cairo/libpixman/src/pixman-sse2.c
--- a/gfx/cairo/libpixman/src/pixman-sse2.c	Sat Jul 14 16:55:18 2012 +0900
+++ b/gfx/cairo/libpixman/src/pixman-sse2.c	Sun Jul 15 20:18:12 2012 +0900
@@ -349,16 +349,23 @@ load_128_unaligned (const __m128i* src)
  */
 static force_inline void
 save_128_write_combining (__m128i* dst,
                           __m128i  data)
 {
     _mm_stream_si128 (dst, data);
 }
 
+/* save 1 pixels using Write Combining memory */
+static force_inline void
+save_32_write_combining (int* dst, int data)
+{
+    _mm_stream_si32 (dst, data);
+}
+
 /* save 4 pixels on a 16-byte boundary aligned address */
 static force_inline void
 save_128_aligned (__m128i* dst,
                   __m128i  data)
 {
     _mm_store_si128 (dst, data);
 }
 
@@ -3227,28 +3234,36 @@ sse2_composite_over_n_8_8888 (pixman_imp
 
 	    w--;
 	    dst++;
 	}
     }
 
 }
 
+#ifdef TT_MEMUTIL
+extern uint32_t dwNonTemporalDataSizeMin;
+extern uint32_t dwNonTemporalMemcpySizeMin;
+#endif
+
 static pixman_bool_t
 pixman_fill_sse2 (uint32_t *bits,
                   int       stride,
                   int       bpp,
                   int       x,
                   int       y,
                   int       width,
                   int       height,
                   uint32_t  data)
 {
     uint32_t byte_width;
     uint8_t         *byte_line;
+#ifdef TT_MEMUTIL
+    pixman_bool_t use_nontemporal_fill;
+#endif
 
     __m128i xmm_def;
 
     if (bpp == 8)
     {
 	uint8_t b;
 	uint16_t w;
 
@@ -3277,16 +3292,20 @@ pixman_fill_sse2 (uint32_t *bits,
 	byte_width = 4 * width;
 	stride *= 4;
     }
     else
     {
 	return FALSE;
     }
 
+#ifdef TT_MEMUTIL
+    use_nontemporal_fill = ((uint32_t)(byte_width * height) > dwNonTemporalDataSizeMin);
+#endif
+
     xmm_def = create_mask_2x32_128 (data, data);
 
     while (height--)
     {
 	int w;
 	uint8_t *d = byte_line;
 	byte_line += stride;
 	w = byte_width;
@@ -3300,16 +3319,81 @@ pixman_fill_sse2 (uint32_t *bits,
 
 	while (w >= 2 && ((unsigned long)d & 3))
 	{
 	    *(uint16_t *)d = data;
 	    w -= 2;
 	    d += 2;
 	}
 
+#ifdef TT_MEMUTIL
+if (use_nontemporal_fill)
+{
+	while (w >= 4 && ((unsigned long)d & 15))
+	{
+	    save_32_write_combining ((int*)d, (int)data);
+
+	    w -= 4;
+	    d += 4;
+	}
+
+	while (w >= 128)
+	{
+	    save_128_write_combining ((__m128i*)(d),     xmm_def);
+	    save_128_write_combining ((__m128i*)(d + 16),  xmm_def);
+	    save_128_write_combining ((__m128i*)(d + 32),  xmm_def);
+	    save_128_write_combining ((__m128i*)(d + 48),  xmm_def);
+	    save_128_write_combining ((__m128i*)(d + 64),  xmm_def);
+	    save_128_write_combining ((__m128i*)(d + 80),  xmm_def);
+	    save_128_write_combining ((__m128i*)(d + 96),  xmm_def);
+	    save_128_write_combining ((__m128i*)(d + 112), xmm_def);
+
+	    d += 128;
+	    w -= 128;
+	}
+
+	if (w >= 64)
+	{
+	    save_128_write_combining ((__m128i*)(d),     xmm_def);
+	    save_128_write_combining ((__m128i*)(d + 16),  xmm_def);
+	    save_128_write_combining ((__m128i*)(d + 32),  xmm_def);
+	    save_128_write_combining ((__m128i*)(d + 48),  xmm_def);
+
+	    d += 64;
+	    w -= 64;
+	}
+
+	if (w >= 32)
+	{
+	    save_128_write_combining ((__m128i*)(d),     xmm_def);
+	    save_128_write_combining ((__m128i*)(d + 16),  xmm_def);
+
+	    d += 32;
+	    w -= 32;
+	}
+
+	if (w >= 16)
+	{
+	    save_128_write_combining ((__m128i*)(d),     xmm_def);
+
+	    d += 16;
+	    w -= 16;
+	}
+
+	while (w >= 4)
+	{
+	    save_32_write_combining ((int*)d, (int)data);
+
+	    w -= 4;
+	    d += 4;
+	}
+}
+else
+#endif
+{
 	while (w >= 4 && ((unsigned long)d & 15))
 	{
 	    *(uint32_t *)d = data;
 
 	    w -= 4;
 	    d += 4;
 	}
 
@@ -3358,32 +3442,40 @@ pixman_fill_sse2 (uint32_t *bits,
 
 	while (w >= 4)
 	{
 	    *(uint32_t *)d = data;
 
 	    w -= 4;
 	    d += 4;
 	}
+}
 
 	if (w >= 2)
 	{
 	    *(uint16_t *)d = data;
 	    w -= 2;
 	    d += 2;
 	}
 
 	if (w >= 1)
 	{
 	    *(uint8_t *)d = data;
 	    w -= 1;
 	    d += 1;
 	}
     }
 
+#ifdef TT_MEMUTIL
+    if (use_nontemporal_fill)
+    {
+        _mm_sfence();
+    }
+#endif
+
     return TRUE;
 }
 
 static void
 sse2_composite_src_n_8_8888 (pixman_implementation_t *imp,
                              pixman_composite_info_t *info)
 {
     PIXMAN_COMPOSITE_ARGS (info);
@@ -4457,16 +4549,19 @@ pixman_blt_sse2 (uint32_t *src_bits,
                  int       dest_x,
                  int       dest_y,
                  int       width,
                  int       height)
 {
     uint8_t *   src_bytes;
     uint8_t *   dst_bytes;
     int byte_width;
+#ifdef TT_MEMUTIL
+    pixman_bool_t use_nontemporal_copy;
+#endif
 
     if (src_bpp != dst_bpp)
 	return FALSE;
 
     if (src_bpp == 16)
     {
 	src_stride = src_stride * (int) sizeof (uint32_t) / 2;
 	dst_stride = dst_stride * (int) sizeof (uint32_t) / 2;
@@ -4486,16 +4581,20 @@ pixman_blt_sse2 (uint32_t *src_bits,
 	src_stride *= 4;
 	dst_stride *= 4;
     }
     else
     {
 	return FALSE;
     }
 
+#ifdef TT_MEMUTIL
+    use_nontemporal_copy = ((uint32_t)(byte_width * height) > dwNonTemporalMemcpySizeMin);
+#endif
+
     while (height--)
     {
 	int w;
 	uint8_t *s = src_bytes;
 	uint8_t *d = dst_bytes;
 	src_bytes += src_stride;
 	dst_bytes += dst_stride;
 	w = byte_width;
@@ -4503,34 +4602,88 @@ pixman_blt_sse2 (uint32_t *src_bits,
 	while (w >= 2 && ((unsigned long)d & 3))
 	{
 	    *(uint16_t *)d = *(uint16_t *)s;
 	    w -= 2;
 	    s += 2;
 	    d += 2;
 	}
 
+#ifdef TT_MEMUTIL
+if (use_nontemporal_copy)
+{
 	while (w >= 4 && ((unsigned long)d & 15))
 	{
-	    *(uint32_t *)d = *(uint32_t *)s;
+	    save_32_write_combining ((int*)d, *(int*)s);
 
 	    w -= 4;
 	    s += 4;
 	    d += 4;
 	}
 
 	while (w >= 64)
 	{
 	    __m128i xmm0, xmm1, xmm2, xmm3;
 
+	    _mm_prefetch((char const *)s + (200*64/34+192), _MM_HINT_NTA);
+
 	    xmm0 = load_128_unaligned ((__m128i*)(s));
 	    xmm1 = load_128_unaligned ((__m128i*)(s + 16));
 	    xmm2 = load_128_unaligned ((__m128i*)(s + 32));
 	    xmm3 = load_128_unaligned ((__m128i*)(s + 48));
 
+	    save_128_write_combining ((__m128i*)(d),    xmm0);
+	    save_128_write_combining ((__m128i*)(d + 16), xmm1);
+	    save_128_write_combining ((__m128i*)(d + 32), xmm2);
+	    save_128_write_combining ((__m128i*)(d + 48), xmm3);
+
+	    s += 64;
+	    d += 64;
+	    w -= 64;
+	}
+
+	while (w >= 16)
+	{
+	    save_128_write_combining ((__m128i*)d, load_128_unaligned ((__m128i*)s) );
+
+	    w -= 16;
+	    d += 16;
+	    s += 16;
+	}
+
+	while (w >= 4)
+	{
+	    save_32_write_combining ((int*)d, *(int*)s);
+
+	    w -= 4;
+	    s += 4;
+	    d += 4;
+	}
+}
+else
+#endif
+{
+	while (w >= 4 && ((unsigned long)d & 15))
+	{
+	    *(uint32_t *)d = *(uint32_t *)s;
+
+	    w -= 4;
+	    s += 4;
+	    d += 4;
+	}
+
+	while (w >= 64)
+	{
+	    __m128i xmm0, xmm1, xmm2, xmm3;
+
+	    xmm0 = load_128_unaligned ((__m128i*)(s));
+	    xmm1 = load_128_unaligned ((__m128i*)(s + 16));
+	    xmm2 = load_128_unaligned ((__m128i*)(s + 32));
+	    xmm3 = load_128_unaligned ((__m128i*)(s + 48));
+
 	    save_128_aligned ((__m128i*)(d),    xmm0);
 	    save_128_aligned ((__m128i*)(d + 16), xmm1);
 	    save_128_aligned ((__m128i*)(d + 32), xmm2);
 	    save_128_aligned ((__m128i*)(d + 48), xmm3);
 
 	    s += 64;
 	    d += 64;
 	    w -= 64;
@@ -4548,26 +4701,33 @@ pixman_blt_sse2 (uint32_t *src_bits,
 	while (w >= 4)
 	{
 	    *(uint32_t *)d = *(uint32_t *)s;
 
 	    w -= 4;
 	    s += 4;
 	    d += 4;
 	}
+}
 
 	if (w >= 2)
 	{
 	    *(uint16_t *)d = *(uint16_t *)s;
 	    w -= 2;
 	    s += 2;
 	    d += 2;
 	}
     }
 
+#ifdef TT_MEMUTIL
+    if (use_nontemporal_copy)
+    {
+        _mm_sfence();
+    }
+#endif
 
     return TRUE;
 }
 
 static void
 sse2_composite_copy_area (pixman_implementation_t *imp,
                           pixman_composite_info_t *info)
 {

diff -r 28eff799c22e gfx/cairo/libpixman/src/pixman-trap.c
--- a/gfx/cairo/libpixman/src/pixman-trap.c	Thu Sep 06 17:23:00 2012 +0900
+++ b/gfx/cairo/libpixman/src/pixman-trap.c	Sat Sep 29 14:24:58 2012 +0900
@@ -20,75 +20,123 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+#include <omp.h>
+#endif
+#include <limits.h>
+
 #include <stdio.h>
 #include <stdlib.h>
 #include "pixman-private.h"
 
 /*
  * Compute the smallest value greater than or equal to y which is on a
  * grid row.
  */
 
 PIXMAN_EXPORT pixman_fixed_t
 pixman_sample_ceil_y (pixman_fixed_t y, int n)
 {
     pixman_fixed_t f = pixman_fixed_frac (y);
     pixman_fixed_t i = pixman_fixed_floor (y);
 
+if (8 == n)
+{
+    f = DIV (f - Y_FRAC_FIRST (8) + (STEP_Y_SMALL (8) - pixman_fixed_e), STEP_Y_SMALL (8)) * STEP_Y_SMALL (8) +
+	Y_FRAC_FIRST (8);
+    
+    if (f > Y_FRAC_LAST (8))
+    {
+	if (pixman_fixed_to_int (i) == 0x7fff)
+	{
+	    f = 0xffff; /* saturate */
+	}
+	else
+	{
+	    f = Y_FRAC_FIRST (8);
+	    i += pixman_fixed_1;
+	}
+    }
+}
+else
+{
     f = DIV (f - Y_FRAC_FIRST (n) + (STEP_Y_SMALL (n) - pixman_fixed_e), STEP_Y_SMALL (n)) * STEP_Y_SMALL (n) +
 	Y_FRAC_FIRST (n);
     
     if (f > Y_FRAC_LAST (n))
     {
 	if (pixman_fixed_to_int (i) == 0x7fff)
 	{
 	    f = 0xffff; /* saturate */
 	}
 	else
 	{
 	    f = Y_FRAC_FIRST (n);
 	    i += pixman_fixed_1;
 	}
     }
+}
     return (i | f);
 }
 
 /*
  * Compute the largest value strictly less than y which is on a
  * grid row.
  */
 PIXMAN_EXPORT pixman_fixed_t
 pixman_sample_floor_y (pixman_fixed_t y,
                        int            n)
 {
     pixman_fixed_t f = pixman_fixed_frac (y);
     pixman_fixed_t i = pixman_fixed_floor (y);
 
+if (8 == n)
+{
+    f = DIV (f - pixman_fixed_e - Y_FRAC_FIRST (8), STEP_Y_SMALL (8)) * STEP_Y_SMALL (8) +
+	Y_FRAC_FIRST (8);
+
+    if (f < Y_FRAC_FIRST (8))
+    {
+	if (pixman_fixed_to_int (i) == 0x8000)
+	{
+	    f = 0; /* saturate */
+	}
+	else
+	{
+	    f = Y_FRAC_LAST (8);
+	    i -= pixman_fixed_1;
+	}
+    }
+}
+else
+{
     f = DIV (f - pixman_fixed_e - Y_FRAC_FIRST (n), STEP_Y_SMALL (n)) * STEP_Y_SMALL (n) +
 	Y_FRAC_FIRST (n);
 
     if (f < Y_FRAC_FIRST (n))
     {
 	if (pixman_fixed_to_int (i) == 0x8000)
 	{
 	    f = 0; /* saturate */
 	}
 	else
 	{
 	    f = Y_FRAC_LAST (n);
 	    i -= pixman_fixed_1;
 	}
     }
+}
+
     return (i | f);
 }
 
 /*
  * Step an edge by any amount (including negative values)
  */
 PIXMAN_EXPORT void
 pixman_edge_step (pixman_edge_t *e,
@@ -181,21 +229,32 @@ pixman_edge_init (pixman_edge_t *e,
 	else
 	{
 	    e->signdx = -1;
 	    e->stepx = -(-dx / dy);
 	    e->dx = -dx % dy;
 	    e->e = 0;
 	}
 
+if (8 == n)
+{
+	_pixman_edge_multi_init (e, STEP_Y_SMALL (8),
+				 &e->stepx_small, &e->dx_small);
+
+	_pixman_edge_multi_init (e, STEP_Y_BIG (8),
+				 &e->stepx_big, &e->dx_big);
+}
+else
+{
 	_pixman_edge_multi_init (e, STEP_Y_SMALL (n),
 				 &e->stepx_small, &e->dx_small);
 
 	_pixman_edge_multi_init (e, STEP_Y_BIG (n),
 				 &e->stepx_big, &e->dx_big);
+}
     }
     pixman_edge_step (e, y_start - y_top);
 }
 
 /*
  * Initialize one edge structure given a line, starting y value
  * and a pixel offset for the line
  */
@@ -322,25 +381,47 @@ pixman_add_trapezoids (pixman_image_t * 
                        const pixman_trapezoid_t *traps)
 {
     int i;
 
 #if 0
     dump_image (image, "before");
 #endif
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+int omp_thread_counts = omp_get_max_threads();
+if (omp_thread_counts >= 2 &&
+    ntraps >= omp_thread_counts &&
+    ntraps >= 160)
+{
+#pragma omp parallel for schedule(guided) default(none) \
+shared(ntraps, traps, image, x_off, y_off)
+    for (i = 0; i < ntraps; ++i)
+    {
+	const pixman_trapezoid_t *trap = &(traps[i]);
+
+	if (pixman_trapezoid_valid (trap))
+	{
+		pixman_rasterize_trapezoid (image, trap, x_off, y_off);
+	}
+    }
+}
+else
+#endif
+{
     for (i = 0; i < ntraps; ++i)
     {
 	const pixman_trapezoid_t *trap = &(traps[i]);
 
 	if (!pixman_trapezoid_valid (trap))
 	    continue;
 
 	pixman_rasterize_trapezoid (image, trap, x_off, y_off);
     }
+}
 
 #if 0
     dump_image (image, "after");
 #endif
 }
 
 PIXMAN_EXPORT void
 pixman_rasterize_trapezoid (pixman_image_t *          image,

diff -r 284837bbf631 xpcom/glue/pldhash.cpp
--- a/xpcom/glue/pldhash.cpp	Sat Aug 25 07:23:12 2012 +0900
+++ b/xpcom/glue/pldhash.cpp	Sat Aug 25 09:42:51 2012 +0900
@@ -3,16 +3,19 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /*
  * Double hashing implementation.
  *
  * Try to keep this file in sync with js/src/jsdhash.cpp.
  */
+#if _MSC_VER >= 1400
+#include <intrin.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include "prbit.h"
 #include "pldhash.h"
 #include "mozilla/HashFunctions.h"
 #include "nsDebug.h"     /* for PR_ASSERT */
 
@@ -123,23 +126,39 @@ PL_DHashMatchStringKey(PLDHashTable *tab
             strcmp((const char *) stub->key, (const char *) key) == 0);
 }
 
 void
 PL_DHashMoveEntryStub(PLDHashTable *table,
                       const PLDHashEntryHdr *from,
                       PLDHashEntryHdr *to)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __movsd((unsigned long*)to, (unsigned long*)from, table->entrySize >> 2);
+    } else {
+        memcpy(to, from, table->entrySize);
+    }
+#else
     memcpy(to, from, table->entrySize);
+#endif
 }
 
 void
 PL_DHashClearEntryStub(PLDHashTable *table, PLDHashEntryHdr *entry)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __stosd((unsigned long*)entry, 0, table->entrySize >> 2);
+    } else {
+        memset(entry, 0, table->entrySize);
+    }
+#else
     memset(entry, 0, table->entrySize);
+#endif
 }
 
 void
 PL_DHashFreeStringKey(PLDHashTable *table, PLDHashEntryHdr *entry)
 {
     const PLDHashEntryStub *stub = (const PLDHashEntryStub *)entry;
 
     free((void *) stub->key);
@@ -530,17 +549,39 @@ ChangeTable(PLDHashTable *table, int del
 #ifdef DEBUG
     recursionLevel = RECURSION_LEVEL(table);
 #endif
     table->hashShift = PL_DHASH_BITS - newLog2;
     table->removedCount = 0;
     table->generation++;
 
     /* Assign the new entry store to table. */
+#ifdef TT_MEMUTIL
+    {
+        static PRBool initialized = PR_FALSE;
+        static PRUint32 dwNonTemporalDataSizeMin = NON_TEMPORAL_STORES_NOT_SUPPORTED;
+
+        if (!initialized) {
+            dwNonTemporalDataSizeMin = GetNonTemporalDataSizeMin_tt();
+            initialized = PR_TRUE;
+        }
+
+        if (nbytes < dwNonTemporalDataSizeMin ||
+            NON_TEMPORAL_STORES_NOT_SUPPORTED == dwNonTemporalDataSizeMin)
+        {
+            memset(newEntryStore, 0, nbytes);
+        }
+        else
+        {
+            memset_nontemporal_tt(newEntryStore, 0, nbytes);
+        }
+    }
+#else
     memset(newEntryStore, 0, nbytes);
+#endif
     oldEntryAddr = oldEntryStore = table->entryStore;
     table->entryStore = newEntryStore;
     moveEntry = table->ops->moveEntry;
 #ifdef DEBUG
     RECURSION_LEVEL(table) = recursionLevel;
 #endif
 
     /* Copy only live entries, leaving removed ones behind. */

diff -r 284837bbf631 nsprpub/pr/src/io/prsocket.c
--- a/nsprpub/pr/src/io/prsocket.c	Sat Aug 25 07:23:12 2012 +0900
+++ b/nsprpub/pr/src/io/prsocket.c	Sat Aug 25 09:43:59 2012 +0900
@@ -283,24 +283,16 @@ static PRStatus PR_CALLBACK SocketConnec
     if (err != 0) {
         _PR_MD_MAP_CONNECT_ERROR(err);
         return PR_FAILURE;
     }
     return PR_SUCCESS;
 
 #elif defined(WIN32) || defined(WIN16)
 
-#if defined(WIN32)
-    /*
-     * The sleep circumvents a bug in Win32 WinSock.
-     * See Microsoft Knowledge Base article ID: Q165989.
-     */
-    Sleep(0);
-#endif /* WIN32 */
-
     if (out_flags & PR_POLL_EXCEPT) {
         int len = sizeof(err);
         if (getsockopt(osfd, (int)SOL_SOCKET, SO_ERROR, (char *) &err, &len)
                 == SOCKET_ERROR) {
             _PR_MD_MAP_GETSOCKOPT_ERROR(WSAGetLastError());
             return PR_FAILURE;
         }
         if (err != 0) {

diff --git a/js/src/gc/Root.h b/js/src/gc/Root.h
--- a/js/src/gc/Root.h
+++ b/js/src/gc/Root.h
@@ -95,18 +95,17 @@ class HandleBase {};
  * specialization, define a HandleBase<T> specialization containing them.
  */
 template <typename T>
 class Handle : public HandleBase<T>
 {
   public:
     /* Creates a handle from a handle of a type convertible to T. */
     template <typename S>
-    Handle(Handle<S> handle,
-           typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy = 0)
+    Handle(Handle<S> handle)
     {
         ptr = reinterpret_cast<const T *>(handle.address());
     }
 
     /* Create a handle for a NULL pointer. */
     Handle(NullPtr) {
         typedef typename js::tl::StaticAssert<js::tl::IsPointerType<T>::result>::result _;
         ptr = reinterpret_cast<const T *>(&NullPtr::constNullValue);
@@ -131,24 +130,22 @@ class Handle : public HandleBase<T>
     }
 
     /*
      * Construct a handle from an explicitly rooted location. This is the
      * normal way to create a handle, and normally happens implicitly.
      */
     template <typename S>
     inline
-    Handle(Rooted<S> &root,
-           typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy = 0);
+    Handle(Rooted<S> &root);
 
     /* Construct a read only handle from a mutable handle. */
     template <typename S>
     inline
-    Handle(MutableHandle<S> &root,
-           typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy = 0);
+    Handle(MutableHandle<S> &root);
 
     const T *address() const { return ptr; }
     T get() const { return *ptr; }
 
     operator T () const { return get(); }
     T operator ->() const { return get(); }
 
   private:
@@ -178,26 +175,24 @@ class MutableHandleBase {};
  * specialization, define a MutableHandleBase<T> specialization containing
  * them.
  */
 template <typename T>
 class MutableHandle : public MutableHandleBase<T>
 {
   public:
     template <typename S>
-    MutableHandle(MutableHandle<S> handle,
-                  typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy = 0)
+    MutableHandle(MutableHandle<S> handle)
     {
         this->ptr = reinterpret_cast<const T *>(handle.address());
     }
 
     template <typename S>
     inline
-    MutableHandle(Rooted<S> *root,
-                  typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy = 0);
+    MutableHandle(Rooted<S> *root);
 
     void set(T v)
     {
         JS_ASSERT(!RootMethods<T>::poisoned(v));
         *ptr = v;
     }
 
     /*
@@ -355,34 +350,31 @@ class Rooted : public RootedBase<T>
     T ptr;
 
     Rooted() MOZ_DELETE;
     Rooted(const Rooted &) MOZ_DELETE;
 };
 
 template<typename T> template <typename S>
 inline
-Handle<T>::Handle(Rooted<S> &root,
-                  typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy)
+Handle<T>::Handle(Rooted<S> &root)
 {
     ptr = reinterpret_cast<const T *>(root.address());
 }
 
 template<typename T> template <typename S>
 inline
-Handle<T>::Handle(MutableHandle<S> &root,
-                  typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy)
+Handle<T>::Handle(MutableHandle<S> &root)
 {
     ptr = reinterpret_cast<const T *>(root.address());
 }
 
 template<typename T> template <typename S>
 inline
-MutableHandle<T>::MutableHandle(Rooted<S> *root,
-                                typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy)
+MutableHandle<T>::MutableHandle(Rooted<S> *root)
 {
     ptr = root->address();
 }
 
 typedef Rooted<JSObject*>    RootedObject;
 typedef Rooted<JSFunction*>  RootedFunction;
 typedef Rooted<JSScript*>    RootedScript;
 typedef Rooted<JSString*>    RootedString;

diff -r 6a3897dad583 security/manager/ssl/src/Makefile.in
--- a/security/manager/ssl/src/Makefile.in	Sat Oct 06 15:30:41 2012 +0900
+++ b/security/manager/ssl/src/Makefile.in	Sat Oct 06 16:23:11 2012 +0900
@@ -94,8 +94,14 @@ EXPORTS += \
   $(NULL)
 
 # Use local includes because they are inserted before INCLUDES
 # so that Mozilla's nss.h is used, not glibc's
 LOCAL_INCLUDES += $(NSS_CFLAGS)
 
 include $(topsrcdir)/config/rules.mk
 
+ifdef MOZ_THUNDERBIRD
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# avoid the fatal error C1001 of compiler when applying PGO to Thunderbird
+COMPILE_CXXFLAGS += -GL-
+endif
+endif

diff --git a/content/svg/content/src/Makefile.in b/content/svg/content/src/Makefile.in
--- a/content/svg/content/src/Makefile.in
+++ b/content/svg/content/src/Makefile.in
@@ -154,8 +154,21 @@ INCLUDES += 	\
 		-I$(srcdir)/../../../../layout/style \
 		-I$(srcdir)/../../../events/src \
 		-I$(srcdir)/../../../html/content/src \
 		-I$(topsrcdir)/content/xbl/src \
 		-I$(srcdir)/../../../smil \
 		$(NULL)
 
 DEFINES += -D_IMPL_NS_LAYOUT
+
+ifdef _MSC_VER
+ifneq (,$(filter -DTT_MEMUTIL,$(MOZ_OPTIMIZE_FLAGS)))
+nsSVGFilters.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL- -openmp
+endif
+endif
+
+ifdef MOZ_THUNDERBIRD
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# avoid the fatal error C1001 of compiler when applying PGO to Thunderbird
+COMPILE_CXXFLAGS += -GL-
+endif
+endif

diff -r 6a3897dad583 mfbt/ThreadLocal.h
--- a/mfbt/ThreadLocal.h	Sat Oct 06 15:30:41 2012 +0900
+++ b/mfbt/ThreadLocal.h	Sat Oct 06 15:40:43 2012 +0900
@@ -12,17 +12,27 @@
 // This file will get included in any file that wants to add a profiler mark.
 // In order to not bring <windows.h> together we could include windef.h and
 // winbase.h which are sufficient to get the prototypes for the Tls* functions.
 // # include <windef.h>
 // # include <winbase.h>
 // Unfortunately, even including these headers causes us to add a bunch of ugly
 // stuff to our namespace e.g #define CreateEvent CreateEventW
 extern "C" {
+#if _MSC_VER >= 1400
+#ifdef _WIN64
+unsigned __int64 __readgsqword(unsigned long Offset);
+#pragma intrinsic(__readgsqword)
+#else /* _WIN64 */
+unsigned long __readfsdword(unsigned long Offset);
+#pragma intrinsic(__readfsdword)
+#endif /* _WIN64 */
+#else
 __declspec(dllimport) void * __stdcall TlsGetValue(unsigned long);
+#endif /* _MSC_VER >= 1400 */
 __declspec(dllimport) int __stdcall TlsSetValue(unsigned long, void *);
 __declspec(dllimport) unsigned long __stdcall TlsAlloc();
 }
 #else
 #  include <pthread.h>
 #  include <signal.h>
 #endif
 
@@ -113,17 +123,25 @@ ThreadLocal<T>::init()
 
 template<typename T>
 inline T
 ThreadLocal<T>::get() const
 {
   MOZ_ASSERT(initialized());
   Helper h;
 #ifdef XP_WIN
+#if _MSC_VER >= 1400
+#ifdef _WIN64
+  h.ptr = (void *)(__readgsqword(key * 8 + 0x1480));
+#else /* _WIN64 */
+  h.ptr = (void *)(*(unsigned long *)(__readfsdword(0x18) + key * 4 + 3600));
+#endif /* _WIN64 */
+#else
   h.ptr = TlsGetValue(key);
+#endif /* _MSC_VER >= 1400 */
 #else
   h.ptr = pthread_getspecific(key);
 #endif
   return h.value;
 }
 
 template<typename T>
 inline bool

diff -r 28eff799c22e gfx/qcms/transform.c
--- a/gfx/qcms/transform.c	Thu Sep 06 17:23:00 2012 +0900
+++ b/gfx/qcms/transform.c	Tue Sep 25 17:55:09 2012 +0900
@@ -30,16 +30,75 @@
 #include "matrix.h"
 #include "transform_util.h"
 
 /* for MSVC, GCC, Intel, and Sun compilers */
 #if defined(_M_IX86) || defined(__i386__) || defined(__i386) || defined(_M_AMD64) || defined(__x86_64__) || defined(__x86_64)
 #define X86
 #endif /* _M_IX86 || __i386__ || __i386 || _M_AMD64 || __x86_64__ || __x86_64 */
 
+#ifdef X86
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+#else  /* _MSC_VER == 1400 */
+#include <smmintrin.h>
+#endif /* _MSC_VER == 1400 */
+#include "mozilla/Attributes.h"
+
+#if defined(_M_IX86) && _MSC_VER == 1400
+__declspec(naked) __declspec(noinline)
+void __fastcall floor_ps_sse4_1(const __m128 * __restrict src, __m128i * __restrict dest) {
+	__asm {
+		/* roundps  xmm0, xmmword ptr [ecx], 1 */
+		__asm _emit 0x66
+		__asm _emit 0x0F
+		__asm _emit 0x3A
+		__asm _emit 0x08
+		__asm _emit 0x01
+		__asm _emit 0x01
+		cvttps2dq   xmm0, xmm0
+		movdqa      xmmword ptr [edx], xmm0
+		ret
+	}
+}
+
+__declspec(naked) __declspec(noinline)
+void __fastcall ceil_ps_sse4_1(const __m128 * __restrict src, __m128i * __restrict dest) {
+	__asm {
+		/* roundps  xmm0, xmmword ptr [ecx], 2 */
+		__asm _emit 0x66
+		__asm _emit 0x0F
+		__asm _emit 0x3A
+		__asm _emit 0x08
+		__asm _emit 0x01
+		__asm _emit 0x02
+		cvttps2dq   xmm0, xmm0
+		movdqa      xmmword ptr [edx], xmm0
+		ret
+	}
+}
+#endif
+
+int sse_version_available(void);
+
+static const ALIGN float ps255[4]  = { 255, 255, 255, 255 };
+static const ALIGN float psZero[4] = {   0,   0,   0,   0 };
+static const ALIGN float psHalf[4] = { 0.5, 0.5, 0.5, 0.5 };
+
+MOZ_ALWAYS_INLINE
+void clamp_u8_sse2(const __m128 *src, __m128i *dest) {
+	__m128 x = *src;
+
+	x = _mm_mul_ps(x, *(__m128 *)&ps255);
+	x = _mm_min_ps(x, *(__m128 *)&ps255);
+	x = _mm_max_ps(x, *(__m128 *)&psZero);
+	*dest = _mm_cvttps_epi32(_mm_add_ps(x, *(__m128 *)&psHalf));
+}
+#endif /* X86 */
+
 // Build a White point, primary chromas transfer matrix from RGB to CIE XYZ
 // This is just an approximation, I am not handling all the non-linear
 // aspects of the RGB to XYZ process, and assumming that the gamma correction
 // has transitive property in the tranformation chain.
 //
 // the alghoritm:
 //
 //            - First I build the absolute conversion matrix using
@@ -229,16 +288,21 @@ qcms_bool set_rgb_colorants(qcms_profile
 	return true;
 }
 
 #if 0
 static void qcms_transform_data_rgb_out_pow(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 {
 	int i;
 	float (*mat)[4] = transform->matrix;
+#ifdef X86
+	int sse_ver = sse_version_available();
+	__m128 xm;
+	__m128i xi;
+#endif
 	for (i=0; i<length; i++) {
 		unsigned char device_r = *src++;
 		unsigned char device_g = *src++;
 		unsigned char device_b = *src++;
 
 		float linear_r = transform->input_gamma_table_r[device_r];
 		float linear_g = transform->input_gamma_table_g[device_g];
 		float linear_b = transform->input_gamma_table_b[device_b];
@@ -246,65 +310,120 @@ static void qcms_transform_data_rgb_out_
 		float out_linear_r = mat[0][0]*linear_r + mat[1][0]*linear_g + mat[2][0]*linear_b;
 		float out_linear_g = mat[0][1]*linear_r + mat[1][1]*linear_g + mat[2][1]*linear_b;
 		float out_linear_b = mat[0][2]*linear_r + mat[1][2]*linear_g + mat[2][2]*linear_b;
 
 		float out_device_r = pow(out_linear_r, transform->out_gamma_r);
 		float out_device_g = pow(out_linear_g, transform->out_gamma_g);
 		float out_device_b = pow(out_linear_b, transform->out_gamma_b);
 
-		*dest++ = clamp_u8(255*out_device_r);
-		*dest++ = clamp_u8(255*out_device_g);
-		*dest++ = clamp_u8(255*out_device_b);
+#ifdef X86
+		if (sse_ver >= 2) {
+			xm.m128_f32[0] = out_device_r;
+			xm.m128_f32[1] = out_device_g;
+			xm.m128_f32[2] = out_device_b;
+			clamp_u8_sse2(&xm, &xi);
+
+			*dest++ = xi.m128i_u32[0];
+			*dest++ = xi.m128i_u32[1];
+			*dest++ = xi.m128i_u32[2];
+		} else {
+#endif
+			*dest++ = clamp_u8(255*out_device_r);
+			*dest++ = clamp_u8(255*out_device_g);
+			*dest++ = clamp_u8(255*out_device_b);
+#ifdef X86
+		}
+#endif
 	}
 }
 #endif
 
 static void qcms_transform_data_gray_out_lut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 {
 	unsigned int i;
+#ifdef X86
+	int sse_ver = sse_version_available();
+	__m128 xm;
+	__m128i xi;
+#endif
 	for (i = 0; i < length; i++) {
 		float out_device_r, out_device_g, out_device_b;
 		unsigned char device = *src++;
 
 		float linear = transform->input_gamma_table_gray[device];
 
                 out_device_r = lut_interp_linear(linear, transform->output_gamma_lut_r, transform->output_gamma_lut_r_length);
 		out_device_g = lut_interp_linear(linear, transform->output_gamma_lut_g, transform->output_gamma_lut_g_length);
 		out_device_b = lut_interp_linear(linear, transform->output_gamma_lut_b, transform->output_gamma_lut_b_length);
 
-		*dest++ = clamp_u8(out_device_r*255);
-		*dest++ = clamp_u8(out_device_g*255);
-		*dest++ = clamp_u8(out_device_b*255);
+#ifdef X86
+		if (sse_ver >= 2) {
+			xm.m128_f32[0] = out_device_r;
+			xm.m128_f32[1] = out_device_g;
+			xm.m128_f32[2] = out_device_b;
+			clamp_u8_sse2(&xm, &xi);
+
+			*dest++ = xi.m128i_u32[0];
+			*dest++ = xi.m128i_u32[1];
+			*dest++ = xi.m128i_u32[2];
+		} else {
+#endif
+			*dest++ = clamp_u8(out_device_r*255);
+			*dest++ = clamp_u8(out_device_g*255);
+			*dest++ = clamp_u8(out_device_b*255);
+#ifdef X86
+		}
+#endif
 	}
 }
 
 /* Alpha is not corrected.
    A rationale for this is found in Alvy Ray's "Should Alpha Be Nonlinear If
    RGB Is?" Tech Memo 17 (December 14, 1998).
 	See: ftp://ftp.alvyray.com/Acrobat/17_Nonln.pdf
 */
 
 static void qcms_transform_data_graya_out_lut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 {
 	unsigned int i;
+#ifdef X86
+	int sse_ver = sse_version_available();
+	__m128 xm;
+	__m128i xi;
+#endif
 	for (i = 0; i < length; i++) {
 		float out_device_r, out_device_g, out_device_b;
 		unsigned char device = *src++;
 		unsigned char alpha = *src++;
 
 		float linear = transform->input_gamma_table_gray[device];
 
                 out_device_r = lut_interp_linear(linear, transform->output_gamma_lut_r, transform->output_gamma_lut_r_length);
 		out_device_g = lut_interp_linear(linear, transform->output_gamma_lut_g, transform->output_gamma_lut_g_length);
 		out_device_b = lut_interp_linear(linear, transform->output_gamma_lut_b, transform->output_gamma_lut_b_length);
 
-		*dest++ = clamp_u8(out_device_r*255);
-		*dest++ = clamp_u8(out_device_g*255);
-		*dest++ = clamp_u8(out_device_b*255);
+#ifdef X86
+		if (sse_ver >= 2) {
+			xm.m128_f32[0] = out_device_r;
+			xm.m128_f32[1] = out_device_g;
+			xm.m128_f32[2] = out_device_b;
+			clamp_u8_sse2(&xm, &xi);
+
+			*dest++ = xi.m128i_u32[0];
+			*dest++ = xi.m128i_u32[1];
+			*dest++ = xi.m128i_u32[2];
+		} else {
+#endif
+			*dest++ = clamp_u8(out_device_r*255);
+			*dest++ = clamp_u8(out_device_g*255);
+			*dest++ = clamp_u8(out_device_b*255);
+#ifdef X86
+		}
+#endif
 		*dest++ = alpha;
 	}
 }
 
 
 static void qcms_transform_data_gray_out_precache(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 {
 	unsigned int i;
@@ -416,22 +535,28 @@ static void qcms_transform_data_rgba_out
 static void qcms_transform_data_clut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length) {
 	unsigned int i;
 	int xy_len = 1;
 	int x_len = transform->grid_size;
 	int len = x_len * x_len;
 	float* r_table = transform->r_clut;
 	float* g_table = transform->g_clut;
 	float* b_table = transform->b_clut;
+	float rcp255 = 1.0f / 255.0f;
+#ifdef X86
+	int sse_ver = sse_version_available();
+	__m128 xm;
+	__m128i xi;
+#endif
   
 	for (i = 0; i < length; i++) {
 		unsigned char in_r = *src++;
 		unsigned char in_g = *src++;
 		unsigned char in_b = *src++;
-		float linear_r = in_r/255.0f, linear_g=in_g/255.0f, linear_b = in_b/255.0f;
+		float linear_r = in_r*rcp255, linear_g=in_g*rcp255, linear_b = in_b*rcp255;
 
 		int x = floor(linear_r * (transform->grid_size-1));
 		int y = floor(linear_g * (transform->grid_size-1));
 		int z = floor(linear_b * (transform->grid_size-1));
 		int x_n = ceil(linear_r * (transform->grid_size-1));
 		int y_n = ceil(linear_g * (transform->grid_size-1));
 		int z_n = ceil(linear_b * (transform->grid_size-1));
 		float x_d = linear_r * (transform->grid_size-1) - x; 
@@ -457,52 +582,121 @@ static void qcms_transform_data_clut(qcm
 		float b_x1 = lerp(CLU(b_table,x,y,z), CLU(b_table,x_n,y,z), x_d);
 		float b_x2 = lerp(CLU(b_table,x,y_n,z), CLU(b_table,x_n,y_n,z), x_d);
 		float b_y1 = lerp(b_x1, b_x2, y_d);
 		float b_x3 = lerp(CLU(b_table,x,y,z_n), CLU(b_table,x_n,y,z_n), x_d);
 		float b_x4 = lerp(CLU(b_table,x,y_n,z_n), CLU(b_table,x_n,y_n,z_n), x_d);
 		float b_y2 = lerp(b_x3, b_x4, y_d);
 		float clut_b = lerp(b_y1, b_y2, z_d);
 
-		*dest++ = clamp_u8(clut_r*255.0f);
-		*dest++ = clamp_u8(clut_g*255.0f);
-		*dest++ = clamp_u8(clut_b*255.0f);
+#ifdef X86
+		if (sse_ver >= 2) {
+			xm.m128_f32[0] = clut_r;
+			xm.m128_f32[1] = clut_g;
+			xm.m128_f32[2] = clut_b;
+			clamp_u8_sse2(&xm, &xi);
+
+			*dest++ = xi.m128i_u32[0];
+			*dest++ = xi.m128i_u32[1];
+			*dest++ = xi.m128i_u32[2];
+		} else {
+#endif
+			*dest++ = clamp_u8(clut_r*255.0f);
+			*dest++ = clamp_u8(clut_g*255.0f);
+			*dest++ = clamp_u8(clut_b*255.0f);
+#ifdef X86
+		}
+#endif
 	}	
 }
 */
 
 // Using lcms' tetra interpolation algorithm.
 static void qcms_transform_data_tetra_clut_rgba(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length) {
 	unsigned int i;
 	int xy_len = 1;
 	int x_len = transform->grid_size;
 	int len = x_len * x_len;
 	float* r_table = transform->r_clut;
 	float* g_table = transform->g_clut;
 	float* b_table = transform->b_clut;
-	float c0_r, c1_r, c2_r, c3_r;
-	float c0_g, c1_g, c2_g, c3_g;
-	float c0_b, c1_b, c2_b, c3_b;
-	float clut_r, clut_g, clut_b;
+	float rcp255 = 1.0f / 255.0f;
+#ifdef X86
+	int sse_ver = sse_version_available();
+#endif
+
 	for (i = 0; i < length; i++) {
-		unsigned char in_r = *src++;
-		unsigned char in_g = *src++;
-		unsigned char in_b = *src++;
-		unsigned char in_a = *src++;
-		float linear_r = in_r/255.0f, linear_g=in_g/255.0f, linear_b = in_b/255.0f;
+		float c0_r, c1_r, c2_r, c3_r;
+		float c0_g, c1_g, c2_g, c3_g;
+		float c0_b, c1_b, c2_b, c3_b;
+		float clut_r, clut_g, clut_b;
+		unsigned char in_r = src[i * 4 + 0];
+		unsigned char in_g = src[i * 4 + 1];
+		unsigned char in_b = src[i * 4 + 2];
+		unsigned char in_a = src[i * 4 + 3];
+		float linear_r = in_r*rcp255, linear_g=in_g*rcp255, linear_b = in_b*rcp255;
+#ifdef X86
+		__m128 xm;
+		__m128i xi;
+#endif
 
-		int x = floor(linear_r * (transform->grid_size-1));
-		int y = floor(linear_g * (transform->grid_size-1));
-		int z = floor(linear_b * (transform->grid_size-1));
-		int x_n = ceil(linear_r * (transform->grid_size-1));
-		int y_n = ceil(linear_g * (transform->grid_size-1));
-		int z_n = ceil(linear_b * (transform->grid_size-1));
-		float rx = linear_r * (transform->grid_size-1) - x; 
-		float ry = linear_g * (transform->grid_size-1) - y;
-		float rz = linear_b * (transform->grid_size-1) - z; 
+		int x;
+		int y;
+		int z;
+		int x_n;
+		int y_n;
+		int z_n;
+		float rx;
+		float ry;
+		float rz;
+		float lr = linear_r * (transform->grid_size-1);
+		float lg = linear_g * (transform->grid_size-1);
+		float lb = linear_b * (transform->grid_size-1);
+
+#if defined(X86) && !(defined(_M_AMD64) && _MSC_VER == 1400)
+		if (sse_ver >= 4) {
+			xm.m128_f32[0] = lr;
+			xm.m128_f32[1] = lg;
+			xm.m128_f32[2] = lb;
+
+#if _MSC_VER == 1400
+			floor_ps_sse4_1(&xm, &xi);
+#else
+			xi = _mm_cvttps_epi32(_mm_floor_ps(xm));
+#endif
+			x = _mm_cvtsi128_si32(xi);
+			y = _mm_cvtsi128_si32(xi = _mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+			z = _mm_cvtsi128_si32(_mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+
+#if _MSC_VER == 1400
+			ceil_ps_sse4_1(&xm, &xi);
+#else
+			xi = _mm_cvttps_epi32(_mm_ceil_ps(xm));
+#endif
+			x_n = _mm_cvtsi128_si32(xi);
+			y_n = _mm_cvtsi128_si32(xi = _mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+			z_n = _mm_cvtsi128_si32(_mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+
+			rx = lr - x; 
+			ry = lg - y;
+			rz = lb - z; 
+		} else {
+#endif /* defined(X86) && !(defined(_M_AMD64) && _MSC_VER == 1400) */
+			x = floor(lr);
+			y = floor(lg);
+			z = floor(lb);
+			x_n = ceil(lr);
+			y_n = ceil(lg);
+			z_n = ceil(lb);
+			rx = lr - x; 
+			ry = lg - y;
+			rz = lb - z; 
+#if defined(X86) && !(defined(_M_AMD64) && _MSC_VER == 1400)
+		}
+#endif
 
 		c0_r = CLU(r_table, x, y, z);
 		c0_g = CLU(g_table, x, y, z);
 		c0_b = CLU(b_table, x, y, z);
 
 		if( rx >= ry ) {
 			if (ry >= rz) { //rx >= ry && ry >= rz
 				c1_r = CLU(r_table, x_n, y, z) - c0_r;
@@ -572,51 +766,120 @@ static void qcms_transform_data_tetra_cl
 				}
 			}
 		}
 				
 		clut_r = c0_r + c1_r*rx + c2_r*ry + c3_r*rz;
 		clut_g = c0_g + c1_g*rx + c2_g*ry + c3_g*rz;
 		clut_b = c0_b + c1_b*rx + c2_b*ry + c3_b*rz;
 
-		*dest++ = clamp_u8(clut_r*255.0f);
-		*dest++ = clamp_u8(clut_g*255.0f);
-		*dest++ = clamp_u8(clut_b*255.0f);
-		*dest++ = in_a;
+#ifdef X86
+		if (sse_ver >= 2) {
+			xm.m128_f32[0] = clut_r;
+			xm.m128_f32[1] = clut_g;
+			xm.m128_f32[2] = clut_b;
+			clamp_u8_sse2(&xm, &xi);
+
+			dest[i * 4 + 0] = _mm_cvtsi128_si32(xi);
+			dest[i * 4 + 1] = _mm_cvtsi128_si32(xi = _mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+			dest[i * 4 + 2] = _mm_cvtsi128_si32(_mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+		} else {
+#endif
+			dest[i * 4 + 0] = clamp_u8(clut_r*255.0f);
+			dest[i * 4 + 1] = clamp_u8(clut_g*255.0f);
+			dest[i * 4 + 2] = clamp_u8(clut_b*255.0f);
+#ifdef X86
+		}
+#endif
+		dest[i * 4 + 3] = in_a;
 	}	
 }
 
 // Using lcms' tetra interpolation code.
 static void qcms_transform_data_tetra_clut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length) {
 	unsigned int i;
 	int xy_len = 1;
 	int x_len = transform->grid_size;
 	int len = x_len * x_len;
 	float* r_table = transform->r_clut;
 	float* g_table = transform->g_clut;
 	float* b_table = transform->b_clut;
-	float c0_r, c1_r, c2_r, c3_r;
-	float c0_g, c1_g, c2_g, c3_g;
-	float c0_b, c1_b, c2_b, c3_b;
-	float clut_r, clut_g, clut_b;
+	float rcp255 = 1.0f / 255.0f;
+#ifdef X86
+	int sse_ver = sse_version_available();
+#endif
+
 	for (i = 0; i < length; i++) {
-		unsigned char in_r = *src++;
-		unsigned char in_g = *src++;
-		unsigned char in_b = *src++;
-		float linear_r = in_r/255.0f, linear_g=in_g/255.0f, linear_b = in_b/255.0f;
+		float c0_r, c1_r, c2_r, c3_r;
+		float c0_g, c1_g, c2_g, c3_g;
+		float c0_b, c1_b, c2_b, c3_b;
+		float clut_r, clut_g, clut_b;
+		unsigned char in_r = src[i * 3 + 0];
+		unsigned char in_g = src[i * 3 + 1];
+		unsigned char in_b = src[i * 3 + 2];
+		float linear_r = in_r*rcp255, linear_g=in_g*rcp255, linear_b = in_b*rcp255;
+#ifdef X86
+		__m128 xm;
+		__m128i xi;
+#endif
 
-		int x = floor(linear_r * (transform->grid_size-1));
-		int y = floor(linear_g * (transform->grid_size-1));
-		int z = floor(linear_b * (transform->grid_size-1));
-		int x_n = ceil(linear_r * (transform->grid_size-1));
-		int y_n = ceil(linear_g * (transform->grid_size-1));
-		int z_n = ceil(linear_b * (transform->grid_size-1));
-		float rx = linear_r * (transform->grid_size-1) - x; 
-		float ry = linear_g * (transform->grid_size-1) - y;
-		float rz = linear_b * (transform->grid_size-1) - z; 
+		int x;
+		int y;
+		int z;
+		int x_n;
+		int y_n;
+		int z_n;
+		float rx;
+		float ry;
+		float rz;
+		float lr = linear_r * (transform->grid_size-1);
+		float lg = linear_g * (transform->grid_size-1);
+		float lb = linear_b * (transform->grid_size-1);
+
+#if defined(X86) && !(defined(_M_AMD64) && _MSC_VER == 1400)
+		if (sse_ver >= 4) {
+			xm.m128_f32[0] = lr;
+			xm.m128_f32[1] = lg;
+			xm.m128_f32[2] = lb;
+
+#if _MSC_VER == 1400
+			floor_ps_sse4_1(&xm, &xi);
+#else
+			xi = _mm_cvttps_epi32(_mm_floor_ps(xm));
+#endif
+			x = _mm_cvtsi128_si32(xi);
+			y = _mm_cvtsi128_si32(xi = _mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+			z = _mm_cvtsi128_si32(_mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+
+#if _MSC_VER == 1400
+			ceil_ps_sse4_1(&xm, &xi);
+#else
+			xi = _mm_cvttps_epi32(_mm_ceil_ps(xm));
+#endif
+			x_n = _mm_cvtsi128_si32(xi);
+			y_n = _mm_cvtsi128_si32(xi = _mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+			z_n = _mm_cvtsi128_si32(_mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+
+			rx = lr - x; 
+			ry = lg - y;
+			rz = lb - z; 
+		} else {
+#endif /* defined(X86) && !(defined(_M_AMD64) && _MSC_VER == 1400) */
+			x = floor(lr);
+			y = floor(lg);
+			z = floor(lb);
+			x_n = ceil(lr);
+			y_n = ceil(lg);
+			z_n = ceil(lb);
+			rx = lr - x; 
+			ry = lg - y;
+			rz = lb - z; 
+#if defined(X86) && !(defined(_M_AMD64) && _MSC_VER == 1400)
+		}
+#endif
 
 		c0_r = CLU(r_table, x, y, z);
 		c0_g = CLU(g_table, x, y, z);
 		c0_b = CLU(b_table, x, y, z);
 
 		if( rx >= ry ) {
 			if (ry >= rz) { //rx >= ry && ry >= rz
 				c1_r = CLU(r_table, x_n, y, z) - c0_r;
@@ -686,26 +949,46 @@ static void qcms_transform_data_tetra_cl
 				}
 			}
 		}
 				
 		clut_r = c0_r + c1_r*rx + c2_r*ry + c3_r*rz;
 		clut_g = c0_g + c1_g*rx + c2_g*ry + c3_g*rz;
 		clut_b = c0_b + c1_b*rx + c2_b*ry + c3_b*rz;
 
-		*dest++ = clamp_u8(clut_r*255.0f);
-		*dest++ = clamp_u8(clut_g*255.0f);
-		*dest++ = clamp_u8(clut_b*255.0f);
+#ifdef X86
+		if (sse_ver >= 2) {
+			xm.m128_f32[0] = clut_r;
+			xm.m128_f32[1] = clut_g;
+			xm.m128_f32[2] = clut_b;
+			clamp_u8_sse2(&xm, &xi);
+
+			dest[i * 3 + 0] = _mm_cvtsi128_si32(xi);
+			dest[i * 3 + 1] = _mm_cvtsi128_si32(xi = _mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+			dest[i * 3 + 2] = _mm_cvtsi128_si32(_mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+		} else {
+#endif
+			dest[i * 3 + 0] = clamp_u8(clut_r*255.0f);
+			dest[i * 3 + 1] = clamp_u8(clut_g*255.0f);
+			dest[i * 3 + 2] = clamp_u8(clut_b*255.0f);
+#ifdef X86
+		}
+#endif
 	}	
 }
 
 static void qcms_transform_data_rgb_out_lut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 {
 	unsigned int i;
 	float (*mat)[4] = transform->matrix;
+#ifdef X86
+	int sse_ver = sse_version_available();
+	__m128 xm;
+	__m128i xi;
+#endif
 	for (i = 0; i < length; i++) {
 		unsigned char device_r = *src++;
 		unsigned char device_g = *src++;
 		unsigned char device_b = *src++;
 		float out_device_r, out_device_g, out_device_b;
 
 		float linear_r = transform->input_gamma_table_r[device_r];
 		float linear_g = transform->input_gamma_table_g[device_g];
@@ -721,26 +1004,46 @@ static void qcms_transform_data_rgb_out_
 
 		out_device_r = lut_interp_linear(out_linear_r, 
 				transform->output_gamma_lut_r, transform->output_gamma_lut_r_length);
 		out_device_g = lut_interp_linear(out_linear_g, 
 				transform->output_gamma_lut_g, transform->output_gamma_lut_g_length);
 		out_device_b = lut_interp_linear(out_linear_b, 
 				transform->output_gamma_lut_b, transform->output_gamma_lut_b_length);
 
-		*dest++ = clamp_u8(out_device_r*255);
-		*dest++ = clamp_u8(out_device_g*255);
-		*dest++ = clamp_u8(out_device_b*255);
+#ifdef X86
+		if (sse_ver >= 2) {
+			xm.m128_f32[0] = out_device_r;
+			xm.m128_f32[1] = out_device_g;
+			xm.m128_f32[2] = out_device_b;
+			clamp_u8_sse2(&xm, &xi);
+
+			*dest++ = xi.m128i_u32[0];
+			*dest++ = xi.m128i_u32[1];
+			*dest++ = xi.m128i_u32[2];
+		} else {
+#endif
+			*dest++ = clamp_u8(out_device_r*255);
+			*dest++ = clamp_u8(out_device_g*255);
+			*dest++ = clamp_u8(out_device_b*255);
+#ifdef X86
+		}
+#endif
 	}
 }
 
 static void qcms_transform_data_rgba_out_lut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 {
 	unsigned int i;
 	float (*mat)[4] = transform->matrix;
+#ifdef X86
+	int sse_ver = sse_version_available();
+	__m128 xm;
+	__m128i xi;
+#endif
 	for (i = 0; i < length; i++) {
 		unsigned char device_r = *src++;
 		unsigned char device_g = *src++;
 		unsigned char device_b = *src++;
 		unsigned char alpha = *src++;
 		float out_device_r, out_device_g, out_device_b;
 
 		float linear_r = transform->input_gamma_table_r[device_r];
@@ -757,44 +1060,79 @@ static void qcms_transform_data_rgba_out
 
 		out_device_r = lut_interp_linear(out_linear_r, 
 				transform->output_gamma_lut_r, transform->output_gamma_lut_r_length);
 		out_device_g = lut_interp_linear(out_linear_g, 
 				transform->output_gamma_lut_g, transform->output_gamma_lut_g_length);
 		out_device_b = lut_interp_linear(out_linear_b, 
 				transform->output_gamma_lut_b, transform->output_gamma_lut_b_length);
 
-		*dest++ = clamp_u8(out_device_r*255);
-		*dest++ = clamp_u8(out_device_g*255);
-		*dest++ = clamp_u8(out_device_b*255);
+#ifdef X86
+		if (sse_ver >= 2) {
+			xm.m128_f32[0] = out_device_r;
+			xm.m128_f32[1] = out_device_g;
+			xm.m128_f32[2] = out_device_b;
+			clamp_u8_sse2(&xm, &xi);
+
+			*dest++ = xi.m128i_u32[0];
+			*dest++ = xi.m128i_u32[1];
+			*dest++ = xi.m128i_u32[2];
+		} else {
+#endif
+			*dest++ = clamp_u8(out_device_r*255);
+			*dest++ = clamp_u8(out_device_g*255);
+			*dest++ = clamp_u8(out_device_b*255);
+#ifdef X86
+		}
+#endif
 		*dest++ = alpha;
 	}
 }
 
 #if 0
 static void qcms_transform_data_rgb_out_linear(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 {
 	int i;
 	float (*mat)[4] = transform->matrix;
+#ifdef X86
+	int sse_ver = sse_version_available();
+	__m128 xm;
+	__m128i xi;
+#endif
 	for (i = 0; i < length; i++) {
 		unsigned char device_r = *src++;
 		unsigned char device_g = *src++;
 		unsigned char device_b = *src++;
 
 		float linear_r = transform->input_gamma_table_r[device_r];
 		float linear_g = transform->input_gamma_table_g[device_g];
 		float linear_b = transform->input_gamma_table_b[device_b];
 
 		float out_linear_r = mat[0][0]*linear_r + mat[1][0]*linear_g + mat[2][0]*linear_b;
 		float out_linear_g = mat[0][1]*linear_r + mat[1][1]*linear_g + mat[2][1]*linear_b;
 		float out_linear_b = mat[0][2]*linear_r + mat[1][2]*linear_g + mat[2][2]*linear_b;
 
-		*dest++ = clamp_u8(out_linear_r*255);
-		*dest++ = clamp_u8(out_linear_g*255);
-		*dest++ = clamp_u8(out_linear_b*255);
+#ifdef X86
+		if (sse_ver >= 2) {
+			xm.m128_f32[0] = out_linear_r;
+			xm.m128_f32[1] = out_linear_g;
+			xm.m128_f32[2] = out_linear_b;
+			clamp_u8_sse2(&xm, &xi);
+
+			*dest++ = xi.m128i_u32[0];
+			*dest++ = xi.m128i_u32[1];
+			*dest++ = xi.m128i_u32[2];
+		} else {
+#endif
+			*dest++ = clamp_u8(out_linear_r*255);
+			*dest++ = clamp_u8(out_linear_g*255);
+			*dest++ = clamp_u8(out_linear_b*255);
+#ifdef X86
+		}
+#endif
 	}
 }
 #endif
 
 static struct precache_output *precache_reference(struct precache_output *p)
 {
 	p->ref_count++;
 	return p;
@@ -880,96 +1218,122 @@ void qcms_transform_release(qcms_transfo
 
 	free(t->output_gamma_lut_r);
 	free(t->output_gamma_lut_g);
 	free(t->output_gamma_lut_b);
 
 	transform_free(t);
 }
 
-#ifdef X86
-// Determine if we can build with SSE2 (this was partly copied from jmorecfg.h in
-// mozilla/jpeg)
- // -------------------------------------------------------------------------
-#if defined(_M_IX86) && defined(_MSC_VER)
-#define HAS_CPUID
-/* Get us a CPUID function. Avoid clobbering EBX because sometimes it's the PIC
-   register - I'm not sure if that ever happens on windows, but cpuid isn't
-   on the critical path so we just preserve the register to be safe and to be
-   consistent with the non-windows version. */
-static void cpuid(uint32_t fxn, uint32_t *a, uint32_t *b, uint32_t *c, uint32_t *d) {
-       uint32_t a_, b_, c_, d_;
-       __asm {
-              xchg   ebx, esi
-              mov    eax, fxn
-              cpuid
-              mov    a_, eax
-              mov    b_, ebx
-              mov    c_, ecx
-              mov    d_, edx
-              xchg   ebx, esi
-       }
-       *a = a_;
-       *b = b_;
-       *c = c_;
-       *d = d_;
+// -------------------------__cpuid Detection----------------------------------
+
+// The following code was largely taken from xpcom/glue/SSE.cpp and
+// made a little simpler.
+enum CPUIDRegister { eax = 0, ebx = 1, ecx = 2, edx = 3 };
+
+#ifdef HAVE_CPUID_H
+
+// cpuid.h is available on gcc 4.3 and higher on i386 and x86_64
+#include <cpuid.h>
+
+static void
+__cpuid(int CPUInfo[4], int InfoType)
+{
+  __get_cpuid(InfoType,
+    (unsigned int*)&CPUInfo[0],
+    (unsigned int*)&CPUInfo[1],
+    (unsigned int*)&CPUInfo[2],
+    (unsigned int*)&CPUInfo[3]);
 }
-#elif (defined(__GNUC__) || defined(__SUNPRO_C)) && (defined(__i386__) || defined(__i386))
-#define HAS_CPUID
-/* Get us a CPUID function. We can't use ebx because it's the PIC register on
-   some platforms, so we use ESI instead and save ebx to avoid clobbering it. */
-static void cpuid(uint32_t fxn, uint32_t *a, uint32_t *b, uint32_t *c, uint32_t *d) {
 
-	uint32_t a_, b_, c_, d_;
-       __asm__ __volatile__ ("xchgl %%ebx, %%esi; cpuid; xchgl %%ebx, %%esi;" 
-                             : "=a" (a_), "=S" (b_), "=c" (c_), "=d" (d_) : "a" (fxn));
-	   *a = a_;
-	   *b = b_;
-	   *c = c_;
-	   *d = d_;
+#define HAVE_CPU_DETECTION
+#else /* HAVE_CPUID_H */
+
+#if defined(_MSC_VER) && _MSC_VER >= 1400 && (defined(_M_IX86) || defined(_M_AMD64))
+#include <intrin.h>
+
+#define HAVE_CPU_DETECTION
+#elif defined(__SUNPRO_CC) && (defined(__i386) || defined(__x86_64__))
+
+// Define a function identical to MSVC function.
+#ifdef __i386
+static void
+__cpuid(int CPUInfo[4], int InfoType)
+{
+  asm (
+    "xchg %esi, %ebx\n"
+    "cpuid\n"
+    "movl %eax, (%edi)\n"
+    "movl %ebx, 4(%edi)\n"
+    "movl %ecx, 8(%edi)\n"
+    "movl %edx, 12(%edi)\n"
+    "xchg %esi, %ebx\n"
+    :
+    : "a"(InfoType), // %eax
+      "D"(CPUInfo) // %edi
+    : "%ecx", "%edx", "%esi"
+  );
 }
+#else
+static void
+__cpuid(int CPUInfo[4], int InfoType)
+{
+  asm (
+    "xchg %rsi, %rbx\n"
+    "cpuid\n"
+    "movl %eax, (%rdi)\n"
+    "movl %ebx, 4(%rdi)\n"
+    "movl %ecx, 8(%rdi)\n"
+    "movl %edx, 12(%rdi)\n"
+    "xchg %rsi, %rbx\n"
+    :
+    : "a"(InfoType), // %eax
+      "D"(CPUInfo) // %rdi
+    : "%ecx", "%edx", "%rsi"
+  );
+}
+
+#define HAVE_CPU_DETECTION
 #endif
+#endif
+
+#endif /* HAVE_CPUID_H */
 
 // -------------------------Runtime SSEx Detection-----------------------------
 
 /* MMX is always supported per
  *  Gecko v1.9.1 minimum CPU requirements */
 #define SSE1_EDX_MASK (1UL << 25)
 #define SSE2_EDX_MASK (1UL << 26)
 #define SSE3_ECX_MASK (1UL <<  0)
+#define SSE4_ECX_MASK (1UL << 19)
 
 static int sse_version_available(void)
 {
-#if defined(__x86_64__) || defined(__x86_64) || defined(_M_AMD64)
-	/* we know at build time that 64-bit CPUs always have SSE2
-	 * this tells the compiler that non-SSE2 branches will never be
-	 * taken (i.e. OK to optimze away the SSE1 and non-SIMD code */
-	return 2;
-#elif defined(HAS_CPUID)
+#if defined(HAVE_CPU_DETECTION)
 	static int sse_version = -1;
-	uint32_t a, b, c, d;
-	uint32_t function = 0x00000001;
 
 	if (sse_version == -1) {
+		volatile int regs[4];
 		sse_version = 0;
-		cpuid(function, &a, &b, &c, &d);
-		if (c & SSE3_ECX_MASK)
+		__cpuid((int *)regs, 1);
+		if (regs[2] & SSE4_ECX_MASK)
+			sse_version = 4;
+		else if (regs[2] & SSE3_ECX_MASK)
 			sse_version = 3;
-		else if (d & SSE2_EDX_MASK)
+		else if (regs[3] & SSE2_EDX_MASK)
 			sse_version = 2;
-		else if (d & SSE1_EDX_MASK)
+		else if (regs[3] & SSE1_EDX_MASK)
 			sse_version = 1;
 	}
-
 	return sse_version;
 #else
 	return 0;
 #endif
 }
-#endif
 
 static const struct matrix bradford_matrix = {{	{ 0.8951f, 0.2664f,-0.1614f},
 						{-0.7502f, 1.7135f, 0.0367f},
 						{ 0.0389f,-0.0685f, 1.0296f}}, 
 						false};
 
 static const struct matrix bradford_matrix_inv = {{ { 0.9869929f,-0.1470543f, 0.1599627f},
 						    { 0.4323053f, 0.5183603f, 0.0492912f},

diff -r 28eff799c22e js/public/Vector.h
--- a/js/public/Vector.h	Thu Sep 06 17:23:00 2012 +0900
+++ b/js/public/Vector.h	Thu Sep 13 18:35:31 2012 +0900
@@ -130,16 +130,20 @@ struct VectorImpl<T, N, AP, true>
          * requiring T == U.
          *
          * memcpy(dst, srcbeg, sizeof(T) * (srcend - srcbeg));
          */
         for (const U *p = srcbeg; p != srcend; ++p, ++dst)
             *dst = *p;
     }
 
+    static inline void copyConstruct(wchar_t *dst, const wchar_t *srcbeg, const wchar_t *srcend) {
+        PodCopy(dst, srcbeg, srcend - srcbeg);
+    }
+
     template <class U>
     static inline void moveConstruct(T *dst, const U *srcbeg, const U *srcend) {
         copyConstruct(dst, srcbeg, srcend);
     }
 
     static inline void copyConstructN(T *dst, size_t n, const T &t) {
         for (T *p = dst, *end = dst + n; p != end; ++p)
             *p = t;

diff --git a/widget/windows/WinUtils.cpp b/widget/windows/WinUtils.cpp
--- a/widget/windows/WinUtils.cpp
+++ b/widget/windows/WinUtils.cpp
@@ -145,26 +145,36 @@ WinUtils::GetTopLevelHWND(HWND aWnd,
       upWnd = ::GetWindow(curWnd, GW_OWNER);
     }
     curWnd = upWnd;
   }
 
   return topWnd;
 }
 
+class CAtom_NSWindowPropName {
+public:
+  CAtom_NSWindowPropName() {
+    PRUnichar sPropName[40] = L"";
+    _snwprintf(sPropName, 39, L"MozillansIWidgetPtr%p",
+               ::GetCurrentProcessId());
+    sPropName[39] = '\0';
+    atom = ::GlobalAddAtomW(sPropName);
+  }
+  ~CAtom_NSWindowPropName() {
+    ::GlobalDeleteAtom(atom);
+  }
+  ATOM atom;
+};
+
 static PRUnichar*
 GetNSWindowPropName()
 {
-  static PRUnichar sPropName[40] = L"";
-  if (!*sPropName) {
-    _snwprintf(sPropName, 39, L"MozillansIWidgetPtr%p",
-               ::GetCurrentProcessId());
-    sPropName[39] = '\0';
-  }
-  return sPropName;
+  static CAtom_NSWindowPropName gaNswpn;
+  return (PRUnichar*)(UINT_PTR)gaNswpn.atom;
 }
 
 /* static */
 bool
 WinUtils::SetNSWindowPtr(HWND aWnd, nsWindow* aWindow)
 {
   if (!aWindow) {
     ::RemovePropW(aWnd, GetNSWindowPropName());

diff -r aa0ca203d703 js/src/yarr/YarrInterpreter.cpp
--- a/js/src/yarr/YarrInterpreter.cpp	Fri Jun 15 21:22:41 2012 +0900
+++ b/js/src/yarr/YarrInterpreter.cpp	Sun Jun 17 12:59:56 2012 +0900
@@ -1848,17 +1848,23 @@ public:
     }
 
 private:
     YarrPattern& m_pattern;
     OwnPtr<ByteDisjunction> m_bodyDisjunction;
     unsigned m_currentAlternativeIndex;
     Vector<ParenthesesStackEntry> m_parenthesesStack;
     Vector<ByteDisjunction*> m_allParenthesesInfo;
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
 };
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
 
 PassOwnPtr<BytecodePattern> byteCompile(YarrPattern& pattern, BumpPointerAllocator* allocator)
 {
     return ByteCompiler(pattern).compile(allocator);
 }
 
 int interpret(BytecodePattern* bytecode, const UChar* input, unsigned start, unsigned length, int* output)
 {


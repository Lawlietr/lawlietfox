diff -r 022513eead7b browser/installer/Makefile.in
--- a/browser/installer/Makefile.in    Wed Dec 05 00:56:18 2012 -0800
+++ b/browser/installer/Makefile.in    Fri Dec 07 19:27:23 2012 +0900
@@ -80,10 +80,6 @@
 DEFINES += -DMOZ_MSVC_REDIST=$(_MSC_VER)
 endif
 
-ifneq (,$(filter aurora beta,$(MOZ_UPDATE_CHANNEL)))
-DEFINES += -DSHIP_FEEDBACK=1
-endif
-
 ifneq (,$(filter WINNT Darwin Android,$(OS_TARGET)))
 DEFINES += -DMOZ_SHARED_MOZGLUE=1
 endif
diff -r 022513eead7b content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/content/base/src/nsContentUtils.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -3305,6 +3305,10 @@
   return sConsoleService->LogMessage(errorObject);
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
+
 bool
 nsContentUtils::IsChromeDoc(nsIDocument *aDocument)
 {
@@ -3318,6 +3322,10 @@
   return aDocument->NodePrincipal() == systemPrincipal;
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
+
 bool
 nsContentUtils::IsChildOfSameType(nsIDocument* aDoc)
 {
@@ -3580,6 +3588,9 @@
 }
 
 /* static */
+#ifdef _MSC_VER
+#pragma inline_recursion(on)
+#endif
 Element*
 nsContentUtils::MatchElementId(nsIContent *aContent, const nsIAtom* aId)
 {
@@ -3593,8 +3604,14 @@
 
   return nullptr;
 }
+#ifdef _MSC_VER
+#pragma inline_recursion(off)
+#endif
 
 /* static */
+#ifdef _MSC_VER
+#pragma inline_recursion(on)
+#endif
 Element *
 nsContentUtils::MatchElementId(nsIContent *aContent, const nsAString& aId)
 {
@@ -3609,6 +3626,9 @@
 
   return MatchElementId(aContent, id);
 }
+#ifdef _MSC_VER
+#pragma inline_recursion(off)
+#endif
 
 // Convert the string from the given charset to Unicode.
 /* static */
diff -r 022513eead7b content/canvas/src/CanvasUtils.cpp
--- a/content/canvas/src/CanvasUtils.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/content/canvas/src/CanvasUtils.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -3,6 +3,21 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+#include <omp.h>
+#endif
+
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+extern "C" {
+  extern __m128i _mm_shuffle_epi8(__m128i a, __m128i b);
+  extern __m128i _mm_alignr_epi8(__m128i a, __m128i b, const int ralign);
+}
+#else
+#include <tmmintrin.h>
+#endif
+#include "mozilla/SSE.h"
+
 #include <stdlib.h>
 #include <stdarg.h>
 
@@ -178,5 +193,260 @@
     return MatrixEltsToJSVal(elts, cx, val);
 }
 
+void
+GetImageData_component(PRUint8* _src, PRUint8* _dst,
+                       PRUint32 width, PRUint32 height,
+                       PRUint32 srcStride, PRUint32 dstStride,
+                       PRUint8 (*sUnpremultiplyTable)[256])
+{
+    PRUint8 *srcFirst = _src;
+    PRUint8 *dstFirst = _dst;
+
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+    int omp_thread_counts = omp_get_max_threads();
+
+#pragma omp parallel for schedule(guided) default(none) \
+shared(srcFirst, dstFirst, width, height, srcStride, dstStride, sUnpremultiplyTable) \
+if (omp_thread_counts >= 2 && \
+    height >= (PRUint32)omp_thread_counts && \
+    width * height >= 4096)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
+    for (PRInt64 j = 0; j < height; j++) {
+        PRUint8 *src = srcFirst + (srcStride * j);
+        PRUint8 *dst = dstFirst + (dstStride * j);
+
+        for (PRUint32 i = 0; i < width; i++) {
+            // XXX Is there some useful swizzle MMX we can use here?
+#ifdef IS_LITTLE_ENDIAN
+            PRUint8 b = *src++;
+            PRUint8 g = *src++;
+            PRUint8 r = *src++;
+            PRUint8 a = *src++;
+#else
+            PRUint8 a = *src++;
+            PRUint8 r = *src++;
+            PRUint8 g = *src++;
+            PRUint8 b = *src++;
+#endif
+            // Convert to non-premultiplied color
+            *dst++ = sUnpremultiplyTable[a][r];
+            *dst++ = sUnpremultiplyTable[a][g];
+            *dst++ = sUnpremultiplyTable[a][b];
+            *dst++ = a;
+        }
+    }
+}
+
+void
+PutImageData_component(PRUint8* _src, PRUint8* _dst,
+                       PRUint32 width, PRUint32 height,
+                       PRUint32 srcStride, PRUint32 dstStride,
+                       PRUint8 (*sPremultiplyTable)[256])
+{
+    PRUint8 *srcFirst = _src;
+    PRUint8 *dstFirst = _dst;
+
+#if (_MSC_VER != 1400) || !defined(_M_AMD64)
+    if (mozilla::supports_ssse3()) {
+        static const __m128i msk_alpha = _mm_set1_epi32(0xFF000000);
+        static const __m128i sfl_alphaLo = _mm_set_epi8(0x80, 7, 0x80, 7, 0x80, 7, 0x80, 7, 0x80, 3, 0x80, 3, 0x80, 3, 0x80, 3);
+        static const __m128i sfl_alphaHi = _mm_set_epi8(0x80, 15, 0x80, 15, 0x80, 15, 0x80, 15, 0x80, 11, 0x80, 11, 0x80, 11, 0x80, 11);
+        static const __m128i word_add = _mm_set1_epi16(0x00FF);
+        static const __m128i word_mul = _mm_set_epi16(0, 257, 257, 257, 0, 257, 257, 257);
+        static const __m128i sfl_bgra = _mm_set_epi8(15, 12, 13, 14, 11, 8, 9, 10, 7, 4, 5, 6, 3, 0, 1, 2);
+
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+        int omp_thread_counts = omp_get_max_threads();
+
+#pragma omp parallel for schedule(guided) default(none) \
+shared(srcFirst, dstFirst, width, height, srcStride, dstStride, sPremultiplyTable) \
+if (omp_thread_counts >= 2 && \
+    height >= (PRUint32)omp_thread_counts && \
+    width * height >= 12000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
+        for (int j = 0; j < height; j++) {
+            PRUint8 *src = srcFirst + (srcStride * j);
+            PRUint8 *dst = dstFirst + (dstStride * j);
+            PRUint32 i = width;
+
+            while (i >= 1 && ((unsigned)dst & 15)) {
+                PRUint8 r = *src++;
+                PRUint8 g = *src++;
+                PRUint8 b = *src++;
+                PRUint8 a = *src++;
+
+                // Convert to premultiplied color (losslessly if the input came from getImageData)
+                *dst++ = sPremultiplyTable[a][b];
+                *dst++ = sPremultiplyTable[a][g];
+                *dst++ = sPremultiplyTable[a][r];
+                *dst++ = a;
+                i -= 1;
+            }
+
+            const int srcMissalignedBytes = ((unsigned)src & 15);
+
+            if (srcMissalignedBytes == 0) {
+                while (i >= 4) {
+                    __m128i xmb = _mm_load_si128((__m128i*)src);
+                    __m128i xmwLo = _mm_unpacklo_epi8(xmb, _mm_setzero_si128());
+                    __m128i xmwHi = _mm_unpackhi_epi8(xmb, _mm_setzero_si128());
+
+                    __m128i xmwAlpha = _mm_and_si128(xmb, msk_alpha);
+                    __m128i xmwAlphaLo = _mm_shuffle_epi8(xmb, sfl_alphaLo);
+                    __m128i xmwAlphaHi = _mm_shuffle_epi8(xmb, sfl_alphaHi);
+
+                    xmwLo = _mm_mullo_epi16(xmwLo, xmwAlphaLo);
+                    xmwLo = _mm_adds_epu16(xmwLo, word_add);
+                    xmwLo = _mm_mulhi_epu16(xmwLo, word_mul);
+
+                    xmwHi = _mm_mullo_epi16(xmwHi, xmwAlphaHi);
+                    xmwHi = _mm_adds_epu16(xmwHi, word_add);
+                    xmwHi = _mm_mulhi_epu16(xmwHi, word_mul);
+
+                    __m128i xmRes = _mm_packus_epi16(xmwLo, xmwHi);
+                    xmRes = _mm_or_si128(xmRes, xmwAlpha);
+                    xmRes = _mm_shuffle_epi8(xmRes, sfl_bgra);
+                    _mm_store_si128((__m128i*)dst, xmRes);
+
+                    src += 16;
+                    dst += 16;
+                    i -= 4;
+                }
+            } else {
+                __m128i xmLoadPre = _mm_load_si128((__m128i*)(src - srcMissalignedBytes));
+
+                while (i >= 4) {
+                    __m128i xmLoadNext = _mm_load_si128((__m128i*)(src - srcMissalignedBytes + 16));
+                    __m128i xmb;
+
+                    switch (srcMissalignedBytes) {
+                    case 1:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 1);
+                        break;
+                    case 2:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 2);
+                        break;
+                    case 3:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 3);
+                        break;
+                    case 4:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 4);
+                        break;
+                    case 5:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 5);
+                        break;
+                    case 6:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 6);
+                        break;
+                    case 7:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 7);
+                        break;
+                    case 8:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 8);
+                        break;
+                    case 9:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 9);
+                        break;
+                    case 10:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 10);
+                        break;
+                    case 11:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 11);
+                        break;
+                    case 12:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 12);
+                        break;
+                    case 13:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 13);
+                        break;
+                    case 14:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 14);
+                        break;
+                    case 15:
+                        xmb = _mm_alignr_epi8(xmLoadNext, xmLoadPre, 15);
+                        break;
+                    }
+                    xmLoadPre = xmLoadNext;
+
+                    __m128i xmwLo = _mm_unpacklo_epi8(xmb, _mm_setzero_si128());
+                    __m128i xmwHi = _mm_unpackhi_epi8(xmb, _mm_setzero_si128());
+
+                    __m128i xmwAlpha = _mm_and_si128(xmb, msk_alpha);
+                    __m128i xmwAlphaLo = _mm_shuffle_epi8(xmb, sfl_alphaLo);
+                    __m128i xmwAlphaHi = _mm_shuffle_epi8(xmb, sfl_alphaHi);
+
+                    xmwLo = _mm_mullo_epi16(xmwLo, xmwAlphaLo);
+                    xmwLo = _mm_adds_epu16(xmwLo, word_add);
+                    xmwLo = _mm_mulhi_epu16(xmwLo, word_mul);
+
+                    xmwHi = _mm_mullo_epi16(xmwHi, xmwAlphaHi);
+                    xmwHi = _mm_adds_epu16(xmwHi, word_add);
+                    xmwHi = _mm_mulhi_epu16(xmwHi, word_mul);
+
+                    __m128i xmRes = _mm_packus_epi16(xmwLo, xmwHi);
+                    xmRes = _mm_or_si128(xmRes, xmwAlpha);
+                    xmRes = _mm_shuffle_epi8(xmRes, sfl_bgra);
+                    _mm_store_si128((__m128i*)dst, xmRes);
+
+                    src += 16;
+                    dst += 16;
+                    i -= 4;
+                }
+            }
+
+            while (i >= 1) {
+                PRUint8 r = *src++;
+                PRUint8 g = *src++;
+                PRUint8 b = *src++;
+                PRUint8 a = *src++;
+
+                // Convert to premultiplied color (losslessly if the input came from getImageData)
+                *dst++ = sPremultiplyTable[a][b];
+                *dst++ = sPremultiplyTable[a][g];
+                *dst++ = sPremultiplyTable[a][r];
+                *dst++ = a;
+                i -= 1;
+            }
+        }
+    } else
+#endif // (_MSC_VER != 1400) || !defined(_M_AMD64)
+    {
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+        int omp_thread_counts = omp_get_max_threads();
+
+#pragma omp parallel for schedule(guided) default(none) \
+shared(srcFirst, dstFirst, width, height, srcStride, dstStride, sPremultiplyTable) \
+if (omp_thread_counts >= 2 && \
+    height >= (PRUint32)omp_thread_counts && \
+    width * height >= 4096)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
+        for (PRInt64 j = 0; j < height; j++) {
+            PRUint8 *src = srcFirst + (srcStride * j);
+            PRUint8 *dst = dstFirst + (dstStride * j);
+
+            for (PRUint32 i = 0; i < width; i++) {
+                // XXX Is there some useful swizzle MMX we can use here?
+                PRUint8 r = *src++;
+                PRUint8 g = *src++;
+                PRUint8 b = *src++;
+                PRUint8 a = *src++;
+
+                // Convert to premultiplied color (losslessly if the input came from getImageData)
+#ifdef IS_LITTLE_ENDIAN
+                *dst++ = sPremultiplyTable[a][b];
+                *dst++ = sPremultiplyTable[a][g];
+                *dst++ = sPremultiplyTable[a][r];
+                *dst++ = a;
+#else
+                *dst++ = a;
+                *dst++ = sPremultiplyTable[a][r];
+                *dst++ = sPremultiplyTable[a][g];
+                *dst++ = sPremultiplyTable[a][b];
+#endif
+            }
+        }
+    }
+}
+
 } // namespace CanvasUtils
 } // namespace mozilla
diff -r 022513eead7b content/canvas/src/CanvasUtils.h
--- a/content/canvas/src/CanvasUtils.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/content/canvas/src/CanvasUtils.h    Fri Dec 07 19:27:23 2012 +0900
@@ -23,6 +23,16 @@
 
 using namespace gfx;
 
+void GetImageData_component(PRUint8* _src, PRUint8* _dst,
+                            PRUint32 width, PRUint32 height,
+                            PRUint32 srcStride, PRUint32 dstStride,
+                            PRUint8 (*sUnpremultiplyTable)[256]);
+
+void PutImageData_component(PRUint8* _src, PRUint8* _dst,
+                            PRUint32 width, PRUint32 height,
+                            PRUint32 srcStride, PRUint32 dstStride,
+                            PRUint8 (*sPremultiplyTable)[256]);
+
 // Check that the rectangle [x,y,w,h] is a subrectangle of [0,0,realWidth,realHeight]
 
 inline bool CheckSaneSubrectSize(int32_t x, int32_t y, int32_t w, int32_t h,
diff -r 022513eead7b content/canvas/src/Makefile.in
--- a/content/canvas/src/Makefile.in    Wed Dec 05 00:56:18 2012 -0800
+++ b/content/canvas/src/Makefile.in    Fri Dec 07 19:27:23 2012 +0900
@@ -100,3 +100,9 @@
         $(NULL)
 
 DEFINES += -D_IMPL_NS_LAYOUT
+
+ifdef _MSC_VER
+ifneq (,$(filter -DTT_MEMUTIL,$(MOZ_OPTIMIZE_FLAGS)))
+CanvasUtils.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL- -openmp
+endif
+endif
diff -r 022513eead7b content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -4002,27 +4002,8 @@
     uint8_t *src = data;
     uint8_t *dst = data;
 
-    for (uint32_t j = 0; j < aHeight; ++j) {
-        for (uint32_t i = 0; i < aWidth; ++i) {
-            // XXX Is there some useful swizzle MMX we can use here?
-#ifdef IS_LITTLE_ENDIAN
-            uint8_t b = *src++;
-            uint8_t g = *src++;
-            uint8_t r = *src++;
-            uint8_t a = *src++;
-#else
-            uint8_t a = *src++;
-            uint8_t r = *src++;
-            uint8_t g = *src++;
-            uint8_t b = *src++;
-#endif
-            // Convert to non-premultiplied color
-            *dst++ = sUnpremultiplyTable[a][r];
-            *dst++ = sUnpremultiplyTable[a][g];
-            *dst++ = sUnpremultiplyTable[a][b];
-            *dst++ = a;
-        }
-    }
+    GetImageData_component(src, dst, aWidth, aHeight,
+      aWidth * 4, aWidth * 4, sUnpremultiplyTable);
 
     *aRetval = darray;
     return NS_OK;
@@ -4166,7 +4147,8 @@
         return NS_ERROR_DOM_SYNTAX_ERR;
 
     nsRefPtr<gfxImageSurface> imgsurf = new gfxImageSurface(gfxIntSize(w, h),
-                                                            gfxASurface::ImageFormatARGB32);
+                                                            gfxASurface::ImageFormatARGB32,
+                                                            false);
     if (!imgsurf || imgsurf->CairoStatus())
         return NS_ERROR_FAILURE;
 
@@ -4176,27 +4158,8 @@
     uint8_t *src = aData;
     uint8_t *dst = imgsurf->Data();
 
-    for (uint32_t j = 0; j < h; j++) {
-        for (uint32_t i = 0; i < w; i++) {
-            uint8_t r = *src++;
-            uint8_t g = *src++;
-            uint8_t b = *src++;
-            uint8_t a = *src++;
-
-            // Convert to premultiplied color (losslessly if the input came from getImageData)
-#ifdef IS_LITTLE_ENDIAN
-            *dst++ = sPremultiplyTable[a][b];
-            *dst++ = sPremultiplyTable[a][g];
-            *dst++ = sPremultiplyTable[a][r];
-            *dst++ = a;
-#else
-            *dst++ = a;
-            *dst++ = sPremultiplyTable[a][r];
-            *dst++ = sPremultiplyTable[a][g];
-            *dst++ = sPremultiplyTable[a][b];
-#endif
-        }
-    }
+    PutImageData_component(src, dst, w, h,
+                           w * 4, w * 4, sPremultiplyTable);
 
     PathAutoSaveRestore pathSR(this);
     gfxContextAutoSaveRestore autoSR(mThebes);
diff -r 022513eead7b content/canvas/src/nsCanvasRenderingContext2DAzure.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2DAzure.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/content/canvas/src/nsCanvasRenderingContext2DAzure.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -4288,29 +4288,8 @@
   // inherited from Thebes canvas and is no longer true
   uint8_t* dst = data + dstWriteRect.y * (aWidth * 4) + dstWriteRect.x * 4;
 
-  for (int32_t j = 0; j < dstWriteRect.height; ++j) {
-    for (int32_t i = 0; i < dstWriteRect.width; ++i) {
-      // XXX Is there some useful swizzle MMX we can use here?
-#ifdef IS_LITTLE_ENDIAN
-      uint8_t b = *src++;
-      uint8_t g = *src++;
-      uint8_t r = *src++;
-      uint8_t a = *src++;
-#else
-      uint8_t a = *src++;
-      uint8_t r = *src++;
-      uint8_t g = *src++;
-      uint8_t b = *src++;
-#endif
-      // Convert to non-premultiplied color
-      *dst++ = sUnpremultiplyTable[a][r];
-      *dst++ = sUnpremultiplyTable[a][g];
-      *dst++ = sUnpremultiplyTable[a][b];
-      *dst++ = a;
-    }
-    src += srcStride - (dstWriteRect.width * 4);
-    dst += (aWidth * 4) - (dstWriteRect.width * 4);
-  }
+  GetImageData_component(src, dst, dstWriteRect.width, dstWriteRect.height,
+                         srcStride, aWidth * 4, sUnpremultiplyTable);
 
   *aRetval = darray;
   return NS_OK;
@@ -4472,7 +4451,8 @@
   }
 
   nsRefPtr<gfxImageSurface> imgsurf = new gfxImageSurface(gfxIntSize(w, h),
-                                                          gfxASurface::ImageFormatARGB32);
+                                                          gfxASurface::ImageFormatARGB32,
+                                                          false);
   if (!imgsurf || imgsurf->CairoStatus()) {
     return NS_ERROR_FAILURE;
   }
@@ -4483,32 +4463,8 @@
   uint8_t *src = aData;
   uint8_t *dst = imgsurf->Data();
 
-  for (uint32_t j = 0; j < h; j++) {
-    for (uint32_t i = 0; i < w; i++) {
-      uint8_t r = *src++;
-      uint8_t g = *src++;
-      uint8_t b = *src++;
-      uint8_t a = *src++;
-
-      // Convert to premultiplied color (losslessly if the input came from getImageData)
-#ifdef IS_LITTLE_ENDIAN
-      *dst++ = sPremultiplyTable[a][b];
-      *dst++ = sPremultiplyTable[a][g];
-      *dst++ = sPremultiplyTable[a][r];
-      *dst++ = a;
-#else
-      *dst++ = a;
-      *dst++ = sPremultiplyTable[a][r];
-      *dst++ = sPremultiplyTable[a][g];
-      *dst++ = sPremultiplyTable[a][b];
-#endif
-    }
-  }
-
-  EnsureTarget();
-  if (!IsTargetValid()) {
-    return NS_ERROR_FAILURE;
-  }
+  PutImageData_component(src, dst, w, h,
+                         w * 4, w * 4, sPremultiplyTable);
 
   RefPtr<SourceSurface> sourceSurface =
     mTarget->CreateSourceSurfaceFromData(imgsurf->Data(), IntSize(w, h), imgsurf->Stride(), FORMAT_B8G8R8A8);
diff -r 022513eead7b content/media/Makefile.in
--- a/content/media/Makefile.in    Wed Dec 05 00:56:18 2012 -0800
+++ b/content/media/Makefile.in    Fri Dec 07 19:27:23 2012 +0900
@@ -107,3 +107,15 @@
 include $(topsrcdir)/config/rules.mk
 
 DEFINES += -D_IMPL_NS_LAYOUT
+
+# Optimizer bug with MSVC PGO
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+nsMediaCache.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL-
+endif
+
+ifdef MOZ_THUNDERBIRD
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# avoid the fatal error C1001 of compiler when applying PGO to Thunderbird
+COMPILE_CXXFLAGS += -GL-
+endif
+endif
diff -r 022513eead7b content/svg/content/src/Makefile.in
--- a/content/svg/content/src/Makefile.in    Wed Dec 05 00:56:18 2012 -0800
+++ b/content/svg/content/src/Makefile.in    Fri Dec 07 19:27:23 2012 +0900
@@ -160,3 +160,16 @@
         $(NULL)
 
 DEFINES += -D_IMPL_NS_LAYOUT
+
+ifdef _MSC_VER
+ifneq (,$(filter -DTT_MEMUTIL,$(MOZ_OPTIMIZE_FLAGS)))
+nsSVGFilters.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL- -openmp
+endif
+endif
+
+ifdef MOZ_THUNDERBIRD
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# avoid the fatal error C1001 of compiler when applying PGO to Thunderbird
+COMPILE_CXXFLAGS += -GL-
+endif
+endif
diff -r 022513eead7b content/svg/content/src/nsSVGFilters.cpp
--- a/content/svg/content/src/nsSVGFilters.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/content/svg/content/src/nsSVGFilters.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -3,6 +3,10 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+#include <omp.h>
+#endif
+
 #include "mozilla/Util.h"
 
 #include "nsSVGElement.h"
@@ -940,6 +944,26 @@
 
   uint16_t mode = mEnumAttributes[MODE].GetAnimValue();
 
+  switch (mode) {
+    case nsSVGFEBlendElement::SVG_MODE_NORMAL:
+    case nsSVGFEBlendElement::SVG_MODE_MULTIPLY:
+    case nsSVGFEBlendElement::SVG_MODE_SCREEN:
+    case nsSVGFEBlendElement::SVG_MODE_DARKEN:
+    case nsSVGFEBlendElement::SVG_MODE_LIGHTEN:
+      break;
+    default:
+      return NS_ERROR_FAILURE;
+      break;
+  }
+
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, targetData, sourceData, mode) \
+if (omp_thread_counts >= 2 && \
+   (rect.XMost() - rect.x) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 7000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t x = rect.x; x < rect.XMost(); x++) {
     for (int32_t y = rect.y; y < rect.YMost(); y++) {
       uint32_t targIndex = y * stride + 4 * x;
@@ -968,11 +992,9 @@
             val = NS_MAX((255 - qa) * cb + 255 * ca,
                          (255 - qb) * ca + 255 * cb);
             break;
-          default:
-            return NS_ERROR_FAILURE;
-            break;
         }
-        val = NS_MIN(val / 255, 255U);
+        FAST_DIVIDE_BY_255(val, val);
+        val = NS_MIN(val, 255U);
         targetData[targIndex + i] =  static_cast<uint8_t>(val);
       }
       uint32_t alpha = 255 * 255 - (255 - qa) * (255 - qb);
@@ -1273,6 +1295,14 @@
     return NS_ERROR_FAILURE;
   }
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, sourceData, colorMatrix, targetData) \
+if (omp_thread_counts >= 2 && \
+   (rect.XMost() - rect.x) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 2300)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t x = rect.x; x < rect.XMost(); x++) {
     for (int32_t y = rect.y; y < rect.YMost(); y++) {
       uint32_t targIndex = y * stride + 4 * x;
@@ -1534,6 +1564,15 @@
     // Blend in the second source image
     float k1Scaled = k1 / 255.0f;
     float k4Scaled = k4*255.0f;
+
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+    int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, targetData, sourceData, stride, k1Scaled, k2, k3, k4Scaled) \
+if (omp_thread_counts >= 2 && \
+    (rect.XMost() - rect.x) >= (uint32_t)omp_thread_counts && \
+    (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 1000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       for (int32_t y = rect.y; y < rect.YMost(); y++) {
         uint32_t targIndex = y * stride + 4 * x;
@@ -1825,6 +1864,14 @@
     }
   }
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, targetData, sourceData, tableB, tableG, tableR, tableA) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 10000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       int32_t targIndex = y * stride + x * 4;
@@ -1995,7 +2042,8 @@
       break;
 
     for (i = 0; i < 256; i++) {
-      uint32_t k = (i * (tvLength - 1)) / 255;
+      uint32_t k;
+      FAST_DIVIDE_BY_255(k, (i * (tvLength - 1)));
       float v1 = tableValues[k];
       float v2 = tableValues[NS_MIN(k + 1, tvLength - 1)];
       int32_t val =
@@ -2013,7 +2061,8 @@
       break;
 
     for (i = 0; i < 256; i++) {
-      uint32_t k = (i * tvLength) / 255;
+      uint32_t k;
+      FAST_DIVIDE_BY_255(k, (i * tvLength));
       k = NS_MIN(k, tvLength - 1);
       float v = tableValues[k];
       int32_t val = int32_t(255 * v);
@@ -3008,6 +3057,14 @@
   // temporary surface data) to get coordinates relative to the origin
   // of the tile
   nsIntPoint offset(-tile.x + tile.width, -tile.y + tile.height);
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, tile, surfaceRect, sourceData, targetData, stride, offset) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts  && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 10000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
     uint32_t tileY = tile.y + WrapInterval(y + offset.y, tile.height);
     if (tileY < (uint32_t)surfaceRect.height) {
@@ -3338,6 +3395,15 @@
     else
       fY = hiFreq;
   }
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, instance, filterSubregion, type, doStitch, \
+  filterX, filterY, filterWidth, filterHeight, fX, fY, octaves, targetData) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 130)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       int32_t targIndex = y * stride + x * 4;
@@ -3361,7 +3427,7 @@
       }
 
       uint8_t r, g, b, a;
-      a = uint8_t(col[3]);
+      a = (uint8_t)(col[3]);
       FAST_DIVIDE_BY_255(r, unsigned(col[0]) * a);
       FAST_DIVIDE_BY_255(g, unsigned(col[1]) * a);
       FAST_DIVIDE_BY_255(b, unsigned(col[2]) * a);
@@ -3826,11 +3892,19 @@
   uint8_t* sourceData = aSources[0]->mImage->Data();
   uint8_t* targetData = aTarget->mImage->Data();
   int32_t stride = aTarget->mImage->Stride();
-  uint8_t extrema[4];         // RGBA magnitude of extrema
   uint16_t op = mEnumAttributes[OPERATOR].GetAnimValue();
 
   // Scan the kernel for each pixel to determine max/min RGBA values.
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, rx, ry, instance, sourceData, targetData, stride, op) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts &&\
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 1800)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
+    uint8_t extrema[4];         // RGBA magnitude of extrema
     int32_t startY = NS_MAX(0, y - ry);
     // We need to read pixels not just in 'rect', which is limited to
     // the dirty part of our filter primitive subregion, but all pixels in
@@ -4324,6 +4398,15 @@
   uint8_t *sourceData = info.mSource->Data();
   uint8_t *targetData = info.mTarget->Data();
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(dataRect, sourceData, targetData, width, height, stride, edgeMode, \
+  kernel, divisor, bias, preserveAlpha, orderX, orderY, targetX, targetY) \
+if (omp_thread_counts >= 2 && \
+   (dataRect.YMost() - dataRect.y) >= (uint32_t)omp_thread_counts && \
+   (dataRect.YMost() - dataRect.y) * (dataRect.XMost() - dataRect.x) >= 200)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = dataRect.y; y < dataRect.YMost(); y++) {
     for (int32_t x = dataRect.x; x < dataRect.XMost(); x++) {
       ConvolvePixel(sourceData, targetData,
@@ -5044,16 +5127,16 @@
 
   const float radPerDeg = M_PI/180.0;
 
-  float L[3];
+  float L_orig[3];
   if (distantLight) {
     float azimuth, elevation;
     static_cast<nsSVGFEDistantLightElement*>
       (distantLight.get())->GetAnimatedNumberValues(&azimuth,
                                                     &elevation,
                                                     nullptr);
-    L[0] = cos(azimuth * radPerDeg) * cos(elevation * radPerDeg);
-    L[1] = sin(azimuth * radPerDeg) * cos(elevation * radPerDeg);
-    L[2] = sin(elevation * radPerDeg);
+    L_orig[0] = cos(azimuth * radPerDeg) * cos(elevation * radPerDeg);
+    L_orig[1] = sin(azimuth * radPerDeg) * cos(elevation * radPerDeg);
+    L_orig[2] = sin(elevation * radPerDeg);
   }
   float lightPos[3], pointsAt[3], specularExponent;
   float cosConeAngle = 0;
@@ -5096,11 +5179,21 @@
   int32_t surfaceWidth = info.mSource->Width();
   int32_t surfaceHeight = info.mSource->Height();
   
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(dataRect, stride, sourceData, surfaceWidth, surfaceHeight, surfaceScale, pointLight, spotLight, lightPos, L_orig, pointsAt, lightColor, targetData, cosConeAngle, specularExponent, instance) \
+if (omp_thread_counts >= 2 && \
+   (dataRect.YMost() - dataRect.y) >= (uint32_t)omp_thread_counts && \
+   (dataRect.XMost() - dataRect.x) * (dataRect.YMost() - dataRect.y) >= 200)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = dataRect.y; y < dataRect.YMost(); y++) {
     for (int32_t x = dataRect.x; x < dataRect.XMost(); x++) {
       int32_t index = y * stride + x * 4;
 
       float N[3];
+      float L[3];
+      memcpy(L, L_orig, sizeof(L));
       GenerateNormal(N, sourceData, stride, surfaceWidth, surfaceHeight,
                      x, y, surfaceScale);
 
@@ -6015,6 +6108,15 @@
   double scaleOver255 = scale / 255.0;
   double scaleAdjustment = 0.5 - 0.5 * scale;
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, scaleOver255, displacementData, xChannel, yChannel, \
+  scaleAdjustment, width, height, targetData, sourceData, dummyData) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 1500)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       uint32_t targIndex = y * stride + 4 * x;
diff -r 022513eead7b dom/ipc/Makefile.in
--- a/dom/ipc/Makefile.in    Wed Dec 05 00:56:18 2012 -0800
+++ b/dom/ipc/Makefile.in    Fri Dec 07 19:27:23 2012 +0900
@@ -118,3 +118,10 @@
 endif
 
 CXXFLAGS += $(TK_CFLAGS)
+
+ifdef MOZ_THUNDERBIRD
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# avoid the fatal error C1001 of compiler when applying PGO to Thunderbird
+COMPILE_CXXFLAGS += -GL-
+endif
+endif
diff -r 022513eead7b dom/plugins/base/nsPluginNativeWindowWin.cpp
--- a/dom/plugins/base/nsPluginNativeWindowWin.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/dom/plugins/base/nsPluginNativeWindowWin.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -35,7 +35,18 @@
    && nsMinorVersion(suppliedV) >= nsMinorVersion(requiredV))
 
 
-#define NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION TEXT("MozillaPluginWindowPropertyAssociation")
+class CAtom_MozillaPluginWindowPropertyAssociation {
+public:
+  CAtom_MozillaPluginWindowPropertyAssociation() {
+    atom = ::GlobalAddAtomW(L"MozillaPluginWindowPropertyAssociation");
+  }
+  ~CAtom_MozillaPluginWindowPropertyAssociation() {
+    ::GlobalDeleteAtom(atom);
+  }
+  ATOM atom;
+};
+static CAtom_MozillaPluginWindowPropertyAssociation gaMpwpa;
+#define NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION ((LPCWSTR)(DWORD)gaMpwpa.atom)
 #define NS_PLUGIN_CUSTOM_MSG_ID TEXT("MozFlashUserRelay")
 #define WM_USER_FLASH WM_USER+1
 static UINT sWM_FLASHBOUNCEMSG = 0;
@@ -192,7 +203,7 @@
  */
 static LRESULT CALLBACK PluginWndProcInternal(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 {
-  nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+  nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
   if (!win)
     return TRUE;
 
@@ -394,7 +405,7 @@
                        LONG_PTR newLong)
 {
   nsPluginNativeWindowWin * win =
-    (nsPluginNativeWindowWin *)GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+    (nsPluginNativeWindowWin *)GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
   if (!win || (win && win->mPluginType != nsPluginType_Flash) ||
       (nIndex == GWLP_WNDPROC &&
        newLong == reinterpret_cast<LONG_PTR>(PluginWndProc)))
@@ -422,7 +433,7 @@
 
   // We already checked this in SetWindowLongHookCheck
   nsPluginNativeWindowWin * win =
-    (nsPluginNativeWindowWin *)GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+    (nsPluginNativeWindowWin *)GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
 
   // Hook our subclass back up, just like we do on setwindow.
   win->SetPrevWindowProc(
@@ -451,7 +462,7 @@
 
   // We already checked this in SetWindowLongHookCheck
   nsPluginNativeWindowWin * win =
-    (nsPluginNativeWindowWin *)GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
+    (nsPluginNativeWindowWin *)GetPropW(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
 
   // Hook our subclass back up, just like we do on setwindow.   
   win->SetPrevWindowProc(
diff -r 022513eead7b dom/plugins/ipc/Makefile.in
--- a/dom/plugins/ipc/Makefile.in    Wed Dec 05 00:56:18 2012 -0800
+++ b/dom/plugins/ipc/Makefile.in    Fri Dec 07 19:27:23 2012 +0900
@@ -129,3 +129,10 @@
 DEFINES += -DFORCE_PR_LOG
 
 CXXFLAGS += $(MOZ_CAIRO_CFLAGS)
+
+ifdef MOZ_THUNDERBIRD
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# avoid the fatal error C1001 of compiler when applying PGO to Thunderbird
+COMPILE_CXXFLAGS += -GL-
+endif
+endif
diff -r 022513eead7b gfx/2d/2D.h
--- a/gfx/2d/2D.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/2d/2D.h    Fri Dec 07 19:27:23 2012 +0900
@@ -844,6 +844,7 @@
 {
 public:
   static bool HasSSE2();
+  static bool HasSSSE3();
 
   static TemporaryRef<DrawTarget> CreateDrawTargetForCairoSurface(cairo_surface_t* aSurface, const IntSize& aSize);
 
diff -r 022513eead7b gfx/2d/BaseRect.h
--- a/gfx/2d/BaseRect.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/2d/BaseRect.h    Fri Dec 07 19:27:23 2012 +0900
@@ -9,6 +9,9 @@
 #include <cmath>
 #include <mozilla/Assertions.h>
 
+#include <stddef.h>
+#include <emmintrin.h>
+
 namespace mozilla {
 namespace gfx {
 
@@ -63,6 +66,45 @@
       x(aX), y(aY), width(aWidth), height(aHeight)
   {
   }
+  BaseRect(const __m128i& a128i)
+  {
+    _mm_storeu_si128((__m128i *)&x, a128i);
+  }
+
+  bool IsInt32x4() const {
+    return _is_int32<T>::value &&
+           offsetof(Sub, x) == offsetof(Sub, y) - 4 &&
+           offsetof(Sub, x) == offsetof(Sub, width) - 8 &&
+           offsetof(Sub, x) == offsetof(Sub, height) - 12;
+  }
+  template <typename T>
+  struct _is_int32 {
+    enum { value = false };
+  };
+  template <>
+  struct _is_int32<long> {
+    enum { value = (sizeof(long) == 4) };
+  };
+  template <>
+  struct _is_int32<long const> {
+    enum { value = (sizeof(long) == 4) };
+  };
+  template <>
+  struct _is_int32<int> {
+    enum { value = (sizeof(int) == 4) };
+  };
+  template <>
+  struct _is_int32<int const> {
+    enum { value = (sizeof(int) == 4) };
+  };
+  template <>
+  struct _is_int32<long long> {
+    enum { value = (sizeof(long long) == 4) };
+  };
+  template <>
+  struct _is_int32<long long const> {
+    enum { value = (sizeof(long long) == 4) };
+  };
 
   // Emptiness. An empty rect is one that has no area, i.e. its height or width
   // is <= 0
diff -r 022513eead7b gfx/2d/DrawTargetD2D.cpp
--- a/gfx/2d/DrawTargetD2D.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/2d/DrawTargetD2D.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -18,6 +18,15 @@
 
 #include <dwrite.h>
 
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+extern "C" {
+  extern __m128i _mm_shuffle_epi8(__m128i a, __m128i b);
+}
+#else
+#include <tmmintrin.h>
+#endif
+
 typedef HRESULT (WINAPI*D2D1CreateFactoryFunc)(
     D2D1_FACTORY_TYPE factoryType,
     REFIID iid,
@@ -2291,6 +2300,12 @@
   return style;
 }
 
+static const float f_zero = 0;
+static const float f_one = 1.0f;
+static const __m128 xm_4095_rcp_mul = _mm_set_ss(1.0f / 4095);
+static const __m128 xm_255x4 = _mm_set1_ps(255.0f);
+static const __m128i sfl_pack4 = _mm_set_epi8(0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 12, 0, 4, 8);
+
 TemporaryRef<ID3D10Texture2D>
 DrawTargetD2D::CreateGradientTexture(const GradientStopsD2D *aStops)
 {
@@ -2300,10 +2315,70 @@
   rawStops.resize(aStops->mStopCollection->GetGradientStopCount());
   aStops->mStopCollection->GetGradientStops(&rawStops.front(), rawStops.size());
 
-  std::vector<unsigned char> textureData;
-  textureData.resize(4096 * 4);
-  unsigned char *texData = &textureData.front();
-
+  unsigned char *textureData = new unsigned char [4096 * 4];
+  unsigned char *texData = textureData;
+
+if (Factory::HasSSE2()) {
+#if (_MSC_VER != 1400) || !defined(_M_AMD64)
+  bool has_ssse3 = Factory::HasSSSE3();
+#endif
+  __m128 prevColorPos = _mm_load_ss(&f_zero);
+  __m128 nextColorPos = _mm_load_ss(&f_one);
+  __m128 prevColor = _mm_loadu_ps((float*)&rawStops[0].color);
+  __m128 nextColor = prevColor;
+
+  if (rawStops.size() >= 2) {
+    nextColor = _mm_loadu_ps((float*)&rawStops[1].color);
+    nextColorPos = _mm_load_ss(&rawStops[1].position);
+  }
+
+  uint32_t stopPosition = 2;
+  __m128 interp_rcp_mul = _mm_div_ss(_mm_load_ss(&f_one), _mm_sub_ss(nextColorPos, prevColorPos));
+
+  // Not the most optimized way but this will do for now.
+  for (int i = 0; i < 4096; i++) {
+    // The 4095 seems a little counter intuitive, but we want the gradient
+    // color at offset 0 at the first pixel, and at offset 1.0f at the last
+    // pixel.
+    __m128 pos;
+    pos = _mm_cvtsi32_ss(pos, i);
+    pos = _mm_mul_ss(pos, xm_4095_rcp_mul);
+
+    if (_mm_comigt_ss(pos, nextColorPos)) {
+      prevColor = nextColor;
+      prevColorPos = nextColorPos;
+      if (rawStops.size() > stopPosition) {
+        nextColor = _mm_loadu_ps((float*)&rawStops[stopPosition].color);
+        nextColorPos = _mm_load_ss(&rawStops[stopPosition++].position);
+      } else {
+        nextColorPos = _mm_load_ss(&f_one);
+      }
+      interp_rcp_mul = _mm_div_ss(_mm_load_ss(&f_one), _mm_sub_ss(nextColorPos, prevColorPos));
+    }
+
+    __m128 interp = _mm_mul_ss(_mm_sub_ss(pos, prevColorPos), interp_rcp_mul);
+    interp = _mm_shuffle_ps(interp, interp, _MM_SHUFFLE(0, 0, 0, 0));
+
+    __m128 newColor = _mm_add_ps(_mm_mul_ps(_mm_sub_ps(nextColor, prevColor), interp), prevColor);
+    newColor = _mm_mul_ps(newColor, xm_255x4);
+
+/* Don't use SSSE3 intrinsics when using VC8-x64 compiler, which has optimizer bugs. */
+#if (_MSC_VER != 1400) || !defined(_M_AMD64)
+    if (has_ssse3) {
+      __m128i xmResult = _mm_cvttps_epi32(newColor);
+      xmResult = _mm_shuffle_epi8(xmResult, sfl_pack4);
+      *((uint32_t*)&texData[i * 4]) = _mm_cvtsi128_si32(xmResult);
+    } else
+#endif
+    {
+      newColor = _mm_shuffle_ps(newColor, newColor, _MM_SHUFFLE(3, 0, 1, 2));
+      __m128i xmResult = _mm_cvttps_epi32(newColor);
+      xmResult = _mm_packs_epi32(xmResult, _mm_setzero_si128());
+      xmResult = _mm_packus_epi16(xmResult, _mm_setzero_si128());
+      *((uint32_t*)&texData[i * 4]) = _mm_cvtsi128_si32(xmResult);
+    }
+  }
+} else {
   float prevColorPos = 0;
   float nextColorPos = 1.0f;
   D2D1_COLOR_F prevColor = rawStops[0].color;
@@ -2352,14 +2427,17 @@
     texData[i * 4 + 2] = (char)(255.0f * newColor.r);
     texData[i * 4 + 3] = (char)(255.0f * newColor.a);
   }
+}
 
   D3D10_SUBRESOURCE_DATA data;
-  data.pSysMem = &textureData.front();
+  data.pSysMem = textureData;
   data.SysMemPitch = 4096 * 4;
 
   RefPtr<ID3D10Texture2D> tex;
   mDevice->CreateTexture2D(&desc, &data, byRef(tex));
 
+  delete [] textureData;
+
   return tex;
 }
 
diff -r 022513eead7b gfx/2d/Factory.cpp
--- a/gfx/2d/Factory.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/2d/Factory.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -162,6 +162,19 @@
 #endif
 }
 
+bool
+Factory::HasSSSE3()
+{
+#if defined(__SSSE3__)
+  // gcc with -mssse3
+  return true;
+#elif defined(HAVE_CPU_DETECTION)
+  return HasCPUIDBit(1u, ecx, (1u<<9));
+#else
+  return false;
+#endif
+}
+
 TemporaryRef<DrawTarget>
 Factory::CreateDrawTarget(BackendType aBackend, const IntSize &aSize, SurfaceFormat aFormat)
 {
diff -r 022513eead7b gfx/2d/ImageScalingSSE2.cpp
--- a/gfx/2d/ImageScalingSSE2.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/2d/ImageScalingSSE2.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -9,6 +9,27 @@
 #include <xmmintrin.h>
 #include <emmintrin.h>
 
+/* VC8 doesn't support some SSE2 built-in functions, so we define them here. */
+#if defined(_MSC_VER) && (_MSC_VER < 1500)
+static __forceinline __m128
+_mm_castsi128_ps(__m128i a)
+{
+    return *(__m128 *)&a;
+}
+
+static __forceinline __m128i
+_mm_castpd_si128(__m128d a)
+{
+    return *(__m128i *)&a;
+}
+
+static __forceinline __m128i
+_mm_castps_si128(__m128 a)
+{
+    return *(__m128i *)&a;
+}
+#endif
+
 /* The functions below use the following system for averaging 4 pixels:
  *
  * The first observation is that a half-adder is implemented as follows:
diff -r 022513eead7b gfx/2d/Makefile.in
--- a/gfx/2d/Makefile.in    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/2d/Makefile.in    Fri Dec 07 19:27:23 2012 +0900
@@ -114,12 +114,9 @@
 
 # Are we targeting x86 or x64?  If so, build SSE2 files.
 ifneq (,$(INTEL_ARCHITECTURE))
-# VC2005 doesn't support _mm_castsi128_ps, so SSE2 is turned off
-ifneq (1400,$(_MSC_VER))
 CPPSRCS += ImageScalingSSE2.cpp
 DEFINES += -DUSE_SSE2
 endif
-endif
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),windows)
 CPPSRCS    += \

diff -r 022513eead7b gfx/cairo/cairo/src/cairo-d2d-private.h
--- a/gfx/cairo/cairo/src/cairo-d2d-private.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/cairo/cairo/src/cairo-d2d-private.h    Fri Dec 07 19:27:23 2012 +0900
@@ -42,6 +42,7 @@
 #include <d2d1.h>
 #include <d3d10.h>
 #include <dxgi.h>
+#include <list>
 
 #include "cairoint.h"
 #include "cairo-surface-clipper-private.h"
@@ -73,6 +74,18 @@
     int mVRAMUsage;
 };
 
+typedef struct
+{
+    RefPtr<ID2D1RadialGradientBrush> radialGradientBrush;
+    RefPtr<ID2D1GradientStopCollection> radialGradientStopCollection;
+} radial_gradient;
+
+typedef struct
+{
+    RefPtr<ID2D1LinearGradientBrush> linearGradientBrush;
+    RefPtr<ID2D1GradientStopCollection> linearGradientStopCollection;
+} linear_gradient;
+
 const unsigned int TEXT_TEXTURE_WIDTH = 2048;
 const unsigned int TEXT_TEXTURE_HEIGHT = 512;
 typedef struct _cairo_d2d_device cairo_d2d_device_t;
@@ -130,6 +143,12 @@
     RefPtr<ID2D1BitmapBrush> bitmapBrush;
     /** Brush used for solid colors */
     RefPtr<ID2D1SolidColorBrush> solidColorBrush;
+
+    /** Brush used for radial gradients */
+    std::list<radial_gradient> mRadialGradientCache;
+    /** Brush used for linear gradients */
+    std::list<linear_gradient> mLinearGradientCache;
+
     /** Indicates if our render target is currently in drawing mode */
     bool isDrawing;
     /** Indicates if text rendering is initialized */
diff -r 022513eead7b gfx/cairo/cairo/src/cairo-d2d-surface.cpp
--- a/gfx/cairo/cairo/src/cairo-d2d-surface.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/cairo/cairo/src/cairo-d2d-surface.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -1541,19 +1541,54 @@
     return NULL;
     }
 
-    RefPtr<ID2D1GradientStopCollection> stopCollection;
-    d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &stopCollection);
-    RefPtr<ID2D1RadialGradientBrush> brush;
-
-    d2dsurf->rt->CreateRadialGradientBrush(D2D1::RadialGradientBrushProperties(center,
-                                           origin,
-                                           outer_radius,
-                                           outer_radius),
-                       brushProps,
-                       stopCollection,
-                       &brush);
+    std::list<radial_gradient>::iterator iterRadialGradient = d2dsurf->mRadialGradientCache.end();
+
+    if (d2dsurf->mRadialGradientCache.size() > 0) {
+        for (std::list<radial_gradient>::iterator iter = d2dsurf->mRadialGradientCache.begin();
+             iter != d2dsurf->mRadialGradientCache.end(); iter++) {
+            UINT32 nCount = (*iter).radialGradientStopCollection->GetGradientStopCount();
+
+            if (nCount == num_stops &&
+                nCount > 0) {
+                D2D1_GRADIENT_STOP *gradientStopsOld = new D2D1_GRADIENT_STOP[nCount];
+
+                (*iter).radialGradientStopCollection->GetGradientStops(gradientStopsOld, nCount);
+                bool stopCollectionEqual = (memcmp(gradientStopsOld, stops, sizeof(D2D1_GRADIENT_STOP) * nCount) == 0);
+                delete [] gradientStopsOld;
+                if (stopCollectionEqual) {
+                    iterRadialGradient = iter;
+                    break;
+                }
+            }
+        }
+    }
+
+    if (iterRadialGradient != d2dsurf->mRadialGradientCache.end()) {
+        (*iterRadialGradient).radialGradientBrush->SetOpacity(brushProps.opacity);
+        (*iterRadialGradient).radialGradientBrush->SetTransform(&brushProps.transform);
+        (*iterRadialGradient).radialGradientBrush->SetCenter(center);
+        (*iterRadialGradient).radialGradientBrush->SetGradientOriginOffset(origin);
+        (*iterRadialGradient).radialGradientBrush->SetRadiusX(outer_radius);
+        (*iterRadialGradient).radialGradientBrush->SetRadiusY(outer_radius);
+    } else {
+        radial_gradient rg;
+
+        d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &rg.radialGradientStopCollection);
+        d2dsurf->rt->CreateRadialGradientBrush(D2D1::RadialGradientBrushProperties(center,
+            origin,
+            outer_radius,
+            outer_radius),
+            brushProps,
+            rg.radialGradientStopCollection,
+            &rg.radialGradientBrush);
+
+        iterRadialGradient = d2dsurf->mRadialGradientCache.insert(d2dsurf->mRadialGradientCache.begin(), rg);
+        if (d2dsurf->mRadialGradientCache.size() > 50) {
+            d2dsurf->mRadialGradientCache.pop_back();
+        }
+    }
     delete [] stops;
-    return brush;
+    return (*iterRadialGradient).radialGradientBrush;
 }
 
 static RefPtr<ID2D1Brush>
@@ -1718,16 +1753,50 @@
     stops[source_pattern->base.n_stops + 1].position = 1.0f;
     stops[source_pattern->base.n_stops + 1].color = D2D1::ColorF(0, 0);
     }
-    RefPtr<ID2D1GradientStopCollection> stopCollection;
-    d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &stopCollection);
-    RefPtr<ID2D1LinearGradientBrush> brush;
-    d2dsurf->rt->CreateLinearGradientBrush(D2D1::LinearGradientBrushProperties(D2D1::Point2F((FLOAT)p1.x, (FLOAT)p1.y),
-                                           D2D1::Point2F((FLOAT)p2.x, (FLOAT)p2.y)),
-                       brushProps,
-                       stopCollection,
-                       &brush);
+
+    std::list<linear_gradient>::iterator iterLinearGradient = d2dsurf->mLinearGradientCache.end();
+
+    if (d2dsurf->mLinearGradientCache.size() > 0) {
+        for (std::list<linear_gradient>::iterator iter = d2dsurf->mLinearGradientCache.begin();
+             iter != d2dsurf->mLinearGradientCache.end(); iter++) {
+            UINT32 nCount = (*iter).linearGradientStopCollection->GetGradientStopCount();
+
+            if (nCount == num_stops &&
+                nCount > 0) {
+                D2D1_GRADIENT_STOP *gradientStopsOld = new D2D1_GRADIENT_STOP[nCount];
+
+                (*iter).linearGradientStopCollection->GetGradientStops(gradientStopsOld, nCount);
+                bool stopCollectionEqual = (memcmp(gradientStopsOld, stops, sizeof(D2D1_GRADIENT_STOP) * nCount) == 0);
+                delete [] gradientStopsOld;
+                if (stopCollectionEqual) {
+                    iterLinearGradient = iter;
+                    break;
+                }
+            }
+        }
+    }
+
+    if (iterLinearGradient != d2dsurf->mLinearGradientCache.end()) {
+        (*iterLinearGradient).linearGradientBrush->SetOpacity(brushProps.opacity);
+        (*iterLinearGradient).linearGradientBrush->SetTransform(&brushProps.transform);
+        (*iterLinearGradient).linearGradientBrush->SetStartPoint(D2D1::Point2F((FLOAT)p1.x, (FLOAT)p1.y));
+        (*iterLinearGradient).linearGradientBrush->SetEndPoint(D2D1::Point2F((FLOAT)p2.x, (FLOAT)p2.y));
+    } else {
+        linear_gradient lg;
+
+        d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &lg.linearGradientStopCollection);
+        d2dsurf->rt->CreateLinearGradientBrush(D2D1::LinearGradientBrushProperties(D2D1::Point2F((FLOAT)p1.x, (FLOAT)p1.y), D2D1::Point2F((FLOAT)p2.x, (FLOAT)p2.y)),
+            brushProps,
+            lg.linearGradientStopCollection,
+            &lg.linearGradientBrush);
+
+        iterLinearGradient = d2dsurf->mLinearGradientCache.insert(d2dsurf->mLinearGradientCache.begin(), lg);
+        if (d2dsurf->mLinearGradientCache.size() > 100) {
+            d2dsurf->mLinearGradientCache.pop_back();
+        }
+    }
     delete [] stops;
-    return brush;
+    return (*iterLinearGradient).linearGradientBrush;
 }
 
 /**
diff -r 022513eead7b gfx/cairo/libpixman/src/Makefile.in
--- a/gfx/cairo/libpixman/src/Makefile.in    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/cairo/libpixman/src/Makefile.in    Fri Dec 07 19:27:23 2012 +0900
@@ -26,7 +26,8 @@
 USE_MMX=1
 endif
 USE_SSE2=1
-MMX_CFLAGS=
+# avoid the bug of PGO
+MMX_CFLAGS=-GL-
 ifneq (,$(filter 1400 1500, $(_MSC_VER)))
 # MSVC 2005 and 2008 generate code that breaks alignment
 # restrictions in debug mode so always optimize.
@@ -150,9 +151,22 @@
 CFLAGS += -Wno-missing-field-initializers
 endif # GNU_CC
 
+ifdef _MSC_VER
+ifneq (,$(filter -DTT_MEMUTIL,$(MOZ_OPTIMIZE_FLAGS)))
+OPENMP_FLAGS_TT = -GL- -openmp
+else
+OPENMP_FLAGS_TT =
+endif
+pixman-cpu.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(OPENMP_FLAGS_TT)
+
+pixman-general.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(OPENMP_FLAGS_TT)
+
+pixman-trap.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(OPENMP_FLAGS_TT)
+endif
+
 # special rule for pixman-mmx to get the right cflags
 pixman-mmx.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(MMX_CFLAGS)
 
-pixman-sse2.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(SSE2_CFLAGS)
+pixman-sse2.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(SSE2_CFLAGS) $(OPENMP_FLAGS_TT)
 
 pixman-arm-neon.$(OBJ_SUFFIX): COMPILE_CFLAGS += $(ARM_NEON_CFLAGS)
diff -r 022513eead7b gfx/cairo/libpixman/src/pixman-cpu.c
--- a/gfx/cairo/libpixman/src/pixman-cpu.c    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/cairo/libpixman/src/pixman-cpu.c    Fri Dec 07 19:27:23 2012 +0900
@@ -31,6 +31,14 @@
 #include <windows.h>
 #endif
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+#include <omp.h>
+#endif
+
+#ifdef _MSC_VER
+#include <windows.h>
+#endif
+
 #if defined(__APPLE__)
 #include "TargetConditionals.h"
 #endif
@@ -747,11 +755,184 @@
     return FALSE;
 }
 
+#ifdef _MSC_VER
+
+#ifdef TT_MEMUTIL
+uint32_t dwNonTemporalDataSizeMin = NON_TEMPORAL_STORES_NOT_SUPPORTED;
+uint32_t dwNonTemporalMemcpySizeMin = NON_TEMPORAL_STORES_NOT_SUPPORTED;
+#endif
+typedef BOOL (WINAPI *LPFN_GLPI)(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION, PDWORD);
+
+int Initialize_TT()
+{
+#ifdef TT_MEMUTIL
+    int omp_thread_counts = 0;
+    DWORD pam, sam;
+
+    long env_omp_num_threads = 0;
+    wchar_t *lpwz_env = _wgetenv(L"OMP_NUM_THREADS");
+    if (lpwz_env)
+    {
+      env_omp_num_threads = _wtol(lpwz_env);
+    }
+
+    omp_set_dynamic(0);
+    omp_set_num_threads(1);
+
+    if (GetProcessAffinityMask(GetCurrentProcess(), &pam, &sam))
+    {
+        LPFN_GLPI glpi =
+            (LPFN_GLPI)GetProcAddress(GetModuleHandle("kernel32.dll"),
+            "GetLogicalProcessorInformation");
+        DWORD returnLength = 0;
+        int *pThreadBindIndex = NULL;
+
+        if (NULL != glpi &&
+            !glpi(NULL, &returnLength) &&
+            GetLastError() == ERROR_INSUFFICIENT_BUFFER)
+        {
+            PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer =
+                (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)malloc(returnLength);
+
+            if (glpi(buffer, &returnLength))
+            {
+                DWORD byteOffset;
+                PSYSTEM_LOGICAL_PROCESSOR_INFORMATION ptr;
+                int i;
+                size_t threadBindIndexSize;
+
+                byteOffset = 0;
+                ptr = buffer;
+                while (byteOffset < returnLength)
+                {
+                    if (RelationProcessorCore == ptr->Relationship)
+                    {
+                        omp_thread_counts++;
+                    }
+                    byteOffset += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
+                    ptr++;
+                }
+
+                threadBindIndexSize = sizeof(int) * omp_thread_counts;
+                pThreadBindIndex = (int *)malloc(threadBindIndexSize);
+                memset(pThreadBindIndex, 0xFF, threadBindIndexSize);
+
+                i = 0;
+                byteOffset = 0;
+                ptr = buffer;
+                while (byteOffset < returnLength)
+                {
+                    if (RelationProcessorCore == ptr->Relationship)
+                    {
+                        if (i < omp_thread_counts)
+                        {
+                            int b;
+
+                            for (b = 0; b <= 31; b++)
+                            {
+                                if ((pam & ptr->ProcessorMask) & (1 << b))
+                                {
+                                    pThreadBindIndex[i++] = b;
+                                    break;
+                                }
+                            }
+                        }
+                        else
+                        {
+                            break;
+                        }
+                    }
+                    byteOffset += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
+                    ptr++;
+                }
+            }
+            free(buffer);
+        }
+
+        if (NULL == pThreadBindIndex)
+        {
+            int b;
+            int i;
+            size_t threadBindIndexSize;
+
+            for (b = 0; b <= 31; b++)
+            {
+                if (pam & (1 << b)) omp_thread_counts++;
+            }
+
+            threadBindIndexSize = sizeof(int) * omp_thread_counts;
+            pThreadBindIndex = (int *)malloc(threadBindIndexSize);
+            memset(pThreadBindIndex, 0xFF, threadBindIndexSize);
+
+            for (i = 0; i < omp_thread_counts; i++)
+            {
+                pThreadBindIndex[i] = i;
+            }
+        }
+
+        if (NULL != pThreadBindIndex)
+        {
+            if (omp_thread_counts >= 1)
+            {
+                OSVERSIONINFO osvi = { sizeof(OSVERSIONINFO) };
+                BOOL bIsWindows7orLater = FALSE;
+
+                omp_set_dynamic(0);
+                if (0 != env_omp_num_threads)
+                {
+                    omp_thread_counts = env_omp_num_threads;
+                }
+                omp_set_num_threads(omp_thread_counts);
+                omp_thread_counts = omp_get_max_threads();
+
+                GetVersionEx(&osvi);
+                bIsWindows7orLater =
+                    (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId) &&
+                    ((6 == osvi.dwMajorVersion && osvi.dwMinorVersion >= 1) || (osvi.dwMajorVersion >= 7));
+                if (!bIsWindows7orLater)
+                {
+#pragma omp parallel
+                    {
+                        SetThreadIdealProcessor(GetCurrentThread(),
+                            pThreadBindIndex[omp_get_thread_num()]);
+                    }
+                }
+            }
+            free(pThreadBindIndex);
+        }
+    }
+#endif /* TT_MEMUTIL */
+
+#ifdef TT_MEMUTIL
+    dwNonTemporalMemcpySizeMin = dwNonTemporalDataSizeMin = GetNonTemporalDataSizeMin_tt();
+    if (dwNonTemporalMemcpySizeMin != NON_TEMPORAL_STORES_NOT_SUPPORTED)
+    {
+        dwNonTemporalMemcpySizeMin = dwNonTemporalDataSizeMin / 2;
+    }
+#endif
+
+    return 0;
+}
+
+#endif /* _MSC_VER */
+
 pixman_implementation_t *
 _pixman_choose_implementation (void)
 {
     pixman_implementation_t *imp;
 
+#ifdef _MSC_VER
+    {
+        static pixman_bool_t initialized = FALSE;
+
+        if (!initialized)
+        {
+            Initialize_TT();
+            initialized = TRUE;
+        }
+    }
+#endif
+
     imp = _pixman_implementation_create_general();
 
     if (!disabled ("fast"))
diff -r 022513eead7b gfx/cairo/libpixman/src/pixman-edge.c
--- a/gfx/cairo/libpixman/src/pixman-edge.c    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/cairo/libpixman/src/pixman-edge.c    Fri Dec 07 19:27:23 2012 +0900
@@ -166,6 +166,8 @@
     uint32_t *buf = (image)->bits.bits;
     int stride = (image)->bits.rowstride;
     int width = (image)->bits.width;
+    pixman_fixed_t rx_old = 0;
+    int rxs_old = 0, rxi_old = 0;
 
     line = buf + pixman_fixed_to_int (y) * stride;
 
@@ -197,12 +199,29 @@
             int lxs, rxs;
 
             /* Find pixel bounds for span. */
-            lxi = pixman_fixed_to_int (lx);
-            rxi = pixman_fixed_to_int (rx);
+            /* Sample coverage for edge pixels */
+            if (lx == 0)
+            {
+                lxi = 0;
+                lxs = 0;
+            }
+            else
+            {
+                lxi = pixman_fixed_to_int (lx);
+                lxs = RENDER_SAMPLES_X (lx, 8);
+            }
 
-            /* Sample coverage for edge pixels */
-            lxs = RENDER_SAMPLES_X (lx, 8);
-            rxs = RENDER_SAMPLES_X (rx, 8);
+            if (rx == rx_old)
+            {
+                rxi = rxi_old;
+                rxs = rxs_old;
+            }
+            else
+            {
+                rxi_old = rxi = pixman_fixed_to_int (rx);
+                rxs_old = rxs = RENDER_SAMPLES_X (rx, 8);
+                rx_old = rx;
+            }
 
             /* Add coverage across row */
             if (lxi == rxi)
diff -r 022513eead7b gfx/cairo/libpixman/src/pixman-private.h
--- a/gfx/cairo/libpixman/src/pixman-private.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/cairo/libpixman/src/pixman-private.h    Fri Dec 07 19:27:23 2012 +0900
@@ -996,4 +996,11 @@
 
 #endif /* PIXMAN_TIMERS */
 
+#ifdef TT_MEMUTIL
+extern pixman_bool_t nt_initialized;
+extern uint32_t dwNonTemporalDataSizeMin;
+extern uint32_t dwNonTemporalMemcpySizeMin;
+void InitializeNonTemporalData();
+#endif /* TT_MEMUTIL */
+
 #endif /* PIXMAN_PRIVATE_H */
diff -r 022513eead7b gfx/cairo/libpixman/src/pixman-sse2.c
--- a/gfx/cairo/libpixman/src/pixman-sse2.c    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/cairo/libpixman/src/pixman-sse2.c    Fri Dec 07 19:27:23 2012 +0900
@@ -354,6 +354,13 @@
     _mm_stream_si128 (dst, data);
 }
 
+/* save 1 pixels using Write Combining memory */
+static force_inline void
+save_32_write_combining (int* dst, int data)
+{
+    _mm_stream_si32 (dst, data);
+}
+
 /* save 4 pixels on a 16-byte boundary aligned address */
 static force_inline void
 save_128_aligned (__m128i* dst,
@@ -3232,6 +3239,11 @@
 
 }
 
+#ifdef TT_MEMUTIL
+extern uint32_t dwNonTemporalDataSizeMin;
+extern uint32_t dwNonTemporalMemcpySizeMin;
+#endif
+
 static pixman_bool_t
 pixman_fill_sse2 (uint32_t *bits,
                   int       stride,
@@ -3244,6 +3256,9 @@
 {
     uint32_t byte_width;
     uint8_t         *byte_line;
+#ifdef TT_MEMUTIL
+    pixman_bool_t use_nontemporal_fill;
+#endif
 
     __m128i xmm_def;
 
@@ -3282,6 +3297,10 @@
     return FALSE;
     }
 
+#ifdef TT_MEMUTIL
+    use_nontemporal_fill = ((uint32_t)(byte_width * height) > dwNonTemporalDataSizeMin);
+#endif
+
     xmm_def = create_mask_2x32_128 (data, data);
 
     while (height--)
@@ -3305,6 +3324,71 @@
         d += 2;
     }
 
+#ifdef TT_MEMUTIL
+if (use_nontemporal_fill)
+{
+    while (w >= 4 && ((unsigned long)d & 15))
+    {
+        save_32_write_combining ((int*)d, (int)data);
+
+        w -= 4;
+        d += 4;
+    }
+
+    while (w >= 128)
+    {
+        save_128_write_combining ((__m128i*)(d),     xmm_def);
+        save_128_write_combining ((__m128i*)(d + 16),  xmm_def);
+        save_128_write_combining ((__m128i*)(d + 32),  xmm_def);
+        save_128_write_combining ((__m128i*)(d + 48),  xmm_def);
+        save_128_write_combining ((__m128i*)(d + 64),  xmm_def);
+        save_128_write_combining ((__m128i*)(d + 80),  xmm_def);
+        save_128_write_combining ((__m128i*)(d + 96),  xmm_def);
+        save_128_write_combining ((__m128i*)(d + 112), xmm_def);
+
+        d += 128;
+        w -= 128;
+    }
+
+    if (w >= 64)
+    {
+        save_128_write_combining ((__m128i*)(d),     xmm_def);
+        save_128_write_combining ((__m128i*)(d + 16),  xmm_def);
+        save_128_write_combining ((__m128i*)(d + 32),  xmm_def);
+        save_128_write_combining ((__m128i*)(d + 48),  xmm_def);
+
+        d += 64;
+        w -= 64;
+    }
+
+    if (w >= 32)
+    {
+        save_128_write_combining ((__m128i*)(d),     xmm_def);
+        save_128_write_combining ((__m128i*)(d + 16),  xmm_def);
+
+        d += 32;
+        w -= 32;
+    }
+
+    if (w >= 16)
+    {
+        save_128_write_combining ((__m128i*)(d),     xmm_def);
+
+        d += 16;
+        w -= 16;
+    }
+
+    while (w >= 4)
+    {
+        save_32_write_combining ((int*)d, (int)data);
+
+        w -= 4;
+        d += 4;
+    }
+}
+else
+#endif
+{
     while (w >= 4 && ((unsigned long)d & 15))
     {
         *(uint32_t *)d = data;
@@ -3363,6 +3447,7 @@
         w -= 4;
         d += 4;
     }
+}
 
     if (w >= 2)
     {
@@ -3379,6 +3464,13 @@
     }
     }
 
+#ifdef TT_MEMUTIL
+    if (use_nontemporal_fill)
+    {
+        _mm_sfence();
+    }
+#endif
+
     return TRUE;
 }
 
@@ -4462,6 +4554,9 @@
     uint8_t *   src_bytes;
     uint8_t *   dst_bytes;
     int byte_width;
+#ifdef TT_MEMUTIL
+    pixman_bool_t use_nontemporal_copy;
+#endif
 
     if (src_bpp != dst_bpp)
     return FALSE;
@@ -4491,6 +4586,10 @@
     return FALSE;
     }
 
+#ifdef TT_MEMUTIL
+    use_nontemporal_copy = ((uint32_t)(byte_width * height) > dwNonTemporalMemcpySizeMin);
+#endif
+
     while (height--)
     {
     int w;
@@ -4508,9 +4607,12 @@
         d += 2;
     }
 
+#ifdef TT_MEMUTIL
+if (use_nontemporal_copy)
+{
     while (w >= 4 && ((unsigned long)d & 15))
     {
-        *(uint32_t *)d = *(uint32_t *)s;
+        save_32_write_combining ((int*)d, *(int*)s);
 
         w -= 4;
         s += 4;
@@ -4521,11 +4623,62 @@
     {
         __m128i xmm0, xmm1, xmm2, xmm3;
 
+        _mm_prefetch((char const *)s + (200*64/34+192), _MM_HINT_NTA);
+
         xmm0 = load_128_unaligned ((__m128i*)(s));
         xmm1 = load_128_unaligned ((__m128i*)(s + 16));
         xmm2 = load_128_unaligned ((__m128i*)(s + 32));
         xmm3 = load_128_unaligned ((__m128i*)(s + 48));
 
+        save_128_write_combining ((__m128i*)(d),    xmm0);
+        save_128_write_combining ((__m128i*)(d + 16), xmm1);
+        save_128_write_combining ((__m128i*)(d + 32), xmm2);
+        save_128_write_combining ((__m128i*)(d + 48), xmm3);
+
+        s += 64;
+        d += 64;
+        w -= 64;
+    }
+
+    while (w >= 16)
+    {
+        save_128_write_combining ((__m128i*)d, load_128_unaligned ((__m128i*)s) );
+
+        w -= 16;
+        d += 16;
+        s += 16;
+    }
+
+    while (w >= 4)
+    {
+        save_32_write_combining ((int*)d, *(int*)s);
+
+        w -= 4;
+        s += 4;
+        d += 4;
+    }
+}
+else
+#endif
+{
+    while (w >= 4 && ((unsigned long)d & 15))
+    {
+        *(uint32_t *)d = *(uint32_t *)s;
+
+        w -= 4;
+        s += 4;
+        d += 4;
+    }
+
+    while (w >= 64)
+    {
+        __m128i xmm0, xmm1, xmm2, xmm3;
+
+        xmm0 = load_128_unaligned ((__m128i*)(s));
+        xmm1 = load_128_unaligned ((__m128i*)(s + 16));
+        xmm2 = load_128_unaligned ((__m128i*)(s + 32));
+        xmm3 = load_128_unaligned ((__m128i*)(s + 48));
+
         save_128_aligned ((__m128i*)(d),    xmm0);
         save_128_aligned ((__m128i*)(d + 16), xmm1);
         save_128_aligned ((__m128i*)(d + 32), xmm2);
@@ -4553,6 +4706,7 @@
         s += 4;
         d += 4;
     }
+}
 
     if (w >= 2)
     {
@@ -4563,6 +4717,12 @@
     }
     }
 
+#ifdef TT_MEMUTIL
+    if (use_nontemporal_copy)
+    {
+        _mm_sfence();
+    }
+#endif
 
     return TRUE;
 }
diff -r 022513eead7b gfx/cairo/libpixman/src/pixman-trap.c
--- a/gfx/cairo/libpixman/src/pixman-trap.c    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/cairo/libpixman/src/pixman-trap.c    Fri Dec 07 19:27:23 2012 +0900
@@ -25,6 +25,11 @@
 #include <config.h>
 #endif
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+#include <omp.h>
+#endif
+#include <limits.h>
+
 #include <stdio.h>
 #include <stdlib.h>
 #include "pixman-private.h"
@@ -40,6 +45,26 @@
     pixman_fixed_t f = pixman_fixed_frac (y);
     pixman_fixed_t i = pixman_fixed_floor (y);
 
+if (8 == n)
+{
+    f = DIV (f - Y_FRAC_FIRST (8) + (STEP_Y_SMALL (8) - pixman_fixed_e), STEP_Y_SMALL (8)) * STEP_Y_SMALL (8) +
+    Y_FRAC_FIRST (8);
+    
+    if (f > Y_FRAC_LAST (8))
+    {
+    if (pixman_fixed_to_int (i) == 0x7fff)
+    {
+        f = 0xffff; /* saturate */
+    }
+    else
+    {
+        f = Y_FRAC_FIRST (8);
+        i += pixman_fixed_1;
+    }
+    }
+}
+else
+{
     f = DIV (f - Y_FRAC_FIRST (n) + (STEP_Y_SMALL (n) - pixman_fixed_e), STEP_Y_SMALL (n)) * STEP_Y_SMALL (n) +
     Y_FRAC_FIRST (n);
     
@@ -55,6 +80,7 @@
         i += pixman_fixed_1;
     }
     }
+}
     return (i | f);
 }
 
@@ -69,6 +95,26 @@
     pixman_fixed_t f = pixman_fixed_frac (y);
     pixman_fixed_t i = pixman_fixed_floor (y);
 
+if (8 == n)
+{
+    f = DIV (f - pixman_fixed_e - Y_FRAC_FIRST (8), STEP_Y_SMALL (8)) * STEP_Y_SMALL (8) +
+    Y_FRAC_FIRST (8);
+
+    if (f < Y_FRAC_FIRST (8))
+    {
+    if (pixman_fixed_to_int (i) == 0x8000)
+    {
+        f = 0; /* saturate */
+    }
+    else
+    {
+        f = Y_FRAC_LAST (8);
+        i -= pixman_fixed_1;
+    }
+    }
+}
+else
+{
     f = DIV (f - pixman_fixed_e - Y_FRAC_FIRST (n), STEP_Y_SMALL (n)) * STEP_Y_SMALL (n) +
     Y_FRAC_FIRST (n);
 
@@ -84,6 +130,8 @@
         i -= pixman_fixed_1;
     }
     }
+}
+
     return (i | f);
 }
 
@@ -186,11 +234,22 @@
         e->e = 0;
     }
 
+if (8 == n)
+{
+    _pixman_edge_multi_init (e, STEP_Y_SMALL (8),
+                 &e->stepx_small, &e->dx_small);
+
+    _pixman_edge_multi_init (e, STEP_Y_BIG (8),
+                 &e->stepx_big, &e->dx_big);
+}
+else
+{
     _pixman_edge_multi_init (e, STEP_Y_SMALL (n),
                  &e->stepx_small, &e->dx_small);
 
     _pixman_edge_multi_init (e, STEP_Y_BIG (n),
                  &e->stepx_big, &e->dx_big);
+}
     }
     pixman_edge_step (e, y_start - y_top);
 }
@@ -327,6 +386,27 @@
     dump_image (image, "before");
 #endif
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+int omp_thread_counts = omp_get_max_threads();
+if (omp_thread_counts >= 2 &&
+    ntraps >= omp_thread_counts &&
+    ntraps >= 160)
+{
+#pragma omp parallel for schedule(guided) default(none) \
+shared(ntraps, traps, image, x_off, y_off)
+    for (i = 0; i < ntraps; ++i)
+    {
+    const pixman_trapezoid_t *trap = &(traps[i]);
+
+    if (pixman_trapezoid_valid (trap))
+    {
+        pixman_rasterize_trapezoid (image, trap, x_off, y_off);
+    }
+    }
+}
+else
+#endif
+{
     for (i = 0; i < ntraps; ++i)
     {
     const pixman_trapezoid_t *trap = &(traps[i]);
@@ -336,6 +416,7 @@
 
     pixman_rasterize_trapezoid (image, trap, x_off, y_off);
     }
+}
 
 #if 0
     dump_image (image, "after");
diff -r 022513eead7b gfx/qcms/transform.c
--- a/gfx/qcms/transform.c    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/qcms/transform.c    Fri Dec 07 19:27:23 2012 +0900
@@ -35,6 +35,65 @@
 #define X86
 #endif /* _M_IX86 || __i386__ || __i386 || _M_AMD64 || __x86_64__ || __x86_64 */
 
+#ifdef X86
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+#else  /* _MSC_VER == 1400 */
+#include <smmintrin.h>
+#endif /* _MSC_VER == 1400 */
+#include "mozilla/Attributes.h"
+
+#if defined(_M_IX86) && _MSC_VER == 1400
+__declspec(naked) __declspec(noinline)
+void __fastcall floor_ps_sse4_1(const __m128 * __restrict src, __m128i * __restrict dest) {
+    __asm {
+        /* roundps  xmm0, xmmword ptr [ecx], 1 */
+        __asm _emit 0x66
+        __asm _emit 0x0F
+        __asm _emit 0x3A
+        __asm _emit 0x08
+        __asm _emit 0x01
+        __asm _emit 0x01
+        cvttps2dq   xmm0, xmm0
+        movdqa      xmmword ptr [edx], xmm0
+        ret
+    }
+}
+
+__declspec(naked) __declspec(noinline)
+void __fastcall ceil_ps_sse4_1(const __m128 * __restrict src, __m128i * __restrict dest) {
+    __asm {
+        /* roundps  xmm0, xmmword ptr [ecx], 2 */
+        __asm _emit 0x66
+        __asm _emit 0x0F
+        __asm _emit 0x3A
+        __asm _emit 0x08
+        __asm _emit 0x01
+        __asm _emit 0x02
+        cvttps2dq   xmm0, xmm0
+        movdqa      xmmword ptr [edx], xmm0
+        ret
+    }
+}
+#endif
+
+int sse_version_available(void);
+
+static const ALIGN float ps255[4]  = { 255, 255, 255, 255 };
+static const ALIGN float psZero[4] = {   0,   0,   0,   0 };
+static const ALIGN float psHalf[4] = { 0.5, 0.5, 0.5, 0.5 };
+
+MOZ_ALWAYS_INLINE
+void clamp_u8_sse2(const __m128 *src, __m128i *dest) {
+    __m128 x = *src;
+
+    x = _mm_mul_ps(x, *(__m128 *)&ps255);
+    x = _mm_min_ps(x, *(__m128 *)&ps255);
+    x = _mm_max_ps(x, *(__m128 *)&psZero);
+    *dest = _mm_cvttps_epi32(_mm_add_ps(x, *(__m128 *)&psHalf));
+}
+#endif /* X86 */
+
 // Build a White point, primary chromas transfer matrix from RGB to CIE XYZ
 // This is just an approximation, I am not handling all the non-linear
 // aspects of the RGB to XYZ process, and assumming that the gamma correction
@@ -234,6 +293,11 @@
 {
     int i;
     float (*mat)[4] = transform->matrix;
+#ifdef X86
+    int sse_ver = sse_version_available();
+    __m128 xm;
+    __m128i xi;
+#endif
     for (i=0; i<length; i++) {
         unsigned char device_r = *src++;
         unsigned char device_g = *src++;
@@ -251,9 +315,24 @@
         float out_device_g = pow(out_linear_g, transform->out_gamma_g);
         float out_device_b = pow(out_linear_b, transform->out_gamma_b);
 
-        dest[OUTPUT_R_INDEX] = clamp_u8(255*out_device_r);
-        dest[OUTPUT_G_INDEX] = clamp_u8(255*out_device_g);
-        dest[OUTPUT_B_INDEX] = clamp_u8(255*out_device_b);
+#ifdef X86
+        if (sse_ver >= 2) {
+            xm.m128_f32[0] = out_device_r;
+            xm.m128_f32[1] = out_device_g;
+            xm.m128_f32[2] = out_device_b;
+            clamp_u8_sse2(&xm, &xi);
+
+            dest[OUTPUT_R_INDEX] = xi.m128i_u32[0];
+            dest[OUTPUT_G_INDEX] = xi.m128i_u32[1];
+            dest[OUTPUT_B_INDEX] = xi.m128i_u32[2];
+        } else {
+#endif
+            dest[OUTPUT_R_INDEX] = clamp_u8(255*out_device_r);
+            dest[OUTPUT_G_INDEX] = clamp_u8(255*out_device_g);
+            dest[OUTPUT_B_INDEX] = clamp_u8(255*out_device_b);
+#ifdef X86
+        }
+#endif
         dest += RGB_OUTPUT_COMPONENTS;
     }
 }
@@ -262,6 +341,11 @@
 static void qcms_transform_data_gray_out_lut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 {
     unsigned int i;
+#ifdef X86
+    int sse_ver = sse_version_available();
+    __m128 xm;
+    __m128i xi;
+#endif
     for (i = 0; i < length; i++) {
         float out_device_r, out_device_g, out_device_b;
         unsigned char device = *src++;
@@ -272,9 +356,24 @@
         out_device_g = lut_interp_linear(linear, transform->output_gamma_lut_g, transform->output_gamma_lut_g_length);
         out_device_b = lut_interp_linear(linear, transform->output_gamma_lut_b, transform->output_gamma_lut_b_length);
 
-        dest[OUTPUT_R_INDEX] = clamp_u8(out_device_r*255);
-        dest[OUTPUT_G_INDEX] = clamp_u8(out_device_g*255);
-        dest[OUTPUT_B_INDEX] = clamp_u8(out_device_b*255);
+#ifdef X86
+        if (sse_ver >= 2) {
+            xm.m128_f32[0] = out_device_r;
+            xm.m128_f32[1] = out_device_g;
+            xm.m128_f32[2] = out_device_b;
+            clamp_u8_sse2(&xm, &xi);
+
+            dest[OUTPUT_R_INDEX] = xi.m128i_u32[0];
+            dest[OUTPUT_G_INDEX] = xi.m128i_u32[1];
+            dest[OUTPUT_B_INDEX] = xi.m128i_u32[2];
+        } else {
+#endif
+            dest[OUTPUT_R_INDEX] = clamp_u8(out_device_r*255);
+            dest[OUTPUT_G_INDEX] = clamp_u8(out_device_g*255);
+            dest[OUTPUT_B_INDEX] = clamp_u8(out_device_b*255);
+#ifdef X86
+        }
+#endif
         dest += RGB_OUTPUT_COMPONENTS;
     }
 }
@@ -288,6 +387,11 @@
 static void qcms_transform_data_graya_out_lut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 {
     unsigned int i;
+#ifdef X86
+    int sse_ver = sse_version_available();
+    __m128 xm;
+    __m128i xi;
+#endif
     for (i = 0; i < length; i++) {
         float out_device_r, out_device_g, out_device_b;
         unsigned char device = *src++;
@@ -299,9 +403,25 @@
         out_device_g = lut_interp_linear(linear, transform->output_gamma_lut_g, transform->output_gamma_lut_g_length);
         out_device_b = lut_interp_linear(linear, transform->output_gamma_lut_b, transform->output_gamma_lut_b_length);
 
-        dest[OUTPUT_R_INDEX] = clamp_u8(out_device_r*255);
-        dest[OUTPUT_G_INDEX] = clamp_u8(out_device_g*255);
-        dest[OUTPUT_B_INDEX] = clamp_u8(out_device_b*255);
+#ifdef X86
+        if (sse_ver >= 2) {
+            xm.m128_f32[0] = out_device_r;
+            xm.m128_f32[1] = out_device_g;
+            xm.m128_f32[2] = out_device_b;
+            clamp_u8_sse2(&xm, &xi);
+
+            dest[OUTPUT_R_INDEX] = xi.m128i_u32[0];
+            dest[OUTPUT_G_INDEX] = xi.m128i_u32[1];
+            dest[OUTPUT_B_INDEX] = xi.m128i_u32[2];
+        } else {
+#endif
+
+            dest[OUTPUT_R_INDEX] = clamp_u8(out_device_r*255);
+            dest[OUTPUT_G_INDEX] = clamp_u8(out_device_g*255);
+            dest[OUTPUT_B_INDEX] = clamp_u8(out_device_b*255);
+#ifdef X86
+        }
+#endif
         dest[OUTPUT_A_INDEX] = alpha;
         dest += RGBA_OUTPUT_COMPONENTS;
     }
@@ -428,12 +548,18 @@
     float* r_table = transform->r_clut;
     float* g_table = transform->g_clut;
     float* b_table = transform->b_clut;
+    float rcp255 = 1.0f / 255.0f;
+#ifdef X86
+    int sse_ver = sse_version_available();
+    __m128 xm;
+    __m128i xi;
+#endif
   
     for (i = 0; i < length; i++) {
         unsigned char in_r = *src++;
         unsigned char in_g = *src++;
         unsigned char in_b = *src++;
-        float linear_r = in_r/255.0f, linear_g=in_g/255.0f, linear_b = in_b/255.0f;
+        float linear_r = in_r*rcp255, linear_g=in_g*rcp255, linear_b = in_b*rcp255;
 
         int x = floor(linear_r * (transform->grid_size-1));
         int y = floor(linear_g * (transform->grid_size-1));
@@ -469,42 +595,119 @@
         float b_y2 = lerp(b_x3, b_x4, y_d);
         float clut_b = lerp(b_y1, b_y2, z_d);
 
-        *dest++ = clamp_u8(clut_r*255.0f);
-        *dest++ = clamp_u8(clut_g*255.0f);
-        *dest++ = clamp_u8(clut_b*255.0f);
+#ifdef X86
+        if (sse_ver >= 2) {
+            xm.m128_f32[0] = clut_r;
+            xm.m128_f32[1] = clut_g;
+            xm.m128_f32[2] = clut_b;
+            clamp_u8_sse2(&xm, &xi);
+
+            *dest++ = xi.m128i_u32[0];
+            *dest++ = xi.m128i_u32[1];
+            *dest++ = xi.m128i_u32[2];
+        } else {
+#endif
+            *dest++ = clamp_u8(clut_r*255.0f);
+            *dest++ = clamp_u8(clut_g*255.0f);
+            *dest++ = clamp_u8(clut_b*255.0f);
+#ifdef X86
+        }
+#endif
     }    
 }
 */
 
 // Using lcms' tetra interpolation algorithm.
 static void qcms_transform_data_tetra_clut_rgba(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length) {
-    unsigned int i;
+    int64_t i;
     int xy_len = 1;
     int x_len = transform->grid_size;
     int len = x_len * x_len;
     float* r_table = transform->r_clut;
     float* g_table = transform->g_clut;
     float* b_table = transform->b_clut;
-    float c0_r, c1_r, c2_r, c3_r;
-    float c0_g, c1_g, c2_g, c3_g;
-    float c0_b, c1_b, c2_b, c3_b;
-    float clut_r, clut_g, clut_b;
+    float rcp255 = 1.0f / 255.0f;
+#ifdef X86
+    int sse_ver = sse_version_available();
+#endif
+
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+    int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(static) default(none) \
+firstprivate(transform, src, dest, length, r_table, g_table, b_table, x_len, xy_len, len, rcp255, sse_ver) \
+if (omp_thread_counts >= 2 && \
+        length >= omp_thread_counts && \
+        length >= 400)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
     for (i = 0; i < length; i++) {
-        unsigned char in_r = *src++;
-        unsigned char in_g = *src++;
-        unsigned char in_b = *src++;
-        unsigned char in_a = *src++;
-        float linear_r = in_r/255.0f, linear_g=in_g/255.0f, linear_b = in_b/255.0f;
+        float c0_r, c1_r, c2_r, c3_r;
+        float c0_g, c1_g, c2_g, c3_g;
+        float c0_b, c1_b, c2_b, c3_b;
+        float clut_r, clut_g, clut_b;
+        unsigned char in_r = src[i * 4 + 0];
+        unsigned char in_g = src[i * 4 + 1];
+        unsigned char in_b = src[i * 4 + 2];
+        unsigned char in_a = src[i * 4 + 3];
+        float linear_r = in_r*rcp255, linear_g=in_g*rcp255, linear_b = in_b*rcp255;
+#ifdef X86
+        __m128 xm;
+        __m128i xi;
+#endif
 
-        int x = floor(linear_r * (transform->grid_size-1));
-        int y = floor(linear_g * (transform->grid_size-1));
-        int z = floor(linear_b * (transform->grid_size-1));
-        int x_n = ceil(linear_r * (transform->grid_size-1));
-        int y_n = ceil(linear_g * (transform->grid_size-1));
-        int z_n = ceil(linear_b * (transform->grid_size-1));
-        float rx = linear_r * (transform->grid_size-1) - x; 
-        float ry = linear_g * (transform->grid_size-1) - y;
-        float rz = linear_b * (transform->grid_size-1) - z; 
+        int x;
+        int y;
+        int z;
+        int x_n;
+        int y_n;
+        int z_n;
+        float rx;
+        float ry;
+        float rz;
+        float lr = linear_r * (transform->grid_size-1);
+        float lg = linear_g * (transform->grid_size-1);
+        float lb = linear_b * (transform->grid_size-1);
+
+#if defined(X86) && !(defined(_M_AMD64) && _MSC_VER == 1400)
+        if (sse_ver >= 4) {
+            xm.m128_f32[0] = lr;
+            xm.m128_f32[1] = lg;
+            xm.m128_f32[2] = lb;
+
+#if _MSC_VER == 1400
+            floor_ps_sse4_1(&xm, &xi);
+#else
+            xi = _mm_cvttps_epi32(_mm_floor_ps(xm));
+#endif
+            x = _mm_cvtsi128_si32(xi);
+            y = _mm_cvtsi128_si32(xi = _mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+            z = _mm_cvtsi128_si32(_mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+
+#if _MSC_VER == 1400
+            ceil_ps_sse4_1(&xm, &xi);
+#else
+            xi = _mm_cvttps_epi32(_mm_ceil_ps(xm));
+#endif
+            x_n = _mm_cvtsi128_si32(xi);
+            y_n = _mm_cvtsi128_si32(xi = _mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+            z_n = _mm_cvtsi128_si32(_mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+
+            rx = lr - x; 
+            ry = lg - y;
+            rz = lb - z; 
+        } else {
+#endif /* defined(X86) && !(defined(_M_AMD64) && _MSC_VER == 1400) */
+            x = floor(lr);
+            y = floor(lg);
+            z = floor(lb);
+            x_n = ceil(lr);
+            y_n = ceil(lg);
+            z_n = ceil(lb);
+            rx = lr - x; 
+            ry = lg - y;
+            rz = lb - z; 
+#if defined(X86) && !(defined(_M_AMD64) && _MSC_VER == 1400)
+        }
+#endif
 
         c0_r = CLU(r_table, x, y, z);
         c0_g = CLU(g_table, x, y, z);
@@ -584,42 +787,112 @@
         clut_g = c0_g + c1_g*rx + c2_g*ry + c3_g*rz;
         clut_b = c0_b + c1_b*rx + c2_b*ry + c3_b*rz;
 
-        dest[OUTPUT_R_INDEX] = clamp_u8(clut_r*255.0f);
-        dest[OUTPUT_G_INDEX] = clamp_u8(clut_g*255.0f);
-        dest[OUTPUT_B_INDEX] = clamp_u8(clut_b*255.0f);
+
+#ifdef X86
+        if (sse_ver >= 2) {
+            xm.m128_f32[0] = clut_r;
+            xm.m128_f32[1] = clut_g;
+            xm.m128_f32[2] = clut_b;
+            clamp_u8_sse2(&xm, &xi);
+
+            dest[OUTPUT_R_INDEX] = _mm_cvtsi128_si32(xi);
+            dest[OUTPUT_G_INDEX] = _mm_cvtsi128_si32(xi = _mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+            dest[OUTPUT_B_INDEX] = _mm_cvtsi128_si32(_mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+        } else {
+#endif
+            dest[OUTPUT_R_INDEX] = clamp_u8(clut_r*255.0f);
+            dest[OUTPUT_G_INDEX] = clamp_u8(clut_g*255.0f);
+            dest[OUTPUT_B_INDEX] = clamp_u8(clut_b*255.0f);
+#ifdef X86
+        }
+#endif
         dest[OUTPUT_A_INDEX] = in_a;
         dest += RGBA_OUTPUT_COMPONENTS;
-    }    
+    }
 }
 
 // Using lcms' tetra interpolation code.
 static void qcms_transform_data_tetra_clut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length) {
-    unsigned int i;
+    int64_t i;
     int xy_len = 1;
     int x_len = transform->grid_size;
     int len = x_len * x_len;
     float* r_table = transform->r_clut;
     float* g_table = transform->g_clut;
     float* b_table = transform->b_clut;
-    float c0_r, c1_r, c2_r, c3_r;
-    float c0_g, c1_g, c2_g, c3_g;
-    float c0_b, c1_b, c2_b, c3_b;
-    float clut_r, clut_g, clut_b;
+    float rcp255 = 1.0f / 255.0f;
+#ifdef X86
+    int sse_ver = sse_version_available();
+#endif
+
     for (i = 0; i < length; i++) {
-        unsigned char in_r = *src++;
-        unsigned char in_g = *src++;
-        unsigned char in_b = *src++;
-        float linear_r = in_r/255.0f, linear_g=in_g/255.0f, linear_b = in_b/255.0f;
+        float c0_r, c1_r, c2_r, c3_r;
+        float c0_g, c1_g, c2_g, c3_g;
+        float c0_b, c1_b, c2_b, c3_b;
+        float clut_r, clut_g, clut_b;
+        unsigned char in_r = src[i * 3 + 0];
+        unsigned char in_g = src[i * 3 + 1];
+        unsigned char in_b = src[i * 3 + 2];
+        float linear_r = in_r*rcp255, linear_g=in_g*rcp255, linear_b = in_b*rcp255;
+#ifdef X86
+        __m128 xm;
+        __m128i xi;
+#endif
 
-        int x = floor(linear_r * (transform->grid_size-1));
-        int y = floor(linear_g * (transform->grid_size-1));
-        int z = floor(linear_b * (transform->grid_size-1));
-        int x_n = ceil(linear_r * (transform->grid_size-1));
-        int y_n = ceil(linear_g * (transform->grid_size-1));
-        int z_n = ceil(linear_b * (transform->grid_size-1));
-        float rx = linear_r * (transform->grid_size-1) - x; 
-        float ry = linear_g * (transform->grid_size-1) - y;
-        float rz = linear_b * (transform->grid_size-1) - z; 
+        int x;
+        int y;
+        int z;
+        int x_n;
+        int y_n;
+        int z_n;
+        float rx;
+        float ry;
+        float rz;
+        float lr = linear_r * (transform->grid_size-1);
+        float lg = linear_g * (transform->grid_size-1);
+        float lb = linear_b * (transform->grid_size-1);
+
+#if defined(X86) && !(defined(_M_AMD64) && _MSC_VER == 1400)
+        if (sse_ver >= 4) {
+            xm.m128_f32[0] = lr;
+            xm.m128_f32[1] = lg;
+            xm.m128_f32[2] = lb;
+
+#if _MSC_VER == 1400
+            floor_ps_sse4_1(&xm, &xi);
+#else
+            xi = _mm_cvttps_epi32(_mm_floor_ps(xm));
+#endif
+            x = _mm_cvtsi128_si32(xi);
+            y = _mm_cvtsi128_si32(xi = _mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+            z = _mm_cvtsi128_si32(_mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+
+#if _MSC_VER == 1400
+            ceil_ps_sse4_1(&xm, &xi);
+#else
+            xi = _mm_cvttps_epi32(_mm_ceil_ps(xm));
+#endif
+            x_n = _mm_cvtsi128_si32(xi);
+            y_n = _mm_cvtsi128_si32(xi = _mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+            z_n = _mm_cvtsi128_si32(_mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+
+            rx = lr - x; 
+            ry = lg - y;
+            rz = lb - z; 
+        } else {
+#endif /* defined(X86) && !(defined(_M_AMD64) && _MSC_VER == 1400) */
+            x = floor(lr);
+            y = floor(lg);
+            z = floor(lb);
+            x_n = ceil(lr);
+            y_n = ceil(lg);
+            z_n = ceil(lb);
+            rx = lr - x; 
+            ry = lg - y;
+            rz = lb - z; 
+#if defined(X86) && !(defined(_M_AMD64) && _MSC_VER == 1400)
+        }
+#endif
 
         c0_r = CLU(r_table, x, y, z);
         c0_g = CLU(g_table, x, y, z);
@@ -699,17 +972,37 @@
         clut_g = c0_g + c1_g*rx + c2_g*ry + c3_g*rz;
         clut_b = c0_b + c1_b*rx + c2_b*ry + c3_b*rz;
 
-        dest[OUTPUT_R_INDEX] = clamp_u8(clut_r*255.0f);
-        dest[OUTPUT_G_INDEX] = clamp_u8(clut_g*255.0f);
-        dest[OUTPUT_B_INDEX] = clamp_u8(clut_b*255.0f);
+#ifdef X86
+        if (sse_ver >= 2) {
+            xm.m128_f32[0] = clut_r;
+            xm.m128_f32[1] = clut_g;
+            xm.m128_f32[2] = clut_b;
+            clamp_u8_sse2(&xm, &xi);
+
+            dest[OUTPUT_R_INDEX] = _mm_cvtsi128_si32(xi);
+            dest[OUTPUT_G_INDEX] = _mm_cvtsi128_si32(xi = _mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+            dest[OUTPUT_B_INDEX] = _mm_cvtsi128_si32(_mm_shuffle_epi32(xi, _MM_SHUFFLE(0, 3, 2, 1)));
+        } else {
+#endif
+            dest[OUTPUT_R_INDEX] = clamp_u8(clut_r*255.0f);
+            dest[OUTPUT_G_INDEX] = clamp_u8(clut_g*255.0f);
+            dest[OUTPUT_B_INDEX] = clamp_u8(clut_b*255.0f);
+#ifdef X86
+        }
+#endif
         dest += RGB_OUTPUT_COMPONENTS;
-    }    
+      }
 }
 
 static void qcms_transform_data_rgb_out_lut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 {
     unsigned int i;
     float (*mat)[4] = transform->matrix;
+#ifdef X86
+    int sse_ver = sse_version_available();
+    __m128 xm;
+    __m128i xi;
+#endif
     for (i = 0; i < length; i++) {
         unsigned char device_r = *src++;
         unsigned char device_g = *src++;
@@ -735,9 +1028,24 @@
         out_device_b = lut_interp_linear(out_linear_b, 
                 transform->output_gamma_lut_b, transform->output_gamma_lut_b_length);
 
-        dest[OUTPUT_R_INDEX] = clamp_u8(out_device_r*255);
-        dest[OUTPUT_G_INDEX] = clamp_u8(out_device_g*255);
-        dest[OUTPUT_B_INDEX] = clamp_u8(out_device_b*255);
+#ifdef X86
+        if (sse_ver >= 2) {
+            xm.m128_f32[0] = out_device_r;
+            xm.m128_f32[1] = out_device_g;
+            xm.m128_f32[2] = out_device_b;
+            clamp_u8_sse2(&xm, &xi);
+
+            dest[OUTPUT_R_INDEX] = xi.m128i_u32[0];
+            dest[OUTPUT_G_INDEX] = xi.m128i_u32[1];
+            dest[OUTPUT_B_INDEX] = xi.m128i_u32[2];
+        } else {
+#endif
+            dest[OUTPUT_R_INDEX] = clamp_u8(out_device_r*255);
+            dest[OUTPUT_G_INDEX] = clamp_u8(out_device_g*255);
+            dest[OUTPUT_B_INDEX] = clamp_u8(out_device_b*255);
+#ifdef X86
+        }
+#endif
         dest += RGB_OUTPUT_COMPONENTS;
     }
 }
@@ -746,6 +1054,11 @@
 {
     unsigned int i;
     float (*mat)[4] = transform->matrix;
+#ifdef X86
+    int sse_ver = sse_version_available();
+    __m128 xm;
+    __m128i xi;
+#endif
     for (i = 0; i < length; i++) {
         unsigned char device_r = *src++;
         unsigned char device_g = *src++;
@@ -772,9 +1085,24 @@
         out_device_b = lut_interp_linear(out_linear_b, 
                 transform->output_gamma_lut_b, transform->output_gamma_lut_b_length);
 
-        dest[OUTPUT_R_INDEX] = clamp_u8(out_device_r*255);
-        dest[OUTPUT_G_INDEX] = clamp_u8(out_device_g*255);
-        dest[OUTPUT_B_INDEX] = clamp_u8(out_device_b*255);
+#ifdef X86
+        if (sse_ver >= 2) {
+            xm.m128_f32[0] = out_device_r;
+            xm.m128_f32[1] = out_device_g;
+            xm.m128_f32[2] = out_device_b;
+            clamp_u8_sse2(&xm, &xi);
+
+            dest[OUTPUT_R_INDEX] = xi.m128i_u32[0];
+            dest[OUTPUT_G_INDEX] = xi.m128i_u32[1];
+            dest[OUTPUT_B_INDEX] = xi.m128i_u32[2];
+        } else {
+#endif
+            dest[OUTPUT_R_INDEX] = clamp_u8(out_device_r*255);
+            dest[OUTPUT_G_INDEX] = clamp_u8(out_device_g*255);
+            dest[OUTPUT_B_INDEX] = clamp_u8(out_device_b*255);
+#ifdef X86
+        }
+#endif
         dest[OUTPUT_A_INDEX] = alpha;
         dest += RGBA_OUTPUT_COMPONENTS;
     }
@@ -785,6 +1113,11 @@
 {
     int i;
     float (*mat)[4] = transform->matrix;
+#ifdef X86
+    int sse_ver = sse_version_available();
+    __m128 xm;
+    __m128i xi;
+#endif
     for (i = 0; i < length; i++) {
         unsigned char device_r = *src++;
         unsigned char device_g = *src++;
@@ -798,9 +1131,24 @@
         float out_linear_g = mat[0][1]*linear_r + mat[1][1]*linear_g + mat[2][1]*linear_b;
         float out_linear_b = mat[0][2]*linear_r + mat[1][2]*linear_g + mat[2][2]*linear_b;
 
-        *dest++ = clamp_u8(out_linear_r*255);
-        *dest++ = clamp_u8(out_linear_g*255);
-        *dest++ = clamp_u8(out_linear_b*255);
+#ifdef X86
+        if (sse_ver >= 2) {
+            xm.m128_f32[0] = out_linear_r;
+            xm.m128_f32[1] = out_linear_g;
+            xm.m128_f32[2] = out_linear_b;
+            clamp_u8_sse2(&xm, &xi);
+
+            *dest++ = xi.m128i_u32[0];
+            *dest++ = xi.m128i_u32[1];
+            *dest++ = xi.m128i_u32[2];
+        } else {
+#endif
+            *dest++ = clamp_u8(out_linear_r*255);
+            *dest++ = clamp_u8(out_linear_g*255);
+            *dest++ = clamp_u8(out_linear_b*255);
+#ifdef X86
+        }
+#endif
     }
 }
 #endif
@@ -896,48 +1244,81 @@
     transform_free(t);
 }
 
-#ifdef X86
-// Determine if we can build with SSE2 (this was partly copied from jmorecfg.h in
-// mozilla/jpeg)
- // -------------------------------------------------------------------------
-#if defined(_M_IX86) && defined(_MSC_VER)
-#define HAS_CPUID
-/* Get us a CPUID function. Avoid clobbering EBX because sometimes it's the PIC
-   register - I'm not sure if that ever happens on windows, but cpuid isn't
-   on the critical path so we just preserve the register to be safe and to be
-   consistent with the non-windows version. */
-static void cpuid(uint32_t fxn, uint32_t *a, uint32_t *b, uint32_t *c, uint32_t *d) {
-       uint32_t a_, b_, c_, d_;
-       __asm {
-              xchg   ebx, esi
-              mov    eax, fxn
-              cpuid
-              mov    a_, eax
-              mov    b_, ebx
-              mov    c_, ecx
-              mov    d_, edx
-              xchg   ebx, esi
-       }
-       *a = a_;
-       *b = b_;
-       *c = c_;
-       *d = d_;
+// -------------------------__cpuid Detection----------------------------------
+
+// The following code was largely taken from xpcom/glue/SSE.cpp and
+// made a little simpler.
+enum CPUIDRegister { eax = 0, ebx = 1, ecx = 2, edx = 3 };
+
+#ifdef HAVE_CPUID_H
+
+// cpuid.h is available on gcc 4.3 and higher on i386 and x86_64
+#include <cpuid.h>
+
+static void
+__cpuid(int CPUInfo[4], int InfoType)
+{
+  __get_cpuid(InfoType,
+    (unsigned int*)&CPUInfo[0],
+    (unsigned int*)&CPUInfo[1],
+    (unsigned int*)&CPUInfo[2],
+    (unsigned int*)&CPUInfo[3]);
 }
-#elif (defined(__GNUC__) || defined(__SUNPRO_C)) && (defined(__i386__) || defined(__i386))
-#define HAS_CPUID
-/* Get us a CPUID function. We can't use ebx because it's the PIC register on
-   some platforms, so we use ESI instead and save ebx to avoid clobbering it. */
-static void cpuid(uint32_t fxn, uint32_t *a, uint32_t *b, uint32_t *c, uint32_t *d) {
 
-    uint32_t a_, b_, c_, d_;
-       __asm__ __volatile__ ("xchgl %%ebx, %%esi; cpuid; xchgl %%ebx, %%esi;" 
-                             : "=a" (a_), "=S" (b_), "=c" (c_), "=d" (d_) : "a" (fxn));
-       *a = a_;
-       *b = b_;
-       *c = c_;
-       *d = d_;
+#define HAVE_CPU_DETECTION
+#else /* HAVE_CPUID_H */
+
+#if defined(_MSC_VER) && _MSC_VER >= 1600 && (defined(_M_IX86) || defined(_M_AMD64))
+// MSVC 2005 or later supports __cpuid by intrin.h
+// But it does't work on MSVC 2005 with SDK 7.1 (Bug 753772)
+#include <intrin.h>
+
+#define HAVE_CPU_DETECTION
+#elif defined(__SUNPRO_CC) && (defined(__i386) || defined(__x86_64__))
+
+// Define a function identical to MSVC function.
+#ifdef __i386
+static void
+__cpuid(int CPUInfo[4], int InfoType)
+{
+  asm (
+    "xchg %esi, %ebx\n"
+    "cpuid\n"
+    "movl %eax, (%edi)\n"
+    "movl %ebx, 4(%edi)\n"
+    "movl %ecx, 8(%edi)\n"
+    "movl %edx, 12(%edi)\n"
+    "xchg %esi, %ebx\n"
+    :
+    : "a"(InfoType), // %eax
+      "D"(CPUInfo) // %edi
+    : "%ecx", "%edx", "%esi"
+  );
 }
+#else
+static void
+__cpuid(int CPUInfo[4], int InfoType)
+{
+  asm (
+    "xchg %rsi, %rbx\n"
+    "cpuid\n"
+    "movl %eax, (%rdi)\n"
+    "movl %ebx, 4(%rdi)\n"
+    "movl %ecx, 8(%rdi)\n"
+    "movl %edx, 12(%rdi)\n"
+    "xchg %rsi, %rbx\n"
+    :
+    : "a"(InfoType), // %eax
+      "D"(CPUInfo) // %rdi
+    : "%ecx", "%edx", "%rsi"
+  );
+}
+
+#define HAVE_CPU_DETECTION
 #endif
+#endif
+
+#endif /* HAVE_CPUID_H */
 
 // -------------------------Runtime SSEx Detection-----------------------------
 
@@ -946,36 +1327,31 @@
 #define SSE1_EDX_MASK (1UL << 25)
 #define SSE2_EDX_MASK (1UL << 26)
 #define SSE3_ECX_MASK (1UL <<  0)
+#define SSE4_ECX_MASK (1UL << 19)
 
 static int sse_version_available(void)
 {
-#if defined(__x86_64__) || defined(__x86_64) || defined(_M_AMD64)
-    /* we know at build time that 64-bit CPUs always have SSE2
-     * this tells the compiler that non-SSE2 branches will never be
-     * taken (i.e. OK to optimze away the SSE1 and non-SIMD code */
-    return 2;
-#elif defined(HAS_CPUID)
+#if defined(HAVE_CPU_DETECTION)
     static int sse_version = -1;
-    uint32_t a, b, c, d;
-    uint32_t function = 0x00000001;
 
     if (sse_version == -1) {
+        volatile int regs[4];
         sse_version = 0;
-        cpuid(function, &a, &b, &c, &d);
-        if (c & SSE3_ECX_MASK)
+        __cpuid((int *)regs, 1);
+        if (regs[2] & SSE4_ECX_MASK)
+            sse_version = 4;
+        else if (regs[2] & SSE3_ECX_MASK)
             sse_version = 3;
-        else if (d & SSE2_EDX_MASK)
+        else if (regs[3] & SSE2_EDX_MASK)
             sse_version = 2;
-        else if (d & SSE1_EDX_MASK)
+        else if (regs[3] & SSE1_EDX_MASK)
             sse_version = 1;
     }
-
     return sse_version;
 #else
     return 0;
 #endif
 }
-#endif
 
 static const struct matrix bradford_matrix = {{    { 0.8951f, 0.2664f,-0.1614f},
                         {-0.7502f, 1.7135f, 0.0367f},
diff -r 022513eead7b gfx/src/nsRect.h
--- a/gfx/src/nsRect.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/src/nsRect.h    Fri Dec 07 19:27:23 2012 +0900
@@ -16,6 +16,62 @@
 #include "nsTraceRefcnt.h"
 #include "mozilla/gfx/BaseRect.h"
 
+#include "mozilla/Util.h"
+#include "mozilla/SSE.h"
+
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+#else
+#include <smmintrin.h>
+#endif
+
+#if (_MSC_VER == 1400) && !defined(_M_AMD64)
+__declspec(naked) __declspec(noinline)
+static __m128d mm_floor_pd_BaseRect(__m128d a)
+{
+  __asm {
+    // roundpd  xmm0, xmm0, 1
+    __asm _emit 0x66
+    __asm _emit 0x0F
+    __asm _emit 0x3A
+    __asm _emit 0x09
+    __asm _emit 0xC0
+    __asm _emit 0x01
+    ret
+  }
+}
+#define _mm_floor_pd(a) mm_floor_pd_BaseRect(a)
+
+__declspec(naked) __declspec(noinline)
+static __m128d mm_ceil_pd_BaseRect(__m128d a)
+{
+  __asm {
+    // roundpd  xmm0, xmm0, 2
+    __asm _emit 0x66
+    __asm _emit 0x0F
+    __asm _emit 0x3A
+    __asm _emit 0x09
+    __asm _emit 0xC0
+    __asm _emit 0x02
+    ret
+  }
+}
+#define _mm_ceil_pd(a) mm_ceil_pd_BaseRect(a)
+
+/* VC8 doesn't support some SSE2 built-in functions, so we define them here. */
+static __forceinline __m128
+_mm_castsi128_ps(__m128i a)
+{
+    return *(__m128 *)&a;
+}
+
+static __forceinline __m128i
+_mm_castps_si128(__m128 a)
+{
+    return *(__m128i *)&a;
+}
+#endif
+
 struct nsIntRect;
 
 struct NS_GFX nsRect :
@@ -42,6 +98,10 @@
   {
     MOZ_COUNT_CTOR(nsRect);
   }
+  nsRect(const __m128i& a128i) : Super(a128i)
+  {
+    MOZ_COUNT_CTOR(nsRect);
+  }
 
 #ifdef NS_BUILD_REFCNT_LOGGING
   ~nsRect() {
@@ -225,6 +285,9 @@
       Super(aX, aY, aWidth, aHeight)
   {
   }
+  nsIntRect(const __m128i& a128i) : Super(a128i)
+  {
+  }
 
   inline nsRect ToAppUnits(nscoord aAppUnitsPerPixel) const;
 
@@ -282,11 +345,29 @@
   return rect;
 }
 
+static const MOZ_ALIGNED_DECL(double d_half[2], 16) = { 0.5, 0.5 };
+
 // scale the rect but round to preserve centers
 inline nsIntRect
 nsRect::ScaleToNearestPixels(float aXScale, float aYScale,
                              nscoord aAppUnitsPerPixel) const
 {
+#if !defined(NS_COORD_IS_FLOAT) && ((_MSC_VER != 1400) || !defined(_M_AMD64))
+  if (IsInt32x4() && mozilla::supports_sse4_1()) {
+    __m128d appUnitsPerPixel_x2 = _mm_cvtepi32_pd(_mm_set1_epi32(aAppUnitsPerPixel));
+    __m128i src_x4 = _mm_loadu_si128((__m128i *)&x);
+    __m128d xy = _mm_cvtepi32_pd(src_x4);
+    __m128d xyMost = _mm_cvtepi32_pd(_mm_add_epi32(src_x4, _mm_srli_si128(src_x4, 8)));
+    __m128d xyScale = _mm_cvtps_pd(_mm_unpacklo_ps(_mm_load_ss(&aXScale), _mm_load_ss(&aYScale)));
+
+    __m128i rectXY = _mm_cvttpd_epi32(_mm_floor_pd(_mm_add_pd(_mm_mul_pd(_mm_div_pd(xy, appUnitsPerPixel_x2), xyScale), *(__m128d *)&d_half)));
+    __m128i rectWH = _mm_sub_epi32(_mm_cvttpd_epi32(_mm_floor_pd(_mm_add_pd(_mm_mul_pd(_mm_div_pd(xyMost, appUnitsPerPixel_x2), xyScale), *(__m128d *)&d_half))), rectXY);
+    __m128i rect = _mm_unpacklo_epi64(rectXY, rectWH);
+
+    return nsIntRect(rect);
+  }
+#endif
+
   nsIntRect rect;
   rect.x = NSToIntRoundUp(NSAppUnitsToDoublePixels(x, aAppUnitsPerPixel) * aXScale);
   rect.y = NSToIntRoundUp(NSAppUnitsToDoublePixels(y, aAppUnitsPerPixel) * aYScale);
@@ -302,6 +383,23 @@
 nsRect::ScaleToOutsidePixels(float aXScale, float aYScale,
                              nscoord aAppUnitsPerPixel) const
 {
+#if !defined(NS_COORD_IS_FLOAT) && ((_MSC_VER != 1400) || !defined(_M_AMD64))
+  if (IsInt32x4() && mozilla::supports_sse4_1()) {
+    __m128 appUnitsPerPixel_x4 = _mm_cvtepi32_ps(_mm_set1_epi32(aAppUnitsPerPixel));
+    __m128i src_x4 = _mm_loadu_si128((__m128i *)&x);
+    __m128 xy_xyMost = _mm_cvtepi32_ps(_mm_add_epi32(src_x4, _mm_slli_si128(src_x4, 8)));
+    __m128 xyScale_x2 = _mm_unpacklo_ps(_mm_load_ss(&aXScale), _mm_load_ss(&aYScale));
+    xyScale_x2 = _mm_movelh_ps(xyScale_x2, xyScale_x2);
+
+    __m128 a = _mm_mul_ps(_mm_div_ps(xy_xyMost, appUnitsPerPixel_x4), xyScale_x2);
+    __m128i rectXY = _mm_cvttpd_epi32(_mm_floor_pd(_mm_cvtps_pd(a)));
+    __m128i rectWH = _mm_sub_epi32(_mm_cvttpd_epi32(_mm_ceil_pd(_mm_cvtps_pd(_mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(a), 8))))), rectXY);
+    __m128i rect = _mm_unpacklo_epi64(rectXY, rectWH);
+
+    return nsIntRect(rect);
+  }
+#endif
+
   nsIntRect rect;
   rect.x = NSToIntFloor(NSAppUnitsToFloatPixels(x, float(aAppUnitsPerPixel)) * aXScale);
   rect.y = NSToIntFloor(NSAppUnitsToFloatPixels(y, float(aAppUnitsPerPixel)) * aYScale);
@@ -317,6 +415,23 @@
 nsRect::ScaleToInsidePixels(float aXScale, float aYScale,
                             nscoord aAppUnitsPerPixel) const
 {
+#if !defined(NS_COORD_IS_FLOAT) && ((_MSC_VER != 1400) || !defined(_M_AMD64))
+  if (IsInt32x4() && mozilla::supports_sse4_1()) {
+    __m128 appUnitsPerPixel_x4 = _mm_cvtepi32_ps(_mm_set1_epi32(aAppUnitsPerPixel));
+    __m128i src_x4 = _mm_loadu_si128((__m128i *)&x);
+    __m128 xy_xyMost = _mm_cvtepi32_ps(_mm_add_epi32(src_x4, _mm_slli_si128(src_x4, 8)));
+    __m128 xyScale_x2 = _mm_unpacklo_ps(_mm_load_ss(&aXScale), _mm_load_ss(&aYScale));
+    xyScale_x2 = _mm_movelh_ps(xyScale_x2, xyScale_x2);
+
+    __m128 a = _mm_mul_ps(_mm_div_ps(xy_xyMost, appUnitsPerPixel_x4), xyScale_x2);
+    __m128i rectXY = _mm_cvttpd_epi32(_mm_ceil_pd(_mm_cvtps_pd(a)));
+    __m128i rectWH = _mm_sub_epi32(_mm_cvttpd_epi32(_mm_floor_pd(_mm_cvtps_pd(_mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(a), 8))))), rectXY);
+    __m128i rect = _mm_unpacklo_epi64(rectXY, rectWH);
+
+    return nsIntRect(rect);
+  }
+#endif
+
   nsIntRect rect;
   rect.x = NSToIntCeil(NSAppUnitsToFloatPixels(x, float(aAppUnitsPerPixel)) * aXScale);
   rect.y = NSToIntCeil(NSAppUnitsToFloatPixels(y, float(aAppUnitsPerPixel)) * aYScale);
@@ -330,18 +445,63 @@
 inline nsIntRect
 nsRect::ToNearestPixels(nscoord aAppUnitsPerPixel) const
 {
+#if !defined(NS_COORD_IS_FLOAT) && ((_MSC_VER != 1400) || !defined(_M_AMD64))
+  if (IsInt32x4() && mozilla::supports_sse4_1()) {
+    __m128d appUnitsPerPixel_x2 = _mm_cvtepi32_pd(_mm_set1_epi32(aAppUnitsPerPixel));
+    __m128i src_x4 = _mm_loadu_si128((__m128i *)&x);
+    __m128d xy = _mm_cvtepi32_pd(src_x4);
+    __m128d xyMost = _mm_cvtepi32_pd(_mm_add_epi32(src_x4, _mm_srli_si128(src_x4, 8)));
+
+    __m128i rectXY = _mm_cvttpd_epi32(_mm_floor_pd(_mm_add_pd(_mm_div_pd(xy, appUnitsPerPixel_x2), *(__m128d *)&d_half)));
+    __m128i rectWH = _mm_sub_epi32(_mm_cvttpd_epi32(_mm_floor_pd(_mm_add_pd(_mm_div_pd(xyMost, appUnitsPerPixel_x2), *(__m128d *)&d_half))), rectXY);
+    __m128i rect = _mm_unpacklo_epi64(rectXY, rectWH);
+
+    return nsIntRect(rect);
+  }
+#endif
+
   return ScaleToNearestPixels(1.0f, 1.0f, aAppUnitsPerPixel);
 }
 
 inline nsIntRect
 nsRect::ToOutsidePixels(nscoord aAppUnitsPerPixel) const
 {
+#if !defined(NS_COORD_IS_FLOAT) && ((_MSC_VER != 1400) || !defined(_M_AMD64))
+  if (IsInt32x4() && mozilla::supports_sse4_1()) {
+    __m128 appUnitsPerPixel_x4 = _mm_cvtepi32_ps(_mm_set1_epi32(aAppUnitsPerPixel));
+    __m128i src_x4 = _mm_loadu_si128((__m128i *)&x);
+    __m128 xy_xyMost = _mm_cvtepi32_ps(_mm_add_epi32(src_x4, _mm_slli_si128(src_x4, 8)));
+
+    __m128 a = _mm_div_ps(xy_xyMost, appUnitsPerPixel_x4);
+    __m128i rectXY = _mm_cvttpd_epi32(_mm_floor_pd(_mm_cvtps_pd(a)));
+    __m128i rectWH = _mm_sub_epi32(_mm_cvttpd_epi32(_mm_ceil_pd(_mm_cvtps_pd(_mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(a), 8))))), rectXY);
+    __m128i rect = _mm_unpacklo_epi64(rectXY, rectWH);
+
+    return nsIntRect(rect);
+  }
+#endif
+
   return ScaleToOutsidePixels(1.0f, 1.0f, aAppUnitsPerPixel);
 }
 
 inline nsIntRect
 nsRect::ToInsidePixels(nscoord aAppUnitsPerPixel) const
 {
+#if !defined(NS_COORD_IS_FLOAT) && ((_MSC_VER != 1400) || !defined(_M_AMD64))
+  if (IsInt32x4() && mozilla::supports_sse4_1()) {
+    __m128 appUnitsPerPixel_x4 = _mm_cvtepi32_ps(_mm_set1_epi32(aAppUnitsPerPixel));
+    __m128i src_x4 = _mm_loadu_si128((__m128i *)&x);
+    __m128 xy_xyMost = _mm_cvtepi32_ps(_mm_add_epi32(src_x4, _mm_slli_si128(src_x4, 8)));
+
+    __m128 a = _mm_div_ps(xy_xyMost, appUnitsPerPixel_x4);
+    __m128i rectXY = _mm_cvttpd_epi32(_mm_ceil_pd(_mm_cvtps_pd(a)));
+    __m128i rectWH = _mm_sub_epi32(_mm_cvttpd_epi32(_mm_floor_pd(_mm_cvtps_pd(_mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(a), 8))))), rectXY);
+    __m128i rect = _mm_unpacklo_epi64(rectXY, rectWH);
+
+    return nsIntRect(rect);
+  }
+#endif
+
   return ScaleToInsidePixels(1.0f, 1.0f, aAppUnitsPerPixel);
 }
 
diff -r 022513eead7b gfx/thebes/gfxContext.h
--- a/gfx/thebes/gfxContext.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/thebes/gfxContext.h    Fri Dec 07 19:27:23 2012 +0900
@@ -659,7 +659,11 @@
         /**
          * Disable copying of backgrounds in PushGroupAndCopyBackground.
          */
-        FLAG_DISABLE_COPY_BACKGROUND = (1 << 2)
+        FLAG_DISABLE_COPY_BACKGROUND = (1 << 2),
+        /**
+         * tete009 extension
+         */
+        FLAG_DRAW_SINGLE_IMAGE_TT = (1 << 20)
     };
 
     void SetFlag(int32_t aFlag) { mFlags |= aFlag; }
diff -r 022513eead7b gfx/thebes/gfxUtils.cpp
--- a/gfx/thebes/gfxUtils.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/gfx/thebes/gfxUtils.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -462,8 +462,12 @@
                            uint32_t         aImageFlags)
 {
     SAMPLE_LABEL("gfxUtils", "DrawPixelSnapped");
-    bool doTile = !aImageRect.Contains(aSourceRect) &&
-                  !(aImageFlags & imgIContainer::FLAG_CLAMP);
+
+    bool drawSingleImage = (aContext->GetFlags() & gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+    aContext->ClearFlag(gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+
+    bool doTile = (drawSingleImage ? false : (!aImageRect.Contains(aSourceRect) &&
+                  !(aImageFlags & imgIContainer::FLAG_CLAMP)));
 
     nsRefPtr<gfxASurface> currentTarget = aContext->CurrentSurface();
     gfxMatrix deviceSpaceToImageSpace =
diff -r 022513eead7b image/decoders/icon/win/nsIconChannel.cpp
--- a/image/decoders/icon/win/nsIconChannel.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/image/decoders/icon/win/nsIconChannel.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -450,6 +450,9 @@
   return bmi;
 }
 
+#ifdef _MSC_VER
+#pragma function(memcpy)
+#endif
 nsresult nsIconChannel::MakeInputStream(nsIInputStream** _retval, bool nonBlocking)
 {
   // Check whether the icon requested's a file icon or a stock icon
@@ -584,6 +587,9 @@
     rv = NS_ERROR_NOT_AVAILABLE;
   return rv;
 }
+#ifdef _MSC_VER
+#pragma intrinsic(memcpy)
+#endif
 
 NS_IMETHODIMP nsIconChannel::GetContentType(nsACString &aContentType) 
 {
diff -r 022513eead7b image/src/imgFrame.cpp
--- a/image/src/imgFrame.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/image/src/imgFrame.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -442,6 +442,9 @@
   NS_ASSERTION(!aSubimage.IsEmpty(), "zero source size --- fix caller");
   NS_ASSERTION(!mPalettedImageData, "Directly drawing a paletted image!");
 
+  bool drawSingleImage = (aContext->GetFlags() & gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+  aContext->ClearFlag(gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+
   bool doPadding = aPadding != nsIntMargin(0,0,0,0);
   bool doPartialDecode = !ImageComplete();
 
@@ -460,14 +463,17 @@
   NS_ASSERTION(!sourceRect.Intersect(subimage).IsEmpty(),
                "We must be allowed to sample *some* source pixels!");
 
-  bool doTile = !imageRect.Contains(sourceRect) &&
-                !(aImageFlags & imgIContainer::FLAG_CLAMP);
+  bool doTile = (drawSingleImage ? false : (!imageRect.Contains(sourceRect) &&
+                !(aImageFlags & imgIContainer::FLAG_CLAMP)));
   SurfaceWithFormat surfaceResult =
     SurfaceForDrawing(doPadding, doPartialDecode, doTile, aPadding,
                       userSpaceToImageSpace, fill, subimage, sourceRect,
                       imageRect);
 
   if (surfaceResult.IsValid()) {
+    if (drawSingleImage) {
+      aContext->SetFlag(gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+    }
     gfxUtils::DrawPixelSnapped(aContext, surfaceResult.mDrawable,
                                userSpaceToImageSpace,
                                subimage, sourceRect, imageRect, fill,
diff -r 022513eead7b image/src/imgLoader.cpp
--- a/image/src/imgLoader.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/image/src/imgLoader.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -1142,13 +1142,15 @@
     NS_ASSERTION(entry, "imgLoader::CheckCacheLimits -- NULL entry pointer");
 
 #if defined(PR_LOGGING)
-    nsRefPtr<imgRequest> req(entry->GetRequest());
-    if (req) {
-      nsCOMPtr<nsIURI> uri;
-      req->GetURI(getter_AddRefs(uri));
-      nsAutoCString spec;
-      uri->GetSpec(spec);
-      LOG_STATIC_FUNC_WITH_PARAM(gImgLog, "imgLoader::CheckCacheLimits", "entry", spec.get());
+    if (entry) {
+      nsRefPtr<imgRequest> req(entry->GetRequest());
+      if (req) {
+        nsCOMPtr<nsIURI> uri;
+        req->GetURI(getter_AddRefs(uri));
+        nsAutoCString spec;
+        uri->GetSpec(spec);
+        LOG_STATIC_FUNC_WITH_PARAM(gImgLog, "imgLoader::CheckCacheLimits", "entry", spec.get());
+      }
     }
 #endif
 
diff -r 022513eead7b ipc/ipdl/Makefile.in
--- a/ipc/ipdl/Makefile.in    Wed Dec 05 00:56:18 2012 -0800
+++ b/ipc/ipdl/Makefile.in    Fri Dec 07 19:27:23 2012 +0900
@@ -101,3 +101,10 @@
 # We #include some things in the dom/plugins/ directory that rely on
 # toolkit libraries.
 CXXFLAGS    += $(TK_CFLAGS)
+
+ifdef MOZ_THUNDERBIRD
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# avoid the fatal error C1001 of compiler when applying PGO to Thunderbird
+COMPILE_CXXFLAGS += -GL-
+endif
+endif
diff -r 022513eead7b js/public/Vector.h
--- a/js/public/Vector.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/js/public/Vector.h    Fri Dec 07 19:27:23 2012 +0900
@@ -135,6 +135,10 @@
             *dst = *p;
     }
 
+    static inline void copyConstruct(wchar_t *dst, const wchar_t *srcbeg, const wchar_t *srcend) {
+        PodCopy(dst, srcbeg, srcend - srcbeg);
+    }
+
     template <class U>
     static inline void moveConstruct(T *dst, const U *srcbeg, const U *srcend) {
         copyConstruct(dst, srcbeg, srcend);
diff -r 022513eead7b js/src/Makefile.in
--- a/js/src/Makefile.in    Wed Dec 05 00:56:18 2012 -0800
+++ b/js/src/Makefile.in    Fri Dec 07 19:27:23 2012 +0900
@@ -950,3 +950,18 @@
 # END kludges for the Nitro assembler
 ###############################################
 
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# Optimizer bug with MSVC PGO (Bug 595653)
+YarrPattern.$(OBJ_SUFFIX): COMPILE_CXXFLAGS := $(COMPILE_CXXFLAGS:arch:SSE2=arch:SSE)
+
+# -LTCG:PGINSTRUMENT bug of MSVC PGO
+PolyIC.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL-
+
+# -LTCG:PGINSTRUMENT bug of MSVC PGO
+MonoIC.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL-
+
+# Optimizer bug with MSVC PGO
+FrameState.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL-
+
+FastOps.$(OBJ_SUFFIX): COMPILE_CXXFLAGS += -GL-
+endif
diff -r 022513eead7b js/src/jsapi.cpp
--- a/js/src/jsapi.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/js/src/jsapi.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -3710,7 +3710,7 @@
         return JS_TRUE;
     }
 
-    *foundp = obj->nativeContains(cx, id);
+    *foundp = obj->nativeContains(cx, (HandleId)id);
     return JS_TRUE;
 }
 
diff -r 022513eead7b js/src/jsdhash.cpp
--- a/js/src/jsdhash.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/js/src/jsdhash.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -8,6 +8,9 @@
  *
  * Try to keep this file in sync with xpcom/glue/pldhash.cpp.
  */
+#if _MSC_VER >= 1400
+#include <intrin.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -133,13 +136,29 @@
                       const JSDHashEntryHdr *from,
                       JSDHashEntryHdr *to)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __movsd((unsigned long*)to, (unsigned long*)from, table->entrySize >> 2);
+    } else {
+        js_memcpy(to, from, table->entrySize);
+    }
+#else
     js_memcpy(to, from, table->entrySize);
+#endif
 }
 
 JS_PUBLIC_API(void)
 JS_DHashClearEntryStub(JSDHashTable *table, JSDHashEntryHdr *entry)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __stosd((unsigned long*)entry, 0, table->entrySize >> 2);
+    } else {
+        memset(entry, 0, table->entrySize);
+    }
+#else
     memset(entry, 0, table->entrySize);
+#endif
 }
 
 JS_PUBLIC_API(void)
@@ -532,7 +551,29 @@
     table->generation++;
 
     /* Assign the new entry store to table. */
+#ifdef TT_MEMUTIL
+    {
+        static JSBool initialized = JS_FALSE;
+        static uint32_t dwNonTemporalDataSizeMin = NON_TEMPORAL_STORES_NOT_SUPPORTED;
+
+        if (!initialized) {
+            dwNonTemporalDataSizeMin = GetNonTemporalDataSizeMin_tt();
+            initialized = JS_TRUE;
+        }
+
+        if (nbytes < dwNonTemporalDataSizeMin ||
+            NON_TEMPORAL_STORES_NOT_SUPPORTED == dwNonTemporalDataSizeMin)
+        {
+            memset(newEntryStore, 0, nbytes);
+        }
+        else
+        {
+            memset_nontemporal_tt(newEntryStore, 0, nbytes);
+        }
+    }
+#else
     memset(newEntryStore, 0, nbytes);
+#endif
     oldEntryAddr = oldEntryStore = table->entryStore;
     table->entryStore = newEntryStore;
     moveEntry = table->ops->moveEntry;
diff -r 022513eead7b js/src/jsmath.cpp
--- a/js/src/jsmath.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/js/src/jsmath.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -28,6 +28,20 @@
 #include "jsinferinlines.h"
 #include "jsobjinlines.h"
 
+#if defined JS_CPU_X86 || defined JS_CPU_X64
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+#else  /* _MSC_VER == 1400 */
+#include <smmintrin.h>
+#endif /* _MSC_VER == 1400 */
+#endif /* defined JS_CPU_X86 || defined JS_CPU_X64 */
+
+# include "assembler/assembler/MacroAssembler.h"
+
+#if (_M_IX86_FP >= 2)
+#pragma function(floor)
+#endif
+
 using namespace js;
 
 #ifndef M_E
@@ -222,13 +236,42 @@
     return JS_TRUE;
 }
 
-double
+JS_ALWAYS_INLINE double
 js_math_ceil_impl(double x)
 {
 #ifdef __APPLE__
     if (x < 0 && x > -1.0)
         return js_copysign(0, -1);
 #endif
+
+#if defined JS_CPU_X86 || defined JS_CPU_X64
+    if (JSC::MacroAssemblerX86Common::getSSEState() >=
+        JSC::MacroAssemblerX86Common::HasSSE4_1) {
+#if _MSC_VER != 1400
+        __m128d xd = _mm_load_sd(&x);
+        double d;
+
+        xd = _mm_ceil_sd(xd, xd);
+        _mm_store_sd(&d, xd);
+        return d;
+#elif defined JS_CPU_X86
+        double d;
+
+        __asm {
+            movsd       xmm0, x
+            /* roundsd  xmm0, xmm0, 2 */
+            __asm _emit 0x66
+            __asm _emit 0x0F
+            __asm _emit 0x3A
+            __asm _emit 0x0B
+            __asm _emit 0xC0
+            __asm _emit 0x02
+            movsd       d, xmm0
+        }
+        return d;
+#endif
+    }
+#endif /* defined JS_CPU_X86 || defined JS_CPU_X64 */
     return ceil(x);
 }
 
@@ -306,9 +349,37 @@
     return JS_TRUE;
 }
 
-double
+JS_ALWAYS_INLINE double
 js_math_floor_impl(double x)
 {
+#if defined JS_CPU_X86 || defined JS_CPU_X64
+    if (JSC::MacroAssemblerX86Common::getSSEState() >=
+        JSC::MacroAssemblerX86Common::HasSSE4_1) {
+#if _MSC_VER != 1400
+        __m128d xd = _mm_load_sd(&x);
+        double d;
+
+        xd = _mm_floor_sd(xd, xd);
+        _mm_store_sd(&d, xd);
+        return d;
+#elif defined JS_CPU_X86
+        double d;
+
+        __asm {
+            movsd       xmm0, x
+            /* roundsd  xmm0, xmm0, 1 */
+            __asm _emit 0x66
+            __asm _emit 0x0F
+            __asm _emit 0x3A
+            __asm _emit 0x0B
+            __asm _emit 0xC0
+            __asm _emit 0x01
+            movsd       d, xmm0
+        }
+        return d;
+#endif
+    }
+#endif /* defined JS_CPU_X86 || defined JS_CPU_X64 */
     return floor(x);
 }
 
@@ -560,6 +631,61 @@
     return JS_TRUE;
 }
 
+#if (defined(JS_CPU_X86) || defined(JS_CPU_X64)) && _MSC_VER
+static const double  dbhalf =  0.5;
+__declspec(align(16)) static const __int64 mask_sign[2] = { 0x8000000000000000 };
+#endif
+
+JS_ALWAYS_INLINE double
+js_math_round_impl(double x)
+{
+#if defined JS_CPU_X86 || defined JS_CPU_X64
+    if (JSC::MacroAssemblerX86Common::getSSEState() >=
+        JSC::MacroAssemblerX86Common::HasSSE4_1) {
+#if _MSC_VER != 1400
+        __m128d xmm1d = _mm_load_sd(&x);
+        __m128d xmm0d = xmm1d;
+        double d;
+
+        xmm0d = _mm_add_sd(xmm0d, *(__m128d *)&dbhalf);
+        xmm0d = _mm_floor_sd(xmm0d, xmm0d);
+
+        __m128i xmm2i = _mm_load_si128((__m128i *)mask_sign);
+        __m128i xmm1i = _mm_castpd_si128(xmm1d);
+
+        xmm1i = _mm_and_si128(xmm1i, xmm2i);
+        xmm2i = _mm_andnot_si128(xmm2i, _mm_castpd_si128(xmm0d));
+        xmm1i = _mm_or_si128(xmm1i, xmm2i);
+
+        _mm_store_sd(&d, _mm_castsi128_pd(xmm1i));
+        return d;
+#elif defined JS_CPU_X86
+        double d;
+
+        __asm {
+            movsd       xmm1, x
+            movdqa      xmm2, mask_sign
+            movaps      xmm0, xmm1
+            addsd       xmm0, dbhalf
+            pand        xmm1, xmm2
+            /* roundsd  xmm0, xmm0, 1 */
+            __asm _emit 0x66
+            __asm _emit 0x0F
+            __asm _emit 0x3A
+            __asm _emit 0x0B
+            __asm _emit 0xC0
+            __asm _emit 0x01
+            pandn       xmm2, xmm0
+            por         xmm1, xmm2
+            movsd       d, xmm1
+        }
+        return d;
+#endif
+    }
+#endif /* defined JS_CPU_X86 || defined JS_CPU_X64 */
+    return js_copysign(js_math_floor_impl(x + 0.5), x);
+}
+
 JSBool /* ES5 15.8.2.15. */
 js_math_round(JSContext *cx, unsigned argc, Value *vp)
 {
@@ -586,7 +712,7 @@
         return true;
     }
 
-    args.rval().setNumber(js_copysign(floor(x + 0.5), x));
+    args.rval().setNumber(js_math_round_impl(x));
     return true;
 }
 
diff -r 022513eead7b js/src/jsobj.cpp
--- a/js/src/jsobj.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/js/src/jsobj.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -4229,7 +4229,7 @@
         return false;
 
     /* Update slotful shapes according to the value produced by the getter. */
-    if (shapeRoot->hasSlot() && pobjRoot->nativeContains(cx, shapeRoot))
+    if (shapeRoot->hasSlot() && pobjRoot->nativeContains(cx, (HandleShape)shapeRoot))
         pobjRoot->nativeSetSlot(shapeRoot->slot(), nvp);
 
     *vp = nvp;
@@ -4282,7 +4282,7 @@
      */
     if (shapeRoot->hasSlot() &&
         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
-         obj->nativeContains(cx, shapeRoot))) {
+         obj->nativeContains(cx, (HandleShape)shapeRoot))) {
         AddTypePropertyId(cx, obj, shape->propid(), *vp);
         obj->setSlot(shapeRoot->slot(), nvp);
     }
diff -r 022513eead7b js/src/jsobjinlines.h
--- a/js/src/jsobjinlines.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/js/src/jsobjinlines.h    Fri Dec 07 19:27:23 2012 +0900
@@ -8,6 +8,10 @@
 #ifndef jsobjinlines_h___
 #define jsobjinlines_h___
 
+#if (_M_IX86_FP >= 2) || defined(__SSE2__) || defined(_M_AMD64) || defined(__amd64__)
+#include <emmintrin.h>
+#endif
+
 #include "jsapi.h"
 #include "jsarray.h"
 #include "jsbool.h"
@@ -1379,7 +1383,25 @@
 inline void
 NewObjectCache::copyCachedToObject(JSObject *dst, JSObject *src)
 {
+#if (_M_IX86_FP >= 2) || defined(__SSE2__) || defined(_M_AMD64) || defined(__amd64__)
+    if ((dst->sizeOfThis() & 15) == 0 &&
+        ((unsigned)dst & 15) == 0) {
+        char *s = (char *)src;
+        char *d = (char *)dst;
+        int count = (dst->sizeOfThis() >> 4);
+
+        for (int i = 0; i < count; i++) {
+            _mm_store_si128((__m128i *)d, _mm_loadu_si128((__m128i const*)s));
+            s += 16;
+            d += 16;
+        }
+    } else {
+        js_memcpy(dst, src, dst->sizeOfThis());
+    }
+#else
     js_memcpy(dst, src, dst->sizeOfThis());
+#endif
+
 #ifdef JSGC_GENERATIONAL
     Shape::writeBarrierPost(dst->shape_, &dst->shape_);
     types::TypeObject::writeBarrierPost(dst->type_, &dst->type_);
diff -r 022513eead7b js/src/methodjit/Compiler.cpp
--- a/js/src/methodjit/Compiler.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/js/src/methodjit/Compiler.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -984,6 +984,10 @@
     return false;
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
+
 CompileStatus
 mjit::CanMethodJIT(JSContext *cx, JSScript *scriptArg, jsbytecode *pc,
                    bool construct, CompileRequest request, StackFrame *frame)
@@ -1117,6 +1121,10 @@
     return status;
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
+
 CompileStatus
 mjit::Compiler::generatePrologue()
 {
@@ -4841,6 +4849,10 @@
     callSites.append(site);
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
+
 void
 mjit::Compiler::inlineStubCall(void *stub, RejoinState rejoin, Uses uses)
 {
@@ -4857,6 +4869,10 @@
     addCallSite(site);
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
+
 bool
 mjit::Compiler::compareTwoValues(JSContext *cx, JSOp op, const Value &lhs, const Value &rhs)
 {
diff -r 022513eead7b js/src/yarr/YarrInterpreter.cpp
--- a/js/src/yarr/YarrInterpreter.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/js/src/yarr/YarrInterpreter.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -1853,7 +1853,13 @@
     unsigned m_currentAlternativeIndex;
     Vector<ParenthesesStackEntry> m_parenthesesStack;
     Vector<ByteDisjunction*> m_allParenthesesInfo;
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
 };
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
 
 PassOwnPtr<BytecodePattern> byteCompile(YarrPattern& pattern, BumpPointerAllocator* allocator)
 {
diff -r 022513eead7b layout/base/FrameLayerBuilder.cpp
--- a/layout/base/FrameLayerBuilder.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/layout/base/FrameLayerBuilder.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -292,6 +292,10 @@
     return aRect.ScaleToNearestPixels(mParameters.mXScale, mParameters.mYScale,
                                       mAppUnitsPerDevPixel);
   }
+  nsIntRect ToNearestPixels(const nsRect& aRect)
+  {
+    return aRect.ToNearestPixels(mAppUnitsPerDevPixel);
+  }
   nsIntRegion ScaleRegionToNearestPixels(const nsRegion& aRegion)
   {
     return aRegion.ScaleToNearestPixels(mParameters.mXScale, mParameters.mYScale,
@@ -305,6 +309,13 @@
     return aRect.ScaleToOutsidePixels(mParameters.mXScale, mParameters.mYScale,
                                       mAppUnitsPerDevPixel);
   }
+  nsIntRect ToOutsidePixels(const nsRect& aRect, bool aSnap)
+  {
+    if (aSnap && mSnappingEnabled) {
+      return ToNearestPixels(aRect);
+    }
+    return aRect.ToOutsidePixels(mAppUnitsPerDevPixel);
+  }
   nsIntRect ScaleToInsidePixels(const nsRect& aRect, bool aSnap)
   {
     if (aSnap && mSnappingEnabled) {
@@ -313,7 +324,13 @@
     return aRect.ScaleToInsidePixels(mParameters.mXScale, mParameters.mYScale,
                                      mAppUnitsPerDevPixel);
   }
-
+  nsIntRect ToInsidePixels(const nsRect& aRect, bool aSnap)
+  {
+    if (aSnap && mSnappingEnabled) {
+      return ToNearestPixels(aRect);
+    }
+    return aRect.ToInsidePixels(mAppUnitsPerDevPixel);
+  }
   nsIntRegion ScaleRegionToInsidePixels(const nsRegion& aRegion, bool aSnap)
   {
     if (aSnap && mSnappingEnabled) {
@@ -2016,6 +2033,7 @@
                                     uint32_t aFlags)
 {
   SAMPLE_LABEL("ContainerState", "ProcessDisplayItems");
+  const bool scaled = mParameters.Scaled();
 
    const nsIFrame* lastActiveScrolledRoot = nullptr;
    nsPoint topLeft;
@@ -2044,13 +2062,16 @@
       "items in a container layer should all have the same app units per dev pixel");
 
     nsIntRect itemVisibleRect =
-      ScaleToOutsidePixels(item->GetVisibleRect(), false);
+      scaled ? ScaleToOutsidePixels(item->GetVisibleRect(), false) :
+               ToOutsidePixels(item->GetVisibleRect(), false);
     bool snap;
     nsRect itemContent = item->GetBounds(mBuilder, &snap);
-    nsIntRect itemDrawRect = ScaleToOutsidePixels(itemContent, snap);
+    nsIntRect itemDrawRect = scaled ? ScaleToOutsidePixels(itemContent, snap) :
+                                          ToOutsidePixels(itemContent, snap);
     if (aClip.mHaveClipRect) {
       itemContent.IntersectRect(itemContent, aClip.mClipRect);
-      nsIntRect clipRect = ScaleToNearestPixels(aClip.mClipRect);
+      nsIntRect clipRect = scaled ? ScaleToNearestPixels(aClip.mClipRect) :
+                                    ToNearestPixels(aClip.mClipRect);
       itemDrawRect.IntersectRect(itemDrawRect, clipRect);
     }
     mBounds.UnionRect(mBounds, itemContent);
@@ -2131,7 +2152,12 @@
                    "If we have rounded rects, we must have a clip rect");
       // It has its own layer. Update that layer's clip and visible rects.
       if (aClip.mHaveClipRect) {
-        nsIntRect clip = ScaleToNearestPixels(aClip.NonRoundedIntersection());
+        nsIntRect clip;
+        if (scaled) {
+          clip = ScaleToNearestPixels(aClip.NonRoundedIntersection());
+        } else {
+          clip = ToNearestPixels(aClip.NonRoundedIntersection());
+        }
         clip.MoveBy(mParameters.mOffset);
         ownLayer->IntersectClipRect(clip);
       }

diff -r 022513eead7b layout/base/FrameLayerBuilder.h
--- a/layout/base/FrameLayerBuilder.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/layout/base/FrameLayerBuilder.h    Fri Dec 07 19:27:23 2012 +0900
@@ -152,6 +152,11 @@
       mInActiveTransformedSubtree(aParent.mInActiveTransformedSubtree),
       mDisableSubpixelAntialiasingInDescendants(aParent.mDisableSubpixelAntialiasingInDescendants)
     {}
+    bool Scaled()
+    {
+      return (0x3f800000 != *(uint32_t *)&mXScale) ||
+             (0x3f800000 != *(uint32_t *)&mYScale);
+    }
     float mXScale, mYScale;
 
     /**
diff -r 022513eead7b layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/layout/base/nsDisplayList.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -10,6 +10,11 @@
  * used during painting and hit testing
  */
 
+#if !defined(NS_COORD_IS_FLOAT) && defined(_M_IX86_FP) && _M_IX86_FP >= 2
+#include <mmintrin.h>
+#include <emmintrin.h>
+#endif
+
 #include "mozilla/layers/PLayers.h"
 
 #include "nsDisplayList.h"
@@ -676,13 +681,29 @@
 
 static uint64_t RegionArea(const nsRegion& aRegion)
 {
+#if !defined(NS_COORD_IS_FLOAT) && defined(_M_IX86_FP) && _M_IX86_FP >= 2
+  __m64 area = _mm_setzero_si64();
+#else
   uint64_t area = 0;
+#endif
   nsRegionRectIterator iter(aRegion);
   const nsRect* r;
   while ((r = iter.Next()) != nullptr) {
+#if !defined(NS_COORD_IS_FLOAT) && defined(_M_IX86_FP) && _M_IX86_FP >= 2
+    __m64 mw = *(__m64 *)&r->width;
+    __m64 mh = _mm_srli_si64(mw, 32);
+    area = _mm_add_si64(area, _mm_mul_su32(mw, mh));
+#else
     area += uint64_t(r->width)*r->height;
+#endif
   }
+#if !defined(NS_COORD_IS_FLOAT) && defined(_M_IX86_FP) && _M_IX86_FP >= 2
+  uint64_t tmp;
+  *(__m64 *)&tmp = area;
+  return tmp;
+#else
   return area;
+#endif
 }
 
 void
@@ -702,6 +723,9 @@
       RegionArea(tmp) <= RegionArea(*aVisibleRegion)/2) {
     *aVisibleRegion = tmp;
   }
+#if !defined(NS_COORD_IS_FLOAT) && defined(_M_IX86_FP) && _M_IX86_FP >= 2
+  _m_empty();
+#endif
 }
 
 nsCaret *
diff -r 022513eead7b layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/layout/base/nsLayoutUtils.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -3729,7 +3729,8 @@
                   const nsPoint&       aAnchor,
                   const nsRect&        aDirty,
                   const nsIntSize&     aImageSize,
-                  uint32_t             aImageFlags)
+                  uint32_t             aImageFlags,
+                  const bool           aSingleImage = false)
 {
   if (aDest.Contains(aFill)) {
     aImageFlags |= imgIContainer::FLAG_CLAMP;
@@ -3749,6 +3750,10 @@
     ctx->IdentityMatrix();
   }
 
+  if (aSingleImage) {
+    ctx->SetFlag(gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+  }
+
   aImage->Draw(ctx, aGraphicsFilter, drawingParams.mUserSpaceToImageSpace,
                drawingParams.mFillRect, drawingParams.mSubimage, aImageSize,
                aImageFlags);
@@ -3829,7 +3834,7 @@
   fill.IntersectRect(fill, dest);
   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter,
                            dest, fill, aDest, aDirty ? *aDirty : dest,
-                           imageSize, aImageFlags);
+                           imageSize, aImageFlags, true);
 }
 
 /* static */ nsresult
@@ -3868,7 +3873,7 @@
   nsRect fill;
   fill.IntersectRect(aDest, dest);
   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter, dest, fill,
-                           fill.TopLeft(), aDirty, imageSize, aImageFlags);
+                           fill.TopLeft(), aDirty, imageSize, aImageFlags, true);
 }
 
 /* static */ void
diff -r 022513eead7b layout/generic/nsContainerFrame.cpp
--- a/layout/generic/nsContainerFrame.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/layout/generic/nsContainerFrame.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -240,6 +240,10 @@
 /////////////////////////////////////////////////////////////////////////////
 // Child frame enumeration
 
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
+
 const nsFrameList&
 nsContainerFrame::GetChildList(ChildListID aListID) const
 {
@@ -266,6 +270,10 @@
   }
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
+
 static void AppendIfNonempty(const nsIFrame* aFrame,
                             FramePropertyTable* aPropTable,
                             const FramePropertyDescriptor* aProperty,
diff -r 022513eead7b layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/layout/generic/nsHTMLReflowState.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -26,6 +26,7 @@
 #include "mozilla/Preferences.h"
 #include "nsBidiUtils.h"
 #include "nsFontInflationData.h"
+#include "mozilla/Attributes.h"
 
 #ifdef DEBUG
 #undef NOISY_VERTICAL_ALIGN
@@ -989,6 +990,7 @@
  * Returns true iff a pre-order traversal of the normal child
  * frames rooted at aFrame finds no non-empty frame before aDescendant.
  */
+MOZ_ALWAYS_INLINE
 static bool AreAllEarlierInFlowFramesEmpty(nsIFrame* aFrame,
   nsIFrame* aDescendant, bool* aFound) {
   if (aFrame == aDescendant) {
diff -r 022513eead7b layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/layout/style/nsCSSDataBlock.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -354,6 +354,10 @@
     }
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", off)
+#endif
+
 void
 nsCSSExpandedDataBlock::Compress(nsCSSCompressedDataBlock **aNormalBlock,
                                  nsCSSCompressedDataBlock **aImportantBlock)
@@ -416,6 +420,10 @@
     *aImportantBlock = result_important.forget();
 }
 
+#ifdef _MSC_VER
+#pragma optimize("g", on)
+#endif
+
 void
 nsCSSExpandedDataBlock::AddLonghandProperty(nsCSSProperty aProperty,
                                             const nsCSSValue& aValue)
diff -r 022513eead7b layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/layout/style/nsCSSRuleProcessor.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -1572,7 +1572,14 @@
 //    which is done only when SelectorMatches calls itself recursively
 //  * what it points to should be set to true whenever a test is skipped
 //    because of aNodeMatchContent.mStateMask
-static bool SelectorMatches(Element* aElement,
+bool SelectorMatchesComponent(Element* aElement,
+                              nsCSSSelector* aSelector,
+                              NodeMatchContext& aNodeMatchContext,
+                              TreeMatchContext& aTreeMatchContext,
+                              bool* const aDependence);
+
+inline
+bool SelectorMatches(Element* aElement,
                               nsCSSSelector* aSelector,
                               NodeMatchContext& aNodeMatchContext,
                               TreeMatchContext& aTreeMatchContext,
@@ -1602,6 +1609,19 @@
     }
   }
 
+  return SelectorMatchesComponent(aElement,
+                                  aSelector,
+                                  aNodeMatchContext,
+                                  aTreeMatchContext,
+                                  aDependence);
+}
+
+static bool SelectorMatchesComponent(Element* aElement,
+                                       nsCSSSelector* aSelector,
+                                       NodeMatchContext& aNodeMatchContext,
+                                       TreeMatchContext& aTreeMatchContext,
+                                       bool* const aDependence)
+{
   nsAtomList* IDList = aSelector->mIDList;
   if (IDList) {
     nsIAtom* id = aElement->GetID();
diff -r 022513eead7b layout/svg/nsSVGMaskFrame.cpp
--- a/layout/svg/nsSVGMaskFrame.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/layout/svg/nsSVGMaskFrame.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -3,6 +3,10 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+#include <omp.h>
+#endif
+
 // Main header first:
 #include "nsSVGMaskFrame.h"
 
@@ -119,6 +123,15 @@
     nsSVGUtils::ConvertImageDataToLinearRGB(data, stride, rect);
   }
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+
+#pragma omp parallel for schedule(guided) default(none) \
+shared(surfaceSize, data, stride, aOpacity) \
+if (omp_thread_counts >= 2 && \
+    surfaceSize.height >= (PRUint32)omp_thread_counts && \
+    surfaceSize.width * surfaceSize.height >= 10000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = 0; y < surfaceSize.height; y++)
     for (int32_t x = 0; x < surfaceSize.width; x++) {
       uint8_t *pixel = data + stride * y + 4 * x;
@@ -129,7 +142,7 @@
                    ((pixel[GFX_ARGB32_OFFSET_R] * 0.2125 +
                         pixel[GFX_ARGB32_OFFSET_G] * 0.7154 +
                         pixel[GFX_ARGB32_OFFSET_B] * 0.0721) *
-                       (pixel[GFX_ARGB32_OFFSET_A] / 255.0) * aOpacity);
+                       (pixel[GFX_ARGB32_OFFSET_A] * 0.003921568627451) * aOpacity);
 
       memset(pixel, alpha, 4);
     }
diff -r 022513eead7b memory/mozjemalloc/jemalloc.c
--- a/memory/mozjemalloc/jemalloc.c    Wed Dec 05 00:56:18 2012 -0800
+++ b/memory/mozjemalloc/jemalloc.c    Fri Dec 07 19:27:23 2012 +0900
@@ -235,6 +235,26 @@
 #define __crtInitCritSecAndSpinCount InitializeCriticalSectionAndSpinCount
 #include <io.h>
 #include <windows.h>
+#include <intrin.h>
+#if defined _M_IX86 || defined _M_AMD64
+#if _MSC_VER == 1400
+#include <emmintrin.h>
+#else  /* _MSC_VER == 1400 */
+#include <smmintrin.h>
+#endif /* _MSC_VER == 1400 */
+#endif /* defined _M_IX86 || defined _M_AMD64 */
+
+#if _MSC_VER >= 1400
+#ifdef _WIN64
+unsigned __int64 __readgsqword(unsigned long Offset);
+#pragma intrinsic(__readgsqword)
+#define TlsGetValue(x) (LPVOID)(__readgsqword((x) * 8 + 0x1480))
+#else /* _WIN64 */
+unsigned long __readfsdword(unsigned long Offset);
+#pragma intrinsic(__readfsdword)
+#define TlsGetValue(x) (LPVOID)(*(unsigned long *)(__readfsdword(0x18) + (x) * 4 + 3600))
+#endif /* _WIN64 */
+#endif /* _MSC_VER >= 1400 */
 
 #pragma warning( disable: 4267 4996 4146 )
 
@@ -251,6 +271,16 @@
 static unsigned long tlsIndex = 0xffffffff;
 #endif 
 
+BOOL ReplaceAPICode(FARPROC lpProcAddr, LPBYTE lpCodeData, int nCodeDataSize);
+static BOOL sse4_1_supported = FALSE;
+typedef struct
+{
+  int EAX;
+  int EBX;
+  int ECX;
+  int EDX;
+} CPU_INFO;
+
 #define    __thread
 #define    _pthread_self() __threadid()
 #define    issetugid() 0
@@ -5654,6 +5684,20 @@
 #ifdef MOZ_MEMORY_WINDOWS
     /* get a thread local storage index */
     tlsIndex = TlsAlloc();
+
+    {
+        CPU_INFO CPUInfo;
+
+        __cpuid((int*)&CPUInfo, 0);
+        if (CPUInfo.EAX >= 1)
+        {
+            __cpuid((int*)&CPUInfo, 1);
+            if (CPUInfo.ECX & (1 << 19))
+            {
+                sse4_1_supported = TRUE;
+            }
+        }
+    }
 #endif
 
     /* Get page size and number of CPUs */
@@ -7209,3 +7253,76 @@
   return TRUE;
 }
 #endif
+
+#ifdef MOZ_MEMORY_WINDOWS
+#include <math.h>
+
+double __cdecl floor_tt(double x)
+{
+#if defined _M_IX86 || defined _M_AMD64
+  if (sse4_1_supported)
+  {
+#if _MSC_VER != 1400
+    __m128d xd = _mm_load_sd(&x);
+    double d;
+
+    xd = _mm_floor_sd(xd, xd);
+    _mm_store_sd(&d, xd);
+    return d;
+#elif defined _M_IX86
+    double d;
+
+    __asm
+    {
+      movsd       xmm0, x
+      /* roundsd  xmm0, xmm0, 1 */
+      __asm _emit 0x66
+      __asm _emit 0x0F
+      __asm _emit 0x3A
+      __asm _emit 0x0B
+      __asm _emit 0xC0
+      __asm _emit 0x01
+      movsd       d, xmm0
+    }
+    return d;
+#endif
+  }
+#endif /* defined _M_IX86 || defined _M_AMD64 */
+  return floor(x);
+}
+
+double __cdecl ceil_tt(double x)
+{
+#if defined _M_IX86 || defined _M_AMD64
+  if (sse4_1_supported)
+  {
+#if _MSC_VER != 1400
+    __m128d xd = _mm_load_sd(&x);
+    double d;
+
+    xd = _mm_ceil_sd(xd, xd);
+    _mm_store_sd(&d, xd);
+    return d;
+#elif defined _M_IX86
+    double d;
+
+    __asm
+    {
+      movsd       xmm0, x
+      /* roundsd  xmm0, xmm0, 2 */
+      __asm _emit 0x66
+      __asm _emit 0x0F
+      __asm _emit 0x3A
+      __asm _emit 0x0B
+      __asm _emit 0xC0
+      __asm _emit 0x02
+      movsd       d, xmm0
+    }
+    return d;
+#endif
+  }
+#endif /* defined _M_IX86 || defined _M_AMD64 */
+  return ceil(x);
+}
+
+#endif
diff -r 022513eead7b mfbt/Attributes.h
--- a/mfbt/Attributes.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/mfbt/Attributes.h    Fri Dec 07 19:27:23 2012 +0900
@@ -13,6 +13,12 @@
  * code that is (only currently) mfbt-incompatible.
  */
 
+#if defined(WIN32) || defined(__SYMBIAN32__)
+#  define TT_RESTRICTED_PTR     __restrict
+#else
+#  define TT_RESTRICTED_PTR     __restrict__
+#endif
+
 /*
  * MOZ_INLINE is a macro which expands to tell the compiler that the method
  * decorated with it should be inlined.  This macro is usable from C and C++
diff -r 022513eead7b mfbt/ThreadLocal.h
--- a/mfbt/ThreadLocal.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/mfbt/ThreadLocal.h    Fri Dec 07 19:27:23 2012 +0900
@@ -17,7 +17,17 @@
 // Unfortunately, even including these headers causes us to add a bunch of ugly
 // stuff to our namespace e.g #define CreateEvent CreateEventW
 extern "C" {
+#if _MSC_VER >= 1400
+#ifdef _WIN64
+unsigned __int64 __readgsqword(unsigned long Offset);
+#pragma intrinsic(__readgsqword)
+#else /* _WIN64 */
+unsigned long __readfsdword(unsigned long Offset);
+#pragma intrinsic(__readfsdword)
+#endif /* _WIN64 */
+#else
 __declspec(dllimport) void * __stdcall TlsGetValue(unsigned long);
+#endif /* _MSC_VER >= 1400 */
 __declspec(dllimport) int __stdcall TlsSetValue(unsigned long, void *);
 __declspec(dllimport) unsigned long __stdcall TlsAlloc();
 }
@@ -118,7 +128,15 @@
   MOZ_ASSERT(initialized());
   Helper h;
 #ifdef XP_WIN
+#if _MSC_VER >= 1400
+#ifdef _WIN64
+  h.ptr = (void *)(__readgsqword(key * 8 + 0x1480));
+#else /* _WIN64 */
+  h.ptr = (void *)(*(unsigned long *)(__readfsdword(0x18) + key * 4 + 3600));
+#endif /* _WIN64 */
+#else
   h.ptr = TlsGetValue(key);
+#endif /* _MSC_VER >= 1400 */
 #else
   h.ptr = pthread_getspecific(key);
 #endif
diff -r 022513eead7b netwerk/base/src/Makefile.in
--- a/netwerk/base/src/Makefile.in    Wed Dec 05 00:56:18 2012 -0800
+++ b/netwerk/base/src/Makefile.in    Fri Dec 07 19:27:23 2012 +0900
@@ -123,3 +123,10 @@
 ifdef MOZ_ENABLE_LIBCONIC
     OS_INCLUDES += $(GLIB_CFLAGS) $(LIBCONIC_CFLAGS)
 endif
+
+ifdef MOZ_THUNDERBIRD
+ifeq (WINNT_1,$(OS_ARCH)_$(MOZ_PROFILE_GENERATE)$(MOZ_PROFILE_USE))
+# avoid the fatal error C1001 of compiler when applying PGO to Thunderbird
+COMPILE_CXXFLAGS += -GL-
+endif
+endif
diff -r 022513eead7b nsprpub/pr/include/md/_win95.h
--- a/nsprpub/pr/include/md/_win95.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/nsprpub/pr/include/md/_win95.h    Fri Dec 07 19:27:23 2012 +0900
@@ -479,6 +479,17 @@
 #define _MD_CURRENT_CPU() _pr_currentCPU
 #define _MD_SET_CURRENT_CPU(_cpu) (_pr_currentCPU = 0)
 #else /* _PR_USE_STATIC_TLS */
+#if _MSC_VER >= 1400
+#ifdef _WIN64
+unsigned __int64 __readgsqword(unsigned long Offset);
+#pragma intrinsic(__readgsqword)
+#define TlsGetValue(x) (LPVOID)(__readgsqword((x) * 8 + 0x1480))
+#else /* _WIN64 */
+unsigned long __readfsdword(unsigned long Offset);
+#pragma intrinsic(__readfsdword)
+#define TlsGetValue(x) (LPVOID)(*(unsigned long *)(__readfsdword(0x18) + (x) * 4 + 3600))
+#endif /* _WIN64 */
+#endif /* _MSC_VER >= 1400 */
 extern DWORD _pr_currentThreadIndex;
 #define _MD_GET_ATTACHED_THREAD() ((PRThread *) TlsGetValue(_pr_currentThreadIndex))
 #define _MD_SET_CURRENT_THREAD(_thread) TlsSetValue(_pr_currentThreadIndex, (_thread))
diff -r 022513eead7b nsprpub/pr/src/io/prsocket.c
--- a/nsprpub/pr/src/io/prsocket.c    Wed Dec 05 00:56:18 2012 -0800
+++ b/nsprpub/pr/src/io/prsocket.c    Fri Dec 07 19:27:23 2012 +0900
@@ -288,14 +288,6 @@
 
 #elif defined(WIN32) || defined(WIN16)
 
-#if defined(WIN32)
-    /*
-     * The sleep circumvents a bug in Win32 WinSock.
-     * See Microsoft Knowledge Base article ID: Q165989.
-     */
-    Sleep(0);
-#endif /* WIN32 */
-
     if (out_flags & PR_POLL_EXCEPT) {
         int len = sizeof(err);
         if (getsockopt(osfd, (int)SOL_SOCKET, SO_ERROR, (char *) &err, &len)
diff -r 022513eead7b security/nss/lib/freebl/Makefile
--- a/security/nss/lib/freebl/Makefile    Wed Dec 05 00:56:18 2012 -0800
+++ b/security/nss/lib/freebl/Makefile    Fri Dec 07 19:27:23 2012 +0900
@@ -129,11 +129,10 @@
     DEFINES += -DMP_NO_MP_WORD -DMP_USE_UINT_DIGIT
 else
 # MSVC
-    MPI_SRCS += mpi_x86_asm.c
     DEFINES += -DMP_ASSEMBLY_MULTIPLY -DMP_ASSEMBLY_SQUARE 
     DEFINES += -DMP_ASSEMBLY_DIV_2DX1D -DMP_USE_UINT_DIGIT -DMP_NO_MP_WORD
     ifdef BUILD_OPT
-    OPTIMIZER += -Ox  # maximum optimization for freebl
+    OPTIMIZER += -O2  # maximum optimization for freebl
     endif
 endif
 else
diff -r 022513eead7b security/nss/lib/freebl/manifest.mn
--- a/security/nss/lib/freebl/manifest.mn    Wed Dec 05 00:56:18 2012 -0800
+++ b/security/nss/lib/freebl/manifest.mn    Fri Dec 07 19:27:23 2012 +0900
@@ -64,7 +64,11 @@
     $(NULL)
 
 MPI_HDRS = mpi-config.h mpi.h mpi-priv.h mplogic.h mpprime.h logtab.h mp_gf2m.h
+ifdef USE_64
 MPI_SRCS = mpprime.c mpmontg.c mplogic.c mpi.c mp_gf2m.c
+else
+MPI_SRCS = mpprime.c mpmontg.c mplogic.c mpi.c mp_gf2m.c mpi_x86_asm.c
+endif
 
 
 ECL_HDRS = ecl-exp.h ecl.h ec2.h ecp.h ecl-priv.h
diff -r 022513eead7b toolkit/content/debug.js
--- a/toolkit/content/debug.js    Wed Dec 05 00:56:18 2012 -0800
+++ b/toolkit/content/debug.js    Fri Dec 07 19:27:23 2012 +0900
@@ -41,7 +41,7 @@
     switch (defB.getCharPref("app.update.channel")) {
       case "nightly":
       case "beta":
-      case "default":
+      // case "default":
         releaseBuild = false;
     }
   } catch(ex) {}
diff -r 022513eead7b toolkit/xre/nsWindowsWMain.cpp
--- a/toolkit/xre/nsWindowsWMain.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/toolkit/xre/nsWindowsWMain.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -10,6 +10,10 @@
 #error This file only makes sense on Windows.
 #endif
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+#include <omp.h>
+#endif
+
 #include "nsUTF8Utils.h"
 
 #ifndef XRE_DONT_PROTECT_DLL_LOAD
diff -r 022513eead7b widget/windows/WinUtils.cpp
--- a/widget/windows/WinUtils.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/widget/windows/WinUtils.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -153,16 +153,26 @@
   return topWnd;
 }
 
+class CAtom_NSWindowPropName {
+public:
+  CAtom_NSWindowPropName() {
+    PRUnichar sPropName[40] = L"";
+    _snwprintf(sPropName, 39, L"MozillansIWidgetPtr%p",
+               ::GetCurrentProcessId());
+    sPropName[39] = '\0';
+    atom = ::GlobalAddAtomW(sPropName);
+  }
+  ~CAtom_NSWindowPropName() {
+    ::GlobalDeleteAtom(atom);
+  }
+  ATOM atom;
+};
+
 static PRUnichar*
 GetNSWindowPropName()
 {
-  static PRUnichar sPropName[40] = L"";
-  if (!*sPropName) {
-    _snwprintf(sPropName, 39, L"MozillansIWidgetPtr%p",
-               ::GetCurrentProcessId());
-    sPropName[39] = '\0';
-  }
-  return sPropName;
+  static CAtom_NSWindowPropName gaNswpn;
+  return (PRUnichar*)(UINT_PTR)gaNswpn.atom;
 }
 
 /* static */
diff -r 022513eead7b widget/windows/nsWindow.cpp
--- a/widget/windows/nsWindow.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/widget/windows/nsWindow.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -1955,7 +1955,18 @@
 // Internally track the caption status via a window property. Required
 // due to our internal handling of WM_NCACTIVATE when custom client
 // margins are set.
-static const PRUnichar kManageWindowInfoProperty[] = L"ManageWindowInfoProperty";
+class CAtom_ManageWindowInfoProperty {
+public:
+  CAtom_ManageWindowInfoProperty() {
+    atom = ::GlobalAddAtomW(L"ManageWindowInfoProperty");
+  }
+  ~CAtom_ManageWindowInfoProperty() {
+    ::GlobalDeleteAtom(atom);
+  }
+  ATOM atom;
+};
+static CAtom_ManageWindowInfoProperty gaMwip;
+#define kManageWindowInfoProperty ((LPCWSTR)(UINT_PTR)gaMwip.atom)
 typedef BOOL (WINAPI *GetWindowInfoPtr)(HWND hwnd, PWINDOWINFO pwi);
 static GetWindowInfoPtr sGetWindowInfoPtrStub = NULL;
 
diff -r 022513eead7b xpcom/glue/nsDeque.cpp
--- a/xpcom/glue/nsDeque.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/xpcom/glue/nsDeque.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -108,7 +108,22 @@
  */
 nsDeque& nsDeque::Empty() {
   if (mSize && mData) {
+#ifdef TT_MEMUTIL
+    static const PRUint32 dwNonTemporalDataSizeMin = GetNonTemporalDataSizeMin_tt();
+    const PRUint32 dwDataSize = mCapacity*sizeof(mData);
+
+    if (dwDataSize < dwNonTemporalDataSizeMin ||
+        NON_TEMPORAL_STORES_NOT_SUPPORTED == dwNonTemporalDataSizeMin)
+    {
+        memset(mData, 0, mCapacity*sizeof(mData));
+    }
+    else
+    {
+        memset_nontemporal_tt(mData, 0, mCapacity*sizeof(mData));
+    }
+#else
     memset(mData, 0, mCapacity*sizeof(mData));
+#endif
   }
   mSize=0;
   mOrigin=0;
diff -r 022513eead7b xpcom/glue/nsThreadUtils.cpp
--- a/xpcom/glue/nsThreadUtils.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/xpcom/glue/nsThreadUtils.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -18,6 +18,17 @@
 #ifdef XP_WIN
 #include <windows.h>
 #include "nsWindowsHelpers.h"
+#if _MSC_VER >= 1400
+#ifdef _WIN64
+unsigned __int64 __readgsqword(unsigned long Offset);
+#pragma intrinsic(__readgsqword)
+#define TlsGetValue(x) (LPVOID)(__readgsqword((x) * 8 + 0x1480))
+#else /* _WIN64 */
+unsigned long __readfsdword(unsigned long Offset);
+#pragma intrinsic(__readfsdword)
+#define TlsGetValue(x) (LPVOID)(*(unsigned long *)(__readfsdword(0x18) + (x) * 4 + 3600))
+#endif /* _WIN64 */
+#endif /* _MSC_VER >= 1400 */
 #elif defined(XP_MACOSX)
 #include <sys/resource.h>
 #endif
diff -r 022513eead7b xpcom/glue/pldhash.cpp
--- a/xpcom/glue/pldhash.cpp    Wed Dec 05 00:56:18 2012 -0800
+++ b/xpcom/glue/pldhash.cpp    Fri Dec 07 19:27:23 2012 +0900
@@ -8,6 +8,9 @@
  *
  * Try to keep this file in sync with js/src/jsdhash.cpp.
  */
+#if _MSC_VER >= 1400
+#include <intrin.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -129,13 +132,29 @@
                       const PLDHashEntryHdr *from,
                       PLDHashEntryHdr *to)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __movsd((unsigned long*)to, (unsigned long*)from, table->entrySize >> 2);
+    } else {
+        memcpy(to, from, table->entrySize);
+    }
+#else
     memcpy(to, from, table->entrySize);
+#endif
 }
 
 void
 PL_DHashClearEntryStub(PLDHashTable *table, PLDHashEntryHdr *entry)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __stosd((unsigned long*)entry, 0, table->entrySize >> 2);
+    } else {
+        memset(entry, 0, table->entrySize);
+    }
+#else
     memset(entry, 0, table->entrySize);
+#endif
 }
 
 void
@@ -536,7 +555,29 @@
     table->generation++;
 
     /* Assign the new entry store to table. */
+#ifdef TT_MEMUTIL
+    {
+        static PRBool initialized = PR_FALSE;
+        static PRUint32 dwNonTemporalDataSizeMin = NON_TEMPORAL_STORES_NOT_SUPPORTED;
+
+        if (!initialized) {
+            dwNonTemporalDataSizeMin = GetNonTemporalDataSizeMin_tt();
+            initialized = PR_TRUE;
+        }
+
+        if (nbytes < dwNonTemporalDataSizeMin ||
+            NON_TEMPORAL_STORES_NOT_SUPPORTED == dwNonTemporalDataSizeMin)
+        {
+            memset(newEntryStore, 0, nbytes);
+        }
+        else
+        {
+            memset_nontemporal_tt(newEntryStore, 0, nbytes);
+        }
+    }
+#else
     memset(newEntryStore, 0, nbytes);
+#endif
     oldEntryAddr = oldEntryStore = table->entryStore;
     table->entryStore = newEntryStore;
     moveEntry = table->ops->moveEntry;
diff -r 022513eead7b xpcom/string/public/nsCharTraits.h
--- a/xpcom/string/public/nsCharTraits.h    Wed Dec 05 00:56:18 2012 -0800
+++ b/xpcom/string/public/nsCharTraits.h    Fri Dec 07 19:27:23 2012 +0900
@@ -182,6 +182,10 @@
     char_type*
     copy( char_type* s1, const char_type* s2, size_t n )
       {
+        if (1 == n) {
+          *s1 = *s2;
+          return s1;
+        }
         return static_cast<char_type*>(memcpy(s1, s2, n * sizeof(char_type)));
       }
 

